<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c32a7cd3f267f6ad99691a54a7da944b20a5a479" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36432030" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate>類別是委派類型的基底類別。 不過，只有系統和編譯器可以明確地從衍生<xref:System.Delegate>類別或從<xref:System.MulticastDelegate>類別。 它也是不允許從委派型別衍生新的類型。 <xref:System.Delegate>類別不是委派類型，則可以用來衍生委派類型的類別。  
  
 大部分語言實作`delegate`關鍵字，與這些語言的編譯器可衍生自<xref:System.MulticastDelegate>類別; 因此，使用者應該使用`delegate`語言所提供的關鍵字。  
  
> [!NOTE]
>  Common language runtime 提供`Invoke`每種委派類型，相同的簽章與委派的方法。 您不需要明確地呼叫這個方法從 C#、 Visual Basic 或 Visual c + + 中，因為編譯器會自動呼叫。 `Invoke`方法中很有用[反映](~/docs/framework/reflection-and-codedom/reflection.md)當您想要尋找的委派類型簽章。  
  
 Common language runtime 提供的每個委派型別`BeginInvoke`和`EndInvoke`方法，以啟用委派的非同步引動過程。 如需有關這些方法的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
 委派類型的宣告會建立指定的一個或多個方法的簽章的合約。 委派是具有參考委派類型的執行個體：  
  
-   類型和目標物件指派給該類型的執行個體方法。  
  
-   類型，並隱藏執行個體方法`this`公開型式參數清單中的參數。 委派是要開啟執行個體委派。  
  
-   靜態方法。  
  
-   靜態方法，而且指派給該方法的第一個參數的目標物件。 此委派會在其第一個引數上關閉。  
  
 如需委派繫結的詳細資訊，請參閱<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，委派可以表示方法，只有當方法的簽章完全相符的委派型別指定的簽章。 因此，只有第一個和第三個項目符號前述清單中的都有支援，而且第一個項目符號需要型別完全符合。  
  
 委派表示關閉其第一個引數 （最常見的情況） 上的執行個體方法，委派會儲存方法的進入點的參考和參考的物件，稱為目標，是指派給類型定義的型別方法。 當委派表示的開啟執行個體方法時，它會儲存方法的進入點的參考。 委派簽章必須包含隱藏`this`其型式參數清單中的參數; 在此情況下，委派沒有目標物件的參考，而且叫用委派時，必須提供目標物件。  
  
 當委派表示的靜態方法時，委派會儲存方法的進入點的參考。 委派表示關閉其第一個引數上的靜態方法，委派會儲存方法的進入點的參考，以及指派給方法的第一個引數類型的目標物件的參考。 叫用委派時，第一個引數的靜態方法會接收目標物件。  
  
 委派的引動過程清單是在其中清單的每個項目叫用一個委派所表示之方法的委派的已排序的集合。 引動過程清單可以包含重複的方法。 在引動過程，方法會叫用引動過程清單中的出現的順序。 委派會嘗試叫用每個方法，在其引動過程清單。重複的項目會叫用之後每次它們出現在引動過程清單。 委派是不可變的;一旦建立之後，就不會變更委派的引動過程清單。  
  
 委派會參照多點傳送，或可組合的類別，因為委派可以叫用一或多個方法，可用於合併作業。  
  
 合併作業，例如<xref:System.Delegate.Combine%2A>和<xref:System.Delegate.Remove%2A>，不會改變現有的委派。 相反地，這類作業會傳回新的委派，其中包含變更的委派，作業的結果或`null`。 合併作業會傳回`null`運算的結果時不會參考至少一個方法的委派。 合併作業會傳回未變更的委派，當要求的作業沒有任何作用。  
  
> [!NOTE]
>  Managed 語言使用<xref:System.Delegate.Combine%2A>和<xref:System.Delegate.Remove%2A>實作委派作業的方法。 範例包括`AddHandler`和`RemoveHandler`在 Visual Basic 中的陳述式和 + = 和-= 運算子委派 C# 中的型別。  
  
 從開始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，泛型委派類型可以有 variant 型別參數。 Contravariant 型別參數可以用做為委派的參數類型與 covariant 類型參數可用來當做傳回型別。 此功能可讓泛型委派類型都從相同泛型類型定義中所述，是指派相容如果其類型引數是參考類型，具有繼承關係，建構[共變數和反變數](~/docs/standard/generics/covariance-and-contravariance.md)。  
  
> [!NOTE]
>  泛型委派指派相容，因為差異不一定可組合的類別。 若要可組合的類別，類型必須完全相符。 例如，假設 具名的類別`Derived`衍生自類別，名為`Base`。 類型的委派`Action<Base>`(`Action(Of Base)`在 Visual Basic 中) 可以指派給類型的變數`Action<Derived>`，但無法結合兩個委派，因為類型不完全相符。  
  
 如果叫用的方法擲回例外狀況，則方法會停止執行、 的委派，呼叫端傳遞的例外狀況和引動過程清單中的剩餘方法不會叫用。 在呼叫端攔截例外狀況不會改變此行為。  
  
 當透過委派叫用的方法簽章包含傳回值時，委派會傳回引動過程清單最後一個元素的傳回值。 當簽章包含傳址方式傳遞的參數時，最後一個參數的值會是每個方法引動過程清單，依序執行，並更新參數的值中的結果。  
  
 最接近的委派，在 C 或 c + + 中相當函式指標。 委派可以表示的靜態方法或執行個體方法。 委派表示的執行個體方法，委派會儲存參考方法的進入點，不僅類別執行個體的參考。 不同之處在於，委派是物件導向，而且型別安全。  
  
   
  
## Examples  
 下列範例示範如何定義名為委派`myMethodDelegate`。 此委派的執行個體的執行個體方法的巢狀的靜態方法會針對建立`mySampleClass`類別。 執行個體方法的委派需要的執行個體`mySampleClass`。 `mySampleClass`執行個體儲存在名為的變數`mySC`。  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new delegate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">The class instance on which the delegate invokes <c>method</c>.</param>
        <param name="method">The name of the instance method that the delegate represents.</param>
        <summary>Initializes a delegate that invokes the specified instance method on the specified class instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式不能在應用程式程式碼。 若要建立委派，藉由指定的執行個體方法名稱，使用的多載<xref:System.Delegate.CreateDelegate%2A>指定方法名稱和目標物件的方法。 例如，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29>方法多載會建立具有指定名稱的執行個體方法的委派。  
  
 這個建構函式只會建立委派執行個體方法。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">There was an error binding to the target method.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">The <see cref="T:System.Type" /> representing the class that defines <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate represents.</param>
        <summary>Initializes a delegate that invokes the specified static method from the specified class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式不能在應用程式程式碼。 若要建立委派，藉由指定的靜態方法名稱，使用的多載<xref:System.Delegate.CreateDelegate%2A>指定方法名稱，但未指定目標物件的方法。 例如，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29>方法多載會建立具有指定名稱的靜態方法的委派。  
  
 這個建構函式會建立只使用靜態方法的委派。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> represents an open generic type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a shallow copy of the delegate.</summary>
        <returns>A shallow copy of the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 複製品具有相同的<xref:System.Type>，與原始的委派目標、 方法和引動過程清單。  
  
 淺層複本建立的原始物件，與相同類型的新執行個體，然後複製原始物件的非靜態欄位。 如果欄位是實值類型，則會執行位元欄位的複本。 如果欄位是參考類型，則會複製參考，但參考的物件不;因此，原始物件的參考和複製品中的參考點相同的物件。 相較之下，物件的深層複本複製直接或間接參考之物件中欄位的所有項目。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatenates the invocation lists of the specified multicast (combinable) delegates.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">The array of delegates to combine.</param>
        <summary>Concatenates the invocation lists of an array of delegates.</summary>
        <returns>A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <paramref name="delegates" /> array. Returns <see langword="null" /> if <paramref name="delegates" /> is <see langword="null" />, if <paramref name="delegates" /> contains zero elements, or if every entry in <paramref name="delegates" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`delegates`陣列包含的項目`null`，這些項目會被忽略。  
  
 引動過程清單可以包含重複的項目。也就是指相同的方法，在相同物件上的項目。  
  
> [!NOTE]
>  泛型委派指派相容，因為差異不一定可組合的類別。 若要可組合的類別，類型必須完全相符。 例如，假設 具名的類別`Derived`衍生自類別，名為`Base`。 類型的委派`Action<Base>`(`Action(Of Base)`在 Visual Basic 中) 可以指派給類型的變數`Action<Derived>`，如下所述[共變數和反變數](~/docs/standard/generics/covariance-and-contravariance.md)，而無法合併兩個委派，因為型別不完全符合。  
  
 <xref:System.Delegate.Combine%2A> 可用於建立多個方法時間事件的呼叫，就會發生的事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Not all the non-null entries in <paramref name="delegates" /> are instances of the same delegate type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">The delegate whose invocation list comes first.</param>
        <param name="b">The delegate whose invocation list comes last.</param>
        <summary>Concatenates the invocation lists of two delegates.</summary>
        <returns>A new delegate with an invocation list that concatenates the invocation lists of <paramref name="a" /> and <paramref name="b" /> in that order. Returns <paramref name="a" /> if <paramref name="b" /> is <see langword="null" />, returns <paramref name="b" /> if <paramref name="a" /> is a null reference, and returns a null reference if both <paramref name="a" /> and <paramref name="b" /> are null references.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引動過程清單可以包含重複的項目。也就是指相同的方法，在相同物件上的項目。  
  
> [!NOTE]
>  泛型委派指派相容，因為差異不一定可組合的類別。 若要可組合的類別，類型必須完全相符。 例如，假設 具名的類別`Derived`衍生自類別，名為`Base`。 類型的委派`Action<Base>`(`Action(Of Base)`在 Visual Basic 中) 可以指派給類型的變數`Action<Derived>`，如下所述[共變數和反變數](~/docs/standard/generics/covariance-and-contravariance.md)，而無法合併兩個委派，因為型別不完全符合。  
  
 <xref:System.Delegate.Combine%2A> 可用於建立多個方法時間事件的呼叫，就會發生的事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Both <paramref name="a" /> and <paramref name="b" /> are not <see langword="null" />, and <paramref name="a" /> and <paramref name="b" /> are not instances of the same delegate type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</param>
        <summary>Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</summary>
        <returns>A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <paramref name="d" />, or the current multicast (combinable) delegate if <paramref name="d" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法僅適用於目前的委派是多點傳送 （可結合的）。  
  
 目前的實作只會擲回<xref:System.MulticastNotSupportedException>。  
  
 引動過程清單可以包含重複的項目。也就是指相同的方法，在相同物件上的項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Always thrown.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a delegate of the specified type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent. Only static methods are supported in the .NET Framework version 1.0 and 1.1.</param>
        <summary>Creates a delegate of the specified type to represent the specified static method.</summary>
        <returns>A delegate of the specified type to represent the specified static method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 1.0 和 1.1 版中，這個方法多載會建立只使用靜態方法的委派。 在.NET Framework 2.0 版中，這個方法多載也可以建立開啟執行個體方法的委派。也就是明確地提供隱藏第一個引數的委派執行個體方法。 詳細的說明，請參閱更多一般<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>方法多載，可讓您建立所有組合的開放式或封閉式委派執行個體或靜態方法，並選擇性地指定第一個引數。  
  
> [!NOTE]
>  這個方法多載應該時使用委派未關閉透過其第一個引數，因為它在該情況下是稍快。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載，並指定`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>相容的參數型別和傳回型別  
 在.NET Framework 2.0 版中，參數型別和使用這個方法多載來建立委派的傳回型別必須是相容的參數類型和傳回型別方法委派所表示。型別沒有完全相符。 這代表放寬的.NET Framework 1.0 和 1.1 中，類型必須完全相符的版本中的繫結行為。  
  
 如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。  
  
 同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。  
  
 例如，類型參數的委派<xref:System.Collections.Hashtable>和傳回型別<xref:System.Object>可以代表具有型別參數的方法<xref:System.Object>和傳回值的型別<xref:System.Collections.Hashtable>。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例示範兩種可以使用這個方法多載來建立的委派： 透過執行個體方法開啟，並開啟透過靜態方法。  
  
 第二個程式碼範例會示範相容的參數型別和傳回型別。  
  
 **範例 1**  
  
 下列程式碼範例示範兩種方式可使用的這個多載來建立委派<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>方法指定<xref:System.Reflection.MethodInfo>，而不是第一次的引數; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。 這個程式碼範例會使用這兩個多載。  
  
 此範例會宣告類別`C`的靜態方法`M2`和執行個體方法`M1`，以及兩個委派型別：`D1`可接受的執行個體`C`和字串，並`D2`接受字串。  
  
 名為第二個類別`Example`包含建立委派的程式碼。  
  
-   類型的委派`D1`，表示開啟的執行個體方法，建立執行個體方法`M1`。 當叫用委派時，必須傳遞執行個體。  
  
-   類型的委派`D2`，代表開放式的靜態方法，建立靜態方法`M2`。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **範例 2**  
  
 下列程式碼範例示範的參數類型相容性和傳回型別。  
  
 程式碼範例定義名為基底類別`Base`和類別，名為`Derived`衍生自`Base`。 在衍生的類別具有`static`(`Shared`在 Visual Basic 中) 方法名為`MyMethod`具有型別的一個參數`Base`和傳回型別`Derived`。 程式碼範例也會定義名為委派`Example`具有型別的一個參數`Derived`和傳回型別`Base`。  
  
 程式碼範例將示範委派名為`Example`可以用來表示方法`MyMethod`。 方法可以繫結至委派，因為：  
  
-   委派的參數型別 (`Derived`) 是更具限制性的參數型別`MyMethod`(`Base`)，因此一律會安全地傳遞至委派的引數、 `MyMethod`。  
  
-   傳回型別`MyMethod`(`Derived`) 是更具限制性的委派的參數類型 (`Base`)，如此可永遠放心轉型為委派的傳回型別方法的傳回型別。  
  
 程式碼範例會產生任何輸出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not a static method, and the .NET Framework version is 1.0 or 1.1.  -or-  <paramref name="method" /> cannot be bound.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 列舉型別相關聯： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="firstArgument">The object to which the delegate is bound, or <see langword="null" /> to treat <c>method</c> as <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</summary>
        <returns>A delegate of the specified type that represents the specified static or instance method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載，並指定`true`如`throwOnBindFailure`。 這些兩個多載提供最具彈性的方式來建立委派。 您可以使用它們來建立委派靜態或執行個體方法，並選擇性地指定第一個引數。  
  
> [!NOTE]
>  如果您未提供第一個引數，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載，以提升效能。  
  
 委派型別和方法必須具有相容的傳回類型。 也就是傳回型別`method`必須可以指派給的傳回型別`type`。  
  
 如果`firstArgument`是提供，它會傳遞至`method`每次叫用委派。`firstArgument`稱為繫結至委派，並委派會在其第一個引數上關閉。 如果`method`是`static`(`Shared`在 Visual Basic 中)，則引數叫用委派時所提供的清單包含第一個; 以外的所有參數，如果`method`是執行個體方法，則`firstArgument`傳遞到隱藏的執行個體參數 (由`this`在 C# 中，或由`Me`在 Visual Basic 中)。  
  
 如果`firstArgument`提供的第一個參數`method`必須是參考類型，和`firstArgument`必須相容於該型別。  
  
> [!IMPORTANT]
>  如果`method`是`static`(`Shared`在 Visual Basic 中) 和其第一個參數的類型是<xref:System.Object>或<xref:System.ValueType>，然後`firstArgument`可以是實值類型。 在此情況下`firstArgument`會自動進行 boxed 處理。 自動 boxing 不會發生的任何其他引數，因為它會以 C# 或 Visual Basic 函式呼叫。  
  
 如果`firstArgument`為 null 參考和`method`是執行個體方法，結果會隨著的委派類型簽章`type`和`method`:  
  
-   如果簽章`type`明確包含隱藏第一個參數`method`，此委派來表示開啟的執行個體方法。 引數清單中的第一個引數叫用委派時，會傳遞到隱藏的執行個體參數的`method`。  
  
-   如果簽章`method`和`type`比對 （也就是所有的參數型別都相容），則此委派會在 null 參考上關閉。 叫用委派就像不是特別有用的做法的 null 執行個體上呼叫執行個體方法。  
  
 如果`firstArgument`為 null 參考和`method`是靜態的結果會隨著的委派類型簽章`type`和`method`:  
  
-   如果簽章`method`和`type`比對 （也就是所有的參數型別都相容），此委派來表示開啟的靜態方法。 這是靜態方法的最常見的情況。 在此情況下，您可以取得稍微提升效能，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載。  
  
-   如果簽章`type`開頭的第二個參數`method`，而且其餘的參數類型相容，則此委派會在 null 參考上關閉。 叫用委派時，第一個參數來傳遞 null 參考`method`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>相容的參數型別和傳回型別  
 參數類型和委派的傳回型別必須是相容的參數類型和傳回型別方法委派所表示。型別沒有完全相符。  
  
> [!NOTE]
>  在.NET Framework 1.0 和 1.1 版中，類型必須完全相符。  
  
 如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。  
  
 同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。  
  
 例如，類型參數的委派<xref:System.Collections.Hashtable>和傳回型別<xref:System.Object>可以代表具有型別參數的方法<xref:System.Object>和傳回值的型別<xref:System.Collections.Hashtable>。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>判斷方法的委派可以表示  
 另一個有用的方式來想到的這個多載所提供的彈性<xref:System.Delegate.CreateDelegate%2A>是任何指定的委派可以代表四個不同的方法簽章與方法類型 （靜態和執行個體） 的組合。 委派類型，請考慮`D`具有單一引數的型別`C`。 下列程式碼說明方法`D`可表示，因為它必須符合在所有情況下忽略的傳回型別：  
  
-   `D` 可以表示有一個引數類型的任何執行個體方法`C`，不論執行個體方法屬於何種類型。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`類型的執行個體`method`屬於，並將產生的委派會在該執行個體上關閉。 (兩者，`D`也可以關閉透過 null 參考如果`firstArgument`為 null 參考。)  
  
-   `D` 可以表示的執行個體方法`C`，沒有任何引數。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`為 null 參考。 產生的委派表示開啟的執行個體方法和執行個體`C`必須提供每次叫用時。  
  
-   `D` 可以代表採用一個引數類型的靜態方法`C`，而且方法可以屬於任何類型。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`為 null 參考。 產生的委派表示開啟的靜態方法和執行個體`C`必須提供每次叫用時。  
  
-   `D` 可以表示的靜態方法屬於型別`F`且具有兩個類型引數，`F`和型別`C`。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`的執行個體`F`。 產生的委派表示關閉該執行個體上的靜態方法`F`。 請注意，在案例其中`F`和`C`都是相同的型別、 靜態方法會具有該類型的兩個引數。 (在此情況下，`D`如果 null 參考透過關閉`firstArgument`為 null 參考。)  
  
   
  
## Examples  
 本節包含三個程式碼範例。 第一個範例將示範委派可建立四種： 關閉透過執行個體方法，透過執行個體方法開啟的靜態方法，透過開啟和關閉透過靜態方法。  
  
 第二個程式碼範例會示範相容的參數型別和傳回型別。  
  
 第三個程式碼範例會定義單一委派類型，並顯示可以表示所有委派類型的方法。  
  
 **範例 1**  
  
 下列程式碼範例示範您可以使用的這個多載建立委派的四種方式<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>方法指定`firstArgument`和<xref:System.Reflection.MethodInfo>; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。 這個程式碼範例會使用這兩個多載。  
  
 此範例會宣告類別`C`的靜態方法`M2`和執行個體方法`M1`，以及三個委派型別：`D1`可接受的執行個體`C`和字串，`D2`採用字串和`D3`沒有引數。  
  
 名為第二個類別`Example`包含建立委派的程式碼。  
  
-   類型的委派`D2`、 執行個體上關閉`C`，建立執行個體方法`M1`。 使用不同的字串，顯示的繫結的執行個體叫用`C`一律使用。  
  
-   類型的委派`D1`，表示開啟的執行個體方法，建立執行個體方法`M1`。 當叫用委派時，必須傳遞執行個體。  
  
-   類型的委派`D2`，代表開放式的靜態方法，建立靜態方法`M2`。  
  
-   最後，類型的委派`D3`字串上為封閉式，建立靜態方法`M2`。 方法會叫用來顯示它所使用的繫結的字串。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **範例 2**  
  
 下列程式碼範例示範的參數類型相容性和傳回型別。  
  
> [!NOTE]
>  這個程式碼範例會使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載。 使用其他多載會採用<xref:System.Reflection.MethodInfo>類似。  
  
 程式碼範例定義名為基底類別`Base`和類別，名為`Derived`衍生自`Base`。 在衍生的類別具有`static`(`Shared`在 Visual Basic 中) 方法名為`MyMethod`具有型別的一個參數`Base`和傳回型別`Derived`。 程式碼範例也會定義名為委派`Example`具有型別的一個參數`Derived`和傳回型別`Base`。  
  
 程式碼範例將示範委派名為`Example`可以用來表示方法`MyMethod`。 方法可以繫結至委派，因為：  
  
-   委派的參數型別 (`Derived`) 是更具限制性的參數型別`MyMethod`(`Base`)，因此一律會安全地傳遞至委派的引數、 `MyMethod`。  
  
-   傳回型別`MyMethod`(`Derived`) 是更具限制性的委派的參數類型 (`Base`)，如此可永遠放心轉型為委派的傳回型別方法的傳回型別。  
  
 程式碼範例會產生任何輸出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **範例 3**  
  
 下列程式碼範例顯示所有的方法可表示的單一委派類型，使用<xref:System.Delegate.CreateDelegate%2A>方法來建立委派。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>方法指定`firstArgument`和<xref:System.Reflection.MethodInfo>; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。 這個程式碼範例會使用這兩個多載。  
  
 程式碼範例定義兩個類別：`C`和`F`，和委派類型`D`具有單一引數的型別`C`。 類別有相符的靜態和執行個體方法`M1`， `M3`，和`M4`，和類別`C`也有執行個體方法`M2`，沒有任何引數。  
  
 名為第三個類別`Example`包含建立委派的程式碼。  
  
-   建立委派執行個體方法`M1`型別的`C`和型別`F`; 每個個別的型別執行個體上已關閉。 方法`M1`型別的`C`顯示`ID`繫結的執行個體與引數的屬性。  
  
-   建立委派方法`M2`型別的`C`。 這是開啟的執行個體的委派，其中委派的引數代表的執行個體方法上的隱藏第一個引數。 此方法沒有任何其他引數。 如同一般的靜態方法呼叫它。  
  
-   針對靜態方法建立委派`M3`型別的`C`和型別`F`; 這些是開啟的靜態委派。  
  
-   靜態方法建立委派的最後，`M4`型別的`C`和型別`F`; 每個方法都宣告的型別做為其第一個引數，並提供類型的執行個體，因此委派會關閉對其第一個引數. 方法`M4`型別的`C`顯示`ID`繫結的執行個體與引數的屬性。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 列舉型別相關聯： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只會建立委派執行個體方法。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，指定`false`如`ignoreCase`和`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 列舉型別相關聯： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type to represent the specified static method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載可以建立開啟的靜態方法的委派，開啟執行個體方法的委派，也就是公開的隱藏第一個引數的委派執行個體方法。 詳細的說明，請參閱更多一般<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載，可讓您建立所有的組合，開放式或封閉式的委派的執行個體或靜態方法。  
  
> [!NOTE]
>  這個方法多載應該時使用委派未關閉透過其第一個引數，因為它在該情況下是稍快。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>相容的參數型別和傳回型別  
 參數類型和委派的傳回型別必須是相容的參數類型和傳回型別方法委派所表示。型別沒有完全相符。  
  
> [!NOTE]
>  在.NET Framework 1.0 和 1.1 版中，類型必須完全相符。  
  
 如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。  
  
 同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。  
  
 例如，類型參數的委派<xref:System.Collections.Hashtable>和傳回型別<xref:System.Object>可以代表具有型別參數的方法<xref:System.Object>和傳回值的型別<xref:System.Collections.Hashtable>。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例示範兩種可以使用這個方法多載來建立的委派： 透過執行個體方法開啟，並開啟透過靜態方法。  
  
 第二個程式碼範例會示範相容的參數型別和傳回型別。  
  
 **範例 1**  
  
 下列程式碼範例示範兩種方式可使用的這個多載來建立委派<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>方法指定<xref:System.Reflection.MethodInfo>，而不是第一次的引數; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。 這個程式碼範例會使用這兩個多載。  
  
 此範例會宣告類別`C`的靜態方法`M2`和執行個體方法`M1`，以及兩個委派型別：`D1`可接受的執行個體`C`和字串，並`D2`接受字串。  
  
 名為第二個類別`Example`包含建立委派的程式碼。  
  
-   類型的委派`D1`，表示開啟的執行個體方法，建立執行個體方法`M1`。 當叫用委派時，必須傳遞執行個體。  
  
-   類型的委派`D2`，代表開放式的靜態方法，建立靜態方法`M2`。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **範例 2**  
  
 下列程式碼範例示範的參數類型相容性和傳回型別。  
  
> [!NOTE]
>  這個程式碼範例會使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載。 使用其他多載會採用<xref:System.Reflection.MethodInfo>類似。  
  
 程式碼範例定義名為基底類別`Base`和類別，名為`Derived`衍生自`Base`。 在衍生的類別具有`static`(`Shared`在 Visual Basic 中) 方法名為`MyMethod`具有型別的一個參數`Base`和傳回型別`Derived`。 程式碼範例也會定義名為委派`Example`具有型別的一個參數`Derived`和傳回型別`Base`。  
  
 程式碼範例將示範委派名為`Example`可以用來表示方法`MyMethod`。 方法可以繫結至委派，因為：  
  
-   委派的參數型別 (`Derived`) 是更具限制性的參數型別`MyMethod`(`Base`)，因此一律會安全地傳遞至委派的引數、 `MyMethod`。  
  
-   傳回型別`MyMethod`(`Derived`) 是更具限制性的委派的參數類型 (`Base`)，如此可永遠放心轉型為委派的傳回型別方法的傳回型別。  
  
 程式碼範例會產生任何輸出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 列舉型別相關聯： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立只使用靜態方法的委派。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，指定`false`如`ignoreCase`和`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 列舉型別相關聯： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> representing the type of delegate to create.</param>
        <param name="firstArgument">An <see cref="T:System.Object" /> that is the first argument of the method the delegate represents. For instance methods, it must be compatible with the instance type.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified static or instance method, or <see langword="null" /> if <paramref name="throwOnBindFailure" /> is <see langword="false" /> and the delegate cannot be bound to <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載而<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>方法多載，一律擲回繫結失敗時發生，提供最具彈性的方式來建立委派。 您可以使用它們來建立委派靜態或執行個體方法，不論第一個引數。  
  
> [!NOTE]
>  如果您未提供第一個引數，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載，以提升效能。  
  
 委派型別和方法必須具有相容的傳回類型。 也就是傳回型別`method`必須可以指派給的傳回型別`type`。  
  
 如果`firstArgument`是提供，它會傳遞至`method`每次叫用委派。`firstArgument`稱為繫結至委派，並委派會在其第一個引數上關閉。 如果`method`是`static`(`Shared`在 Visual Basic 中)，則引數叫用委派時所提供的清單包含第一個; 以外的所有參數，如果`method`是執行個體方法，則`firstArgument`傳遞到隱藏的執行個體參數 (由`this`在 C# 中，或由`Me`在 Visual Basic 中)。  
  
 如果`firstArgument`提供的第一個參數`method`必須是參考類型，和`firstArgument`必須相容於該型別。  
  
> [!IMPORTANT]
>  如果`method`是`static`(`Shared`在 Visual Basic 中) 和其第一個參數的類型是<xref:System.Object>或<xref:System.ValueType>，然後`firstArgument`可以是實值類型。 在此情況下`firstArgument`會自動進行 boxed 處理。 自動 boxing 不會發生的任何其他引數，因為它會以 C# 或 Visual Basic 函式呼叫。  
  
 如果`firstArgument`為 null 參考和`method`是執行個體方法，結果會隨著的委派類型簽章`type`和`method`:  
  
-   如果簽章`type`明確包含隱藏第一個參數`method`，此委派來表示開啟的執行個體方法。 引數清單中的第一個引數叫用委派時，會傳遞到隱藏的執行個體參數的`method`。  
  
-   如果簽章`method`和`type`比對 （也就是所有的參數型別都相容），則此委派會在 null 參考上關閉。 叫用委派就像不是特別有用的做法的 null 執行個體上呼叫執行個體方法。  
  
 如果`firstArgument`為 null 參考和`method`是靜態的結果會隨著的委派類型簽章`type`和`method`:  
  
-   如果簽章`method`和`type`比對 （也就是所有的參數型別都相容），此委派來表示開啟的靜態方法。 這是靜態方法的最常見的情況。 在此情況下，您可以取得稍微提升效能，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載。  
  
-   如果簽章`type`開頭的第二個參數`method`，而且其餘的參數類型相容，則此委派會在 null 參考上關閉。 叫用委派時，第一個參數來傳遞 null 參考`method`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>相容的參數型別和傳回型別  
 參數類型和委派的傳回型別必須是相容的參數類型和傳回型別方法委派所表示。型別沒有完全相符。  
  
> [!NOTE]
>  .NET Framework 1.0 和 1.1 版中的類型必須完全相符。  
  
 如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。  
  
 同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。  
  
 例如，類型參數的委派<xref:System.Collections.Hashtable>和傳回型別<xref:System.Object>可以代表具有型別參數的方法<xref:System.Object>和傳回值的型別<xref:System.Collections.Hashtable>。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>判斷方法的委派可以表示  
 另一個有用的方式來想到的這個多載所提供的彈性<xref:System.Delegate.CreateDelegate%2A>是任何指定的委派可以代表四個不同的方法簽章與方法類型 （靜態和執行個體） 的組合。 委派類型，請考慮`D`具有單一引數的型別`C`。 下列程式碼說明方法`D`可表示，因為它必須符合在所有情況下忽略的傳回型別：  
  
-   `D` 可以表示有一個引數類型的任何執行個體方法`C`，不論執行個體方法屬於何種類型。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`類型的執行個體`method`屬於，並將產生的委派會在該執行個體上關閉。 (兩者，`D`也可以關閉透過 null 參考如果`firstArgument`是`null`。)  
  
-   `D` 可以表示的執行個體方法`C`，沒有任何引數。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`為 null 參考。 產生的委派表示開啟的執行個體方法和執行個體`C`必須提供每次叫用時。  
  
-   `D` 可以代表採用一個引數類型的靜態方法`C`，而且方法可以屬於任何類型。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`為 null 參考。 產生的委派表示開啟的靜態方法和執行個體`C`必須提供每次叫用時。  
  
-   `D` 可以表示的靜態方法屬於型別`F`且具有兩個類型引數，`F`和型別`C`。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`的執行個體`F`。 產生的委派表示關閉該執行個體上的靜態方法`F`。 請注意，在案例其中`F`和`C`都是相同的型別、 靜態方法會具有該類型的兩個引數。 (在此情況下，`D`如果 null 參考透過關閉`firstArgument`是`null`。)  
  
   
  
## Examples  
 本節包含三個程式碼範例。 第一個範例將示範委派可建立四種： 關閉透過執行個體方法，透過執行個體方法開啟的靜態方法，透過開啟和關閉透過靜態方法。  
  
 第二個程式碼範例會示範相容的參數型別和傳回型別。  
  
 第三個程式碼範例會定義單一委派類型，並顯示可以表示所有委派類型的方法。  
  
 **範例 1**  
  
 下列程式碼範例示範您可以使用的這個多載建立委派的四種方式<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>方法指定`firstArgument`和<xref:System.Reflection.MethodInfo>; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。 這個程式碼範例會使用這兩個多載。  
  
 此範例會宣告類別`C`的靜態方法`M2`和執行個體方法`M1`，以及三個委派型別：`D1`可接受的執行個體`C`和字串，`D2`採用字串和`D3`沒有引數。  
  
 名為第二個類別`Example`包含建立委派的程式碼。  
  
-   類型的委派`D2`、 執行個體上關閉`C`，建立執行個體方法`M1`。 使用不同的字串，顯示的繫結的執行個體叫用`C`一律使用。  
  
-   類型的委派`D1`，表示開啟的執行個體方法，建立執行個體方法`M1`。 當叫用委派時，必須傳遞執行個體。  
  
-   類型的委派`D2`，代表開放式的靜態方法，建立靜態方法`M2`。  
  
-   最後，類型的委派`D3`字串上為封閉式，建立靜態方法`M2`。 方法會叫用來顯示它所使用的繫結的字串。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **範例 2**  
  
 下列程式碼範例示範的參數類型相容性和傳回型別。  
  
> [!NOTE]
>  這個程式碼範例會使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載。 使用其他多載會採用<xref:System.Reflection.MethodInfo>類似。  
  
 程式碼範例定義名為基底類別`Base`和類別，名為`Derived`衍生自`Base`。 在衍生的類別具有`static`(`Shared`在 Visual Basic 中) 方法名為`MyMethod`具有型別的一個參數`Base`和傳回型別`Derived`。 程式碼範例也會定義名為委派`Example`具有型別的一個參數`Derived`和傳回型別`Base`。  
  
 程式碼範例將示範委派名為`Example`可以用來表示方法`MyMethod`。 方法可以繫結至委派，因為：  
  
-   委派的參數型別 (`Derived`) 是更具限制性的參數型別`MyMethod`(`Base`)，因此一律會安全地傳遞至委派的引數、 `MyMethod`。  
  
-   傳回型別`MyMethod`(`Derived`) 是更具限制性的委派的參數類型 (`Base`)，如此可永遠放心轉型為委派的傳回型別方法的傳回型別。  
  
 程式碼範例會產生任何輸出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **範例 3**  
  
 下列程式碼範例會顯示所有單一委派類型可以表示的方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>方法指定`firstArgument`和<xref:System.Reflection.MethodInfo>; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。 這個程式碼範例會使用這兩個多載。  
  
 程式碼範例定義兩個類別：`C`和`F`，和委派類型`D`具有單一引數的型別`C`。 類別有相符的靜態和執行個體方法`M1`， `M3`，和`M4`，和類別`C`也有執行個體方法`M2`，沒有任何引數。  
  
 名為第三個類別`Example`包含建立委派的程式碼。  
  
-   建立委派執行個體方法`M1`型別的`C`和型別`F`; 每個個別的型別執行個體上已關閉。 方法`M1`型別的`C`顯示`ID`繫結的執行個體與引數的屬性。  
  
-   建立委派方法`M2`型別的`C`。 這是開啟的執行個體的委派，其中委派的引數代表的執行個體方法上的隱藏第一個引數。 此方法沒有任何其他引數。  
  
-   針對靜態方法建立委派`M3`型別的`C`和型別`F`; 這些是開啟的靜態委派。  
  
-   靜態方法建立委派的最後，`M4`型別的`C`和型別`F`; 每個方法都宣告的型別做為其第一個引數，並提供類型的執行個體，因此委派會關閉對其第一個引數. 方法`M4`型別的`C`顯示`ID`繫結的執行個體與引數的屬性。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 列舉型別相關聯： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只會建立委派執行個體方法。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，指定`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 列舉型別相關聯： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立只使用靜態方法的委派。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，指定`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 列舉型別相關聯： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只會建立委派執行個體方法。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 列舉型別相關聯： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立只使用靜態方法的委派。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 列舉型別相關聯： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">An array of objects that are the arguments to pass to the method represented by the current delegate.  -or-  <see langword="null" />, if the method represented by the current delegate does not require arguments.</param>
        <summary>Dynamically invokes (late-bound) the method represented by the current delegate.</summary>
        <returns>The object returned by the method represented by the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫 <xref:System.Delegate.DynamicInvokeImpl%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).  -or-  The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</exception>
        <exception cref="T:System.ArgumentException">The method represented by the delegate is invoked on an object or a class that does not support it.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The method represented by the delegate is an instance method and the target object is <see langword="null" />.  -or-  One of the encapsulated methods throws an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">An array of objects that are the arguments to pass to the method represented by the current delegate.  -or-  <see langword="null" />, if the method represented by the current delegate does not require arguments.</param>
        <summary>Dynamically invokes (late-bound) the method represented by the current delegate.</summary>
        <returns>The object returned by the method represented by the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會實作 <xref:System.Delegate.DynamicInvoke%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).  -or-  The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</exception>
        <exception cref="T:System.ArgumentException">The method represented by the delegate is invoked on an object or a class that does not support it.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The method represented by the delegate is an instance method and the target object is <see langword="null" />.  -or-  One of the encapsulated methods throws an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object to compare with the current delegate.</param>
        <summary>Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> and the current delegate have the same targets, methods, and invocation list; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果兩個委派不是相同的型別中，則不會視為相等。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 版中，兩個委派視為相等，如果其目標、 方法和引動過程清單相同，即使為不同類型的委派。  
  
 方法和目標會比較相等，如下所示：  
  
-   如果正在比較的兩個方法都是靜態，且都是相同類別上相同的方法，方法會視為相等，以及目標也視為相等。  
  
-   如果正在比較的兩個方法是執行個體方法，而且都是相同物件上的相同方法，方法會視為相等，以及目標也視為相等。  
  
-   否則，方法不被視為相等，目標也不會視為相等。  
  
 只有具有相同的順序，而且兩個 list 的對應元素代表相同的方法和目標，則兩個引動過程清單會視為相同。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a hash code for the delegate.</summary>
        <returns>A hash code for the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的傳回值必須不會保存兩個原因。 首先，類別的雜湊函式可能會改變以產生較佳的分佈，呈現沒有幫助，舊的雜湊函式的任何值。 第二，這個類別的預設實作不保證，將由不同執行個體傳回相同的值。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the invocation list of the delegate.</summary>
        <returns>An array of delegates representing the invocation list of the current delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 陣列中的每個委派代表一個方法。  
  
 陣列中委派的順序是目前的委派叫用的方法，這些委派所表示的相同順序。  
  
   
  
## Examples  
 下列範例會將三個方法指派給委派。 然後它會呼叫<xref:System.Delegate.GetInvocationList%2A>方法來取得 「 檔案 」 的總計數的方法指派給委派，相反的順序執行的委派，以及執行其名稱不包含子字串的方法。  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the static method represented by the current delegate.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> describing the static method represented by the current delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法僅適用於目前委派所表示的靜態方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Not supported.</param>
        <param name="context">Not supported.</param>
        <summary>Not supported.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">This method is not supported.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the method represented by the delegate.</summary>
        <value>A<see cref="T:System.Reflection.MethodInfo" />描述委派所表示的方法。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">The first delegate to compare.</param>
        <param name="d2">The second delegate to compare.</param>
        <summary>Determines whether the specified delegates are equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="d1" /> is equal to <paramref name="d2" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 兩個具有相同的目標、 方法和引動過程清單之相同類型的委派視為相等。  
  
 如果兩個委派不是相同的型別中，則不會視為相等。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 版中，兩個委派視為相等，如果其目標、 方法和引動過程清單相同，即使為不同類型的委派。  
  
 方法和目標會比較相等，如下所示：  
  
-   如果正在比較的兩個方法都是靜態，且都是相同類別上相同的方法，方法會視為相等，以及目標也視為相等。  
  
-   如果正在比較的兩個方法是執行個體方法，而且都是相同物件上的相同方法，方法會視為相等，以及目標也視為相等。  
  
-   否則，方法不被視為相等，目標也不會視為相等。  
  
 如果具有相同的順序，而且兩個 list 的對應元素代表相同的方法和目標，則兩個引動過程清單會視為相同。  
  
 這個運算子的對等方法是 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">The first delegate to compare.</param>
        <param name="d2">The second delegate to compare.</param>
        <summary>Determines whether the specified delegates are not equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="d1" /> is not equal to <paramref name="d2" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它們是不同的類型，或是有不同的方法、 不同的目標或不同的引動過程清單，即視為等於不到兩個委派。  
  
 如果兩個委派不是相同的型別中，則不會視為相等。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 版中，兩個委派視為相等，如果其目標、 方法和引動過程清單相同，即使為不同類型的委派。  
  
 方法和目標會比較相等，如下所示：  
  
-   如果正在比較的兩個方法都是靜態，且都是相同類別上相同的方法，方法會視為相等，以及目標也視為相等。  
  
-   如果正在比較的兩個方法是執行個體方法，而且都是相同物件上的相同方法，方法會視為相等，以及目標也視為相等。  
  
-   否則，方法不被視為相等，目標也不會視為相等。  
  
 兩個引動過程清單不相等，如果它們的順序不同，如果有不同的大小，或從一個清單的至少一個項目代表方法或不同於其他清單中其對應項目所表示的目標。  
  
 這個運算子的對等方法是 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The delegate from which to remove the invocation list of <c>value</c>.</param>
        <param name="value">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</param>
        <summary>Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing the last occurrence of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />. Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" /> or if <paramref name="source" /> is a null reference.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果引動過程清單`value`符合一組連續的引動過程清單中的項目`source`，然後引動過程清單`value`發生在引動過程清單中稱為`source`。 如果引動過程清單`value`出現一次以上的引動過程清單中`source`，移除最後一個出現項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <exception cref="T:System.ArgumentException">The delegate types do not match.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The delegate from which to remove the invocation list of <c>value</c>.</param>
        <param name="value">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</param>
        <summary>Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing all occurrences of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />. Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" />, if <paramref name="source" /> contains only a series of invocation lists that are equal to the invocation list of <paramref name="value" />, or if <paramref name="source" /> is a null reference.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果引動過程清單`value`符合一組連續的引動過程清單中的項目`source`，然後引動過程清單`value`發生在引動過程清單中稱為`source`。 如果引動過程清單`value`出現一次以上的引動過程清單中`source`，會移除所有項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <exception cref="T:System.ArgumentException">The delegate types do not match.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</param>
        <summary>Removes the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the current delegate's invocation list. Returns the current delegate if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the current delegate's invocation list. Returns <see langword="null" /> if the invocation list of <paramref name="value" /> is equal to the current delegate's invocation list.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果引動過程清單`value`符合一組連續的目前委派的引動過程清單中，則引動過程清單中的項目`value`稱為發生在目前的委派引動過程清單中。 如果引動過程清單`value`發生超過一次在目前的委派引動過程清單中，移除最後一個出現項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the class instance on which the current delegate invokes the instance method.</summary>
        <value>在其中目前的委派叫用的執行個體方法，委派所表示的執行個體方法; 如果物件<see langword="null" />如果委派所表示的靜態方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 如果委派叫用一或多個執行個體方法，這個屬性會傳回目標的最後一個執行個體方法的引動過程清單中。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>