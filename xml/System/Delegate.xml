<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Delegate.xml" source-language="en-US" target-language="zh-TW">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac53f0536eac77f3171e3a7eeb74486cfcf863ec3d8.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3f0536eac77f3171e3a7eeb74486cfcf863ec3d8</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</source>
          <target state="translated">表示委派，它是參考靜態方法或該類別的類別執行個體和執行個體方法 (Instance Method) 的資料結構。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class is the base class for delegate types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Delegate&gt;</ph>類別是委派類型的基底類別。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>However, only the system and compilers can derive explicitly from the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class or from the <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> class.</source>
          <target state="translated">不過，只有系統和編譯器可以明確地從衍生<ph id="ph1">&lt;xref:System.Delegate&gt;</ph>類別或從<ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>It is also not permissible to derive a new type from a delegate type.</source>
          <target state="translated">它也是不允許從委派型別衍生新的類型。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class is not considered a delegate type; it is a class used to derive delegate types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Delegate&gt;</ph>類別不是委派類型，則可以用來衍生委派類型的類別。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Most languages implement a <ph id="ph1">`delegate`</ph> keyword, and compilers for those languages are able to derive from the <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> class; therefore, users should use the <ph id="ph3">`delegate`</ph> keyword provided by the language.</source>
          <target state="translated">大部分語言實作<ph id="ph1">`delegate`</ph>關鍵字，與這些語言的編譯器可衍生自<ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph>類別; 因此，使用者應該使用<ph id="ph3">`delegate`</ph>語言所提供的關鍵字。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The common language runtime provides an <ph id="ph1">`Invoke`</ph> method for each delegate type, with the same signature as the delegate.</source>
          <target state="translated">Common language runtime 提供<ph id="ph1">`Invoke`</ph>每種委派類型，相同的簽章與委派的方法。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>You do not have to call this method explicitly from C#, Visual Basic, or Visual C++, because the compilers call it automatically.</source>
          <target state="translated">您不需要明確地呼叫這個方法從 C#、 Visual Basic 或 Visual c + + 中，因為編譯器會自動呼叫。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">`Invoke`</ph> method is useful in <bpt id="p1">[</bpt>reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/reflection.md)</ept> when you want to find the signature of the delegate type.</source>
          <target state="translated"><ph id="ph1">`Invoke`</ph>方法中很有用<bpt id="p1">[</bpt>反映<ept id="p1">](~/docs/framework/reflection-and-codedom/reflection.md)</ept>當您想要尋找的委派類型簽章。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The common language runtime provides each delegate type with <ph id="ph1">`BeginInvoke`</ph> and <ph id="ph2">`EndInvoke`</ph> methods, to enable asynchronous invocation of the delegate.</source>
          <target state="translated">Common language runtime 提供的每個委派型別<ph id="ph1">`BeginInvoke`</ph>和<ph id="ph2">`EndInvoke`</ph>方法，以啟用委派的非同步引動過程。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>For more information about these methods, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">如需有關這些方法的詳細資訊，請參閱<bpt id="p1">[</bpt>呼叫同步方法以非同步方式<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The declaration of a delegate type establishes a contract that specifies the signature of one or more methods.</source>
          <target state="translated">委派類型的宣告會建立指定的一個或多個方法的簽章的合約。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate is an instance of a delegate type that has references to:</source>
          <target state="translated">委派是具有參考委派類型的執行個體：</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>An instance method of a type and a target object assignable to that type.</source>
          <target state="translated">類型和目標物件指派給該類型的執行個體方法。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>An instance method of a type, with the hidden <ph id="ph1">`this`</ph> parameter exposed in the formal parameter list.</source>
          <target state="translated">類型，並隱藏執行個體方法<ph id="ph1">`this`</ph>公開型式參數清單中的參數。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate is said to be an open instance delegate.</source>
          <target state="translated">委派是要開啟執行個體委派。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A static method.</source>
          <target state="translated">靜態方法。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A static method and a target object assignable to the first parameter of the method.</source>
          <target state="translated">靜態方法，而且指派給該方法的第一個參數的目標物件。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate is said to be closed over its first argument.</source>
          <target state="translated">此委派會在其第一個引數上關閉。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>For more information on delegate binding, see the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">如需委派繫結的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph>方法多載。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>In the .NET Framework versions 1.0 and 1.1, a delegate can represent a method only if the signature of the method exactly matches the signature specified by the delegate type.</source>
          <target state="translated">在.NET framework 1.0 和 1.1 版中，委派可以表示方法，只有當方法的簽章完全相符的委派型別指定的簽章。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Thus, only the first and third bullets in the preceding list are supported, and the first bullet requires an exact type match.</source>
          <target state="translated">因此，只有第一個和第三個項目符號前述清單中的都有支援，而且第一個項目符號需要型別完全符合。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents an instance method closed over its first argument (the most common case), the delegate stores a reference to the method's entry point and a reference to an object, called the target, which is of a type assignable to the type that defined the method.</source>
          <target state="translated">委派表示關閉其第一個引數 （最常見的情況） 上的執行個體方法，委派會儲存方法的進入點的參考和參考的物件，稱為目標，是指派給類型定義的型別方法。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents an open instance method, it stores a reference to the method's entry point.</source>
          <target state="translated">當委派表示的開啟執行個體方法時，它會儲存方法的進入點的參考。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate signature must include the hidden <ph id="ph1">`this`</ph> parameter in its formal parameter list; in this case, the delegate does not have a reference to a target object, and a target object must be supplied when the delegate is invoked.</source>
          <target state="translated">委派簽章必須包含隱藏<ph id="ph1">`this`</ph>其型式參數清單中的參數; 在此情況下，委派沒有目標物件的參考，而且叫用委派時，必須提供目標物件。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents a static method, the delegate stores a reference to the method's entry point.</source>
          <target state="translated">當委派表示的靜態方法時，委派會儲存方法的進入點的參考。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents a static method closed over its first argument, the delegate stores a reference to the method's entry point and a reference to a target object assignable to the type of the method's first argument.</source>
          <target state="translated">委派表示關閉其第一個引數上的靜態方法，委派會儲存方法的進入點的參考，以及指派給方法的第一個引數類型的目標物件的參考。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the delegate is invoked, the first argument of the static method receives the target object.</source>
          <target state="translated">叫用委派時，第一個引數的靜態方法會接收目標物件。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The invocation list of a delegate is an ordered set of delegates in which each element of the list invokes exactly one of the methods represented by the delegate.</source>
          <target state="translated">委派的引動過程清單是在其中清單的每個項目叫用一個委派所表示之方法的委派的已排序的集合。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>An invocation list can contain duplicate methods.</source>
          <target state="translated">引動過程清單可以包含重複的方法。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>During an invocation, methods are invoked in the order in which they appear in the invocation list.</source>
          <target state="translated">在引動過程，方法會叫用引動過程清單中的出現的順序。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate attempts to invoke every method in its invocation list; duplicates are invoked once for each time they appear in the invocation list.</source>
          <target state="translated">委派會嘗試叫用每個方法，在其引動過程清單。重複的項目會叫用之後每次它們出現在引動過程清單。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Delegates are immutable; once created, the invocation list of a delegate does not change.</source>
          <target state="translated">委派是不可變的;一旦建立之後，就不會變更委派的引動過程清單。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Delegates are referred to as multicast, or combinable, because a delegate can invoke one or more methods and can be used in combining operations.</source>
          <target state="translated">委派會參照多點傳送，或可組合的類別，因為委派可以叫用一或多個方法，可用於合併作業。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Combining operations, such as <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph>, do not alter existing delegates.</source>
          <target state="translated">合併作業，例如<ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph>，不會改變現有的委派。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Instead, such an operation returns a new delegate that contains the results of the operation, an unchanged delegate, or <ph id="ph1">`null`</ph>.</source>
          <target state="translated">相反地，這類作業會傳回新的委派，其中包含變更的委派，作業的結果或<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A combining operation returns <ph id="ph1">`null`</ph> when the result of the operation is a delegate that does not reference at least one method.</source>
          <target state="translated">合併作業會傳回<ph id="ph1">`null`</ph>運算的結果時不會參考至少一個方法的委派。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A combining operation returns an unchanged delegate when the requested operation has no effect.</source>
          <target state="translated">合併作業會傳回未變更的委派，當要求的作業沒有任何作用。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Managed languages use the <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph> methods to implement delegate operations.</source>
          <target state="translated">Managed 語言使用<ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph>實作委派作業的方法。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Examples include the <ph id="ph1">`AddHandler`</ph> and <ph id="ph2">`RemoveHandler`</ph> statements in Visual Basic and the += and -= operators on delegate types in C#.</source>
          <target state="translated">範例包括<ph id="ph1">`AddHandler`</ph>和<ph id="ph2">`RemoveHandler`</ph>在 Visual Basic 中的陳述式和 + = 和-= 運算子委派 C# 中的型別。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, generic delegate types can have variant type parameters.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>，泛型委派類型可以有 variant 型別參數。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Contravariant type parameters can be used as parameter types of the delegate, and a covariant type parameter can be used as the return type.</source>
          <target state="translated">Contravariant 型別參數可以用做為委派的參數類型與 covariant 類型參數可用來當做傳回型別。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>This feature allows generic delegate types that are constructed from the same generic type definition to be assignment-compatible if their type arguments are reference types with an inheritance relationship, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>.</source>
          <target state="translated">此功能可讓泛型委派類型都從相同泛型類型定義中所述，是指派相容如果其類型引數是參考類型，具有繼承關係，建構<bpt id="p1">[</bpt>共變數和反變數<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
          <target state="translated">泛型委派指派相容，因為差異不一定可組合的類別。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>To be combinable, the types must match exactly.</source>
          <target state="translated">若要可組合的類別，類型必須完全相符。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
          <target state="translated">例如，假設 具名的類別<ph id="ph1">`Derived`</ph>衍生自類別，名為<ph id="ph2">`Base`</ph>。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, but the two delegates cannot be combined because the types do not match exactly.</source>
          <target state="translated">類型的委派<ph id="ph1">`Action&lt;Base&gt;`</ph>(<ph id="ph2">`Action(Of Base)`</ph>在 Visual Basic 中) 可以指派給類型的變數<ph id="ph3">`Action&lt;Derived&gt;`</ph>，但無法結合兩個委派，因為類型不完全相符。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>If an invoked method throws an exception, the method stops executing, the exception is passed back to the caller of the delegate, and remaining methods in the invocation list are not invoked.</source>
          <target state="translated">如果叫用的方法擲回例外狀況，則方法會停止執行、 的委派，呼叫端傳遞的例外狀況和引動過程清單中的剩餘方法不會叫用。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Catching the exception in the caller does not alter this behavior.</source>
          <target state="translated">在呼叫端攔截例外狀況不會改變此行為。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the signature of the methods invoked by a delegate includes a return value, the delegate returns the return value of the last element in the invocation list.</source>
          <target state="translated">當透過委派叫用的方法簽章包含傳回值時，委派會傳回引動過程清單最後一個元素的傳回值。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the signature includes a parameter that is passed by reference, the final value of the parameter is the result of every method in the invocation list executing sequentially and updating the parameter's value.</source>
          <target state="translated">當簽章包含傳址方式傳遞的參數時，最後一個參數的值會是每個方法引動過程清單，依序執行，並更新參數的值中的結果。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The closest equivalent of a delegate in C or C++ is a function pointer.</source>
          <target state="translated">最接近的委派，在 C 或 c + + 中相當函式指標。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate can represent a static method or an instance method.</source>
          <target state="translated">委派可以表示的靜態方法或執行個體方法。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the delegate represents an instance method, the delegate stores not only a reference to the method's entry point, but also a reference to the class instance.</source>
          <target state="translated">委派表示的執行個體方法，委派會儲存參考方法的進入點，不僅類別執行個體的參考。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Unlike function pointers, delegates are object oriented and type safe.</source>
          <target state="translated">不同之處在於，委派是物件導向，而且型別安全。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The following example shows how to define a delegate named <ph id="ph1">`myMethodDelegate`</ph>.</source>
          <target state="translated">下列範例示範如何定義名為委派<ph id="ph1">`myMethodDelegate`</ph>。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Instances of this delegate are created for an instance method and a static method of the nested <ph id="ph1">`mySampleClass`</ph> class.</source>
          <target state="translated">此委派的執行個體的執行個體方法的巢狀的靜態方法會針對建立<ph id="ph1">`mySampleClass`</ph>類別。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate for the instance method requires an instance of <ph id="ph1">`mySampleClass`</ph>.</source>
          <target state="translated">執行個體方法的委派需要的執行個體<ph id="ph1">`mySampleClass`</ph>。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">`mySampleClass`</ph> instance is saved in a variable named <ph id="ph2">`mySC`</ph>.</source>
          <target state="translated"><ph id="ph1">`mySampleClass`</ph>執行個體儲存在名為的變數<ph id="ph2">`mySC`</ph>。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Initializes a new delegate.</source>
          <target state="translated">初始化新的委派。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>The class instance on which the delegate invokes <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">委派叫用 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 所在的類別執行個體。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>The name of the instance method that the delegate represents.</source>
          <target state="translated">委派表示的執行個體方法名稱。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>Initializes a delegate that invokes the specified instance method on the specified class instance.</source>
          <target state="translated">初始化委派，這個委派會在指定的類別執行個體上叫用指定的執行個體方法。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>This constructor cannot be used in application code.</source>
          <target state="translated">這個建構函式不能在應用程式程式碼。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>To create a delegate by specifying the name of an instance method, use an overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specifies a method name and a target object.</source>
          <target state="translated">若要建立委派，藉由指定的執行個體方法名稱，使用的多載<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>指定方法名稱和目標物件的方法。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29&gt;</ph> method overload creates a delegate for an instance method with a specified name.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29&gt;</ph>方法多載會建立具有指定名稱的執行個體方法的委派。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>This constructor creates delegates for instance methods only.</source>
          <target state="translated">這個建構函式只會建立委派執行個體方法。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>There was an error binding to the target method.</source>
          <target state="translated">繫結至目標方法時發生錯誤。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that defines <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>，表示定義 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 的類別。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>The name of the static method that the delegate represents.</source>
          <target state="translated">委派表示的靜態方法名稱。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>Initializes a delegate that invokes the specified static method from the specified class.</source>
          <target state="translated">初始化委派，這個委派會從指定的類別叫用指定的靜態方法。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>This constructor cannot be used in application code.</source>
          <target state="translated">這個建構函式不能在應用程式程式碼。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>To create a delegate by specifying the name of a static method, use an overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specifies a method name but does not specify a target object.</source>
          <target state="translated">若要建立委派，藉由指定的靜態方法名稱，使用的多載<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>指定方法名稱，但未指定目標物件的方法。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29&gt;</ph> method overload creates a static delegate for a method with a specified name.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29&gt;</ph>方法多載會建立具有指定名稱的靜態方法的委派。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>This constructor creates delegates for static methods only.</source>
          <target state="translated">這個建構函式會建立只使用靜態方法的委派。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> represents an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 代表開放式泛型類型。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Delegate.Clone">
          <source>Creates a shallow copy of the delegate.</source>
          <target state="translated">建立委派的淺層複本 (Shallow Copy)。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Delegate.Clone">
          <source>A shallow copy of the delegate.</source>
          <target state="translated">委派的淺層複本。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>The clone has the same <ph id="ph1">&lt;xref:System.Type&gt;</ph>, target, method, and invocation list as the original delegate.</source>
          <target state="translated">複製品具有相同的<ph id="ph1">&lt;xref:System.Type&gt;</ph>，與原始的委派目標、 方法和引動過程清單。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>A shallow copy creates a new instance of the same type as the original object, and then copies the nonstatic fields of the original object.</source>
          <target state="translated">淺層複本建立的原始物件，與相同類型的新執行個體，然後複製原始物件的非靜態欄位。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>If the field is a value type, a bit-by-bit copy of the field is performed.</source>
          <target state="translated">如果欄位是實值類型，則會執行位元欄位的複本。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>If the field is a reference type, the reference is copied but the referred object is not; therefore, the reference in the original object and the reference in the clone point to the same object.</source>
          <target state="translated">如果欄位是參考類型，則會複製參考，但參考的物件不;因此，原始物件的參考和複製品中的參考點相同的物件。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>In contrast, a deep copy of an object duplicates everything directly or indirectly referenced by the fields in the object.</source>
          <target state="translated">相較之下，物件的深層複本複製直接或間接參考之物件中欄位的所有項目。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Concatenates the invocation lists of the specified multicast (combinable) delegates.</source>
          <target state="translated">串連指定多點傳送 (可結合的) 委派的引動過程清單。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>The array of delegates to combine.</source>
          <target state="translated">要結合的委派陣列。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Concatenates the invocation lists of an array of delegates.</source>
          <target state="translated">串連委派陣列的引動過程清單。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <ph id="ph1">&lt;paramref name="delegates" /&gt;</ph> array.</source>
          <target state="translated">具有引動過程清單的新委派，此清單可串連 <ph id="ph1">&lt;paramref name="delegates" /&gt;</ph> 陣列中委派的引動過程清單。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="delegates" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, if <ph id="ph4">&lt;paramref name="delegates" /&gt;</ph> contains zero elements, or if every entry in <ph id="ph5">&lt;paramref name="delegates" /&gt;</ph> is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="delegates" /&gt;</ph> 是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>、<ph id="ph4">&lt;paramref name="delegates" /&gt;</ph> 包含零個元素，或者 <ph id="ph5">&lt;paramref name="delegates" /&gt;</ph> 中的每個項目都是 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，則會傳回 <ph id="ph6">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>If the <ph id="ph1">`delegates`</ph> array contains entries that are <ph id="ph2">`null`</ph>, those entries are ignored.</source>
          <target state="translated">如果<ph id="ph1">`delegates`</ph>陣列包含的項目<ph id="ph2">`null`</ph>，這些項目會被忽略。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
          <target state="translated">引動過程清單可以包含重複的項目。也就是指相同的方法，在相同物件上的項目。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
          <target state="translated">泛型委派指派相容，因為差異不一定可組合的類別。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>To be combinable, the types must match exactly.</source>
          <target state="translated">若要可組合的類別，類型必須完全相符。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
          <target state="translated">例如，假設 具名的類別<ph id="ph1">`Derived`</ph>衍生自類別，名為<ph id="ph2">`Base`</ph>。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, but the two delegates cannot be combined because the types do not match exactly.</source>
          <target state="translated">類型的委派<ph id="ph1">`Action&lt;Base&gt;`</ph>(<ph id="ph2">`Action(Of Base)`</ph>在 Visual Basic 中) 可以指派給類型的變數<ph id="ph3">`Action&lt;Derived&gt;`</ph>，如下所述<bpt id="p1">[</bpt>共變數和反變數<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>，而無法合併兩個委派，因為型別不完全符合。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> is useful for creating event handlers that call multiple methods each time an event occurs.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> 可用於建立多個方法時間事件的呼叫，就會發生的事件處理常式。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Not all the non-null entries in <ph id="ph1">&lt;paramref name="delegates" /&gt;</ph> are instances of the same delegate type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delegates" /&gt;</ph> 中的所有非 Null 元素並非都是相同委派型別的執行個體。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>The delegate whose invocation list comes first.</source>
          <target state="translated">引動過程清單首先到達的委派。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>The delegate whose invocation list comes last.</source>
          <target state="translated">引動過程清單最後到達的委派。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Concatenates the invocation lists of two delegates.</source>
          <target state="translated">串連兩個委派的引動過程清單。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>A new delegate with an invocation list that concatenates the invocation lists of <ph id="ph1">&lt;paramref name="a" /&gt;</ph> and <ph id="ph2">&lt;paramref name="b" /&gt;</ph> in that order.</source>
          <target state="translated">具有引動過程清單的新委派，這個清單可以該順序串連 <ph id="ph1">&lt;paramref name="a" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="b" /&gt;</ph> 的引動過程清單。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Returns <ph id="ph1">&lt;paramref name="a" /&gt;</ph> if <ph id="ph2">&lt;paramref name="b" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, returns <ph id="ph4">&lt;paramref name="b" /&gt;</ph> if <ph id="ph5">&lt;paramref name="a" /&gt;</ph> is a null reference, and returns a null reference if both <ph id="ph6">&lt;paramref name="a" /&gt;</ph> and <ph id="ph7">&lt;paramref name="b" /&gt;</ph> are null references.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="b" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，則會傳回 <ph id="ph1">&lt;paramref name="a" /&gt;</ph>；如果 <ph id="ph5">&lt;paramref name="a" /&gt;</ph> 為 Null 參考，則會傳回 <ph id="ph4">&lt;paramref name="b" /&gt;</ph>；如果 <ph id="ph6">&lt;paramref name="a" /&gt;</ph> 和 <ph id="ph7">&lt;paramref name="b" /&gt;</ph> 兩者都是 Null 參考，則會傳回 Null 參考。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
          <target state="translated">引動過程清單可以包含重複的項目。也就是指相同的方法，在相同物件上的項目。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
          <target state="translated">泛型委派指派相容，因為差異不一定可組合的類別。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>To be combinable, the types must match exactly.</source>
          <target state="translated">若要可組合的類別，類型必須完全相符。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
          <target state="translated">例如，假設 具名的類別<ph id="ph1">`Derived`</ph>衍生自類別，名為<ph id="ph2">`Base`</ph>。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, but the two delegates cannot be combined because the types do not match exactly.</source>
          <target state="translated">類型的委派<ph id="ph1">`Action&lt;Base&gt;`</ph>(<ph id="ph2">`Action(Of Base)`</ph>在 Visual Basic 中) 可以指派給類型的變數<ph id="ph3">`Action&lt;Derived&gt;`</ph>，如下所述<bpt id="p1">[</bpt>共變數和反變數<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>，而無法合併兩個委派，因為型別不完全符合。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> is useful for creating event handlers that call multiple methods each time an event occurs.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> 可用於建立多個方法時間事件的呼叫，就會發生的事件處理常式。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Both <ph id="ph1">&lt;paramref name="a" /&gt;</ph> and <ph id="ph2">&lt;paramref name="b" /&gt;</ph> are not <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="a" /&gt;</ph> and <ph id="ph5">&lt;paramref name="b" /&gt;</ph> are not instances of the same delegate type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="a" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="b" /&gt;</ph> 都不是 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，而且 <ph id="ph4">&lt;paramref name="a" /&gt;</ph> 和 <ph id="ph5">&lt;paramref name="b" /&gt;</ph> 不是相同委派類型的執行個體。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</source>
          <target state="translated">多點傳送 (可結合的) 委派，其引動過程清單要附加到目前多點傳送 (可結合的) 委派的引動過程清單末端。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</source>
          <target state="translated">串連指定的多點傳送 (可結合的) 委派和目前多點傳送 (可結合的) 委派的引動過程清單。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <ph id="ph1">&lt;paramref name="d" /&gt;</ph>, or the current multicast (combinable) delegate if <ph id="ph2">&lt;paramref name="d" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">具有引動過程清單的新多點傳送 (可結合式) 委派，此清單可串連目前多點傳送 (可結合式) 委派的引動過程清單和 <ph id="ph1">&lt;paramref name="d" /&gt;</ph> 的引動過程清單之委派；而在 <ph id="ph2">&lt;paramref name="d" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph> 時，則為目前多點傳送 (可結合式) 委派。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>This method applies only if the current delegate is multicast (combinable).</source>
          <target state="translated">這個方法僅適用於目前的委派是多點傳送 （可結合的）。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>The current implementation simply throws a <ph id="ph1">&lt;xref:System.MulticastNotSupportedException&gt;</ph>.</source>
          <target state="translated">目前的實作只會擲回<ph id="ph1">&lt;xref:System.MulticastNotSupportedException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
          <target state="translated">引動過程清單可以包含重複的項目。也就是指相同的方法，在相同物件上的項目。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>Always thrown.</source>
          <target state="translated">一律擲回。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Creates a delegate of the specified type.</source>
          <target state="translated">建立指定類型的委派。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">要建立之委派的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>，描述委派所要表示的靜態或執行個體方法。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Only static methods are supported in the .NET Framework version 1.0 and 1.1.</source>
          <target state="translated">在 .NET Framework 1.0 和 1.1 版中只支援靜態方法。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Creates a delegate of the specified type to represent the specified static method.</source>
          <target state="translated">建立指定類型的委派來表示指定的靜態方法。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A delegate of the specified type to represent the specified static method.</source>
          <target state="translated">指定類型的委派，用來表示指定的靜態方法。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 1.0 and 1.1, this method overload creates delegates for static methods only.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 版中，這個方法多載會建立只使用靜態方法的委派。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 2.0, this method overload also can create open instance method delegates; that is, delegates that explicitly supply the hidden first argument of instance methods.</source>
          <target state="translated">在.NET Framework 2.0 版中，這個方法多載也可以建立開啟執行個體方法的委派。也就是明確地提供隱藏第一個引數的委派執行個體方法。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>For a detailed explanation, see the more general <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods, and optionally to specify a first argument.</source>
          <target state="translated">詳細的說明，請參閱更多一般<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph>方法多載，可讓您建立所有組合的開放式或封閉式委派執行個體或靜態方法，並選擇性地指定第一個引數。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</source>
          <target state="translated">這個方法多載應該時使用委派未關閉透過其第一個引數，因為它在該情況下是稍快。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">這個方法多載就相當於呼叫<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph>方法多載，並指定<ph id="ph2">`true`</ph>如<ph id="ph3">`throwOnBindFailure`</ph>。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，這個方法可以用來存取非公用方法，如果呼叫端被授與<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>與<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用這項功能，您的應用程式應將目標設為 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> (含) 以後版本。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">相容的參數型別和傳回型別</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 2.0, the parameter types and return type of a delegate created using this method overload must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">在.NET Framework 2.0 版中，參數型別和使用這個方法多載來建立委派的傳回型別必須是相容的參數類型和傳回型別方法委派所表示。型別沒有完全相符。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This represents a relaxation of the binding behavior in the .NET Framework version 1.0 and 1.1, where the types must match exactly.</source>
          <target state="translated">這代表放寬的.NET Framework 1.0 和 1.1 中，類型必須完全相符的版本中的繫結行為。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">例如，類型參數的委派<ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>和傳回型別<ph id="ph2">&lt;xref:System.Object&gt;</ph>可以代表具有型別參數的方法<ph id="ph3">&lt;xref:System.Object&gt;</ph>和傳回值的型別<ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This section contains two code examples.</source>
          <target state="translated">本節包含兩個程式碼範例。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</source>
          <target state="translated">第一個範例示範兩種可以使用這個方法多載來建立的委派： 透過執行個體方法開啟，並開啟透過靜態方法。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">第二個程式碼範例會示範相容的參數型別和傳回型別。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>範例 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates the two ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">下列程式碼範例示範兩種方式可使用的這個多載來建立委派<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">有兩個多載<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>方法指定<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>，而不是第一次的引數; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This code example uses both overloads.</source>
          <target state="translated">這個程式碼範例會使用這兩個多載。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and two delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, and <ph id="ph6">`D2`</ph> takes a string.</source>
          <target state="translated">此範例會宣告類別<ph id="ph1">`C`</ph>的靜態方法<ph id="ph2">`M2`</ph>和執行個體方法<ph id="ph3">`M1`</ph>，以及兩個委派型別：<ph id="ph4">`D1`</ph>可接受的執行個體<ph id="ph5">`C`</ph>和字串，並<ph id="ph6">`D2`</ph>接受字串。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">名為第二個類別<ph id="ph1">`Example`</ph>包含建立委派的程式碼。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">類型的委派<ph id="ph1">`D1`</ph>，表示開啟的執行個體方法，建立執行個體方法<ph id="ph2">`M1`</ph>。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">當叫用委派時，必須傳遞執行個體。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">類型的委派<ph id="ph1">`D2`</ph>，代表開放式的靜態方法，建立靜態方法<ph id="ph2">`M2`</ph>。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>範例 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">下列程式碼範例示範的參數類型相容性和傳回型別。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">程式碼範例定義名為基底類別<ph id="ph1">`Base`</ph>和類別，名為<ph id="ph2">`Derived`</ph>衍生自<ph id="ph3">`Base`</ph>。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">在衍生的類別具有<ph id="ph1">`static`</ph>(<ph id="ph2">`Shared`</ph>在 Visual Basic 中) 方法名為<ph id="ph3">`MyMethod`</ph>具有型別的一個參數<ph id="ph4">`Base`</ph>和傳回型別<ph id="ph5">`Derived`</ph>。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">程式碼範例也會定義名為委派<ph id="ph1">`Example`</ph>具有型別的一個參數<ph id="ph2">`Derived`</ph>和傳回型別<ph id="ph3">`Base`</ph>。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">程式碼範例將示範委派名為<ph id="ph1">`Example`</ph>可以用來表示方法<ph id="ph2">`MyMethod`</ph>。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">方法可以繫結至委派，因為：</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">委派的參數型別 (<ph id="ph1">`Derived`</ph>) 是更具限制性的參數型別<ph id="ph2">`MyMethod`</ph>(<ph id="ph3">`Base`</ph>)，因此一律會安全地傳遞至委派的引數、 <ph id="ph4">`MyMethod`</ph>。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">傳回型別<ph id="ph1">`MyMethod`</ph>(<ph id="ph2">`Derived`</ph>) 是更具限制性的委派的參數類型 (<ph id="ph3">`Base`</ph>)，如此可永遠放心轉型為委派的傳回型別方法的傳回型別。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example produces no output.</source>
          <target state="translated">程式碼範例會產生任何輸出。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不會繼承 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a static method, and the .NET Framework version is 1.0 or 1.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 不是靜態方法，而 .NET Framework 版本為 1.0 或 1.1。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound.</source>
          <target state="translated">無法繫結 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">找不到 <ph id="ph2">&lt;paramref name="type" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">呼叫端沒有存取 <ph id="ph1">&lt;paramref name="method" /&gt;</ph> 所需的權限。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">關聯的列舉型別：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">要建立之委派的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The object to which the delegate is bound, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> to treat <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> as <ph id="ph2">&lt;see langword="static" /&gt;</ph> (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">此委派要繫結的物件，或是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，表示將 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 視為 <ph id="ph2">&lt;see langword="static" /&gt;</ph> (Visual Basic 中則為 <ph id="ph3">&lt;see langword="Shared" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>，描述委派所要表示的靜態或執行個體方法。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</source>
          <target state="translated">建立指定之類型的委派，其表示指定之靜態或執行個體方法，並有指定第一個引數。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of the specified type that represents the specified static or instance method.</source>
          <target state="translated">指定之類型的委派，其表示指定的靜態或執行個體方法。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Calling this method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">呼叫這個方法多載就相當於呼叫<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph>方法多載，並指定<ph id="ph2">`true`</ph>如<ph id="ph3">`throwOnBindFailure`</ph>。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>These two overloads provide the most flexible way to create delegates.</source>
          <target state="translated">這些兩個多載提供最具彈性的方式來建立委派。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>You can use them to create delegates for either static or instance methods, and optionally to specify the first argument.</source>
          <target state="translated">您可以使用它們來建立委派靜態或執行個體方法，並選擇性地指定第一個引數。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If you do not supply a first argument, use the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload for better performance.</source>
          <target state="translated">如果您未提供第一個引數，使用<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>方法多載，以提升效能。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The delegate type and the method must have compatible return types.</source>
          <target state="translated">委派型別和方法必須具有相容的傳回類型。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>That is, the return type of <ph id="ph1">`method`</ph> must be assignable to the return type of <ph id="ph2">`type`</ph>.</source>
          <target state="translated">也就是傳回型別<ph id="ph1">`method`</ph>必須可以指派給的傳回型別<ph id="ph2">`type`</ph>。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, it is passed to <ph id="ph2">`method`</ph> every time the delegate is invoked; <ph id="ph3">`firstArgument`</ph> is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</source>
          <target state="translated">如果<ph id="ph1">`firstArgument`</ph>是提供，它會傳遞至<ph id="ph2">`method`</ph>每次叫用委派。<ph id="ph3">`firstArgument`</ph>稱為繫結至委派，並委派會在其第一個引數上關閉。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if <ph id="ph4">`method`</ph> is an instance method, then <ph id="ph5">`firstArgument`</ph> is passed to the hidden instance parameter (represented by <ph id="ph6">`this`</ph> in C#, or by <ph id="ph7">`Me`</ph> in Visual Basic).</source>
          <target state="translated">如果<ph id="ph1">`method`</ph>是<ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph>在 Visual Basic 中)，則引數叫用委派時所提供的清單包含第一個; 以外的所有參數，如果<ph id="ph4">`method`</ph>是執行個體方法，則<ph id="ph5">`firstArgument`</ph>傳遞到隱藏的執行個體參數 (由<ph id="ph6">`this`</ph>在 C# 中，或由<ph id="ph7">`Me`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, the first parameter of <ph id="ph2">`method`</ph> must be a reference type, and <ph id="ph3">`firstArgument`</ph> must be compatible with that type.</source>
          <target state="translated">如果<ph id="ph1">`firstArgument`</ph>提供的第一個參數<ph id="ph2">`method`</ph>必須是參考類型，和<ph id="ph3">`firstArgument`</ph>必須相容於該型別。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) and its first parameter is of type <ph id="ph4">&lt;xref:System.Object&gt;</ph> or <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, then <ph id="ph6">`firstArgument`</ph> can be a value type.</source>
          <target state="translated">如果<ph id="ph1">`method`</ph>是<ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph>在 Visual Basic 中) 和其第一個參數的類型是<ph id="ph4">&lt;xref:System.Object&gt;</ph>或<ph id="ph5">&lt;xref:System.ValueType&gt;</ph>，然後<ph id="ph6">`firstArgument`</ph>可以是實值類型。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>In this case <ph id="ph1">`firstArgument`</ph> is automatically boxed.</source>
          <target state="translated">在此情況下<ph id="ph1">`firstArgument`</ph>會自動進行 boxed 處理。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</source>
          <target state="translated">自動 boxing 不會發生的任何其他引數，因為它會以 C# 或 Visual Basic 函式呼叫。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is an instance method, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">如果<ph id="ph1">`firstArgument`</ph>為 null 參考和<ph id="ph2">`method`</ph>是執行個體方法，結果會隨著的委派類型簽章<ph id="ph3">`type`</ph>和<ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signature of <ph id="ph1">`type`</ph> explicitly includes the hidden first parameter of <ph id="ph2">`method`</ph>, the delegate is said to represent an open instance method.</source>
          <target state="translated">如果簽章<ph id="ph1">`type`</ph>明確包含隱藏第一個參數<ph id="ph2">`method`</ph>，此委派來表示開啟的執行個體方法。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">引數清單中的第一個引數叫用委派時，會傳遞到隱藏的執行個體參數的<ph id="ph1">`method`</ph>。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signatures of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</source>
          <target state="translated">如果簽章<ph id="ph1">`method`</ph>和<ph id="ph2">`type`</ph>比對 （也就是所有的參數型別都相容），則此委派會在 null 參考上關閉。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</source>
          <target state="translated">叫用委派就像不是特別有用的做法的 null 執行個體上呼叫執行個體方法。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is static, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">如果<ph id="ph1">`firstArgument`</ph>為 null 參考和<ph id="ph2">`method`</ph>是靜態的結果會隨著的委派類型簽章<ph id="ph3">`type`</ph>和<ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signature of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</source>
          <target state="translated">如果簽章<ph id="ph1">`method`</ph>和<ph id="ph2">`type`</ph>比對 （也就是所有的參數型別都相容），此委派來表示開啟的靜態方法。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This is the most common case for static methods.</source>
          <target state="translated">這是靜態方法的最常見的情況。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>In this case, you can get slightly better performance by using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">在此情況下，您可以取得稍微提升效能，使用<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>方法多載。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signature of <ph id="ph1">`type`</ph> begins with the second parameter of <ph id="ph2">`method`</ph> and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</source>
          <target state="translated">如果簽章<ph id="ph1">`type`</ph>開頭的第二個參數<ph id="ph2">`method`</ph>，而且其餘的參數類型相容，則此委派會在 null 參考上關閉。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When the delegate is invoked, a null reference is passed to the first parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">叫用委派時，第一個參數來傳遞 null 參考<ph id="ph1">`method`</ph>。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，這個方法可以用來存取非公用方法，如果呼叫端被授與<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>與<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用這項功能，您的應用程式應將目標設為 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> (含) 以後版本。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">相容的參數型別和傳回型別</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">參數類型和委派的傳回型別必須是相容的參數類型和傳回型別方法委派所表示。型別沒有完全相符。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 1.0 and 1.1, the types must match exactly.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 版中，類型必須完全相符。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">例如，類型參數的委派<ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>和傳回型別<ph id="ph2">&lt;xref:System.Object&gt;</ph>可以代表具有型別參數的方法<ph id="ph3">&lt;xref:System.Object&gt;</ph>和傳回值的型別<ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Determining the Methods a Delegate Can Represent</source>
          <target state="translated">判斷方法的委派可以表示</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Another useful way to think of the flexibility provided by this overload of <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</source>
          <target state="translated">另一個有用的方式來想到的這個多載所提供的彈性<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>是任何指定的委派可以代表四個不同的方法簽章與方法類型 （靜態和執行個體） 的組合。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Consider a delegate type <ph id="ph1">`D`</ph> with one argument of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">委派類型，請考慮<ph id="ph1">`D`</ph>具有單一引數的型別<ph id="ph2">`C`</ph>。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following describes the methods <ph id="ph1">`D`</ph> can represent, ignoring the return type since it must match in all cases:</source>
          <target state="translated">下列程式碼說明方法<ph id="ph1">`D`</ph>可表示，因為它必須符合在所有情況下忽略的傳回型別：</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent any instance method that has exactly one argument of type <ph id="ph2">`C`</ph>, regardless of what type the instance method belongs to.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 可以表示有一個引數類型的任何執行個體方法<ph id="ph2">`C`</ph>，不論執行個體方法屬於何種類型。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of the type <ph id="ph3">`method`</ph> belongs to, and the resulting delegate is said to be closed over that instance.</source>
          <target state="translated">當<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>呼叫時，<ph id="ph2">`firstArgument`</ph>類型的執行個體<ph id="ph3">`method`</ph>屬於，並將產生的委派會在該執行個體上關閉。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>(Trivially, <ph id="ph1">`D`</ph> can also be closed over a null reference if <ph id="ph2">`firstArgument`</ph> is a null reference.)</source>
          <target state="translated">(兩者，<ph id="ph1">`D`</ph>也可以關閉透過 null 參考如果<ph id="ph2">`firstArgument`</ph>為 null 參考。)</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent an instance method of <ph id="ph2">`C`</ph> that has no arguments.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 可以表示的執行個體方法<ph id="ph2">`C`</ph>，沒有任何引數。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">當<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>呼叫時，<ph id="ph2">`firstArgument`</ph>為 null 參考。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The resulting delegate represents an open instance method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">產生的委派表示開啟的執行個體方法和執行個體<ph id="ph1">`C`</ph>必須提供每次叫用時。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent a static method that takes one argument of type <ph id="ph2">`C`</ph>, and that method can belong to any type.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 可以代表採用一個引數類型的靜態方法<ph id="ph2">`C`</ph>，而且方法可以屬於任何類型。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">當<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>呼叫時，<ph id="ph2">`firstArgument`</ph>為 null 參考。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The resulting delegate represents an open static method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">產生的委派表示開啟的靜態方法和執行個體<ph id="ph1">`C`</ph>必須提供每次叫用時。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent a static method that belongs to type <ph id="ph2">`F`</ph> and has two arguments, of type <ph id="ph3">`F`</ph> and type <ph id="ph4">`C`</ph>.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 可以表示的靜態方法屬於型別<ph id="ph2">`F`</ph>且具有兩個類型引數，<ph id="ph3">`F`</ph>和型別<ph id="ph4">`C`</ph>。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of <ph id="ph3">`F`</ph>.</source>
          <target state="translated">當<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>呼叫時，<ph id="ph2">`firstArgument`</ph>的執行個體<ph id="ph3">`F`</ph>。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The resulting delegate represents a static method that is closed over that instance of <ph id="ph1">`F`</ph>.</source>
          <target state="translated">產生的委派表示關閉該執行個體上的靜態方法<ph id="ph1">`F`</ph>。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Note that in the case where <ph id="ph1">`F`</ph> and <ph id="ph2">`C`</ph> are the same type, the static method has two arguments of that type.</source>
          <target state="translated">請注意，在案例其中<ph id="ph1">`F`</ph>和<ph id="ph2">`C`</ph>都是相同的型別、 靜態方法會具有該類型的兩個引數。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>(In this case, <ph id="ph1">`D`</ph> is closed over a null reference if <ph id="ph2">`firstArgument`</ph> is a null reference.)</source>
          <target state="translated">(在此情況下，<ph id="ph1">`D`</ph>如果 null 參考透過關閉<ph id="ph2">`firstArgument`</ph>為 null 參考。)</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This section contains three code examples.</source>
          <target state="translated">本節包含三個程式碼範例。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</source>
          <target state="translated">第一個範例將示範委派可建立四種： 關閉透過執行個體方法，透過執行個體方法開啟的靜態方法，透過開啟和關閉透過靜態方法。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">第二個程式碼範例會示範相容的參數型別和傳回型別。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</source>
          <target state="translated">第三個程式碼範例會定義單一委派類型，並顯示可以表示所有委派類型的方法。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>範例 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates the four ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">下列程式碼範例示範您可以使用的這個多載建立委派的四種方式<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">有兩個多載<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>方法指定<ph id="ph2">`firstArgument`</ph>和<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This code example uses both overloads.</source>
          <target state="translated">這個程式碼範例會使用這兩個多載。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and three delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, <ph id="ph6">`D2`</ph> takes a string, and <ph id="ph7">`D3`</ph> has no arguments.</source>
          <target state="translated">此範例會宣告類別<ph id="ph1">`C`</ph>的靜態方法<ph id="ph2">`M2`</ph>和執行個體方法<ph id="ph3">`M1`</ph>，以及三個委派型別：<ph id="ph4">`D1`</ph>可接受的執行個體<ph id="ph5">`C`</ph>和字串，<ph id="ph6">`D2`</ph>採用字串和<ph id="ph7">`D3`</ph>沒有引數。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">名為第二個類別<ph id="ph1">`Example`</ph>包含建立委派的程式碼。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, closed over an instance of <ph id="ph2">`C`</ph>, is created for the instance method <ph id="ph3">`M1`</ph>.</source>
          <target state="translated">類型的委派<ph id="ph1">`D2`</ph>、 執行個體上關閉<ph id="ph2">`C`</ph>，建立執行個體方法<ph id="ph3">`M1`</ph>。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>It is invoked with different strings, to show that the bound instance of <ph id="ph1">`C`</ph> is always used.</source>
          <target state="translated">使用不同的字串，顯示的繫結的執行個體叫用<ph id="ph1">`C`</ph>一律使用。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">類型的委派<ph id="ph1">`D1`</ph>，表示開啟的執行個體方法，建立執行個體方法<ph id="ph2">`M1`</ph>。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">當叫用委派時，必須傳遞執行個體。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">類型的委派<ph id="ph1">`D2`</ph>，代表開放式的靜態方法，建立靜態方法<ph id="ph2">`M2`</ph>。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Finally, a delegate of type <ph id="ph1">`D3`</ph>, closed over a string, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">最後，類型的委派<ph id="ph1">`D3`</ph>字串上為封閉式，建立靜態方法<ph id="ph2">`M2`</ph>。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The method is invoked to show that it uses the bound string.</source>
          <target state="translated">方法會叫用來顯示它所使用的繫結的字串。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>範例 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">下列程式碼範例示範的參數類型相容性和傳回型別。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This code example uses the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">這個程式碼範例會使用<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>方法多載。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The use of other overloads that take <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is similar.</source>
          <target state="translated">使用其他多載會採用<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>類似。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">程式碼範例定義名為基底類別<ph id="ph1">`Base`</ph>和類別，名為<ph id="ph2">`Derived`</ph>衍生自<ph id="ph3">`Base`</ph>。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">在衍生的類別具有<ph id="ph1">`static`</ph>(<ph id="ph2">`Shared`</ph>在 Visual Basic 中) 方法名為<ph id="ph3">`MyMethod`</ph>具有型別的一個參數<ph id="ph4">`Base`</ph>和傳回型別<ph id="ph5">`Derived`</ph>。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">程式碼範例也會定義名為委派<ph id="ph1">`Example`</ph>具有型別的一個參數<ph id="ph2">`Derived`</ph>和傳回型別<ph id="ph3">`Base`</ph>。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">程式碼範例將示範委派名為<ph id="ph1">`Example`</ph>可以用來表示方法<ph id="ph2">`MyMethod`</ph>。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">方法可以繫結至委派，因為：</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">委派的參數型別 (<ph id="ph1">`Derived`</ph>) 是更具限制性的參數型別<ph id="ph2">`MyMethod`</ph>(<ph id="ph3">`Base`</ph>)，因此一律會安全地傳遞至委派的引數、 <ph id="ph4">`MyMethod`</ph>。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">傳回型別<ph id="ph1">`MyMethod`</ph>(<ph id="ph2">`Derived`</ph>) 是更具限制性的委派的參數類型 (<ph id="ph3">`Base`</ph>)，如此可永遠放心轉型為委派的傳回型別方法的傳回型別。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example produces no output.</source>
          <target state="translated">程式碼範例會產生任何輸出。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 3<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>範例 3<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following code example shows all the methods a single delegate type can represent, using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method to create the delegates.</source>
          <target state="translated">下列程式碼範例顯示所有的方法可表示的單一委派類型，使用<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>方法來建立委派。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">有兩個多載<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>方法指定<ph id="ph2">`firstArgument`</ph>和<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This code example uses both overloads.</source>
          <target state="translated">這個程式碼範例會使用這兩個多載。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example defines two classes, <ph id="ph1">`C`</ph> and <ph id="ph2">`F`</ph>, and a delegate type <ph id="ph3">`D`</ph> with one argument of type <ph id="ph4">`C`</ph>.</source>
          <target state="translated">程式碼範例定義兩個類別：<ph id="ph1">`C`</ph>和<ph id="ph2">`F`</ph>，和委派類型<ph id="ph3">`D`</ph>具有單一引數的型別<ph id="ph4">`C`</ph>。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The classes have matching static and instance methods <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, and <ph id="ph3">`M4`</ph>, and class <ph id="ph4">`C`</ph> also has an instance method <ph id="ph5">`M2`</ph> that has no arguments.</source>
          <target state="translated">類別有相符的靜態和執行個體方法<ph id="ph1">`M1`</ph>， <ph id="ph2">`M3`</ph>，和<ph id="ph3">`M4`</ph>，和類別<ph id="ph4">`C`</ph>也有執行個體方法<ph id="ph5">`M2`</ph>，沒有任何引數。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A third class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">名為第三個類別<ph id="ph1">`Example`</ph>包含建立委派的程式碼。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Delegates are created for instance method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each is closed over an instance of the respective type.</source>
          <target state="translated">建立委派執行個體方法<ph id="ph1">`M1`</ph>型別的<ph id="ph2">`C`</ph>和型別<ph id="ph3">`F`</ph>; 每個個別的型別執行個體上已關閉。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">方法<ph id="ph1">`M1`</ph>型別的<ph id="ph2">`C`</ph>顯示<ph id="ph3">`ID`</ph>繫結的執行個體與引數的屬性。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate is created for method <ph id="ph1">`M2`</ph> of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">建立委派方法<ph id="ph1">`M2`</ph>型別的<ph id="ph2">`C`</ph>。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</source>
          <target state="translated">這是開啟的執行個體的委派，其中委派的引數代表的執行個體方法上的隱藏第一個引數。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The method has no other arguments.</source>
          <target state="translated">此方法沒有任何其他引數。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>It is called as if it were a static method.</source>
          <target state="translated">如同一般的靜態方法呼叫它。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Delegates are created for static method <ph id="ph1">`M3`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; these are open static delegates.</source>
          <target state="translated">針對靜態方法建立委派<ph id="ph1">`M3`</ph>型別的<ph id="ph2">`C`</ph>和型別<ph id="ph3">`F`</ph>; 這些是開啟的靜態委派。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Finally, delegates are created for static method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</source>
          <target state="translated">靜態方法建立委派的最後，<ph id="ph1">`M4`</ph>型別的<ph id="ph2">`C`</ph>和型別<ph id="ph3">`F`</ph>; 每個方法都宣告的型別做為其第一個引數，並提供類型的執行個體，因此委派會關閉對其第一個引數.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">方法<ph id="ph1">`M4`</ph>型別的<ph id="ph2">`C`</ph>顯示<ph id="ph3">`ID`</ph>繫結的執行個體與引數的屬性。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不會繼承 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound.</source>
          <target state="translated">無法繫結 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">找不到 <ph id="ph2">&lt;paramref name="type" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">呼叫端沒有存取 <ph id="ph1">&lt;paramref name="method" /&gt;</ph> 所需的權限。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">關聯的列舉型別：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">要建立之委派的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The class instance on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is invoked.</source>
          <target state="translated">叫用 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 的類別執行個體。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The name of the instance method that the delegate is to represent.</source>
          <target state="translated">委派要表示的執行個體方法名稱。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">建立指定類型的委派，這個委派表示要在指定的類別執行個體上叫用的指定執行個體方法。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">指定類型的委派，表示要在指定的類別執行個體上叫用的指定執行個體方法。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>This method creates delegates for instance methods only.</source>
          <target state="translated">這個方法只會建立委派執行個體方法。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`ignoreCase`</ph> and <ph id="ph4">`true`</ph> for <ph id="ph5">`throwOnBindFailure`</ph>.</source>
          <target state="translated">這個方法多載就相當於呼叫<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>方法多載，指定<ph id="ph2">`false`</ph>如<ph id="ph3">`ignoreCase`</ph>和<ph id="ph4">`true`</ph>如<ph id="ph5">`throwOnBindFailure`</ph>。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，這個方法可以用來存取非公用方法，如果呼叫端被授與<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>與<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用這項功能，您的應用程式應將目標設為 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> (含) 以後版本。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不會繼承 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not an instance method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 不是執行個體方法。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found.</source>
          <target state="translated">例如，因為找不到 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>，所以無法將其繫結。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">找不到 <ph id="ph2">&lt;paramref name="type" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">呼叫端沒有存取 <ph id="ph1">&lt;paramref name="method" /&gt;</ph> 所需的權限。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">關聯的列舉型別：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">要建立之委派的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>，描述委派所要表示的靜態或執行個體方法。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示如果無法繫結 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 則擲回例外狀況，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</source>
          <target state="translated">建立指定之類型的委派，用來表示指定之靜態方法，並包含在繫結失敗時發生的指定之行為。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of the specified type to represent the specified static method.</source>
          <target state="translated">指定類型的委派，用來表示指定的靜態方法。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This method overload can create open static method delegates and open instance method delegates — that is, delegates that expose the hidden first argument of instance methods.</source>
          <target state="translated">這個方法多載可以建立開啟的靜態方法的委派，開啟執行個體方法的委派，也就是公開的隱藏第一個引數的委派執行個體方法。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>For a detailed explanation, see the more general <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods.</source>
          <target state="translated">詳細的說明，請參閱更多一般<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph>方法多載，可讓您建立所有的組合，開放式或封閉式的委派的執行個體或靜態方法。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</source>
          <target state="translated">這個方法多載應該時使用委派未關閉透過其第一個引數，因為它在該情況下是稍快。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，這個方法可以用來存取非公用方法，如果呼叫端被授與<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>與<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用這項功能，您的應用程式應將目標設為 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> (含) 以後版本。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">相容的參數型別和傳回型別</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">參數類型和委派的傳回型別必須是相容的參數類型和傳回型別方法委派所表示。型別沒有完全相符。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>In the .NET Framework version 1.0 and 1.1, the types must match exactly.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 版中，類型必須完全相符。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">例如，類型參數的委派<ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>和傳回型別<ph id="ph2">&lt;xref:System.Object&gt;</ph>可以代表具有型別參數的方法<ph id="ph3">&lt;xref:System.Object&gt;</ph>和傳回值的型別<ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This section contains two code examples.</source>
          <target state="translated">本節包含兩個程式碼範例。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</source>
          <target state="translated">第一個範例示範兩種可以使用這個方法多載來建立的委派： 透過執行個體方法開啟，並開啟透過靜態方法。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">第二個程式碼範例會示範相容的參數型別和傳回型別。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>範例 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates the two ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">下列程式碼範例示範兩種方式可使用的這個多載來建立委派<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">有兩個多載<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>方法指定<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>，而不是第一次的引數; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses both overloads.</source>
          <target state="translated">這個程式碼範例會使用這兩個多載。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and two delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, and <ph id="ph6">`D2`</ph> takes a string.</source>
          <target state="translated">此範例會宣告類別<ph id="ph1">`C`</ph>的靜態方法<ph id="ph2">`M2`</ph>和執行個體方法<ph id="ph3">`M1`</ph>，以及兩個委派型別：<ph id="ph4">`D1`</ph>可接受的執行個體<ph id="ph5">`C`</ph>和字串，並<ph id="ph6">`D2`</ph>接受字串。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">名為第二個類別<ph id="ph1">`Example`</ph>包含建立委派的程式碼。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">類型的委派<ph id="ph1">`D1`</ph>，表示開啟的執行個體方法，建立執行個體方法<ph id="ph2">`M1`</ph>。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">當叫用委派時，必須傳遞執行個體。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">類型的委派<ph id="ph1">`D2`</ph>，代表開放式的靜態方法，建立靜態方法<ph id="ph2">`M2`</ph>。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>範例 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">下列程式碼範例示範的參數類型相容性和傳回型別。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">這個程式碼範例會使用<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>方法多載。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The use of other overloads that take <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is similar.</source>
          <target state="translated">使用其他多載會採用<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>類似。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">程式碼範例定義名為基底類別<ph id="ph1">`Base`</ph>和類別，名為<ph id="ph2">`Derived`</ph>衍生自<ph id="ph3">`Base`</ph>。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">在衍生的類別具有<ph id="ph1">`static`</ph>(<ph id="ph2">`Shared`</ph>在 Visual Basic 中) 方法名為<ph id="ph3">`MyMethod`</ph>具有型別的一個參數<ph id="ph4">`Base`</ph>和傳回型別<ph id="ph5">`Derived`</ph>。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">程式碼範例也會定義名為委派<ph id="ph1">`Example`</ph>具有型別的一個參數<ph id="ph2">`Derived`</ph>和傳回型別<ph id="ph3">`Base`</ph>。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">程式碼範例將示範委派名為<ph id="ph1">`Example`</ph>可以用來表示方法<ph id="ph2">`MyMethod`</ph>。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">方法可以繫結至委派，因為：</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">委派的參數型別 (<ph id="ph1">`Derived`</ph>) 是更具限制性的參數型別<ph id="ph2">`MyMethod`</ph>(<ph id="ph3">`Base`</ph>)，因此一律會安全地傳遞至委派的引數、 <ph id="ph4">`MyMethod`</ph>。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">傳回型別<ph id="ph1">`MyMethod`</ph>(<ph id="ph2">`Derived`</ph>) 是更具限制性的委派的參數類型 (<ph id="ph3">`Base`</ph>)，如此可永遠放心轉型為委派的傳回型別方法的傳回型別。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example produces no output.</source>
          <target state="translated">程式碼範例會產生任何輸出。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不會繼承 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">無法繫結 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>，而且 <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">找不到 <ph id="ph2">&lt;paramref name="type" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">呼叫端沒有存取 <ph id="ph1">&lt;paramref name="method" /&gt;</ph> 所需的權限。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">關聯的列舉型別：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">要建立之委派的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that implements <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>，代表可實作 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 的類別。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The name of the static method that the delegate is to represent.</source>
          <target state="translated">委派要表示的靜態方法名稱。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">建立指定類型的委派，這個委派表示指定類別的指定靜態方法。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">指定類型的委派，表示指定類別的指定靜態方法。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>This method creates delegates for static methods only.</source>
          <target state="translated">這個方法會建立只使用靜態方法的委派。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`ignoreCase`</ph> and <ph id="ph4">`true`</ph> for <ph id="ph5">`throwOnBindFailure`</ph>.</source>
          <target state="translated">這個方法多載就相當於呼叫<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>方法多載，指定<ph id="ph2">`false`</ph>如<ph id="ph3">`ignoreCase`</ph>和<ph id="ph4">`true`</ph>如<ph id="ph5">`throwOnBindFailure`</ph>。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，這個方法可以用來存取非公用方法，如果呼叫端被授與<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>與<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用這項功能，您的應用程式應將目標設為 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> (含) 以後版本。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不會繼承 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 是開放式泛型類型。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>That is, its <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">亦即，其 <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> 屬性為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="static" /&gt;</ph> method (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> method in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="static" /&gt;</ph> 方法 (Visual Basic 中的 <ph id="ph3">&lt;see langword="Shared" /&gt;</ph> 方法)。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">無法繫結 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>，例如因為找不到該方法，以及 <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">找不到 <ph id="ph2">&lt;paramref name="type" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">呼叫端沒有存取 <ph id="ph1">&lt;paramref name="method" /&gt;</ph> 所需的權限。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">關聯的列舉型別：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the type of delegate to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>，表示要建立的委派之類型。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that is the first argument of the method the delegate represents.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>，委派所表示的方法之第一個引數。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>For instance methods, it must be compatible with the instance type.</source>
          <target state="translated">對於執行個體方法而言，它必須與執行個體類型相容。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>，描述委派所要表示的靜態或執行個體方法。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示如果無法繫結 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 則擲回例外狀況，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</source>
          <target state="translated">建立指定之類型的委派，其表示指定之靜態或執行個體方法，並有指定第一個引數以及繫結失敗時所發生的行為。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of the specified type that represents the specified static or instance method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="false" /&gt;</ph> and the delegate cannot be bound to <ph id="ph4">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">指定之類型的委派，表示指定之靜態或執行個體方法；如果 <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>，且委派無法繫結至 <ph id="ph4">&lt;paramref name="method" /&gt;</ph>，則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This method overload and the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload, which always throws on failure to bind, provide the most flexible way to create delegates.</source>
          <target state="translated">這個方法多載而<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph>方法多載，一律擲回繫結失敗時發生，提供最具彈性的方式來建立委派。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>You can use them to create delegates for either static or instance methods, with or without a first argument.</source>
          <target state="translated">您可以使用它們來建立委派靜態或執行個體方法，不論第一個引數。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If you do not supply a first argument, use the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload for better performance.</source>
          <target state="translated">如果您未提供第一個引數，使用<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph>方法多載，以提升效能。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The delegate type and the method must have compatible return types.</source>
          <target state="translated">委派型別和方法必須具有相容的傳回類型。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>That is, the return type of <ph id="ph1">`method`</ph> must be assignable to the return type of <ph id="ph2">`type`</ph>.</source>
          <target state="translated">也就是傳回型別<ph id="ph1">`method`</ph>必須可以指派給的傳回型別<ph id="ph2">`type`</ph>。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, it is passed to <ph id="ph2">`method`</ph> every time the delegate is invoked; <ph id="ph3">`firstArgument`</ph> is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</source>
          <target state="translated">如果<ph id="ph1">`firstArgument`</ph>是提供，它會傳遞至<ph id="ph2">`method`</ph>每次叫用委派。<ph id="ph3">`firstArgument`</ph>稱為繫結至委派，並委派會在其第一個引數上關閉。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if <ph id="ph4">`method`</ph> is an instance method, then <ph id="ph5">`firstArgument`</ph> is passed to the hidden instance parameter (represented by <ph id="ph6">`this`</ph> in C#, or by <ph id="ph7">`Me`</ph> in Visual Basic).</source>
          <target state="translated">如果<ph id="ph1">`method`</ph>是<ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph>在 Visual Basic 中)，則引數叫用委派時所提供的清單包含第一個; 以外的所有參數，如果<ph id="ph4">`method`</ph>是執行個體方法，則<ph id="ph5">`firstArgument`</ph>傳遞到隱藏的執行個體參數 (由<ph id="ph6">`this`</ph>在 C# 中，或由<ph id="ph7">`Me`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, the first parameter of <ph id="ph2">`method`</ph> must be a reference type, and <ph id="ph3">`firstArgument`</ph> must be compatible with that type.</source>
          <target state="translated">如果<ph id="ph1">`firstArgument`</ph>提供的第一個參數<ph id="ph2">`method`</ph>必須是參考類型，和<ph id="ph3">`firstArgument`</ph>必須相容於該型別。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) and its first parameter is of type <ph id="ph4">&lt;xref:System.Object&gt;</ph> or <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, then <ph id="ph6">`firstArgument`</ph> can be a value type.</source>
          <target state="translated">如果<ph id="ph1">`method`</ph>是<ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph>在 Visual Basic 中) 和其第一個參數的類型是<ph id="ph4">&lt;xref:System.Object&gt;</ph>或<ph id="ph5">&lt;xref:System.ValueType&gt;</ph>，然後<ph id="ph6">`firstArgument`</ph>可以是實值類型。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>In this case <ph id="ph1">`firstArgument`</ph> is automatically boxed.</source>
          <target state="translated">在此情況下<ph id="ph1">`firstArgument`</ph>會自動進行 boxed 處理。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</source>
          <target state="translated">自動 boxing 不會發生的任何其他引數，因為它會以 C# 或 Visual Basic 函式呼叫。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is an instance method, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">如果<ph id="ph1">`firstArgument`</ph>為 null 參考和<ph id="ph2">`method`</ph>是執行個體方法，結果會隨著的委派類型簽章<ph id="ph3">`type`</ph>和<ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signature of <ph id="ph1">`type`</ph> explicitly includes the hidden first parameter of <ph id="ph2">`method`</ph>, the delegate is said to represent an open instance method.</source>
          <target state="translated">如果簽章<ph id="ph1">`type`</ph>明確包含隱藏第一個參數<ph id="ph2">`method`</ph>，此委派來表示開啟的執行個體方法。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">引數清單中的第一個引數叫用委派時，會傳遞到隱藏的執行個體參數的<ph id="ph1">`method`</ph>。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signatures of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</source>
          <target state="translated">如果簽章<ph id="ph1">`method`</ph>和<ph id="ph2">`type`</ph>比對 （也就是所有的參數型別都相容），則此委派會在 null 參考上關閉。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</source>
          <target state="translated">叫用委派就像不是特別有用的做法的 null 執行個體上呼叫執行個體方法。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is static, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">如果<ph id="ph1">`firstArgument`</ph>為 null 參考和<ph id="ph2">`method`</ph>是靜態的結果會隨著的委派類型簽章<ph id="ph3">`type`</ph>和<ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signature of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</source>
          <target state="translated">如果簽章<ph id="ph1">`method`</ph>和<ph id="ph2">`type`</ph>比對 （也就是所有的參數型別都相容），此委派來表示開啟的靜態方法。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This is the most common case for static methods.</source>
          <target state="translated">這是靜態方法的最常見的情況。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>In this case, you can get slightly better performance by using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">在此情況下，您可以取得稍微提升效能，使用<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph>方法多載。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signature of <ph id="ph1">`type`</ph> begins with the second parameter of <ph id="ph2">`method`</ph> and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</source>
          <target state="translated">如果簽章<ph id="ph1">`type`</ph>開頭的第二個參數<ph id="ph2">`method`</ph>，而且其餘的參數類型相容，則此委派會在 null 參考上關閉。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When the delegate is invoked, a null reference is passed to the first parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">叫用委派時，第一個參數來傳遞 null 參考<ph id="ph1">`method`</ph>。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，這個方法可以用來存取非公用方法，如果呼叫端被授與<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>與<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用這項功能，您的應用程式應將目標設為 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> (含) 以後版本。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">相容的參數型別和傳回型別</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">參數類型和委派的傳回型別必須是相容的參數類型和傳回型別方法委派所表示。型別沒有完全相符。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>In the .NET Framework version 1.0 and 1.1 the types must match exactly.</source>
          <target state="translated">.NET Framework 1.0 和 1.1 版中的類型必須完全相符。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">例如，類型參數的委派<ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>和傳回型別<ph id="ph2">&lt;xref:System.Object&gt;</ph>可以代表具有型別參數的方法<ph id="ph3">&lt;xref:System.Object&gt;</ph>和傳回值的型別<ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Determining the Methods a Delegate Can Represent</source>
          <target state="translated">判斷方法的委派可以表示</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Another useful way to think of the flexibility provided by this overload of <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</source>
          <target state="translated">另一個有用的方式來想到的這個多載所提供的彈性<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>是任何指定的委派可以代表四個不同的方法簽章與方法類型 （靜態和執行個體） 的組合。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Consider a delegate type <ph id="ph1">`D`</ph> with one argument of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">委派類型，請考慮<ph id="ph1">`D`</ph>具有單一引數的型別<ph id="ph2">`C`</ph>。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following describes the methods <ph id="ph1">`D`</ph> can represent, ignoring the return type since it must match in all cases:</source>
          <target state="translated">下列程式碼說明方法<ph id="ph1">`D`</ph>可表示，因為它必須符合在所有情況下忽略的傳回型別：</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent any instance method that has exactly one argument of type <ph id="ph2">`C`</ph>, regardless of what type the instance method belongs to.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 可以表示有一個引數類型的任何執行個體方法<ph id="ph2">`C`</ph>，不論執行個體方法屬於何種類型。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of the type <ph id="ph3">`method`</ph> belongs to, and the resulting delegate is said to be closed over that instance.</source>
          <target state="translated">當<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>呼叫時，<ph id="ph2">`firstArgument`</ph>類型的執行個體<ph id="ph3">`method`</ph>屬於，並將產生的委派會在該執行個體上關閉。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>(Trivially, <ph id="ph1">`D`</ph> can also be closed over a null reference if <ph id="ph2">`firstArgument`</ph> is <ph id="ph3">`null`</ph>.)</source>
          <target state="translated">(兩者，<ph id="ph1">`D`</ph>也可以關閉透過 null 參考如果<ph id="ph2">`firstArgument`</ph>是<ph id="ph3">`null`</ph>。)</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent an instance method of <ph id="ph2">`C`</ph> that has no arguments.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 可以表示的執行個體方法<ph id="ph2">`C`</ph>，沒有任何引數。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">當<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>呼叫時，<ph id="ph2">`firstArgument`</ph>為 null 參考。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The resulting delegate represents an open instance method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">產生的委派表示開啟的執行個體方法和執行個體<ph id="ph1">`C`</ph>必須提供每次叫用時。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent a static method that takes one argument of type <ph id="ph2">`C`</ph>, and that method can belong to any type.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 可以代表採用一個引數類型的靜態方法<ph id="ph2">`C`</ph>，而且方法可以屬於任何類型。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">當<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>呼叫時，<ph id="ph2">`firstArgument`</ph>為 null 參考。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The resulting delegate represents an open static method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">產生的委派表示開啟的靜態方法和執行個體<ph id="ph1">`C`</ph>必須提供每次叫用時。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent a static method that belongs to type <ph id="ph2">`F`</ph> and has two arguments, of type <ph id="ph3">`F`</ph> and type <ph id="ph4">`C`</ph>.</source>
          <target state="translated"><ph id="ph1">`D`</ph> 可以表示的靜態方法屬於型別<ph id="ph2">`F`</ph>且具有兩個類型引數，<ph id="ph3">`F`</ph>和型別<ph id="ph4">`C`</ph>。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of <ph id="ph3">`F`</ph>.</source>
          <target state="translated">當<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>呼叫時，<ph id="ph2">`firstArgument`</ph>的執行個體<ph id="ph3">`F`</ph>。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The resulting delegate represents a static method that is closed over that instance of <ph id="ph1">`F`</ph>.</source>
          <target state="translated">產生的委派表示關閉該執行個體上的靜態方法<ph id="ph1">`F`</ph>。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Note that in the case where <ph id="ph1">`F`</ph> and <ph id="ph2">`C`</ph> are the same type, the static method has two arguments of that type.</source>
          <target state="translated">請注意，在案例其中<ph id="ph1">`F`</ph>和<ph id="ph2">`C`</ph>都是相同的型別、 靜態方法會具有該類型的兩個引數。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>(In this case, <ph id="ph1">`D`</ph> is closed over a null reference if <ph id="ph2">`firstArgument`</ph> is <ph id="ph3">`null`</ph>.)</source>
          <target state="translated">(在此情況下，<ph id="ph1">`D`</ph>如果 null 參考透過關閉<ph id="ph2">`firstArgument`</ph>是<ph id="ph3">`null`</ph>。)</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This section contains three code examples.</source>
          <target state="translated">本節包含三個程式碼範例。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</source>
          <target state="translated">第一個範例將示範委派可建立四種： 關閉透過執行個體方法，透過執行個體方法開啟的靜態方法，透過開啟和關閉透過靜態方法。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">第二個程式碼範例會示範相容的參數型別和傳回型別。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</source>
          <target state="translated">第三個程式碼範例會定義單一委派類型，並顯示可以表示所有委派類型的方法。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>範例 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates the four ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">下列程式碼範例示範您可以使用的這個多載建立委派的四種方式<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">有兩個多載<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>方法指定<ph id="ph2">`firstArgument`</ph>和<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses both overloads.</source>
          <target state="translated">這個程式碼範例會使用這兩個多載。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and three delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, <ph id="ph6">`D2`</ph> takes a string, and <ph id="ph7">`D3`</ph> has no arguments.</source>
          <target state="translated">此範例會宣告類別<ph id="ph1">`C`</ph>的靜態方法<ph id="ph2">`M2`</ph>和執行個體方法<ph id="ph3">`M1`</ph>，以及三個委派型別：<ph id="ph4">`D1`</ph>可接受的執行個體<ph id="ph5">`C`</ph>和字串，<ph id="ph6">`D2`</ph>採用字串和<ph id="ph7">`D3`</ph>沒有引數。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">名為第二個類別<ph id="ph1">`Example`</ph>包含建立委派的程式碼。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, closed over an instance of <ph id="ph2">`C`</ph>, is created for the instance method <ph id="ph3">`M1`</ph>.</source>
          <target state="translated">類型的委派<ph id="ph1">`D2`</ph>、 執行個體上關閉<ph id="ph2">`C`</ph>，建立執行個體方法<ph id="ph3">`M1`</ph>。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>It is invoked with different strings, to show that the bound instance of <ph id="ph1">`C`</ph> is always used.</source>
          <target state="translated">使用不同的字串，顯示的繫結的執行個體叫用<ph id="ph1">`C`</ph>一律使用。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">類型的委派<ph id="ph1">`D1`</ph>，表示開啟的執行個體方法，建立執行個體方法<ph id="ph2">`M1`</ph>。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">當叫用委派時，必須傳遞執行個體。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">類型的委派<ph id="ph1">`D2`</ph>，代表開放式的靜態方法，建立靜態方法<ph id="ph2">`M2`</ph>。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Finally, a delegate of type <ph id="ph1">`D3`</ph>, closed over a string, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">最後，類型的委派<ph id="ph1">`D3`</ph>字串上為封閉式，建立靜態方法<ph id="ph2">`M2`</ph>。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method is invoked to show that it uses the bound string.</source>
          <target state="translated">方法會叫用來顯示它所使用的繫結的字串。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>範例 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">下列程式碼範例示範的參數類型相容性和傳回型別。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">這個程式碼範例會使用<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>方法多載。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The use of other overloads that take <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is similar.</source>
          <target state="translated">使用其他多載會採用<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>類似。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">程式碼範例定義名為基底類別<ph id="ph1">`Base`</ph>和類別，名為<ph id="ph2">`Derived`</ph>衍生自<ph id="ph3">`Base`</ph>。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">在衍生的類別具有<ph id="ph1">`static`</ph>(<ph id="ph2">`Shared`</ph>在 Visual Basic 中) 方法名為<ph id="ph3">`MyMethod`</ph>具有型別的一個參數<ph id="ph4">`Base`</ph>和傳回型別<ph id="ph5">`Derived`</ph>。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">程式碼範例也會定義名為委派<ph id="ph1">`Example`</ph>具有型別的一個參數<ph id="ph2">`Derived`</ph>和傳回型別<ph id="ph3">`Base`</ph>。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">程式碼範例將示範委派名為<ph id="ph1">`Example`</ph>可以用來表示方法<ph id="ph2">`MyMethod`</ph>。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">方法可以繫結至委派，因為：</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">委派的參數型別 (<ph id="ph1">`Derived`</ph>) 是更具限制性的參數型別<ph id="ph2">`MyMethod`</ph>(<ph id="ph3">`Base`</ph>)，因此一律會安全地傳遞至委派的引數、 <ph id="ph4">`MyMethod`</ph>。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">傳回型別<ph id="ph1">`MyMethod`</ph>(<ph id="ph2">`Derived`</ph>) 是更具限制性的委派的參數類型 (<ph id="ph3">`Base`</ph>)，如此可永遠放心轉型為委派的傳回型別方法的傳回型別。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example produces no output.</source>
          <target state="translated">程式碼範例會產生任何輸出。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 3<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>範例 3<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example shows all the methods a single delegate type can represent.</source>
          <target state="translated">下列程式碼範例會顯示所有單一委派類型可以表示的方法。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">有兩個多載<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph>方法指定<ph id="ph2">`firstArgument`</ph>和<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses both overloads.</source>
          <target state="translated">這個程式碼範例會使用這兩個多載。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example defines two classes, <ph id="ph1">`C`</ph> and <ph id="ph2">`F`</ph>, and a delegate type <ph id="ph3">`D`</ph> with one argument of type <ph id="ph4">`C`</ph>.</source>
          <target state="translated">程式碼範例定義兩個類別：<ph id="ph1">`C`</ph>和<ph id="ph2">`F`</ph>，和委派類型<ph id="ph3">`D`</ph>具有單一引數的型別<ph id="ph4">`C`</ph>。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The classes have matching static and instance methods <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, and <ph id="ph3">`M4`</ph>, and class <ph id="ph4">`C`</ph> also has an instance method <ph id="ph5">`M2`</ph> that has no arguments.</source>
          <target state="translated">類別有相符的靜態和執行個體方法<ph id="ph1">`M1`</ph>， <ph id="ph2">`M3`</ph>，和<ph id="ph3">`M4`</ph>，和類別<ph id="ph4">`C`</ph>也有執行個體方法<ph id="ph5">`M2`</ph>，沒有任何引數。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A third class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">名為第三個類別<ph id="ph1">`Example`</ph>包含建立委派的程式碼。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Delegates are created for instance method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each is closed over an instance of the respective type.</source>
          <target state="translated">建立委派執行個體方法<ph id="ph1">`M1`</ph>型別的<ph id="ph2">`C`</ph>和型別<ph id="ph3">`F`</ph>; 每個個別的型別執行個體上已關閉。</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">方法<ph id="ph1">`M1`</ph>型別的<ph id="ph2">`C`</ph>顯示<ph id="ph3">`ID`</ph>繫結的執行個體與引數的屬性。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate is created for method <ph id="ph1">`M2`</ph> of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">建立委派方法<ph id="ph1">`M2`</ph>型別的<ph id="ph2">`C`</ph>。</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</source>
          <target state="translated">這是開啟的執行個體的委派，其中委派的引數代表的執行個體方法上的隱藏第一個引數。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method has no other arguments.</source>
          <target state="translated">此方法沒有任何其他引數。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Delegates are created for static method <ph id="ph1">`M3`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; these are open static delegates.</source>
          <target state="translated">針對靜態方法建立委派<ph id="ph1">`M3`</ph>型別的<ph id="ph2">`C`</ph>和型別<ph id="ph3">`F`</ph>; 這些是開啟的靜態委派。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Finally, delegates are created for static method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</source>
          <target state="translated">靜態方法建立委派的最後，<ph id="ph1">`M4`</ph>型別的<ph id="ph2">`C`</ph>和型別<ph id="ph3">`F`</ph>; 每個方法都宣告的型別做為其第一個引數，並提供類型的執行個體，因此委派會關閉對其第一個引數.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">方法<ph id="ph1">`M4`</ph>型別的<ph id="ph2">`C`</ph>顯示<ph id="ph3">`ID`</ph>繫結的執行個體與引數的屬性。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不會繼承 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">無法繫結 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>，而且 <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">找不到 <ph id="ph2">&lt;paramref name="type" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">呼叫端沒有存取 <ph id="ph1">&lt;paramref name="method" /&gt;</ph> 所需的權限。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">關聯的列舉型別：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">要建立之委派的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The class instance on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is invoked.</source>
          <target state="translated">叫用 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 的類別執行個體。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The name of the instance method that the delegate is to represent.</source>
          <target state="translated">委派要表示的執行個體方法名稱。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">布林值 (Boolean)，指出是否在比較方法名稱時忽略大小寫。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</source>
          <target state="translated">建立指定類型的委派，這個委派表示要在指定的類別執行個體上，使用指定的大小寫區分來叫用的指定執行個體方法。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">指定類型的委派，表示要在指定的類別執行個體上叫用的指定執行個體方法。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>This method creates delegates for instance methods only.</source>
          <target state="translated">這個方法只會建立委派執行個體方法。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">這個方法多載就相當於呼叫<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>方法多載，指定<ph id="ph2">`true`</ph>如<ph id="ph3">`throwOnBindFailure`</ph>。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，這個方法可以用來存取非公用方法，如果呼叫端被授與<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>與<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用這項功能，您的應用程式應將目標設為 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> (含) 以後版本。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不會繼承 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not an instance method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 不是執行個體方法。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found.</source>
          <target state="translated">例如，因為找不到 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>，所以無法將其繫結。</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">找不到 <ph id="ph2">&lt;paramref name="type" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">呼叫端沒有存取 <ph id="ph1">&lt;paramref name="method" /&gt;</ph> 所需的權限。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">關聯的列舉型別：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">要建立之委派的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that implements <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>，代表可實作 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 的類別。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The name of the static method that the delegate is to represent.</source>
          <target state="translated">委派要表示的靜態方法名稱。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">布林值 (Boolean)，指出是否在比較方法名稱時忽略大小寫。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</source>
          <target state="translated">建立指定之類型的委派，其表示指定之類別的指定靜態方法，且指定區分大小寫的方式。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">指定類型的委派，表示指定類別的指定靜態方法。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>This method creates delegates for static methods only.</source>
          <target state="translated">這個方法會建立只使用靜態方法的委派。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">這個方法多載就相當於呼叫<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>方法多載，指定<ph id="ph2">`true`</ph>如<ph id="ph3">`throwOnBindFailure`</ph>。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，這個方法可以用來存取非公用方法，如果呼叫端被授與<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>與<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用這項功能，您的應用程式應將目標設為 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> (含) 以後版本。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不會繼承 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 是開放式泛型類型。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>That is, its <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">亦即，其 <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> 屬性為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="static" /&gt;</ph> method (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> method in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="static" /&gt;</ph> 方法 (Visual Basic 中的 <ph id="ph3">&lt;see langword="Shared" /&gt;</ph> 方法)。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found.</source>
          <target state="translated">例如，因為找不到 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>，所以無法將其繫結。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">找不到 <ph id="ph2">&lt;paramref name="type" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">呼叫端沒有存取 <ph id="ph1">&lt;paramref name="method" /&gt;</ph> 所需的權限。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">關聯的列舉型別：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">要建立之委派的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The class instance on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is invoked.</source>
          <target state="translated">叫用 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 的類別執行個體。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The name of the instance method that the delegate is to represent.</source>
          <target state="translated">委派要表示的執行個體方法名稱。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">布林值 (Boolean)，指出是否在比較方法名稱時忽略大小寫。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示如果無法繫結 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 則擲回例外狀況，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</source>
          <target state="translated">建立指定之類型的委派，其表示要在指定的類別執行個體上叫用的指定執行個體方法，且會指定區分大小寫的方式以及在繫結失敗時要發生的行為。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">指定類型的委派，表示要在指定的類別執行個體上叫用的指定執行個體方法。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>This method creates delegates for instance methods only.</source>
          <target state="translated">這個方法只會建立委派執行個體方法。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，這個方法可以用來存取非公用方法，如果呼叫端被授與<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>與<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用這項功能，您的應用程式應將目標設為 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> (含) 以後版本。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不會繼承 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not an instance method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 不是執行個體方法。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">無法繫結 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>，例如因為找不到該方法，以及 <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">找不到 <ph id="ph2">&lt;paramref name="type" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">呼叫端沒有存取 <ph id="ph1">&lt;paramref name="method" /&gt;</ph> 所需的權限。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">關聯的列舉型別：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">要建立之委派的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that implements <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>，代表可實作 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 的類別。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The name of the static method that the delegate is to represent.</source>
          <target state="translated">委派要表示的靜態方法名稱。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">布林值 (Boolean)，指出是否在比較方法名稱時忽略大小寫。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示如果無法繫結 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 則擲回例外狀況，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</source>
          <target state="translated">建立指定之類型的委派，其表示指定之類別的指定靜態方法，且會指定區分大小寫的方式以及在繫結失敗時要發生的行為。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">指定類型的委派，表示指定類別的指定靜態方法。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>This method creates delegates for static methods only.</source>
          <target state="translated">這個方法會建立只使用靜態方法的委派。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，這個方法可以用來存取非公用方法，如果呼叫端被授與<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>與<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>反映的安全性考量<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用這項功能，您的應用程式應將目標設為 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> (含) 以後版本。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不會繼承 <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">請參閱<bpt id="p1">[</bpt>反映中的執行階段類型<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> 是開放式泛型類型。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>That is, its <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">亦即，其 <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> 屬性為 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="static" /&gt;</ph> method (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> method in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="static" /&gt;</ph> 方法 (Visual Basic 中的 <ph id="ph3">&lt;see langword="Shared" /&gt;</ph> 方法)。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">無法繫結 <ph id="ph1">&lt;paramref name="method" /&gt;</ph>，例如因為找不到該方法，以及 <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">找不到 <ph id="ph2">&lt;paramref name="type" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">呼叫端沒有存取 <ph id="ph1">&lt;paramref name="method" /&gt;</ph> 所需的權限。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">關聯的列舉型別：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>An array of objects that are the arguments to pass to the method represented by the current delegate.</source>
          <target state="translated">物件的陣列，這些物件是要傳遞至目前委派所表示方法的引數。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph>, if the method represented by the current delegate does not require arguments.</source>
          <target state="translated">如果目前委派所表示的方法不需要引數，則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>Dynamically invokes (late-bound) the method represented by the current delegate.</source>
          <target state="translated">動態叫用 (晚期繫結) 目前委派所表示的方法。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The object returned by the method represented by the delegate.</source>
          <target state="translated">物件，由委派所表示的方法傳回。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>This method calls the <ph id="ph1">&lt;xref:System.Delegate.DynamicInvokeImpl%2A&gt;</ph> method.</source>
          <target state="translated">這個方法會呼叫 <ph id="ph1">&lt;xref:System.Delegate.DynamicInvokeImpl%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The number, order, or type of parameters listed in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> is invalid.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="args" /&gt;</ph> 中列示的參數數目、順序或型別是無效的。</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The method represented by the delegate is invoked on an object or a class that does not support it.</source>
          <target state="translated">委派所表示的方法在不支援該方法的物件或類別上被叫用。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The method represented by the delegate is an instance method and the target object is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">委派所表示的方法是執行個體方法，並且目標物件是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>One of the encapsulated methods throws an exception.</source>
          <target state="translated">其中一個封裝的方法會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>An array of objects that are the arguments to pass to the method represented by the current delegate.</source>
          <target state="translated">物件的陣列，這些物件是要傳遞至目前委派所表示方法的引數。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph>, if the method represented by the current delegate does not require arguments.</source>
          <target state="translated">如果目前委派所表示的方法不需要引數，則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>Dynamically invokes (late-bound) the method represented by the current delegate.</source>
          <target state="translated">動態叫用 (晚期繫結) 目前委派所表示的方法。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The object returned by the method represented by the delegate.</source>
          <target state="translated">物件，由委派所表示的方法傳回。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>This method implements the <ph id="ph1">&lt;xref:System.Delegate.DynamicInvoke%2A&gt;</ph> method.</source>
          <target state="translated">這個方法會實作 <ph id="ph1">&lt;xref:System.Delegate.DynamicInvoke%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The number, order, or type of parameters listed in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> is invalid.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="args" /&gt;</ph> 中列示的參數數目、順序或型別是無效的。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The method represented by the delegate is invoked on an object or a class that does not support it.</source>
          <target state="translated">委派所表示的方法在不支援該方法的物件或類別上被叫用。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The method represented by the delegate is an instance method and the target object is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">委派所表示的方法是執行個體方法，並且目標物件是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>One of the encapsulated methods throws an exception.</source>
          <target state="translated">其中一個封裝的方法會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source>The object to compare with the current delegate.</source>
          <target state="translated">要與目前委派比較的物件。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source>Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</source>
          <target state="translated">判斷指定的物件和目前的委派是否具有相同類型，並共用相同的目標、方法和引動過程清單。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> and the current delegate have the same targets, methods, and invocation list; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> 和目前的委派具有相同的目標、方法和引動過程清單，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
          <target state="translated">如果兩個委派不是相同的型別中，則不會視為相等。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 版中，兩個委派視為相等，如果其目標、 方法和引動過程清單相同，即使為不同類型的委派。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>The methods and targets are compared for equality as follows:</source>
          <target state="translated">方法和目標會比較相等，如下所示：</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">如果正在比較的兩個方法都是靜態，且都是相同類別上相同的方法，方法會視為相等，以及目標也視為相等。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">如果正在比較的兩個方法是執行個體方法，而且都是相同物件上的相同方法，方法會視為相等，以及目標也視為相等。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
          <target state="translated">否則，方法不被視為相等，目標也不會視為相等。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>Two invocation lists are considered identical only if they have the same order and the corresponding elements from the two lists represent the same method and target.</source>
          <target state="translated">只有具有相同的順序，而且兩個 list 的對應元素代表相同的方法和目標，則兩個引動過程清單會視為相同。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetHashCode">
          <source>Returns a hash code for the delegate.</source>
          <target state="translated">傳回委派的雜湊碼。</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetHashCode">
          <source>A hash code for the delegate.</source>
          <target state="translated">委派的雜湊碼。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>The return value of this method must not be persisted for two reasons.</source>
          <target state="translated">這個方法的傳回值必須不會保存兩個原因。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>First, the hash function of a class might be altered to generate a better distribution, rendering any values from the old hash function useless.</source>
          <target state="translated">首先，類別的雜湊函式可能會改變以產生較佳的分佈，呈現沒有幫助，舊的雜湊函式的任何值。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>Second, the default implementation of this class does not guarantee that the same value will be returned by different instances.</source>
          <target state="translated">第二，這個類別的預設實作不保證，將由不同執行個體傳回相同的值。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetInvocationList">
          <source>Returns the invocation list of the delegate.</source>
          <target state="translated">傳回委派的引動過程清單。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetInvocationList">
          <source>An array of delegates representing the invocation list of the current delegate.</source>
          <target state="translated">委派的陣列，表示目前委派的引動過程清單。</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>Each delegate in the array represents exactly one method.</source>
          <target state="translated">陣列中的每個委派代表一個方法。</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>The order of the delegates in the array is the same order in which the current delegate invokes the methods that those delegates represent.</source>
          <target state="translated">陣列中委派的順序是目前的委派叫用的方法，這些委派所表示的相同順序。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>The following example assigns three methods to a delegate.</source>
          <target state="translated">下列範例會將三個方法指派給委派。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>It then calls the  <ph id="ph1">&lt;xref:System.Delegate.GetInvocationList%2A&gt;</ph> method to get a total count of the methods assigned to the delegate, to execute the delegates in reverse order, and to execute the methods whose name do not include the substring "File".</source>
          <target state="translated">然後它會呼叫<ph id="ph1">&lt;xref:System.Delegate.GetInvocationList%2A&gt;</ph>方法來取得 「 檔案 」 的總計數的方法指派給委派，相反的順序執行的委派，以及執行其名稱不包含子字串的方法。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetMethodImpl">
          <source>Gets the static method represented by the current delegate.</source>
          <target state="translated">取得目前委派所表示的靜態方法。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetMethodImpl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static method represented by the current delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>，描述目前委派所表示的靜態方法。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetMethodImpl">
          <source>This method applies only if the current delegate represents a static method.</source>
          <target state="translated">這個方法僅適用於目前委派所表示的靜態方法。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetMethodImpl">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetMethodImpl">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetMethodImpl">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Not supported.</source>
          <target state="translated">不支援。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Not supported.</source>
          <target state="translated">不支援。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Not supported.</source>
          <target state="translated">不支援。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method is not supported.</source>
          <target state="translated">不支援這個方法。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="P:System.Delegate.Method">
          <source>Gets the method represented by the delegate.</source>
          <target state="translated">取得委派所表示的方法。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Method">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the method represented by the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>，描述委派所表示的方法。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="P:System.Delegate.Method">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Method">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Method">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The first delegate to compare.</source>
          <target state="translated">要比較的第一個委派。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The second delegate to compare.</source>
          <target state="translated">要比較的第二個委派。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Determines whether the specified delegates are equal.</source>
          <target state="translated">判斷指定的委派是否相等。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="d2" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 等於 <ph id="ph2">&lt;paramref name="d1" /&gt;</ph>，則為 <ph id="ph3">&lt;paramref name="d2" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Two delegates of the same type with the same targets, methods, and invocation lists are considered equal.</source>
          <target state="translated">兩個具有相同的目標、 方法和引動過程清單之相同類型的委派視為相等。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
          <target state="translated">如果兩個委派不是相同的型別中，則不會視為相等。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 版中，兩個委派視為相等，如果其目標、 方法和引動過程清單相同，即使為不同類型的委派。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The methods and targets are compared for equality as follows:</source>
          <target state="translated">方法和目標會比較相等，如下所示：</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">如果正在比較的兩個方法都是靜態，且都是相同類別上相同的方法，方法會視為相等，以及目標也視為相等。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">如果正在比較的兩個方法是執行個體方法，而且都是相同物件上的相同方法，方法會視為相等，以及目標也視為相等。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
          <target state="translated">否則，方法不被視為相等，目標也不會視為相等。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Two invocation lists are considered identical if they have the same order and the corresponding elements from the two lists represent the same method and target.</source>
          <target state="translated">如果具有相同的順序，而且兩個 list 的對應元素代表相同的方法和目標，則兩個引動過程清單會視為相同。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">這個運算子的對等方法是 <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The first delegate to compare.</source>
          <target state="translated">要比較的第一個委派。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The second delegate to compare.</source>
          <target state="translated">要比較的第二個委派。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Determines whether the specified delegates are not equal.</source>
          <target state="translated">判斷指定的委派是否不相等。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="d2" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 不等於 <ph id="ph2">&lt;paramref name="d1" /&gt;</ph>，則為 <ph id="ph3">&lt;paramref name="d2" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Two delegates are considered not equal if they are of different types, or have different methods, different targets, or different invocation lists.</source>
          <target state="translated">如果它們是不同的類型，或是有不同的方法、 不同的目標或不同的引動過程清單，即視為等於不到兩個委派。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
          <target state="translated">如果兩個委派不是相同的型別中，則不會視為相等。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates are considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 版中，兩個委派視為相等，如果其目標、 方法和引動過程清單相同，即使為不同類型的委派。</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The methods and targets are compared for equality as follows:</source>
          <target state="translated">方法和目標會比較相等，如下所示：</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">如果正在比較的兩個方法都是靜態，且都是相同類別上相同的方法，方法會視為相等，以及目標也視為相等。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">如果正在比較的兩個方法是執行個體方法，而且都是相同物件上的相同方法，方法會視為相等，以及目標也視為相等。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
          <target state="translated">否則，方法不被視為相等，目標也不會視為相等。</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Two invocation lists are not equal if they have different sizes, if they are ordered differently, or if at least one element from one list represents a method or target that is different from that represented by its corresponding element in the other list.</source>
          <target state="translated">兩個引動過程清單不相等，如果它們的順序不同，如果有不同的大小，或從一個清單的至少一個項目代表方法或不同於其他清單中其對應項目所表示的目標。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">這個運算子的對等方法是 <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The delegate from which to remove the invocation list of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">委派，要從其中移除 <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 的引動過程清單。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The delegate that supplies the invocation list to remove from the invocation list of <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">委派，提供要從 <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept> 的引動過程清單移除的引動過程清單。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</source>
          <target state="translated">從另一個委派的引動過程清單，移除委派的引動過程清單上最後一個項目。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>A new delegate with an invocation list formed by taking the invocation list of <ph id="ph1">&lt;paramref name="source" /&gt;</ph> and removing the last occurrence of the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, if the invocation list of <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found within the invocation list of <ph id="ph4">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated">如果在 <ph id="ph1">&lt;paramref name="source" /&gt;</ph> 的引動過程清單中找到 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 的引動過程清單，則為新委派 (其具有藉由取得 <ph id="ph3">&lt;paramref name="value" /&gt;</ph> 的引動過程清單並移除 <ph id="ph4">&lt;paramref name="source" /&gt;</ph> 的引動過程清單上最後一個項目所形成的引動過程清單)。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Returns <ph id="ph1">&lt;paramref name="source" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or if the invocation list of <ph id="ph4">&lt;paramref name="value" /&gt;</ph> is not found within the invocation list of <ph id="ph5">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="source" /&gt;</ph> 是 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，或未在 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 的引動過程清單中找到 <ph id="ph4">&lt;paramref name="value" /&gt;</ph> 的引動過程清單，則會傳回 <ph id="ph5">&lt;paramref name="source" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Returns a null reference if the invocation list of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to the invocation list of <ph id="ph2">&lt;paramref name="source" /&gt;</ph> or if <ph id="ph3">&lt;paramref name="source" /&gt;</ph> is a null reference.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 的引動過程清單等於 <ph id="ph2">&lt;paramref name="source" /&gt;</ph> 的引動過程清單，或是 <ph id="ph3">&lt;paramref name="source" /&gt;</ph> 等於 null 參考，則會傳回 null 參考。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the invocation list of <ph id="ph2">`source`</ph>, then the invocation list of <ph id="ph3">`value`</ph> is said to occur within the invocation list of <ph id="ph4">`source`</ph>.</source>
          <target state="translated">如果引動過程清單<ph id="ph1">`value`</ph>符合一組連續的引動過程清單中的項目<ph id="ph2">`source`</ph>，然後引動過程清單<ph id="ph3">`value`</ph>發生在引動過程清單中稱為<ph id="ph4">`source`</ph>。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the invocation list of <ph id="ph2">`source`</ph>, the last occurrence is removed.</source>
          <target state="translated">如果引動過程清單<ph id="ph1">`value`</ph>出現一次以上的引動過程清單中<ph id="ph2">`source`</ph>，移除最後一個出現項目。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The delegate types do not match.</source>
          <target state="translated">委派型別不相符。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The delegate from which to remove the invocation list of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">委派，要從其中移除 <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 的引動過程清單。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The delegate that supplies the invocation list to remove from the invocation list of <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">委派，提供要從 <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept> 的引動過程清單移除的引動過程清單。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</source>
          <target state="translated">從另一個委派的引動過程清單，移除委派的引動過程清單上所有的項目。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>A new delegate with an invocation list formed by taking the invocation list of <ph id="ph1">&lt;paramref name="source" /&gt;</ph> and removing all occurrences of the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, if the invocation list of <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found within the invocation list of <ph id="ph4">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated">如果在 <ph id="ph1">&lt;paramref name="source" /&gt;</ph> 的引動過程清單中找到 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 的引動過程清單，則為新委派 (其具有藉由取得 <ph id="ph3">&lt;paramref name="value" /&gt;</ph> 的引動過程清單並移除 <ph id="ph4">&lt;paramref name="source" /&gt;</ph> 的引動過程清單上所有的項目所形成的引動過程清單)。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Returns <ph id="ph1">&lt;paramref name="source" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or if the invocation list of <ph id="ph4">&lt;paramref name="value" /&gt;</ph> is not found within the invocation list of <ph id="ph5">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="source" /&gt;</ph> 是 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，或未在 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 的引動過程清單中找到 <ph id="ph4">&lt;paramref name="value" /&gt;</ph> 的引動過程清單，則會傳回 <ph id="ph5">&lt;paramref name="source" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Returns a null reference if the invocation list of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to the invocation list of <ph id="ph2">&lt;paramref name="source" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="source" /&gt;</ph> contains only a series of invocation lists that are equal to the invocation list of <ph id="ph4">&lt;paramref name="value" /&gt;</ph>, or if <ph id="ph5">&lt;paramref name="source" /&gt;</ph> is a null reference.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 的引動過程清單等於 <ph id="ph2">&lt;paramref name="source" /&gt;</ph> 的引動過程清單、<ph id="ph3">&lt;paramref name="source" /&gt;</ph> 只包含等於 <ph id="ph4">&lt;paramref name="value" /&gt;</ph> 引動過程清單的一系列引動過程清單，或是 <ph id="ph5">&lt;paramref name="source" /&gt;</ph> 為 null 參考時，會傳回 null 參考。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the invocation list of <ph id="ph2">`source`</ph>, then the invocation list of <ph id="ph3">`value`</ph> is said to occur within the invocation list of <ph id="ph4">`source`</ph>.</source>
          <target state="translated">如果引動過程清單<ph id="ph1">`value`</ph>符合一組連續的引動過程清單中的項目<ph id="ph2">`source`</ph>，然後引動過程清單<ph id="ph3">`value`</ph>發生在引動過程清單中稱為<ph id="ph4">`source`</ph>。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the invocation list of <ph id="ph2">`source`</ph>, all occurrences are removed.</source>
          <target state="translated">如果引動過程清單<ph id="ph1">`value`</ph>出現一次以上的引動過程清單中<ph id="ph2">`source`</ph>，會移除所有項目。</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The delegate types do not match.</source>
          <target state="translated">委派型別不相符。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</source>
          <target state="translated">委派，提供要從目前委派的引動過程清單移除的引動過程清單。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Removes the invocation list of a delegate from the invocation list of another delegate.</source>
          <target state="translated">從另一個委派的引動過程清單移除委派的引動過程清單。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is found within the current delegate's invocation list.</source>
          <target state="translated">如果在目前委派的引動過程清單中找到 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 的引動過程清單，則為新委派 (其具有藉由取得目前委派的引動過程清單並移除 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 的引動過程清單所形成的引動過程清單)。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Returns the current delegate if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or if the invocation list of <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is not found within the current delegate's invocation list.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，或未在目前委派的引動過程清單中找到 <ph id="ph3">&lt;paramref name="value" /&gt;</ph> 的引動過程清單時，會傳回目前的委派。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is equal to the current delegate's invocation list.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 的引動過程清單等於目前委派的引動過程清單，則會傳回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the current delegate's invocation list, then the invocation list of <ph id="ph2">`value`</ph> is said to occur within the current delegate's invocation list.</source>
          <target state="translated">如果引動過程清單<ph id="ph1">`value`</ph>符合一組連續的目前委派的引動過程清單中，則引動過程清單中的項目<ph id="ph2">`value`</ph>稱為發生在目前的委派引動過程清單中。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the current delegate's invocation list, the last occurrence is removed.</source>
          <target state="translated">如果引動過程清單<ph id="ph1">`value`</ph>發生超過一次在目前的委派引動過程清單中，移除最後一個出現項目。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="P:System.Delegate.Target">
          <source>Gets the class instance on which the current delegate invokes the instance method.</source>
          <target state="translated">取得目前的委派在其中叫用執行個體方法的類別執行個體。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>The object on which the current delegate invokes the instance method, if the delegate represents an instance method; <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the delegate represents a static method.</source>
          <target state="translated">如果目前的委派表示執行個體方法時，則為目前委派用來叫用執行個體方法的物件；如果此委派表示靜態方法，則為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>If the delegate invokes one or more instance methods, this property returns the target of the last instance method in the invocation list.</source>
          <target state="translated">如果委派叫用一或多個執行個體方法，這個屬性會傳回目標的最後一個執行個體方法的引動過程清單中。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">叫用時晚期繫結透過機制例如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">相關聯的列舉型別： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>