<Type Name="Delegate" FullName="System.Delegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3d9b1839ccedabbb705da25899027acccda6a8a3" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53233116" /></Metadata><TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示委派，它是參考靜態方法或該類別的類別執行個體和執行個體方法 (Instance Method) 的資料結構。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate>類別是委派類型的基底類別。 不過，只有系統和編譯器可以明確地從衍生<xref:System.Delegate>類別或從<xref:System.MulticastDelegate>類別。 它也不是允許從委派型別衍生新的類型。 <xref:System.Delegate>類別不是委派類型，它是用來衍生的委派類型的類別。  
  
 大部分語言中實作`delegate`關鍵字，而這些語言的編譯器可衍生自<xref:System.MulticastDelegate>類別; 因此，使用者應該使用`delegate`語言所提供的關鍵字。  
  
> [!NOTE]
>  Common language runtime 提供`Invoke`每個委派類型都使用相同的簽章與委派的方法。 您不需要明確地呼叫這個方法，從 C#、 Visual Basic 或 Visual c + +，因為編譯器會自動呼叫。 `Invoke`方法可用於[反映](~/docs/framework/reflection-and-codedom/reflection.md)當您想要尋找的委派類型簽章。  
  
 Common language runtime 提供每個委派類型與`BeginInvoke`和`EndInvoke`方法，來啟用委派的非同步引動過程。 如需這些方法的詳細資訊，請參閱[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
 委派類型的宣告會建立合約，指定一或多個方法的簽章。 委派是參考委派類型的執行個體：  
  
-   類型和目標物件指派給該類型的執行個體方法。  
  
-   型別，隱藏的執行個體方法`this`公開型式參數清單中的參數。 委派是要開啟執行個體的委派。  
  
-   靜態方法。  
  
-   靜態方法，而且目標物件指派給該方法的第一個參數。 此委派會在第一個引數上關閉。  
  
 如需有關委派繫結的詳細資訊，請參閱<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，委派可以代表方法，只有當方法的簽章完全符合委派型別所指定的簽章。 因此，只有第一個和第三個項目符號在上述清單中的都有支援，而第一項需要的確切型別相符項目。  
  
 當委派表示其第一個引數 （最常見的情況） 上關閉執行個體方法時，此委派會儲存方法的進入點的參考和參考的物件，稱為目標，也就是指派給類型定義的類型方法。 當委派表示開啟的執行個體方法時，它會儲存至方法的進入點的參考。 委派簽章必須包含隱藏`this`其型式參數清單中的參數; 在此情況下，委派沒有目標物件的參考，並在叫用委派時，就必須提供目標物件。  
  
 當委派表示靜態方法時，委派就會儲存至方法的進入點的參考。 當委派表示靜態方法，其第一個引數所覆蓋時，委派會儲存參考方法的進入點和指派給方法的第一個引數類型的目標物件的參考。 叫用委派時，靜態方法的第一個引數會接收目標物件。  
  
 委派的引動過程清單是在其中清單的每個項目叫用只有其中一個委派所表示之方法的委派的已排序的集合。 引動過程清單可以包含重複的方法。 在引動過程，方法是以其出現在引動過程清單中的順序叫用。 委派嘗試叫用其引動過程清單中的每個方法重複的項目會叫用之後每次出現在引動過程清單中。 委派是不可變的;建立之後，就不會變更委派的引動過程清單。  
  
 委派就多點傳送，或可組合的類別，因為委派可以叫用一或多個方法，可用在合併作業。  
  
 合併作業，例如<xref:System.Delegate.Combine%2A>和<xref:System.Delegate.Remove%2A>，不會改變現有的委派。 相反地，這類作業會傳回新的委派來包含結果的作業，也就是不變的委派，或`null`。 合併作業會傳回`null`作業的結果時不會參考至少一個方法的委派。 合併作業會傳回未變更的委派，當要求的作業沒有任何作用。  
  
> [!NOTE]
>  Managed 語言使用<xref:System.Delegate.Combine%2A>和<xref:System.Delegate.Remove%2A>實作委派作業的方法。 範例包括`AddHandler`和`RemoveHandler`Visual Basic 中的陳述式和 + = 和-= 運算子委派 C# 中的型別。  
  
 從開始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，泛型委派類型可以有 variant 類型參數。 Contravariant 類型參數可用來當做委派參數類型與 covariant 類型參數可用來當做傳回型別。 這項功能可讓泛型委派類型從相同泛型類型定義與指派相容其類型引數是否具有繼承關係，參考型別中所述建構[共變數和反變數](~/docs/standard/generics/covariance-and-contravariance.md)。  
  
> [!NOTE]
>  與指派相容的泛型委派因為時間差異不一定是可組合的類別。 若要可組合的類別，類型必須完全相符。 例如，假設 具名的類別`Derived`衍生自類別，名為`Base`。 類型的委派`Action<Base>`(`Action(Of Base)` Visual Basic 中) 可以指派給類型的變數`Action<Derived>`，但無法合併兩個委派，因為類型不完全相符。  
  
 如果叫用的方法擲回例外狀況，則方法會停止執行、 例外狀況會傳遞至委派的呼叫端和引動過程清單中的其餘方法不會叫用。 在呼叫端攔截的例外狀況時，不會改變此行為。  
  
 當叫用由委派的方法簽章包含傳回的值時，委派會傳回引動過程清單最後一個元素的傳回值。 當簽章包含傳址方式傳遞的參數時，最後一個參數的值會是每個方法引動過程清單，依序執行，並更新參數的值中的結果。  
  
 在 C 中委派的最接近對等項目是函式指標。 委派可以表示的靜態方法或執行個體方法。 當委派表示執行個體方法時，此委派會儲存參考至方法的進入點，不僅類別執行個體的參考。 不同於函式指標，委派是物件導向和型別安全。  
  
   
  
## Examples  
 下列範例示範如何定義委派，名為`myMethodDelegate`。 執行個體方法和巢狀的靜態方法建立這個委派的執行個體`mySampleClass`類別。 執行個體方法的委派要求的執行個體`mySampleClass`。 `mySampleClass`執行個體儲存在變數，名為`mySC`。  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">以非同步的方式呼叫同步方法</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">委派 (C# 程式設計手冊)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">委派 (Visual Basic)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">如何：定義和使用委派 (C++/CLI)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">處理和引發事件</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化新的委派。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">委派用來叫用 <paramref name="method" /> 的類別執行個體。</param>
        <param name="method">委派表示的執行個體方法名稱。</param>
        <summary>初始化委派，這個委派會在指定的類別執行個體上叫用指定的執行個體方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式不能在應用程式程式碼。 若要建立委派，藉由指定的執行個體方法名稱，使用的多載<xref:System.Delegate.CreateDelegate%2A>指定方法名稱和目標物件的方法。 比方說，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29>方法多載會建立具有指定名稱的執行個體方法的委派。  
  
 這個建構函式只會建立委派執行個體方法。 執行個體方法則是類別; 的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">繫結至目標方法時發生錯誤。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Type" />，代表定義 <paramref name="method" /> 的類別。</param>
        <param name="method">委派表示的靜態方法名稱。</param>
        <summary>初始化委派，這個委派會從指定的類別叫用指定的靜態方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式不能在應用程式程式碼。 若要建立委派，藉由指定的靜態方法名稱，使用的多載<xref:System.Delegate.CreateDelegate%2A>指定方法名稱，但未指定目標物件的方法。 比方說，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29>方法多載會建立具有指定名稱的靜態方法的委派。  
  
 這個建構函式會建立只有靜態方法的委派。 執行個體方法則是類別; 的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
-或- 
 <paramref name="target" /> 代表開放式泛型類型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立委派的淺層複本 (Shallow Copy)。</summary>
        <returns>委派的淺層複本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 複製具有相同<xref:System.Type>，做為原始的委派的目標、 方法和引動過程清單。  
  
 淺層複本建立與原始物件，而相同類型的新執行個體，並接著會將複製原始物件的非靜態欄位。 如果欄位是實值型別，則會執行位元欄位的複本。 如果欄位是參考型別，則會複製參考，但參考的物件不;因此，在原始物件的參考和複製品中的參考點相同的物件。 相較之下，物件的深層複本複製直接或間接參考的欄位物件中的所有項目。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>串連指定多點傳送 (可結合的) 委派的引動過程清單。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">要結合的委派陣列。</param>
        <summary>串連委派陣列的引動過程清單。</summary>
        <returns>具有引動過程清單的新委派，這個清單可串連 <paramref name="delegates" /> 陣列中委派的引動過程清單。 如果 <paramref name="delegates" /> 是 <see langword="null" />、<paramref name="delegates" /> 包含零個項目，或者 <paramref name="delegates" /> 中的每個項目都是 <see langword="null" />，則會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`delegates`陣列包含的項目`null`，這些項目都會被忽略。  
  
 引動過程清單可以包含重複的項目;也就是指相同的方法相同的物件上的項目。  
  
> [!NOTE]
>  與指派相容的泛型委派因為時間差異不一定是可組合的類別。 若要可組合的類別，類型必須完全相符。 例如，假設 具名的類別`Derived`衍生自類別，名為`Base`。 類型的委派`Action<Base>`(`Action(Of Base)` Visual Basic 中) 可以指派給類型的變數`Action<Derived>`，如下所述[共變性與逆變性](~/docs/standard/generics/covariance-and-contravariance.md)，但無法合併兩個委派，因為型別不完全相符。  
  
 <xref:System.Delegate.Combine%2A> 可用於建立多個方法的時間事件的呼叫，就會發生的事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">並非 <paramref name="delegates" /> 中的所有非 null 項目都是相同委派類型的執行個體。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">引動過程清單首先到達的委派。</param>
        <param name="b">引動過程清單最後到達的委派。</param>
        <summary>串連兩個委派的引動過程清單。</summary>
        <returns>具有引動過程清單的新委派，這個清單可以該順序串連 <paramref name="a" /> 和 <paramref name="b" /> 的引動過程清單。 如果 <paramref name="b" /> 為 <see langword="null" />，則會傳回 <paramref name="a" />；如果 <paramref name="a" /> 為 Null 參考，則會傳回 <paramref name="b" />；如果 <paramref name="a" /> 和 <paramref name="b" /> 兩者都是 Null 參考，則會傳回 Null 參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引動過程清單可以包含重複的項目;也就是指相同的方法相同的物件上的項目。  
  
> [!NOTE]
>  與指派相容的泛型委派因為時間差異不一定是可組合的類別。 若要可組合的類別，類型必須完全相符。 例如，假設 具名的類別`Derived`衍生自類別，名為`Base`。 類型的委派`Action<Base>`(`Action(Of Base)` Visual Basic 中) 可以指派給類型的變數`Action<Derived>`，如下所述[共變性與逆變性](~/docs/standard/generics/covariance-and-contravariance.md)，但無法合併兩個委派，因為型別不完全相符。  
  
 <xref:System.Delegate.Combine%2A> 可用於建立多個方法的時間事件的呼叫，就會發生的事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="a" /> 和 <paramref name="b" /> 都不是 <see langword="null" />，而且 <paramref name="a" /> 和 <paramref name="b" /> 不是相同委派類型的執行個體。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">多點傳送 (可結合的) 委派，其引動過程清單要附加到目前多點傳送 (可結合的) 委派的引動過程清單末端。</param>
        <summary>串連指定的多點傳送 (可結合的) 委派和目前多點傳送 (可結合的) 委派的引動過程清單。</summary>
        <returns>具有引動過程清單的新多點傳送 (可結合式) 委派，此清單可串連目前多點傳送 (可結合式) 委派的引動過程清單和 <paramref name="d" /> 的引動過程清單之委派；而在 <paramref name="d" /> 為 <see langword="null" /> 時，則為目前多點傳送 (可結合式) 委派。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只適用於目前的委派是多點傳送 （可結合式）。  
  
 目前的實作只會擲回<xref:System.MulticastNotSupportedException>。  
  
 引動過程清單可以包含重複的項目;也就是指相同的方法相同的物件上的項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">一律擲回。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立指定類型的委派。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" />，描述委派所要表示的靜態或執行個體方法。 在 .NET Framework 1.0 和 1.1 版中只支援靜態方法。</param>
        <summary>建立指定類型的委派來表示指定的靜態方法。</summary>
        <returns>指定類型的委派，用來表示指定的靜態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 1.0 和 1.1 版中，這個方法多載會建立只有靜態方法的委派。 在.NET Framework 2.0 版中，這個方法多載也可以建立開啟的執行個體方法委派，也就是明確地提供隱藏第一個引數的委派執行個體方法。 如需詳細說明，請參閱更多一般<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>方法多載，可讓您建立所有組合的開放式或封閉式的委派執行個體或靜態方法，並選擇性地指定第一個引數。  
  
> [!NOTE]
>  這個方法多載應該時使用委派未關閉透過其第一個引數，因為它在此情況下是稍快。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載，並指定`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用方法，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，並限制為呼叫端的非公用方法的授權集是否授與集或子集效果。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>相容的參數型別和傳回型別  
 在.NET Framework 2.0 版中，使用這個方法多載建立委派的傳回型別與參數類型必須是相容的參數類型和委派所表示; 方法的傳回型別型別沒有完全相符。 這代表鬆散的.NET Framework 1.0 和 1.1 中，類型必須完全相符的版本中的繫結行為。  
  
 如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。  
  
 同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。  
  
 例如，使用類型參數的委派<xref:System.Collections.Hashtable>和傳回型別<xref:System.Object>可以代表具有一個型別的參數的方法<xref:System.Object>以及傳回值的型別<xref:System.Collections.Hashtable>。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例示範的委派，可以使用這個方法多載來建立兩種： 透過執行個體方法開啟，並開啟移轉的靜態方法。  
  
 第二個程式碼範例會示範相容的參數型別和傳回型別。  
  
 **範例 1**  
  
 下列程式碼範例示範兩種方式可以建立委派，使用的這個多載<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>指定的方法<xref:System.Reflection.MethodInfo>不的第一次的引數，但其功能都相同，但是其中一個可讓您指定是否要在繫結，失敗時擲回，而其他一律會擲回。 此程式碼範例會使用這兩個多載。  
  
 此範例會宣告類別`C`靜態方法`M2`和執行個體方法`M1`，以及兩個委派型別：`D1`可接受的執行個體`C`和一個字串和`D2`採用字串。  
  
 第二個類別，名為`Example`包含建立委派的程式碼。  
  
-   類型的委派`D1`，表示開啟執行個體方法，建立執行個體方法`M1`。 叫用委派時，必須傳遞執行個體。  
  
-   類型的委派`D2`，表示開啟的靜態方法，靜態方法，建立`M2`。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **範例 2**  
  
 下列程式碼範例示範的參數類型相容性，並傳回型別。  
  
 在程式碼範例定義名為基底類別`Base`和名為類別`Derived`衍生自`Base`。 衍生的類別有`static`(`Shared` Visual Basic 中) 名為方法`MyMethod`具有一個參數的型別`Base`且傳回類型為`Derived`。 在程式碼範例也會定義名為委派`Example`具有一個參數的型別`Derived`且傳回類型為`Base`。  
  
 在程式碼範例示範委派名為`Example`可用來表示方法`MyMethod`。 此方法可以繫結至委派，因為：  
  
-   委派的參數類型 (`Derived`) 是更具限制性的參數型別`MyMethod`(`Base`)，如此一來，它一律是安全地傳遞至委派的引數`MyMethod`。  
  
-   傳回型別`MyMethod`(`Derived`) 是更具限制性的委派參數類型 (`Base`)，如此一來，一定是安全轉型為委派的傳回型別方法的傳回型別。  
  
 在程式碼範例會產生任何輸出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
-或- 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
-或- 
 <paramref name="method" /> 不是靜態方法，且 .NET Framework 版本為 1.0 或 1.1。  
  
-或- 
 無法繫結 <paramref name="method" />。  
  
-或- 
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="firstArgument">此委派要繫結的物件，或是 <see langword="null" />，表示將 <paramref name="method" /> 視為 <see langword="static" /> (Visual Basic 中則為 <see langword="Shared" />)。</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" />，描述委派所要表示的靜態或執行個體方法。</param>
        <summary>建立指定之類型的委派，其表示指定之靜態或執行個體方法，並有指定第一個引數。</summary>
        <returns>指定之類型的委派，其表示指定的靜態或執行個體方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載，並指定`true`如`throwOnBindFailure`。 這些兩個多載會提供最具彈性的方式來建立委派。 您可以使用它們來建立委派的靜態或執行個體方法，並選擇性地指定第一個引數。  
  
> [!NOTE]
>  如果您未提供第一個引數，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載，以提升效能。  
  
 委派型別和方法必須具有相容傳回型別。 也就是說，傳回型別`method`必須是指派給的傳回型別`type`。  
  
 如果`firstArgument`是提供，則會傳遞至`method`每次叫用委派時;`firstArgument`稱為繫結至委派，以及此委派會在第一個引數上關閉。 如果`method`已`static`(`Shared`在 Visual Basic 中)，則引數叫用委派時所提供的清單包含第一個; 以外的所有參數，如果`method`是執行個體方法，然後`firstArgument`傳遞到隱藏的執行個體參數 (由`this`在 C# 中，或由`Me`Visual Basic 中)。  
  
 如果`firstArgument`提供的第一個參數`method`必須是參考型別和`firstArgument`必須相容於該型別。  
  
> [!IMPORTANT]
>  如果`method`已`static`(`Shared`在 Visual Basic 中) 以及其第一個參數為類型<xref:System.Object>或<xref:System.ValueType>，然後`firstArgument`可以是實值型別。 在此情況下`firstArgument`會自動進行 boxed 處理。 自動 boxing 不會發生的任何其他引數，因為它會以 C# 或 Visual Basic 函式呼叫。  
  
 如果`firstArgument`為 null 參考並`method`是執行個體方法，結果會取決於委派型別的簽章`type`以及`method`:  
  
-   如果簽章`type`明確包含隱藏第一個參數`method`，此委派表示開啟執行個體方法。 叫用委派時，要將引數清單中的第一個引數傳遞給隱藏的執行個體參數`method`。  
  
-   如果簽章`method`和`type`符合 （也就是所有的參數型別都相容），則此委派會在 null 參考上關閉。 叫用委派就像是在 null 執行個體，不是一個特別有用的東西，要呼叫的執行個體方法。  
  
 如果`firstArgument`為 null 參考並`method`是靜態的結果會取決於委派型別的簽章`type`以及`method`:  
  
-   如果簽章`method`和`type`符合 （也就是所有的參數型別都相容），此委派會表示開啟的靜態方法。 這是最常見的案例，對於靜態方法。 在此情況下，您可以在這裡取得更好的效能使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載。  
  
-   如果簽章`type`開頭的第二個參數`method`和其餘的參數類型相容，則此委派會在 null 參考上關閉。 第一個參數來叫用委派時，要傳遞 null 參考`method`。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用方法，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，並限制為呼叫端的非公用方法的授權集是否授與集或子集效果。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>相容的參數型別和傳回型別  
 參數類型和委派的傳回型別必須與參數類型和委派所表示; 方法的傳回型別相容型別沒有完全相符。  
  
> [!NOTE]
>  在.NET Framework 1.0 和 1.1 版中，類型必須完全相符。  
  
 如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。  
  
 同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。  
  
 例如，使用類型參數的委派<xref:System.Collections.Hashtable>和傳回型別<xref:System.Object>可以代表具有一個型別的參數的方法<xref:System.Object>以及傳回值的型別<xref:System.Collections.Hashtable>。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>判斷方法的委派可以表示  
 另一個實用的方式，將這個多載所提供之彈性<xref:System.Delegate.CreateDelegate%2A>是任何指定的委派可以代表四個不同的方法簽章和方法種類 （靜態和執行個體） 的組合。 委派型別，請考慮`D`argumentem typu `C`。 以下描述方法`D`可以代表，忽略的傳回型別，因為它必須符合在所有情況下：  
  
-   `D` 可以代表任何有類型只有一個引數的執行個體方法`C`，不論執行個體方法屬於何種類型。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`是類型的執行個體`method`所屬，並產生的委派會在該執行個體上關閉。 (透過極簡方式，`D`也可以關閉透過 null 參考如果`firstArgument`為 null 參考。)  
  
-   `D` 可以代表的執行個體方法`C`，沒有任何引數。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`為 null 參考。 產生的委派表示開啟的執行個體方法和執行個體`C`必須提供每次叫用時。  
  
-   `D` 可以代表採用一個引數類型的靜態方法`C`，而且方法可以屬於任何類型。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`為 null 參考。 產生的委派表示開啟的靜態方法和執行個體`C`必須提供每次叫用時。  
  
-   `D` 可以代表屬於類型的靜態方法`F`且具有兩個引數，型別的`F`並輸入`C`。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`的執行個體`F`。 產生的委派表示靜態方法，關閉該執行個體透過`F`。 請注意，萬一其中`F`和`C`都是相同的型別、 靜態方法會具有該類型的兩個引數。 (在此情況下，`D`如果覆蓋 null 參考`firstArgument`為 null 參考。)  
  
   
  
## Examples  
 本節包含三個程式碼範例。 第一個範例示範委派可建立四種： 覆蓋的執行個體方法，透過執行個體方法，是靜態方法，透過開啟開啟和關閉透過靜態方法。  
  
 第二個程式碼範例會示範相容的參數型別和傳回型別。  
  
 第三個程式碼範例會定義單一的委派類型，並顯示可以代表委派類型的所有方法。  
  
 **範例 1**  
  
 下列程式碼範例示範可使用的這個多載來建立委派的四種方式<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>指定的方法`firstArgument`和<xref:System.Reflection.MethodInfo>; 其功能都相同，但是其中一個可讓您指定是否要在繫結，失敗時擲回，而其他一律會擲回。 此程式碼範例會使用這兩個多載。  
  
 此範例會宣告類別`C`靜態方法`M2`和執行個體方法`M1`，以及三個委派型別：`D1`可接受的執行個體`C`和字串，`D2`接受字串，而`D3`沒有任何引數。  
  
 第二個類別，名為`Example`包含建立委派的程式碼。  
  
-   類型的委派`D2`、 已關閉的執行個體透過`C`，建立執行個體方法`M1`。 它會使用不同的字串，表示繫結執行個體叫用`C`一律會使用。  
  
-   類型的委派`D1`，表示開啟執行個體方法，建立執行個體方法`M1`。 叫用委派時，必須傳遞執行個體。  
  
-   類型的委派`D2`，表示開啟的靜態方法，靜態方法，建立`M2`。  
  
-   最後，類型的委派`D3`覆蓋字串、 靜態方法，建立`M2`。 方法會叫用來顯示它會使用繫結的字串。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **範例 2**  
  
 下列程式碼範例示範的參數類型相容性，並傳回型別。  
  
> [!NOTE]
>  此程式碼範例會使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載。 使用其他多載會採用<xref:System.Reflection.MethodInfo>類似。  
  
 在程式碼範例定義名為基底類別`Base`和名為類別`Derived`衍生自`Base`。 衍生的類別有`static`(`Shared` Visual Basic 中) 名為方法`MyMethod`具有一個參數的型別`Base`且傳回類型為`Derived`。 在程式碼範例也會定義名為委派`Example`具有一個參數的型別`Derived`且傳回類型為`Base`。  
  
 在程式碼範例示範委派名為`Example`可用來表示方法`MyMethod`。 此方法可以繫結至委派，因為：  
  
-   委派的參數類型 (`Derived`) 是更具限制性的參數型別`MyMethod`(`Base`)，如此一來，它一律是安全地傳遞至委派的引數`MyMethod`。  
  
-   傳回型別`MyMethod`(`Derived`) 是更具限制性的委派參數類型 (`Base`)，如此一來，一定是安全轉型為委派的傳回型別方法的傳回型別。  
  
 在程式碼範例會產生任何輸出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **範例 3**  
  
 下列程式碼範例顯示所有的方法是單一的委派型別可以代表使用<xref:System.Delegate.CreateDelegate%2A>方法用來建立委派。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>指定的方法`firstArgument`和<xref:System.Reflection.MethodInfo>; 其功能都相同，但是其中一個可讓您指定是否要在繫結，失敗時擲回，而其他一律會擲回。 此程式碼範例會使用這兩個多載。  
  
 此程式碼範例會定義兩個類別：`C`和`F`，和委派型別`D`argumentem typu `C`。 類別有相符的靜態和執行個體方法`M1`， `M3`，並`M4`，和類別`C`也有執行個體方法`M2`，沒有任何引數。  
  
 第三個類別，名為`Example`包含建立委派的程式碼。  
  
-   委派會建立執行個體方法`M1`型別的`C`並輸入`F`; 透過個別類型的執行個體，每個已關閉。 方法`M1`型別的`C`顯示`ID`屬性繫結的執行個體與引數。  
  
-   方法建立委派`M2`型別的`C`。 這是開啟的執行個體的委派，其中委派的引數代表方法的執行個體上的隱藏第一個引數。 此方法會有任何其他引數。 如同它是一種靜態方法呼叫它。  
  
-   為靜態方法建立委派`M3`型別的`C`並輸入`F`; 這些是開啟的靜態委派。  
  
-   最後，委派會建立靜態方法`M4`型別的`C`並輸入`F`; 每個方法都宣告的型別，做為其第一個引數，以及提供型別的執行個體，所以委派會覆蓋其第一個引數. 方法`M4`型別的`C`顯示`ID`屬性繫結的執行個體與引數。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
-或- 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
-或- 
 無法繫結 <paramref name="method" />。  
  
-或- 
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="target">叫用 <paramref name="method" /> 的類別執行個體。</param>
        <param name="method">委派要表示的執行個體方法名稱。</param>
        <summary>建立指定類型的委派，這個委派表示要在指定的類別執行個體上叫用的指定執行個體方法。</summary>
        <returns>指定類型的委派，表示要在指定的類別執行個體上叫用的指定執行個體方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只會建立委派執行個體方法。 執行個體方法則是類別; 的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，指定`false`for`ignoreCase`並`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用方法，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，並限制為呼叫端的非公用方法的授權集是否授與集或子集效果。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="target" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
-或- 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
-或- 
 <paramref name="method" /> 不是執行個體方法。  
  
-或- 
 例如，因為找不到 <paramref name="method" />，所以無法將其繫結。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" />，描述委派所要表示的靜態或執行個體方法。</param>
        <param name="throwOnBindFailure"><paramref name="method" /> 表示如果無法繫結 <see langword="true" /> 時，則擲回例外狀況；否則為 <see langword="false" />。</param>
        <summary>建立指定之類型的委派，用來表示指定之靜態方法，並包含在繫結失敗時發生的指定之行為。</summary>
        <returns>指定類型的委派，用來表示指定的靜態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載可以建立開啟的靜態方法的委派，並開啟執行個體方法委派-也就是公開隱藏的第一個引數的執行個體方法的委派。 如需詳細說明，請參閱更多一般<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載，可讓您建立所有組合的開放式或封閉式的委派執行個體或靜態方法。  
  
> [!NOTE]
>  這個方法多載應該時使用委派未關閉透過其第一個引數，因為它在此情況下是稍快。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用方法，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，並限制為呼叫端的非公用方法的授權集是否授與集或子集效果。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>相容的參數型別和傳回型別  
 參數類型和委派的傳回型別必須與參數類型和委派所表示; 方法的傳回型別相容型別沒有完全相符。  
  
> [!NOTE]
>  在.NET Framework 1.0 和 1.1 版中，類型必須完全相符。  
  
 如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。  
  
 同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。  
  
 例如，使用類型參數的委派<xref:System.Collections.Hashtable>和傳回型別<xref:System.Object>可以代表具有一個型別的參數的方法<xref:System.Object>以及傳回值的型別<xref:System.Collections.Hashtable>。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例示範的委派，可以使用這個方法多載來建立兩種： 透過執行個體方法開啟，並開啟移轉的靜態方法。  
  
 第二個程式碼範例會示範相容的參數型別和傳回型別。  
  
 **範例 1**  
  
 下列程式碼範例示範兩種方式可以建立委派，使用的這個多載<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>指定的方法<xref:System.Reflection.MethodInfo>不的第一次的引數，但其功能都相同，但是其中一個可讓您指定是否要在繫結，失敗時擲回，而其他一律會擲回。 此程式碼範例會使用這兩個多載。  
  
 此範例會宣告類別`C`靜態方法`M2`和執行個體方法`M1`，以及兩個委派型別：`D1`可接受的執行個體`C`和一個字串和`D2`採用字串。  
  
 第二個類別，名為`Example`包含建立委派的程式碼。  
  
-   類型的委派`D1`，表示開啟執行個體方法，建立執行個體方法`M1`。 叫用委派時，必須傳遞執行個體。  
  
-   類型的委派`D2`，表示開啟的靜態方法，靜態方法，建立`M2`。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **範例 2**  
  
 下列程式碼範例示範的參數類型相容性，並傳回型別。  
  
> [!NOTE]
>  此程式碼範例會使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載。 使用其他多載會採用<xref:System.Reflection.MethodInfo>類似。  
  
 在程式碼範例定義名為基底類別`Base`和名為類別`Derived`衍生自`Base`。 衍生的類別有`static`(`Shared` Visual Basic 中) 名為方法`MyMethod`具有一個參數的型別`Base`且傳回類型為`Derived`。 在程式碼範例也會定義名為委派`Example`具有一個參數的型別`Derived`且傳回類型為`Base`。  
  
 在程式碼範例示範委派名為`Example`可用來表示方法`MyMethod`。 此方法可以繫結至委派，因為：  
  
-   委派的參數類型 (`Derived`) 是更具限制性的參數型別`MyMethod`(`Base`)，如此一來，它一律是安全地傳遞至委派的引數`MyMethod`。  
  
-   傳回型別`MyMethod`(`Derived`) 是更具限制性的委派參數類型 (`Base`)，如此一來，一定是安全轉型為委派的傳回型別方法的傳回型別。  
  
 在程式碼範例會產生任何輸出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
-或- 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
-或- 
 無法繫結 <paramref name="method" />，而且 <paramref name="throwOnBindFailure" /> 為 <see langword="true" />。  
  
-或- 
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="target"><see cref="T:System.Type" />，代表可實作 <paramref name="method" /> 的類別。</param>
        <param name="method">委派要表示的靜態方法名稱。</param>
        <summary>建立指定類型的委派，這個委派表示指定類別的指定靜態方法。</summary>
        <returns>指定類型的委派，表示指定類別的指定靜態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立只有靜態方法的委派。 執行個體方法則是類別; 的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，指定`false`for`ignoreCase`並`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用方法，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，並限制為呼叫端的非公用方法的授權集是否授與集或子集效果。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="target" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
-或- 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
-或- 
 <paramref name="target" /> 不是 <see langword="RuntimeType" />。  
  
-或- 
 <paramref name="target" /> 是開放式泛型類型。 亦即，其 <see cref="P:System.Type.ContainsGenericParameters" /> 屬性為 <see langword="true" />。  
  
-或- 
 <paramref name="method" /> 不是 <see langword="static" /> 方法 (Visual Basic 中的 <see langword="Shared" /> 方法)。  
  
-或- 
 無法繫結 <paramref name="method" />，例如因為找不到該方法，以及 <paramref name="throwOnBindFailure" /> 為 <see langword="true" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" />，表示要建立的委派之類型。</param>
        <param name="firstArgument"><see cref="T:System.Object" />，委派所表示的方法之第一個引數。 對於執行個體方法而言，它必須與執行個體類型相容。</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" />，描述委派所要表示的靜態或執行個體方法。</param>
        <param name="throwOnBindFailure"><paramref name="method" /> 表示如果無法繫結 <see langword="true" /> 時，則擲回例外狀況；否則為 <see langword="false" />。</param>
        <summary>建立指定之類型的委派，其表示指定之靜態或執行個體方法，並有指定第一個引數以及繫結失敗時所發生的行為。</summary>
        <returns>指定之類型的委派，表示指定之靜態或執行個體方法；如果 <paramref name="throwOnBindFailure" /> 為 <see langword="false" />，且委派無法繫結至 <paramref name="method" />，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載和<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>方法多載而言，一定要繫結失敗時擲回，提供最具彈性的方式，來建立委派。 您可以使用它們來建立委派的靜態或執行個體方法，不論第一個引數。  
  
> [!NOTE]
>  如果您未提供第一個引數，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載，以提升效能。  
  
 委派型別和方法必須具有相容傳回型別。 也就是說，傳回型別`method`必須是指派給的傳回型別`type`。  
  
 如果`firstArgument`是提供，則會傳遞至`method`每次叫用委派時;`firstArgument`稱為繫結至委派，以及此委派會在第一個引數上關閉。 如果`method`已`static`(`Shared`在 Visual Basic 中)，則引數叫用委派時所提供的清單包含第一個; 以外的所有參數，如果`method`是執行個體方法，然後`firstArgument`傳遞到隱藏的執行個體參數 (由`this`在 C# 中，或由`Me`Visual Basic 中)。  
  
 如果`firstArgument`提供的第一個參數`method`必須是參考型別和`firstArgument`必須相容於該型別。  
  
> [!IMPORTANT]
>  如果`method`已`static`(`Shared`在 Visual Basic 中) 以及其第一個參數為類型<xref:System.Object>或<xref:System.ValueType>，然後`firstArgument`可以是實值型別。 在此情況下`firstArgument`會自動進行 boxed 處理。 自動 boxing 不會發生的任何其他引數，因為它會以 C# 或 Visual Basic 函式呼叫。  
  
 如果`firstArgument`為 null 參考並`method`是執行個體方法，結果會取決於委派型別的簽章`type`以及`method`:  
  
-   如果簽章`type`明確包含隱藏第一個參數`method`，此委派表示開啟執行個體方法。 叫用委派時，要將引數清單中的第一個引數傳遞給隱藏的執行個體參數`method`。  
  
-   如果簽章`method`和`type`符合 （也就是所有的參數型別都相容），則此委派會在 null 參考上關閉。 叫用委派就像是在 null 執行個體，不是一個特別有用的東西，要呼叫的執行個體方法。  
  
 如果`firstArgument`為 null 參考並`method`是靜態的結果會取決於委派型別的簽章`type`以及`method`:  
  
-   如果簽章`method`和`type`符合 （也就是所有的參數型別都相容），此委派會表示開啟的靜態方法。 這是最常見的案例，對於靜態方法。 在此情況下，您可以在這裡取得更好的效能使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載。  
  
-   如果簽章`type`開頭的第二個參數`method`和其餘的參數類型相容，則此委派會在 null 參考上關閉。 第一個參數來叫用委派時，要傳遞 null 參考`method`。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用方法，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，並限制為呼叫端的非公用方法的授權集是否授與集或子集效果。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>相容的參數型別和傳回型別  
 參數類型和委派的傳回型別必須與參數類型和委派所表示; 方法的傳回型別相容型別沒有完全相符。  
  
> [!NOTE]
>  .NET Framework 1.0 和 1.1 版中的類型必須完全相符。  
  
 如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。  
  
 同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。  
  
 例如，使用類型參數的委派<xref:System.Collections.Hashtable>和傳回型別<xref:System.Object>可以代表具有一個型別的參數的方法<xref:System.Object>以及傳回值的型別<xref:System.Collections.Hashtable>。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>判斷方法的委派可以表示  
 另一個實用的方式，將這個多載所提供之彈性<xref:System.Delegate.CreateDelegate%2A>是任何指定的委派可以代表四個不同的方法簽章和方法種類 （靜態和執行個體） 的組合。 委派型別，請考慮`D`argumentem typu `C`。 以下描述方法`D`可以代表，忽略的傳回型別，因為它必須符合在所有情況下：  
  
-   `D` 可以代表任何有類型只有一個引數的執行個體方法`C`，不論執行個體方法屬於何種類型。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`是類型的執行個體`method`所屬，並產生的委派會在該執行個體上關閉。 (透過極簡方式，`D`也可以關閉透過 null 參考若`firstArgument`是`null`。)  
  
-   `D` 可以代表的執行個體方法`C`，沒有任何引數。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`為 null 參考。 產生的委派表示開啟的執行個體方法和執行個體`C`必須提供每次叫用時。  
  
-   `D` 可以代表採用一個引數類型的靜態方法`C`，而且方法可以屬於任何類型。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`為 null 參考。 產生的委派表示開啟的靜態方法和執行個體`C`必須提供每次叫用時。  
  
-   `D` 可以代表屬於類型的靜態方法`F`且具有兩個引數，型別的`F`並輸入`C`。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`的執行個體`F`。 產生的委派表示靜態方法，關閉該執行個體透過`F`。 請注意，萬一其中`F`和`C`都是相同的型別、 靜態方法會具有該類型的兩個引數。 (在此情況下，`D`如果覆蓋 null 參考`firstArgument`是`null`。)  
  
   
  
## Examples  
 本節包含三個程式碼範例。 第一個範例示範委派可建立四種： 覆蓋的執行個體方法，透過執行個體方法，是靜態方法，透過開啟開啟和關閉透過靜態方法。  
  
 第二個程式碼範例會示範相容的參數型別和傳回型別。  
  
 第三個程式碼範例會定義單一的委派類型，並顯示可以代表委派類型的所有方法。  
  
 **範例 1**  
  
 下列程式碼範例示範可使用的這個多載來建立委派的四種方式<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>指定的方法`firstArgument`和<xref:System.Reflection.MethodInfo>; 其功能都相同，但是其中一個可讓您指定是否要在繫結，失敗時擲回，而其他一律會擲回。 此程式碼範例會使用這兩個多載。  
  
 此範例會宣告類別`C`靜態方法`M2`和執行個體方法`M1`，以及三個委派型別：`D1`可接受的執行個體`C`和字串，`D2`接受字串，而`D3`沒有任何引數。  
  
 第二個類別，名為`Example`包含建立委派的程式碼。  
  
-   類型的委派`D2`、 已關閉的執行個體透過`C`，建立執行個體方法`M1`。 它會使用不同的字串，表示繫結執行個體叫用`C`一律會使用。  
  
-   類型的委派`D1`，表示開啟執行個體方法，建立執行個體方法`M1`。 叫用委派時，必須傳遞執行個體。  
  
-   類型的委派`D2`，表示開啟的靜態方法，靜態方法，建立`M2`。  
  
-   最後，類型的委派`D3`覆蓋字串、 靜態方法，建立`M2`。 方法會叫用來顯示它會使用繫結的字串。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **範例 2**  
  
 下列程式碼範例示範的參數類型相容性，並傳回型別。  
  
> [!NOTE]
>  此程式碼範例會使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載。 使用其他多載會採用<xref:System.Reflection.MethodInfo>類似。  
  
 在程式碼範例定義名為基底類別`Base`和名為類別`Derived`衍生自`Base`。 衍生的類別有`static`(`Shared` Visual Basic 中) 名為方法`MyMethod`具有一個參數的型別`Base`且傳回類型為`Derived`。 在程式碼範例也會定義名為委派`Example`具有一個參數的型別`Derived`且傳回類型為`Base`。  
  
 在程式碼範例示範委派名為`Example`可用來表示方法`MyMethod`。 此方法可以繫結至委派，因為：  
  
-   委派的參數類型 (`Derived`) 是更具限制性的參數型別`MyMethod`(`Base`)，如此一來，它一律是安全地傳遞至委派的引數`MyMethod`。  
  
-   傳回型別`MyMethod`(`Derived`) 是更具限制性的委派參數類型 (`Base`)，如此一來，一定是安全轉型為委派的傳回型別方法的傳回型別。  
  
 在程式碼範例會產生任何輸出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **範例 3**  
  
 下列程式碼範例顯示單一的委派類型可以表示的所有方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>指定的方法`firstArgument`和<xref:System.Reflection.MethodInfo>; 其功能都相同，但是其中一個可讓您指定是否要在繫結，失敗時擲回，而其他一律會擲回。 此程式碼範例會使用這兩個多載。  
  
 此程式碼範例會定義兩個類別：`C`和`F`，和委派型別`D`argumentem typu `C`。 類別有相符的靜態和執行個體方法`M1`， `M3`，並`M4`，和類別`C`也有執行個體方法`M2`，沒有任何引數。  
  
 第三個類別，名為`Example`包含建立委派的程式碼。  
  
-   委派會建立執行個體方法`M1`型別的`C`並輸入`F`; 透過個別類型的執行個體，每個已關閉。 方法`M1`型別的`C`顯示`ID`屬性繫結的執行個體與引數。  
  
-   方法建立委派`M2`型別的`C`。 這是開啟的執行個體的委派，其中委派的引數代表方法的執行個體上的隱藏第一個引數。 此方法會有任何其他引數。  
  
-   為靜態方法建立委派`M3`型別的`C`並輸入`F`; 這些是開啟的靜態委派。  
  
-   最後，委派會建立靜態方法`M4`型別的`C`並輸入`F`; 每個方法都宣告的型別，做為其第一個引數，以及提供型別的執行個體，所以委派會覆蓋其第一個引數. 方法`M4`型別的`C`顯示`ID`屬性繫結的執行個體與引數。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
-或- 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
-或- 
 無法繫結 <paramref name="method" />，而且 <paramref name="throwOnBindFailure" /> 為 <see langword="true" />。  
  
-或- 
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="target">叫用 <paramref name="method" /> 的類別執行個體。</param>
        <param name="method">委派要表示的執行個體方法名稱。</param>
        <param name="ignoreCase">布林值 (Boolean)，指出是否在比較方法名稱時忽略大小寫。</param>
        <summary>建立指定類型的委派，這個委派表示要在指定的類別執行個體上，使用指定的大小寫區分來叫用的指定執行個體方法。</summary>
        <returns>指定類型的委派，表示要在指定的類別執行個體上叫用的指定執行個體方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只會建立委派執行個體方法。 執行個體方法則是類別; 的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，指定`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用方法，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，並限制為呼叫端的非公用方法的授權集是否授與集或子集效果。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="target" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
-或- 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
-或- 
 <paramref name="method" /> 不是執行個體方法。  
  
-或- 
 例如，因為找不到 <paramref name="method" />，所以無法將其繫結。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="target"><see cref="T:System.Type" />，代表可實作 <paramref name="method" /> 的類別。</param>
        <param name="method">委派要表示的靜態方法名稱。</param>
        <param name="ignoreCase">布林值 (Boolean)，指出是否在比較方法名稱時忽略大小寫。</param>
        <summary>建立指定之類型的委派，其表示指定之類別的指定靜態方法，且指定區分大小寫的方式。</summary>
        <returns>指定類型的委派，表示指定類別的指定靜態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立只有靜態方法的委派。 執行個體方法則是類別; 的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，指定`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用方法，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，並限制為呼叫端的非公用方法的授權集是否授與集或子集效果。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="target" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
-或- 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
-或- 
 <paramref name="target" /> 不是 <see langword="RuntimeType" />。  
  
-或- 
 <paramref name="target" /> 是開放式泛型類型。 亦即，其 <see cref="P:System.Type.ContainsGenericParameters" /> 屬性為 <see langword="true" />。  
  
-或- 
 <paramref name="method" /> 不是 <see langword="static" /> 方法 (Visual Basic 中的 <see langword="Shared" /> 方法)。  
  
-或- 
 例如，因為找不到 <paramref name="method" />，所以無法將其繫結。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="target">叫用 <paramref name="method" /> 的類別執行個體。</param>
        <param name="method">委派要表示的執行個體方法名稱。</param>
        <param name="ignoreCase">布林值 (Boolean)，指出是否在比較方法名稱時忽略大小寫。</param>
        <param name="throwOnBindFailure"><paramref name="method" /> 表示如果無法繫結 <see langword="true" /> 時，則擲回例外狀況；否則為 <see langword="false" />。</param>
        <summary>建立指定之類型的委派，其表示要在指定的類別執行個體上叫用的指定執行個體方法，且會指定區分大小寫的方式以及在繫結失敗時要發生的行為。</summary>
        <returns>指定類型的委派，表示要在指定的類別執行個體上叫用的指定執行個體方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只會建立委派執行個體方法。 執行個體方法則是類別; 的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用方法，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，並限制為呼叫端的非公用方法的授權集是否授與集或子集效果。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="target" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
-或- 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
-或- 
 <paramref name="method" /> 不是執行個體方法。  
  
-或- 
 無法繫結 <paramref name="method" />，例如因為找不到該方法，以及 <paramref name="throwOnBindFailure" /> 為 <see langword="true" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="target"><see cref="T:System.Type" />，代表可實作 <paramref name="method" /> 的類別。</param>
        <param name="method">委派要表示的靜態方法名稱。</param>
        <param name="ignoreCase">布林值 (Boolean)，指出是否在比較方法名稱時忽略大小寫。</param>
        <param name="throwOnBindFailure"><paramref name="method" /> 表示如果無法繫結 <see langword="true" /> 時，則擲回例外狀況；否則為 <see langword="false" />。</param>
        <summary>建立指定之類型的委派，其表示指定之類別的指定靜態方法，且會指定區分大小寫的方式以及在繫結失敗時要發生的行為。</summary>
        <returns>指定類型的委派，表示指定類別的指定靜態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立只有靜態方法的委派。 執行個體方法則是類別; 的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用方法，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，並限制為呼叫端的非公用方法的授權集是否授與集或子集效果。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="target" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
-或- 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
-或- 
 <paramref name="target" /> 不是 <see langword="RuntimeType" />。  
  
-或- 
 <paramref name="target" /> 是開放式泛型類型。 亦即，其 <see cref="P:System.Type.ContainsGenericParameters" /> 屬性為 <see langword="true" />。  
  
-或- 
 <paramref name="method" /> 不是 <see langword="static" /> 方法 (Visual Basic 中的 <see langword="Shared" /> 方法)。  
  
-或- 
 無法繫結 <paramref name="method" />，例如因為找不到該方法，以及 <paramref name="throwOnBindFailure" /> 為 <see langword="true" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">物件的陣列，這些物件是要傳遞至目前委派所表示方法的引數。  
  
-或- 
 如果目前委派所表示的方法不需要引數，則為 <see langword="null" />。</param>
        <summary>動態叫用 (晚期繫結) 目前委派所表示的方法。</summary>
        <returns>物件，由委派所表示的方法傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫 <xref:System.Delegate.DynamicInvokeImpl%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。  
  
-或- 
在 <paramref name="args" /> 中列示的參數數目、順序或型別是無效的。</exception>
        <exception cref="T:System.ArgumentException">委派所表示的方法在不支援該方法的物件或類別上被叫用。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">委派所表示的方法是執行個體方法，並且目標物件是 <see langword="null" />。  
  
-或- 
其中一個封裝的方法會擲回例外狀況。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">物件的陣列，這些物件是要傳遞至目前委派所表示方法的引數。  
  
-或- 
 如果目前委派所表示的方法不需要引數，則為 <see langword="null" />。</param>
        <summary>動態叫用 (晚期繫結) 目前委派所表示的方法。</summary>
        <returns>物件，由委派所表示的方法傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會實作 <xref:System.Delegate.DynamicInvoke%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。  
  
-或- 
在 <paramref name="args" /> 中列示的參數數目、順序或型別是無效的。</exception>
        <exception cref="T:System.ArgumentException">委派所表示的方法在不支援該方法的物件或類別上被叫用。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">委派所表示的方法是執行個體方法，並且目標物件是 <see langword="null" />。  
  
-或- 
其中一個封裝的方法會擲回例外狀況。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要與目前委派比較的物件。</param>
        <summary>判斷指定的物件和目前的委派是否具有相同類型，並共用相同的目標、方法和引動過程清單。</summary>
        <returns>如果 <paramref name="obj" /> 和目前的委派具有相同的目標、方法和引動過程清單，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果兩個委派型別相同，它們不會視為相等。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 版中，兩個委派視為相等，如果其目標、 方法和引動過程清單等於，即使委派的型別不同。  
  
 方法和目標會比較相等，如下所示：  
  
-   如果要比較的兩個方法都是靜態，而且都是相同的類別上的相同方法，方法都視為相等，並為目標也會視為相等。  
  
-   如果要比較的兩種方法是執行個體方法，而且都是相同物件上的相同方法，方法都視為相等，並為目標也會視為相等。  
  
-   否則，方法不會被視為相等，而且目標也不會視為相等。  
  
 只有具有相同的順序，而且在兩個清單的對應項目代表相同的方法和目標，則兩個引動過程清單會視為相同。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回委派的雜湊碼。</summary>
        <returns>委派的雜湊碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的傳回值必須不會保存兩個原因。 首先，類別的雜湊函式可能會改變以產生更好的分佈，呈現從舊的雜湊函式的任何值沒有什麼用處。 其次，這個類別的預設實作不保證相同的值會由不同執行個體。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回委派的引動過程清單。</summary>
        <returns>委派的陣列，表示目前委派的引動過程清單。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 陣列中的每個委派代表一個方法。  
  
 陣列中委派的順序是目前的委派叫用這些委派代表之方法的相同順序。  
  
   
  
## Examples  
 下列範例會將三個方法指派給委派。 然後它會呼叫<xref:System.Delegate.GetInvocationList%2A>方法來取得指派給委派，以相反順序中，執行委派，並執行其名稱不包含子字串的方法之方法的總計數，「 檔案 」。  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得目前委派所表示的靜態方法。</summary>
        <returns><see cref="T:System.Reflection.MethodInfo" />，描述目前委派所表示的靜態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有在目前委派所表示的靜態方法，就會適用這個方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">不支援。</param>
        <param name="context">不支援。</param>
        <summary>不支援。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">不支援這個方法。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得委派所表示的方法。</summary>
        <value><see cref="T:System.Reflection.MethodInfo" />，描述委派所表示的方法。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">要比較的第一個委派。</param>
        <param name="d2">要比較的第二個委派。</param>
        <summary>判斷指定的委派是否相等。</summary>
        <returns>如果 <see langword="true" /> 等於 <paramref name="d1" />，則為 <paramref name="d2" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具有相同的目標、 方法和引動過程清單之相同類型的兩個委派視為相等。  
  
 如果兩個委派型別相同，它們不會視為相等。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 版中，兩個委派視為相等，如果其目標、 方法和引動過程清單等於，即使委派的型別不同。  
  
 方法和目標會比較相等，如下所示：  
  
-   如果要比較的兩個方法都是靜態，而且都是相同的類別上的相同方法，方法都視為相等，並為目標也會視為相等。  
  
-   如果要比較的兩種方法是執行個體方法，而且都是相同物件上的相同方法，方法都視為相等，並為目標也會視為相等。  
  
-   否則，方法不會被視為相等，而且目標也不會視為相等。  
  
 如果具有相同的順序，並且在兩個清單的對應項目代表相同的方法和目標，則兩個引動過程清單會視為相同。  
  
 這個運算子的對等方法是 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">要比較的第一個委派。</param>
        <param name="d2">要比較的第二個委派。</param>
        <summary>判斷指定的委派是否不相等。</summary>
        <returns>如果 <see langword="true" /> 不等於 <paramref name="d1" />，則為 <paramref name="d2" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它們都是不同的類型，或有不同的方法、 不同的目標或不同的引動過程清單，即視為等於不到兩個委派。  
  
 如果兩個委派型別相同，它們不會視為相等。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 版中，兩個委派視為相等，如果其目標、 方法和引動過程清單等於，即使委派的型別不同。  
  
 方法和目標會比較相等，如下所示：  
  
-   如果要比較的兩個方法都是靜態，而且都是相同的類別上的相同方法，方法都視為相等，並為目標也會視為相等。  
  
-   如果要比較的兩種方法是執行個體方法，而且都是相同物件上的相同方法，方法都視為相等，並為目標也會視為相等。  
  
-   否則，方法不會被視為相等，而且目標也不會視為相等。  
  
 兩個引動過程清單不相等，如果它們擁有不同的大小，以不同的方式排序，或至少一個項目從一份清單表示方法或不同於其他清單中其對應項目所代表的目標。  
  
 這個運算子的對等方法是 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">委派，要從其中移除 <paramref name="value" /> 的引動過程清單。</param>
        <param name="value">委派，提供要從 <paramref name="source" /> 的引動過程清單移除的引動過程清單。</param>
        <summary>從另一個委派的引動過程清單，移除委派的引動過程清單上最後一個項目。</summary>
        <returns>如果在 <paramref name="source" /> 的引動過程清單中找到 <paramref name="value" /> 的引動過程清單，則為新委派 (其具有藉由取得 <paramref name="value" /> 的引動過程清單並移除 <paramref name="source" /> 的引動過程清單上最後一個項目所形成的引動過程清單)。 如果 <paramref name="source" /> 是 <see langword="null" />，或未在 <paramref name="value" /> 的引動過程清單中找到 <paramref name="value" /> 的引動過程清單，則會傳回 <paramref name="source" />。 如果 <paramref name="value" /> 的引動過程清單等於 <paramref name="source" /> 的引動過程清單，或是 <paramref name="source" /> 等於 null 參考，則會傳回 null 參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果引動過程清單`value`符合一組連續的引動過程清單中的項目數`source`，然後引動過程清單`value`即為發生的引動過程清單內`source`。 如果引動過程清單`value`出現在引動過程清單中的一次以上`source`，已移除的最後一個相符項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</exception>
        <exception cref="T:System.ArgumentException">委派型別不相符。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">委派，要從其中移除 <paramref name="value" /> 的引動過程清單。</param>
        <param name="value">委派，提供要從 <paramref name="source" /> 的引動過程清單移除的引動過程清單。</param>
        <summary>從另一個委派的引動過程清單，移除委派的引動過程清單上所有的項目。</summary>
        <returns>如果在 <paramref name="source" /> 的引動過程清單中找到 <paramref name="value" /> 的引動過程清單，則為新委派 (其具有藉由取得 <paramref name="value" /> 的引動過程清單並移除 <paramref name="source" /> 的引動過程清單上所有的項目所形成的引動過程清單)。 如果 <paramref name="source" /> 是 <see langword="null" />，或未在 <paramref name="value" /> 的引動過程清單中找到 <paramref name="value" /> 的引動過程清單，則會傳回 <paramref name="source" />。 如果 <paramref name="value" /> 的引動過程清單等於 <paramref name="source" /> 的引動過程清單、<paramref name="source" /> 只包含等於 <paramref name="value" /> 引動過程清單的一系列引動過程清單，或是 <paramref name="source" /> 為 null 參考時，會傳回 null 參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果引動過程清單`value`符合一組連續的引動過程清單中的項目數`source`，然後引動過程清單`value`即為發生的引動過程清單內`source`。 如果引動過程清單`value`出現在引動過程清單中的一次以上`source`，會移除所有項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</exception>
        <exception cref="T:System.ArgumentException">委派型別不相符。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">委派，提供要從目前委派的引動過程清單移除的引動過程清單。</param>
        <summary>從另一個委派的引動過程清單移除委派的引動過程清單。</summary>
        <returns>如果在目前委派的引動過程清單中找到 <paramref name="value" /> 的引動過程清單，則為新委派 (其具有藉由取得目前委派的引動過程清單並移除 <paramref name="value" /> 的引動過程清單所形成的引動過程清單)。 如果 <paramref name="value" /> 是 <see langword="null" />，或未在目前委派的引動過程清單中找到 <paramref name="value" /> 的引動過程清單時，會傳回目前的委派。 如果 <paramref name="value" /> 的引動過程清單等於目前委派的引動過程清單，則會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果引動過程清單`value`符合一組連續的項目在目前委派的引動過程清單，則引動過程清單`value`說是出現在目前委派的引動過程清單。 如果引動過程清單`value`，就會發生一次在目前委派的引動過程清單中，已移除的最後一個相符項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前的委派在其中叫用執行個體方法的類別執行個體。</summary>
        <value>如果目前的委派表示執行個體方法時，則為目前委派用來叫用執行個體方法的物件；如果此委派表示靜態方法，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行個體方法則是類別; 的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 如果委派叫用一或多個執行個體方法，這個屬性會傳回目標的最後一個執行個體方法的引動過程清單中。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>