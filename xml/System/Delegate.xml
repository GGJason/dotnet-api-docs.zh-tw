<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3f0536eac77f3171e3a7eeb74486cfcf863ec3d8" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731652" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示委派，它是參考靜態方法或該類別的類別執行個體和執行個體方法 (Instance Method) 的資料結構。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate>類別是委派類型的基底類別。 不過，只有系統和編譯器可以明確地從衍生<xref:System.Delegate>類別或從<xref:System.MulticastDelegate>類別。 它也是不允許從委派型別衍生新的類型。 <xref:System.Delegate>類別不是委派類型，則可以用來衍生委派類型的類別。  
  
 大部分語言實作`delegate`關鍵字，與這些語言的編譯器可衍生自<xref:System.MulticastDelegate>類別; 因此，使用者應該使用`delegate`語言所提供的關鍵字。  
  
> [!NOTE]
>  Common language runtime 提供`Invoke`每種委派類型，相同的簽章與委派的方法。 您不需要明確地呼叫這個方法從 C#、 Visual Basic 或 Visual c + + 中，因為編譯器會自動呼叫。 `Invoke`方法中很有用[反映](~/docs/framework/reflection-and-codedom/reflection.md)當您想要尋找的委派類型簽章。  
  
 Common language runtime 提供的每個委派型別`BeginInvoke`和`EndInvoke`方法，以啟用委派的非同步引動過程。 如需有關這些方法的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
 委派類型的宣告會建立指定的一個或多個方法的簽章的合約。 委派是具有參考委派類型的執行個體：  
  
-   類型和目標物件指派給該類型的執行個體方法。  
  
-   類型，並隱藏執行個體方法`this`公開型式參數清單中的參數。 委派是要開啟執行個體委派。  
  
-   靜態方法。  
  
-   靜態方法，而且指派給該方法的第一個參數的目標物件。 此委派會在其第一個引數上關閉。  
  
 如需委派繫結的詳細資訊，請參閱<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，委派可以表示方法，只有當方法的簽章完全相符的委派型別指定的簽章。 因此，只有第一個和第三個項目符號前述清單中的都有支援，而且第一個項目符號需要型別完全符合。  
  
 委派表示關閉其第一個引數 （最常見的情況） 上的執行個體方法，委派會儲存方法的進入點的參考和參考的物件，稱為目標，是指派給類型定義的型別方法。 當委派表示的開啟執行個體方法時，它會儲存方法的進入點的參考。 委派簽章必須包含隱藏`this`其型式參數清單中的參數; 在此情況下，委派沒有目標物件的參考，而且叫用委派時，必須提供目標物件。  
  
 當委派表示的靜態方法時，委派會儲存方法的進入點的參考。 委派表示關閉其第一個引數上的靜態方法，委派會儲存方法的進入點的參考，以及指派給方法的第一個引數類型的目標物件的參考。 叫用委派時，第一個引數的靜態方法會接收目標物件。  
  
 委派的引動過程清單是在其中清單的每個項目叫用一個委派所表示之方法的委派的已排序的集合。 引動過程清單可以包含重複的方法。 在引動過程，方法會叫用引動過程清單中的出現的順序。 委派會嘗試叫用每個方法，在其引動過程清單。重複的項目會叫用之後每次它們出現在引動過程清單。 委派是不可變的;一旦建立之後，就不會變更委派的引動過程清單。  
  
 委派會參照多點傳送，或可組合的類別，因為委派可以叫用一或多個方法，可用於合併作業。  
  
 合併作業，例如<xref:System.Delegate.Combine%2A>和<xref:System.Delegate.Remove%2A>，不會改變現有的委派。 相反地，這類作業會傳回新的委派，其中包含變更的委派，作業的結果或`null`。 合併作業會傳回`null`運算的結果時不會參考至少一個方法的委派。 合併作業會傳回未變更的委派，當要求的作業沒有任何作用。  
  
> [!NOTE]
>  Managed 語言使用<xref:System.Delegate.Combine%2A>和<xref:System.Delegate.Remove%2A>實作委派作業的方法。 範例包括`AddHandler`和`RemoveHandler`在 Visual Basic 中的陳述式和 + = 和-= 運算子委派 C# 中的型別。  
  
 從開始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，泛型委派類型可以有 variant 型別參數。 Contravariant 型別參數可以用做為委派的參數類型與 covariant 類型參數可用來當做傳回型別。 此功能可讓泛型委派類型都從相同泛型類型定義中所述，是指派相容如果其類型引數是參考類型，具有繼承關係，建構[共變數和反變數](~/docs/standard/generics/covariance-and-contravariance.md)。  
  
> [!NOTE]
>  泛型委派指派相容，因為差異不一定可組合的類別。 若要可組合的類別，類型必須完全相符。 例如，假設 具名的類別`Derived`衍生自類別，名為`Base`。 類型的委派`Action<Base>`(`Action(Of Base)`在 Visual Basic 中) 可以指派給類型的變數`Action<Derived>`，但無法結合兩個委派，因為類型不完全相符。  
  
 如果叫用的方法擲回例外狀況，則方法會停止執行、 的委派，呼叫端傳遞的例外狀況和引動過程清單中的剩餘方法不會叫用。 在呼叫端攔截例外狀況不會改變此行為。  
  
 當透過委派叫用的方法簽章包含傳回值時，委派會傳回引動過程清單最後一個元素的傳回值。 當簽章包含傳址方式傳遞的參數時，最後一個參數的值會是每個方法引動過程清單，依序執行，並更新參數的值中的結果。  
  
 最接近的委派，在 C 或 c + + 中相當函式指標。 委派可以表示的靜態方法或執行個體方法。 委派表示的執行個體方法，委派會儲存參考方法的進入點，不僅類別執行個體的參考。 不同之處在於，委派是物件導向，而且型別安全。  
  
   
  
## Examples  
 下列範例示範如何定義名為委派`myMethodDelegate`。 此委派的執行個體的執行個體方法的巢狀的靜態方法會針對建立`mySampleClass`類別。 執行個體方法的委派需要的執行個體`mySampleClass`。 `mySampleClass`執行個體儲存在名為的變數`mySC`。  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化新的委派。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">委派叫用 <c>method</c> 所在的類別執行個體。</param>
        <param name="method">委派表示的執行個體方法名稱。</param>
        <summary>初始化委派，這個委派會在指定的類別執行個體上叫用指定的執行個體方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式不能在應用程式程式碼。 若要建立委派，藉由指定的執行個體方法名稱，使用的多載<xref:System.Delegate.CreateDelegate%2A>指定方法名稱和目標物件的方法。 例如，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29>方法多載會建立具有指定名稱的執行個體方法的委派。  
  
 這個建構函式只會建立委派執行個體方法。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">繫結至目標方法時發生錯誤。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Type" />，表示定義 <c>method</c> 的類別。</param>
        <param name="method">委派表示的靜態方法名稱。</param>
        <summary>初始化委派，這個委派會從指定的類別叫用指定的靜態方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式不能在應用程式程式碼。 若要建立委派，藉由指定的靜態方法名稱，使用的多載<xref:System.Delegate.CreateDelegate%2A>指定方法名稱，但未指定目標物件的方法。 例如，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29>方法多載會建立具有指定名稱的靜態方法的委派。  
  
 這個建構函式會建立只使用靜態方法的委派。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
 -或-  
  
 <paramref name="target" /> 代表開放式泛型類型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立委派的淺層複本 (Shallow Copy)。</summary>
        <returns>委派的淺層複本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 複製品具有相同的<xref:System.Type>，與原始的委派目標、 方法和引動過程清單。  
  
 淺層複本建立的原始物件，與相同類型的新執行個體，然後複製原始物件的非靜態欄位。 如果欄位是實值類型，則會執行位元欄位的複本。 如果欄位是參考類型，則會複製參考，但參考的物件不;因此，原始物件的參考和複製品中的參考點相同的物件。 相較之下，物件的深層複本複製直接或間接參考之物件中欄位的所有項目。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>串連指定多點傳送 (可結合的) 委派的引動過程清單。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">要結合的委派陣列。</param>
        <summary>串連委派陣列的引動過程清單。</summary>
        <returns>具有引動過程清單的新委派，此清單可串連 <paramref name="delegates" /> 陣列中委派的引動過程清單。 如果 <paramref name="delegates" /> 是 <see langword="null" />、<paramref name="delegates" /> 包含零個元素，或者 <paramref name="delegates" /> 中的每個項目都是 <see langword="null" />，則會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`delegates`陣列包含的項目`null`，這些項目會被忽略。  
  
 引動過程清單可以包含重複的項目。也就是指相同的方法，在相同物件上的項目。  
  
> [!NOTE]
>  泛型委派指派相容，因為差異不一定可組合的類別。 若要可組合的類別，類型必須完全相符。 例如，假設 具名的類別`Derived`衍生自類別，名為`Base`。 類型的委派`Action<Base>`(`Action(Of Base)`在 Visual Basic 中) 可以指派給類型的變數`Action<Derived>`，如下所述[共變數和反變數](~/docs/standard/generics/covariance-and-contravariance.md)，而無法合併兩個委派，因為型別不完全符合。  
  
 <xref:System.Delegate.Combine%2A> 可用於建立多個方法時間事件的呼叫，就會發生的事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegates" /> 中的所有非 Null 元素並非都是相同委派型別的執行個體。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">引動過程清單首先到達的委派。</param>
        <param name="b">引動過程清單最後到達的委派。</param>
        <summary>串連兩個委派的引動過程清單。</summary>
        <returns>具有引動過程清單的新委派，這個清單可以該順序串連 <paramref name="a" /> 和 <paramref name="b" /> 的引動過程清單。 如果 <paramref name="b" /> 為 <see langword="null" />，則會傳回 <paramref name="a" />；如果 <paramref name="a" /> 為 Null 參考，則會傳回 <paramref name="b" />；如果 <paramref name="a" /> 和 <paramref name="b" /> 兩者都是 Null 參考，則會傳回 Null 參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引動過程清單可以包含重複的項目。也就是指相同的方法，在相同物件上的項目。  
  
> [!NOTE]
>  泛型委派指派相容，因為差異不一定可組合的類別。 若要可組合的類別，類型必須完全相符。 例如，假設 具名的類別`Derived`衍生自類別，名為`Base`。 類型的委派`Action<Base>`(`Action(Of Base)`在 Visual Basic 中) 可以指派給類型的變數`Action<Derived>`，如下所述[共變數和反變數](~/docs/standard/generics/covariance-and-contravariance.md)，而無法合併兩個委派，因為型別不完全符合。  
  
 <xref:System.Delegate.Combine%2A> 可用於建立多個方法時間事件的呼叫，就會發生的事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="a" /> 和 <paramref name="b" /> 都不是 <see langword="null" />，而且 <paramref name="a" /> 和 <paramref name="b" /> 不是相同委派類型的執行個體。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">多點傳送 (可結合的) 委派，其引動過程清單要附加到目前多點傳送 (可結合的) 委派的引動過程清單末端。</param>
        <summary>串連指定的多點傳送 (可結合的) 委派和目前多點傳送 (可結合的) 委派的引動過程清單。</summary>
        <returns>具有引動過程清單的新多點傳送 (可結合式) 委派，此清單可串連目前多點傳送 (可結合式) 委派的引動過程清單和 <paramref name="d" /> 的引動過程清單之委派；而在 <paramref name="d" /> 為 <see langword="null" /> 時，則為目前多點傳送 (可結合式) 委派。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法僅適用於目前的委派是多點傳送 （可結合的）。  
  
 目前的實作只會擲回<xref:System.MulticastNotSupportedException>。  
  
 引動過程清單可以包含重複的項目。也就是指相同的方法，在相同物件上的項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">一律擲回。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立指定類型的委派。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" />，描述委派所要表示的靜態或執行個體方法。 在 .NET Framework 1.0 和 1.1 版中只支援靜態方法。</param>
        <summary>建立指定類型的委派來表示指定的靜態方法。</summary>
        <returns>指定類型的委派，用來表示指定的靜態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 1.0 和 1.1 版中，這個方法多載會建立只使用靜態方法的委派。 在.NET Framework 2.0 版中，這個方法多載也可以建立開啟執行個體方法的委派。也就是明確地提供隱藏第一個引數的委派執行個體方法。 詳細的說明，請參閱更多一般<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>方法多載，可讓您建立所有組合的開放式或封閉式委派執行個體或靜態方法，並選擇性地指定第一個引數。  
  
> [!NOTE]
>  這個方法多載應該時使用委派未關閉透過其第一個引數，因為它在該情況下是稍快。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載，並指定`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>相容的參數型別和傳回型別  
 在.NET Framework 2.0 版中，參數型別和使用這個方法多載來建立委派的傳回型別必須是相容的參數類型和傳回型別方法委派所表示。型別沒有完全相符。 這代表放寬的.NET Framework 1.0 和 1.1 中，類型必須完全相符的版本中的繫結行為。  
  
 如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。  
  
 同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。  
  
 例如，類型參數的委派<xref:System.Collections.Hashtable>和傳回型別<xref:System.Object>可以代表具有型別參數的方法<xref:System.Object>和傳回值的型別<xref:System.Collections.Hashtable>。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例示範兩種可以使用這個方法多載來建立的委派： 透過執行個體方法開啟，並開啟透過靜態方法。  
  
 第二個程式碼範例會示範相容的參數型別和傳回型別。  
  
 **範例 1**  
  
 下列程式碼範例示範兩種方式可使用的這個多載來建立委派<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>方法指定<xref:System.Reflection.MethodInfo>，而不是第一次的引數; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。 這個程式碼範例會使用這兩個多載。  
  
 此範例會宣告類別`C`的靜態方法`M2`和執行個體方法`M1`，以及兩個委派型別：`D1`可接受的執行個體`C`和字串，並`D2`接受字串。  
  
 名為第二個類別`Example`包含建立委派的程式碼。  
  
-   類型的委派`D1`，表示開啟的執行個體方法，建立執行個體方法`M1`。 當叫用委派時，必須傳遞執行個體。  
  
-   類型的委派`D2`，代表開放式的靜態方法，建立靜態方法`M2`。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **範例 2**  
  
 下列程式碼範例示範的參數類型相容性和傳回型別。  
  
 程式碼範例定義名為基底類別`Base`和類別，名為`Derived`衍生自`Base`。 在衍生的類別具有`static`(`Shared`在 Visual Basic 中) 方法名為`MyMethod`具有型別的一個參數`Base`和傳回型別`Derived`。 程式碼範例也會定義名為委派`Example`具有型別的一個參數`Derived`和傳回型別`Base`。  
  
 程式碼範例將示範委派名為`Example`可以用來表示方法`MyMethod`。 方法可以繫結至委派，因為：  
  
-   委派的參數型別 (`Derived`) 是更具限制性的參數型別`MyMethod`(`Base`)，因此一律會安全地傳遞至委派的引數、 `MyMethod`。  
  
-   傳回型別`MyMethod`(`Derived`) 是更具限制性的委派的參數類型 (`Base`)，如此可永遠放心轉型為委派的傳回型別方法的傳回型別。  
  
 程式碼範例會產生任何輸出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
 -或-  
  
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
 -或-  
  
 <paramref name="method" /> 不是靜態方法，而 .NET Framework 版本為 1.0 或 1.1。  
  
 -或-  
  
 無法繫結 <paramref name="method" />。  
  
 -或-  
  
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="firstArgument">此委派要繫結的物件，或是 <see langword="null" />，表示將 <c>method</c> 視為 <see langword="static" /> (Visual Basic 中則為 <see langword="Shared" />)。</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" />，描述委派所要表示的靜態或執行個體方法。</param>
        <summary>建立指定之類型的委派，其表示指定之靜態或執行個體方法，並有指定第一個引數。</summary>
        <returns>指定之類型的委派，其表示指定的靜態或執行個體方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載，並指定`true`如`throwOnBindFailure`。 這些兩個多載提供最具彈性的方式來建立委派。 您可以使用它們來建立委派靜態或執行個體方法，並選擇性地指定第一個引數。  
  
> [!NOTE]
>  如果您未提供第一個引數，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載，以提升效能。  
  
 委派型別和方法必須具有相容的傳回類型。 也就是傳回型別`method`必須可以指派給的傳回型別`type`。  
  
 如果`firstArgument`是提供，它會傳遞至`method`每次叫用委派。`firstArgument`稱為繫結至委派，並委派會在其第一個引數上關閉。 如果`method`是`static`(`Shared`在 Visual Basic 中)，則引數叫用委派時所提供的清單包含第一個; 以外的所有參數，如果`method`是執行個體方法，則`firstArgument`傳遞到隱藏的執行個體參數 (由`this`在 C# 中，或由`Me`在 Visual Basic 中)。  
  
 如果`firstArgument`提供的第一個參數`method`必須是參考類型，和`firstArgument`必須相容於該型別。  
  
> [!IMPORTANT]
>  如果`method`是`static`(`Shared`在 Visual Basic 中) 和其第一個參數的類型是<xref:System.Object>或<xref:System.ValueType>，然後`firstArgument`可以是實值類型。 在此情況下`firstArgument`會自動進行 boxed 處理。 自動 boxing 不會發生的任何其他引數，因為它會以 C# 或 Visual Basic 函式呼叫。  
  
 如果`firstArgument`為 null 參考和`method`是執行個體方法，結果會隨著的委派類型簽章`type`和`method`:  
  
-   如果簽章`type`明確包含隱藏第一個參數`method`，此委派來表示開啟的執行個體方法。 引數清單中的第一個引數叫用委派時，會傳遞到隱藏的執行個體參數的`method`。  
  
-   如果簽章`method`和`type`比對 （也就是所有的參數型別都相容），則此委派會在 null 參考上關閉。 叫用委派就像不是特別有用的做法的 null 執行個體上呼叫執行個體方法。  
  
 如果`firstArgument`為 null 參考和`method`是靜態的結果會隨著的委派類型簽章`type`和`method`:  
  
-   如果簽章`method`和`type`比對 （也就是所有的參數型別都相容），此委派來表示開啟的靜態方法。 這是靜態方法的最常見的情況。 在此情況下，您可以取得稍微提升效能，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載。  
  
-   如果簽章`type`開頭的第二個參數`method`，而且其餘的參數類型相容，則此委派會在 null 參考上關閉。 叫用委派時，第一個參數來傳遞 null 參考`method`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>相容的參數型別和傳回型別  
 參數類型和委派的傳回型別必須是相容的參數類型和傳回型別方法委派所表示。型別沒有完全相符。  
  
> [!NOTE]
>  在.NET Framework 1.0 和 1.1 版中，類型必須完全相符。  
  
 如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。  
  
 同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。  
  
 例如，類型參數的委派<xref:System.Collections.Hashtable>和傳回型別<xref:System.Object>可以代表具有型別參數的方法<xref:System.Object>和傳回值的型別<xref:System.Collections.Hashtable>。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>判斷方法的委派可以表示  
 另一個有用的方式來想到的這個多載所提供的彈性<xref:System.Delegate.CreateDelegate%2A>是任何指定的委派可以代表四個不同的方法簽章與方法類型 （靜態和執行個體） 的組合。 委派類型，請考慮`D`具有單一引數的型別`C`。 下列程式碼說明方法`D`可表示，因為它必須符合在所有情況下忽略的傳回型別：  
  
-   `D` 可以表示有一個引數類型的任何執行個體方法`C`，不論執行個體方法屬於何種類型。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`類型的執行個體`method`屬於，並將產生的委派會在該執行個體上關閉。 (兩者，`D`也可以關閉透過 null 參考如果`firstArgument`為 null 參考。)  
  
-   `D` 可以表示的執行個體方法`C`，沒有任何引數。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`為 null 參考。 產生的委派表示開啟的執行個體方法和執行個體`C`必須提供每次叫用時。  
  
-   `D` 可以代表採用一個引數類型的靜態方法`C`，而且方法可以屬於任何類型。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`為 null 參考。 產生的委派表示開啟的靜態方法和執行個體`C`必須提供每次叫用時。  
  
-   `D` 可以表示的靜態方法屬於型別`F`且具有兩個類型引數，`F`和型別`C`。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`的執行個體`F`。 產生的委派表示關閉該執行個體上的靜態方法`F`。 請注意，在案例其中`F`和`C`都是相同的型別、 靜態方法會具有該類型的兩個引數。 (在此情況下，`D`如果 null 參考透過關閉`firstArgument`為 null 參考。)  
  
   
  
## Examples  
 本節包含三個程式碼範例。 第一個範例將示範委派可建立四種： 關閉透過執行個體方法，透過執行個體方法開啟的靜態方法，透過開啟和關閉透過靜態方法。  
  
 第二個程式碼範例會示範相容的參數型別和傳回型別。  
  
 第三個程式碼範例會定義單一委派類型，並顯示可以表示所有委派類型的方法。  
  
 **範例 1**  
  
 下列程式碼範例示範您可以使用的這個多載建立委派的四種方式<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>方法指定`firstArgument`和<xref:System.Reflection.MethodInfo>; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。 這個程式碼範例會使用這兩個多載。  
  
 此範例會宣告類別`C`的靜態方法`M2`和執行個體方法`M1`，以及三個委派型別：`D1`可接受的執行個體`C`和字串，`D2`採用字串和`D3`沒有引數。  
  
 名為第二個類別`Example`包含建立委派的程式碼。  
  
-   類型的委派`D2`、 執行個體上關閉`C`，建立執行個體方法`M1`。 使用不同的字串，顯示的繫結的執行個體叫用`C`一律使用。  
  
-   類型的委派`D1`，表示開啟的執行個體方法，建立執行個體方法`M1`。 當叫用委派時，必須傳遞執行個體。  
  
-   類型的委派`D2`，代表開放式的靜態方法，建立靜態方法`M2`。  
  
-   最後，類型的委派`D3`字串上為封閉式，建立靜態方法`M2`。 方法會叫用來顯示它所使用的繫結的字串。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **範例 2**  
  
 下列程式碼範例示範的參數類型相容性和傳回型別。  
  
> [!NOTE]
>  這個程式碼範例會使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載。 使用其他多載會採用<xref:System.Reflection.MethodInfo>類似。  
  
 程式碼範例定義名為基底類別`Base`和類別，名為`Derived`衍生自`Base`。 在衍生的類別具有`static`(`Shared`在 Visual Basic 中) 方法名為`MyMethod`具有型別的一個參數`Base`和傳回型別`Derived`。 程式碼範例也會定義名為委派`Example`具有型別的一個參數`Derived`和傳回型別`Base`。  
  
 程式碼範例將示範委派名為`Example`可以用來表示方法`MyMethod`。 方法可以繫結至委派，因為：  
  
-   委派的參數型別 (`Derived`) 是更具限制性的參數型別`MyMethod`(`Base`)，因此一律會安全地傳遞至委派的引數、 `MyMethod`。  
  
-   傳回型別`MyMethod`(`Derived`) 是更具限制性的委派的參數類型 (`Base`)，如此可永遠放心轉型為委派的傳回型別方法的傳回型別。  
  
 程式碼範例會產生任何輸出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **範例 3**  
  
 下列程式碼範例顯示所有的方法可表示的單一委派類型，使用<xref:System.Delegate.CreateDelegate%2A>方法來建立委派。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>方法指定`firstArgument`和<xref:System.Reflection.MethodInfo>; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。 這個程式碼範例會使用這兩個多載。  
  
 程式碼範例定義兩個類別：`C`和`F`，和委派類型`D`具有單一引數的型別`C`。 類別有相符的靜態和執行個體方法`M1`， `M3`，和`M4`，和類別`C`也有執行個體方法`M2`，沒有任何引數。  
  
 名為第三個類別`Example`包含建立委派的程式碼。  
  
-   建立委派執行個體方法`M1`型別的`C`和型別`F`; 每個個別的型別執行個體上已關閉。 方法`M1`型別的`C`顯示`ID`繫結的執行個體與引數的屬性。  
  
-   建立委派方法`M2`型別的`C`。 這是開啟的執行個體的委派，其中委派的引數代表的執行個體方法上的隱藏第一個引數。 此方法沒有任何其他引數。 如同一般的靜態方法呼叫它。  
  
-   針對靜態方法建立委派`M3`型別的`C`和型別`F`; 這些是開啟的靜態委派。  
  
-   靜態方法建立委派的最後，`M4`型別的`C`和型別`F`; 每個方法都宣告的型別做為其第一個引數，並提供類型的執行個體，因此委派會關閉對其第一個引數. 方法`M4`型別的`C`顯示`ID`繫結的執行個體與引數的屬性。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
 -或-  
  
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
 -或-  
  
 無法繫結 <paramref name="method" />。  
  
 -或-  
  
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="target">叫用 <c>method</c> 的類別執行個體。</param>
        <param name="method">委派要表示的執行個體方法名稱。</param>
        <summary>建立指定類型的委派，這個委派表示要在指定的類別執行個體上叫用的指定執行個體方法。</summary>
        <returns>指定類型的委派，表示要在指定的類別執行個體上叫用的指定執行個體方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只會建立委派執行個體方法。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，指定`false`如`ignoreCase`和`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="target" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
 -或-  
  
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
 -或-  
  
 <paramref name="method" /> 不是執行個體方法。  
  
 -或-  
  
 例如，因為找不到 <paramref name="method" />，所以無法將其繫結。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" />，描述委派所要表示的靜態或執行個體方法。</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> 表示如果無法繫結 <c>method</c> 則擲回例外狀況，否則為 <see langword="false" />。</param>
        <summary>建立指定之類型的委派，用來表示指定之靜態方法，並包含在繫結失敗時發生的指定之行為。</summary>
        <returns>指定類型的委派，用來表示指定的靜態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載可以建立開啟的靜態方法的委派，開啟執行個體方法的委派，也就是公開的隱藏第一個引數的委派執行個體方法。 詳細的說明，請參閱更多一般<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載，可讓您建立所有的組合，開放式或封閉式的委派的執行個體或靜態方法。  
  
> [!NOTE]
>  這個方法多載應該時使用委派未關閉透過其第一個引數，因為它在該情況下是稍快。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>相容的參數型別和傳回型別  
 參數類型和委派的傳回型別必須是相容的參數類型和傳回型別方法委派所表示。型別沒有完全相符。  
  
> [!NOTE]
>  在.NET Framework 1.0 和 1.1 版中，類型必須完全相符。  
  
 如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。  
  
 同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。  
  
 例如，類型參數的委派<xref:System.Collections.Hashtable>和傳回型別<xref:System.Object>可以代表具有型別參數的方法<xref:System.Object>和傳回值的型別<xref:System.Collections.Hashtable>。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例示範兩種可以使用這個方法多載來建立的委派： 透過執行個體方法開啟，並開啟透過靜態方法。  
  
 第二個程式碼範例會示範相容的參數型別和傳回型別。  
  
 **範例 1**  
  
 下列程式碼範例示範兩種方式可使用的這個多載來建立委派<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>方法指定<xref:System.Reflection.MethodInfo>，而不是第一次的引數; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。 這個程式碼範例會使用這兩個多載。  
  
 此範例會宣告類別`C`的靜態方法`M2`和執行個體方法`M1`，以及兩個委派型別：`D1`可接受的執行個體`C`和字串，並`D2`接受字串。  
  
 名為第二個類別`Example`包含建立委派的程式碼。  
  
-   類型的委派`D1`，表示開啟的執行個體方法，建立執行個體方法`M1`。 當叫用委派時，必須傳遞執行個體。  
  
-   類型的委派`D2`，代表開放式的靜態方法，建立靜態方法`M2`。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **範例 2**  
  
 下列程式碼範例示範的參數類型相容性和傳回型別。  
  
> [!NOTE]
>  這個程式碼範例會使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載。 使用其他多載會採用<xref:System.Reflection.MethodInfo>類似。  
  
 程式碼範例定義名為基底類別`Base`和類別，名為`Derived`衍生自`Base`。 在衍生的類別具有`static`(`Shared`在 Visual Basic 中) 方法名為`MyMethod`具有型別的一個參數`Base`和傳回型別`Derived`。 程式碼範例也會定義名為委派`Example`具有型別的一個參數`Derived`和傳回型別`Base`。  
  
 程式碼範例將示範委派名為`Example`可以用來表示方法`MyMethod`。 方法可以繫結至委派，因為：  
  
-   委派的參數型別 (`Derived`) 是更具限制性的參數型別`MyMethod`(`Base`)，因此一律會安全地傳遞至委派的引數、 `MyMethod`。  
  
-   傳回型別`MyMethod`(`Derived`) 是更具限制性的委派的參數類型 (`Base`)，如此可永遠放心轉型為委派的傳回型別方法的傳回型別。  
  
 程式碼範例會產生任何輸出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
 -或-  
  
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
 -或-  
  
 無法繫結 <paramref name="method" />，而且 <paramref name="throwOnBindFailure" /> 為 <see langword="true" />。  
  
 -或-  
  
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="target">
          <see cref="T:System.Type" />，代表可實作 <c>method</c> 的類別。</param>
        <param name="method">委派要表示的靜態方法名稱。</param>
        <summary>建立指定類型的委派，這個委派表示指定類別的指定靜態方法。</summary>
        <returns>指定類型的委派，表示指定類別的指定靜態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立只使用靜態方法的委派。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，指定`false`如`ignoreCase`和`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="target" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
 -或-  
  
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
 -或-  
  
 <paramref name="target" /> 不是 <see langword="RuntimeType" />。  
  
 -或-  
  
 <paramref name="target" /> 是開放式泛型類型。 亦即，其 <see cref="P:System.Type.ContainsGenericParameters" /> 屬性為 <see langword="true" />。  
  
 -或-  
  
 <paramref name="method" /> 不是 <see langword="static" /> 方法 (Visual Basic 中的 <see langword="Shared" /> 方法)。  
  
 -或-  
  
 無法繫結 <paramref name="method" />，例如因為找不到該方法，以及 <paramref name="throwOnBindFailure" /> 為 <see langword="true" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" />，表示要建立的委派之類型。</param>
        <param name="firstArgument">
          <see cref="T:System.Object" />，委派所表示的方法之第一個引數。 對於執行個體方法而言，它必須與執行個體類型相容。</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" />，描述委派所要表示的靜態或執行個體方法。</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> 表示如果無法繫結 <c>method</c> 則擲回例外狀況，否則為 <see langword="false" />。</param>
        <summary>建立指定之類型的委派，其表示指定之靜態或執行個體方法，並有指定第一個引數以及繫結失敗時所發生的行為。</summary>
        <returns>指定之類型的委派，表示指定之靜態或執行個體方法；如果 <paramref name="throwOnBindFailure" /> 為 <see langword="false" />，且委派無法繫結至 <paramref name="method" />，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載而<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>方法多載，一律擲回繫結失敗時發生，提供最具彈性的方式來建立委派。 您可以使用它們來建立委派靜態或執行個體方法，不論第一個引數。  
  
> [!NOTE]
>  如果您未提供第一個引數，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載，以提升效能。  
  
 委派型別和方法必須具有相容的傳回類型。 也就是傳回型別`method`必須可以指派給的傳回型別`type`。  
  
 如果`firstArgument`是提供，它會傳遞至`method`每次叫用委派。`firstArgument`稱為繫結至委派，並委派會在其第一個引數上關閉。 如果`method`是`static`(`Shared`在 Visual Basic 中)，則引數叫用委派時所提供的清單包含第一個; 以外的所有參數，如果`method`是執行個體方法，則`firstArgument`傳遞到隱藏的執行個體參數 (由`this`在 C# 中，或由`Me`在 Visual Basic 中)。  
  
 如果`firstArgument`提供的第一個參數`method`必須是參考類型，和`firstArgument`必須相容於該型別。  
  
> [!IMPORTANT]
>  如果`method`是`static`(`Shared`在 Visual Basic 中) 和其第一個參數的類型是<xref:System.Object>或<xref:System.ValueType>，然後`firstArgument`可以是實值類型。 在此情況下`firstArgument`會自動進行 boxed 處理。 自動 boxing 不會發生的任何其他引數，因為它會以 C# 或 Visual Basic 函式呼叫。  
  
 如果`firstArgument`為 null 參考和`method`是執行個體方法，結果會隨著的委派類型簽章`type`和`method`:  
  
-   如果簽章`type`明確包含隱藏第一個參數`method`，此委派來表示開啟的執行個體方法。 引數清單中的第一個引數叫用委派時，會傳遞到隱藏的執行個體參數的`method`。  
  
-   如果簽章`method`和`type`比對 （也就是所有的參數型別都相容），則此委派會在 null 參考上關閉。 叫用委派就像不是特別有用的做法的 null 執行個體上呼叫執行個體方法。  
  
 如果`firstArgument`為 null 參考和`method`是靜態的結果會隨著的委派類型簽章`type`和`method`:  
  
-   如果簽章`method`和`type`比對 （也就是所有的參數型別都相容），此委派來表示開啟的靜態方法。 這是靜態方法的最常見的情況。 在此情況下，您可以取得稍微提升效能，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法多載。  
  
-   如果簽章`type`開頭的第二個參數`method`，而且其餘的參數類型相容，則此委派會在 null 參考上關閉。 叫用委派時，第一個參數來傳遞 null 參考`method`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>相容的參數型別和傳回型別  
 參數類型和委派的傳回型別必須是相容的參數類型和傳回型別方法委派所表示。型別沒有完全相符。  
  
> [!NOTE]
>  .NET Framework 1.0 和 1.1 版中的類型必須完全相符。  
  
 如果委派參數的型別比方法參數的型別更嚴格，則委派的參數與對應的方法參數相容，因為這樣可保證傳遞給委派的引數能夠安全地傳遞給方法。  
  
 同樣的，如果方法的傳回型別比委派的傳回型別更具限制性，由於此保證方法傳回的值會安全地轉換為委派的傳回型別，委派的傳回型別就會相容於方法的傳回型別。  
  
 例如，類型參數的委派<xref:System.Collections.Hashtable>和傳回型別<xref:System.Object>可以代表具有型別參數的方法<xref:System.Object>和傳回值的型別<xref:System.Collections.Hashtable>。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>判斷方法的委派可以表示  
 另一個有用的方式來想到的這個多載所提供的彈性<xref:System.Delegate.CreateDelegate%2A>是任何指定的委派可以代表四個不同的方法簽章與方法類型 （靜態和執行個體） 的組合。 委派類型，請考慮`D`具有單一引數的型別`C`。 下列程式碼說明方法`D`可表示，因為它必須符合在所有情況下忽略的傳回型別：  
  
-   `D` 可以表示有一個引數類型的任何執行個體方法`C`，不論執行個體方法屬於何種類型。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`類型的執行個體`method`屬於，並將產生的委派會在該執行個體上關閉。 (兩者，`D`也可以關閉透過 null 參考如果`firstArgument`是`null`。)  
  
-   `D` 可以表示的執行個體方法`C`，沒有任何引數。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`為 null 參考。 產生的委派表示開啟的執行個體方法和執行個體`C`必須提供每次叫用時。  
  
-   `D` 可以代表採用一個引數類型的靜態方法`C`，而且方法可以屬於任何類型。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`為 null 參考。 產生的委派表示開啟的靜態方法和執行個體`C`必須提供每次叫用時。  
  
-   `D` 可以表示的靜態方法屬於型別`F`且具有兩個類型引數，`F`和型別`C`。 當<xref:System.Delegate.CreateDelegate%2A>呼叫時，`firstArgument`的執行個體`F`。 產生的委派表示關閉該執行個體上的靜態方法`F`。 請注意，在案例其中`F`和`C`都是相同的型別、 靜態方法會具有該類型的兩個引數。 (在此情況下，`D`如果 null 參考透過關閉`firstArgument`是`null`。)  
  
   
  
## Examples  
 本節包含三個程式碼範例。 第一個範例將示範委派可建立四種： 關閉透過執行個體方法，透過執行個體方法開啟的靜態方法，透過開啟和關閉透過靜態方法。  
  
 第二個程式碼範例會示範相容的參數型別和傳回型別。  
  
 第三個程式碼範例會定義單一委派類型，並顯示可以表示所有委派類型的方法。  
  
 **範例 1**  
  
 下列程式碼範例示範您可以使用的這個多載建立委派的四種方式<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>方法指定`firstArgument`和<xref:System.Reflection.MethodInfo>; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。 這個程式碼範例會使用這兩個多載。  
  
 此範例會宣告類別`C`的靜態方法`M2`和執行個體方法`M1`，以及三個委派型別：`D1`可接受的執行個體`C`和字串，`D2`採用字串和`D3`沒有引數。  
  
 名為第二個類別`Example`包含建立委派的程式碼。  
  
-   類型的委派`D2`、 執行個體上關閉`C`，建立執行個體方法`M1`。 使用不同的字串，顯示的繫結的執行個體叫用`C`一律使用。  
  
-   類型的委派`D1`，表示開啟的執行個體方法，建立執行個體方法`M1`。 當叫用委派時，必須傳遞執行個體。  
  
-   類型的委派`D2`，代表開放式的靜態方法，建立靜態方法`M2`。  
  
-   最後，類型的委派`D3`字串上為封閉式，建立靜態方法`M2`。 方法會叫用來顯示它所使用的繫結的字串。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **範例 2**  
  
 下列程式碼範例示範的參數類型相容性和傳回型別。  
  
> [!NOTE]
>  這個程式碼範例會使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法多載。 使用其他多載會採用<xref:System.Reflection.MethodInfo>類似。  
  
 程式碼範例定義名為基底類別`Base`和類別，名為`Derived`衍生自`Base`。 在衍生的類別具有`static`(`Shared`在 Visual Basic 中) 方法名為`MyMethod`具有型別的一個參數`Base`和傳回型別`Derived`。 程式碼範例也會定義名為委派`Example`具有型別的一個參數`Derived`和傳回型別`Base`。  
  
 程式碼範例將示範委派名為`Example`可以用來表示方法`MyMethod`。 方法可以繫結至委派，因為：  
  
-   委派的參數型別 (`Derived`) 是更具限制性的參數型別`MyMethod`(`Base`)，因此一律會安全地傳遞至委派的引數、 `MyMethod`。  
  
-   傳回型別`MyMethod`(`Derived`) 是更具限制性的委派的參數類型 (`Base`)，如此可永遠放心轉型為委派的傳回型別方法的傳回型別。  
  
 程式碼範例會產生任何輸出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **範例 3**  
  
 下列程式碼範例會顯示所有單一委派類型可以表示的方法。  
  
> [!NOTE]
>  有兩個多載<xref:System.Delegate.CreateDelegate%2A>方法指定`firstArgument`和<xref:System.Reflection.MethodInfo>; 其功能都相同，但是其中一個可讓您指定是否要繫結，失敗時擲回，而其他一律會擲回。 這個程式碼範例會使用這兩個多載。  
  
 程式碼範例定義兩個類別：`C`和`F`，和委派類型`D`具有單一引數的型別`C`。 類別有相符的靜態和執行個體方法`M1`， `M3`，和`M4`，和類別`C`也有執行個體方法`M2`，沒有任何引數。  
  
 名為第三個類別`Example`包含建立委派的程式碼。  
  
-   建立委派執行個體方法`M1`型別的`C`和型別`F`; 每個個別的型別執行個體上已關閉。 方法`M1`型別的`C`顯示`ID`繫結的執行個體與引數的屬性。  
  
-   建立委派方法`M2`型別的`C`。 這是開啟的執行個體的委派，其中委派的引數代表的執行個體方法上的隱藏第一個引數。 此方法沒有任何其他引數。  
  
-   針對靜態方法建立委派`M3`型別的`C`和型別`F`; 這些是開啟的靜態委派。  
  
-   靜態方法建立委派的最後，`M4`型別的`C`和型別`F`; 每個方法都宣告的型別做為其第一個引數，並提供類型的執行個體，因此委派會關閉對其第一個引數. 方法`M4`型別的`C`顯示`ID`繫結的執行個體與引數的屬性。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
 -或-  
  
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
 -或-  
  
 無法繫結 <paramref name="method" />，而且 <paramref name="throwOnBindFailure" /> 為 <see langword="true" />。  
  
 -或-  
  
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="target">叫用 <c>method</c> 的類別執行個體。</param>
        <param name="method">委派要表示的執行個體方法名稱。</param>
        <param name="ignoreCase">布林值 (Boolean)，指出是否在比較方法名稱時忽略大小寫。</param>
        <summary>建立指定類型的委派，這個委派表示要在指定的類別執行個體上，使用指定的大小寫區分來叫用的指定執行個體方法。</summary>
        <returns>指定類型的委派，表示要在指定的類別執行個體上叫用的指定執行個體方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只會建立委派執行個體方法。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，指定`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="target" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
 -或-  
  
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
 -或-  
  
 <paramref name="method" /> 不是執行個體方法。  
  
 -或-  
  
 例如，因為找不到 <paramref name="method" />，所以無法將其繫結。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="target">
          <see cref="T:System.Type" />，代表可實作 <c>method</c> 的類別。</param>
        <param name="method">委派要表示的靜態方法名稱。</param>
        <param name="ignoreCase">布林值 (Boolean)，指出是否在比較方法名稱時忽略大小寫。</param>
        <summary>建立指定之類型的委派，其表示指定之類別的指定靜態方法，且指定區分大小寫的方式。</summary>
        <returns>指定類型的委派，表示指定類別的指定靜態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立只使用靜態方法的委派。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 這個方法多載就相當於呼叫<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法多載，指定`true`如`throwOnBindFailure`。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="target" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
 -或-  
  
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
 -或-  
  
 <paramref name="target" /> 不是 <see langword="RuntimeType" />。  
  
 -或-  
  
 <paramref name="target" /> 是開放式泛型類型。 亦即，其 <see cref="P:System.Type.ContainsGenericParameters" /> 屬性為 <see langword="true" />。  
  
 -或-  
  
 <paramref name="method" /> 不是 <see langword="static" /> 方法 (Visual Basic 中的 <see langword="Shared" /> 方法)。  
  
 -或-  
  
 例如，因為找不到 <paramref name="method" />，所以無法將其繫結。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="target">叫用 <c>method</c> 的類別執行個體。</param>
        <param name="method">委派要表示的執行個體方法名稱。</param>
        <param name="ignoreCase">布林值 (Boolean)，指出是否在比較方法名稱時忽略大小寫。</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> 表示如果無法繫結 <c>method</c> 則擲回例外狀況，否則為 <see langword="false" />。</param>
        <summary>建立指定之類型的委派，其表示要在指定的類別執行個體上叫用的指定執行個體方法，且會指定區分大小寫的方式以及在繫結失敗時要發生的行為。</summary>
        <returns>指定類型的委派，表示要在指定的類別執行個體上叫用的指定執行個體方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只會建立委派執行個體方法。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="target" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
 -或-  
  
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
 -或-  
  
 <paramref name="method" /> 不是執行個體方法。  
  
 -或-  
  
 無法繫結 <paramref name="method" />，例如因為找不到該方法，以及 <paramref name="throwOnBindFailure" /> 為 <see langword="true" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要建立之委派的 <see cref="T:System.Type" />。</param>
        <param name="target">
          <see cref="T:System.Type" />，代表可實作 <c>method</c> 的類別。</param>
        <param name="method">委派要表示的靜態方法名稱。</param>
        <param name="ignoreCase">布林值 (Boolean)，指出是否在比較方法名稱時忽略大小寫。</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> 表示如果無法繫結 <c>method</c> 則擲回例外狀況，否則為 <see langword="false" />。</param>
        <summary>建立指定之類型的委派，其表示指定之類別的指定靜態方法，且會指定區分大小寫的方式以及在繫結失敗時要發生的行為。</summary>
        <returns>指定類型的委派，表示指定類別的指定靜態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立只使用靜態方法的委派。 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用方法，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用方法的授權集僅限於呼叫者的授與集或子集類別。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="target" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不會繼承 <see cref="T:System.MulticastDelegate" />。  
  
 -或-  
  
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 請參閱[反映中的執行階段類型](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
 -或-  
  
 <paramref name="target" /> 不是 <see langword="RuntimeType" />。  
  
 -或-  
  
 <paramref name="target" /> 是開放式泛型類型。 亦即，其 <see cref="P:System.Type.ContainsGenericParameters" /> 屬性為 <see langword="true" />。  
  
 -或-  
  
 <paramref name="method" /> 不是 <see langword="static" /> 方法 (Visual Basic 中的 <see langword="Shared" /> 方法)。  
  
 -或-  
  
 無法繫結 <paramref name="method" />，例如因為找不到該方法，以及 <paramref name="throwOnBindFailure" /> 為 <see langword="true" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有存取 <paramref name="method" /> 所需的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">物件的陣列，這些物件是要傳遞至目前委派所表示方法的引數。  
  
 -或-  
  
 如果目前委派所表示的方法不需要引數，則為 <see langword="null" />。</param>
        <summary>動態叫用 (晚期繫結) 目前委派所表示的方法。</summary>
        <returns>物件，由委派所表示的方法傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫 <xref:System.Delegate.DynamicInvokeImpl%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。  
  
 -或-  
  
 在 <paramref name="args" /> 中列示的參數數目、順序或型別是無效的。</exception>
        <exception cref="T:System.ArgumentException">委派所表示的方法在不支援該方法的物件或類別上被叫用。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">委派所表示的方法是執行個體方法，並且目標物件是 <see langword="null" />。  
  
 -或-  
  
 其中一個封裝的方法會擲回例外狀況。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">物件的陣列，這些物件是要傳遞至目前委派所表示方法的引數。  
  
 -或-  
  
 如果目前委派所表示的方法不需要引數，則為 <see langword="null" />。</param>
        <summary>動態叫用 (晚期繫結) 目前委派所表示的方法。</summary>
        <returns>物件，由委派所表示的方法傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會實作 <xref:System.Delegate.DynamicInvoke%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。  
  
 -或-  
  
 在 <paramref name="args" /> 中列示的參數數目、順序或型別是無效的。</exception>
        <exception cref="T:System.ArgumentException">委派所表示的方法在不支援該方法的物件或類別上被叫用。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">委派所表示的方法是執行個體方法，並且目標物件是 <see langword="null" />。  
  
 -或-  
  
 其中一個封裝的方法會擲回例外狀況。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要與目前委派比較的物件。</param>
        <summary>判斷指定的物件和目前的委派是否具有相同類型，並共用相同的目標、方法和引動過程清單。</summary>
        <returns>
          如果 <paramref name="obj" /> 和目前的委派具有相同的目標、方法和引動過程清單，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果兩個委派不是相同的型別中，則不會視為相等。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 版中，兩個委派視為相等，如果其目標、 方法和引動過程清單相同，即使為不同類型的委派。  
  
 方法和目標會比較相等，如下所示：  
  
-   如果正在比較的兩個方法都是靜態，且都是相同類別上相同的方法，方法會視為相等，以及目標也視為相等。  
  
-   如果正在比較的兩個方法是執行個體方法，而且都是相同物件上的相同方法，方法會視為相等，以及目標也視為相等。  
  
-   否則，方法不被視為相等，目標也不會視為相等。  
  
 只有具有相同的順序，而且兩個 list 的對應元素代表相同的方法和目標，則兩個引動過程清單會視為相同。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回委派的雜湊碼。</summary>
        <returns>委派的雜湊碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的傳回值必須不會保存兩個原因。 首先，類別的雜湊函式可能會改變以產生較佳的分佈，呈現沒有幫助，舊的雜湊函式的任何值。 第二，這個類別的預設實作不保證，將由不同執行個體傳回相同的值。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回委派的引動過程清單。</summary>
        <returns>委派的陣列，表示目前委派的引動過程清單。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 陣列中的每個委派代表一個方法。  
  
 陣列中委派的順序是目前的委派叫用的方法，這些委派所表示的相同順序。  
  
   
  
## Examples  
 下列範例會將三個方法指派給委派。 然後它會呼叫<xref:System.Delegate.GetInvocationList%2A>方法來取得 「 檔案 」 的總計數的方法指派給委派，相反的順序執行的委派，以及執行其名稱不包含子字串的方法。  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得目前委派所表示的靜態方法。</summary>
        <returns>
          <see cref="T:System.Reflection.MethodInfo" />，描述目前委派所表示的靜態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法僅適用於目前委派所表示的靜態方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">不支援。</param>
        <param name="context">不支援。</param>
        <summary>不支援。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">不支援這個方法。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得委派所表示的方法。</summary>
        <value>
          <see cref="T:System.Reflection.MethodInfo" />，描述委派所表示的方法。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">要比較的第一個委派。</param>
        <param name="d2">要比較的第二個委派。</param>
        <summary>判斷指定的委派是否相等。</summary>
        <returns>
          如果 <see langword="true" /> 等於 <paramref name="d1" />，則為 <paramref name="d2" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 兩個具有相同的目標、 方法和引動過程清單之相同類型的委派視為相等。  
  
 如果兩個委派不是相同的型別中，則不會視為相等。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 版中，兩個委派視為相等，如果其目標、 方法和引動過程清單相同，即使為不同類型的委派。  
  
 方法和目標會比較相等，如下所示：  
  
-   如果正在比較的兩個方法都是靜態，且都是相同類別上相同的方法，方法會視為相等，以及目標也視為相等。  
  
-   如果正在比較的兩個方法是執行個體方法，而且都是相同物件上的相同方法，方法會視為相等，以及目標也視為相等。  
  
-   否則，方法不被視為相等，目標也不會視為相等。  
  
 如果具有相同的順序，而且兩個 list 的對應元素代表相同的方法和目標，則兩個引動過程清單會視為相同。  
  
 這個運算子的對等方法是 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">要比較的第一個委派。</param>
        <param name="d2">要比較的第二個委派。</param>
        <summary>判斷指定的委派是否不相等。</summary>
        <returns>
          如果 <see langword="true" /> 不等於 <paramref name="d1" />，則為 <paramref name="d2" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它們是不同的類型，或是有不同的方法、 不同的目標或不同的引動過程清單，即視為等於不到兩個委派。  
  
 如果兩個委派不是相同的型別中，則不會視為相等。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 版中，兩個委派視為相等，如果其目標、 方法和引動過程清單相同，即使為不同類型的委派。  
  
 方法和目標會比較相等，如下所示：  
  
-   如果正在比較的兩個方法都是靜態，且都是相同類別上相同的方法，方法會視為相等，以及目標也視為相等。  
  
-   如果正在比較的兩個方法是執行個體方法，而且都是相同物件上的相同方法，方法會視為相等，以及目標也視為相等。  
  
-   否則，方法不被視為相等，目標也不會視為相等。  
  
 兩個引動過程清單不相等，如果它們的順序不同，如果有不同的大小，或從一個清單的至少一個項目代表方法或不同於其他清單中其對應項目所表示的目標。  
  
 這個運算子的對等方法是 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">委派，要從其中移除 <c>value</c> 的引動過程清單。</param>
        <param name="value">委派，提供要從 <c>source</c> 的引動過程清單移除的引動過程清單。</param>
        <summary>從另一個委派的引動過程清單，移除委派的引動過程清單上最後一個項目。</summary>
        <returns>如果在 <paramref name="source" /> 的引動過程清單中找到 <paramref name="value" /> 的引動過程清單，則為新委派 (其具有藉由取得 <paramref name="value" /> 的引動過程清單並移除 <paramref name="source" /> 的引動過程清單上最後一個項目所形成的引動過程清單)。 如果 <paramref name="source" /> 是 <see langword="null" />，或未在 <paramref name="value" /> 的引動過程清單中找到 <paramref name="value" /> 的引動過程清單，則會傳回 <paramref name="source" />。 如果 <paramref name="value" /> 的引動過程清單等於 <paramref name="source" /> 的引動過程清單，或是 <paramref name="source" /> 等於 null 參考，則會傳回 null 參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果引動過程清單`value`符合一組連續的引動過程清單中的項目`source`，然後引動過程清單`value`發生在引動過程清單中稱為`source`。 如果引動過程清單`value`出現一次以上的引動過程清單中`source`，移除最後一個出現項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</exception>
        <exception cref="T:System.ArgumentException">委派型別不相符。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">委派，要從其中移除 <c>value</c> 的引動過程清單。</param>
        <param name="value">委派，提供要從 <c>source</c> 的引動過程清單移除的引動過程清單。</param>
        <summary>從另一個委派的引動過程清單，移除委派的引動過程清單上所有的項目。</summary>
        <returns>如果在 <paramref name="source" /> 的引動過程清單中找到 <paramref name="value" /> 的引動過程清單，則為新委派 (其具有藉由取得 <paramref name="value" /> 的引動過程清單並移除 <paramref name="source" /> 的引動過程清單上所有的項目所形成的引動過程清單)。 如果 <paramref name="source" /> 是 <see langword="null" />，或未在 <paramref name="value" /> 的引動過程清單中找到 <paramref name="value" /> 的引動過程清單，則會傳回 <paramref name="source" />。 如果 <paramref name="value" /> 的引動過程清單等於 <paramref name="source" /> 的引動過程清單、<paramref name="source" /> 只包含等於 <paramref name="value" /> 引動過程清單的一系列引動過程清單，或是 <paramref name="source" /> 為 null 參考時，會傳回 null 參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果引動過程清單`value`符合一組連續的引動過程清單中的項目`source`，然後引動過程清單`value`發生在引動過程清單中稱為`source`。 如果引動過程清單`value`出現一次以上的引動過程清單中`source`，會移除所有項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</exception>
        <exception cref="T:System.ArgumentException">委派型別不相符。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">委派，提供要從目前委派的引動過程清單移除的引動過程清單。</param>
        <summary>從另一個委派的引動過程清單移除委派的引動過程清單。</summary>
        <returns>如果在目前委派的引動過程清單中找到 <paramref name="value" /> 的引動過程清單，則為新委派 (其具有藉由取得目前委派的引動過程清單並移除 <paramref name="value" /> 的引動過程清單所形成的引動過程清單)。 如果 <paramref name="value" /> 是 <see langword="null" />，或未在目前委派的引動過程清單中找到 <paramref name="value" /> 的引動過程清單時，會傳回目前的委派。 如果 <paramref name="value" /> 的引動過程清單等於目前委派的引動過程清單，則會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果引動過程清單`value`符合一組連續的目前委派的引動過程清單中，則引動過程清單中的項目`value`稱為發生在目前的委派引動過程清單中。 如果引動過程清單`value`發生超過一次在目前的委派引動過程清單中，移除最後一個出現項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">呼叫端無權存取由委派所表示的方法 (例如，如果方法是私用的)。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前的委派在其中叫用執行個體方法的類別執行個體。</summary>
        <value>如果目前的委派表示執行個體方法時，則為目前委派用來叫用執行個體方法的物件；如果此委派表示靜態方法，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行個體方法是類別; 事件類別的執行個體相關聯的方法靜態方法是類別本身相關聯的方法。  
  
 如果委派叫用一或多個執行個體方法，這個屬性會傳回目標的最後一個執行個體方法的引動過程清單中。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>