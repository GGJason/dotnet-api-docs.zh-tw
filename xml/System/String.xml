<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="db23f2db04db6d6720f79033432dc316007c5489" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57932919" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>以一連串的 UTF-16 字碼單位表示文字。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 字串是用來代表文字字元的循序集合。 A<xref:System.String>物件是循序集合<xref:System.Char?displayProperty=nameWithType>物件來代表的字串;<xref:System.Char?displayProperty=nameWithType>物件會對應至的 utf-16 字碼單位。 值<xref:System.String>物件是循序集合的內容<xref:System.Char?displayProperty=nameWithType>物件和值是不可變 （亦即，它是唯讀）。 字串的不變性的相關資訊，請參閱[的不變性和 StringBuilder 類別](#Immutability)本主題稍後的章節。 大小上限<xref:System.String>物件在記憶體中的是 2 GB 的資料或大約 1 億個字元。  
  
 本節內容：  
  
 [具現化字串物件](#Instantiation)   
 [Char 物件和 Unicode 字元](#Characters)   
 [字串及 Unicode 標準](#Unicode)   
 [字串和內嵌的 null 字元](#EmbeddedNulls)   
 [字串和索引](#Indexes)   
 [Null 字串和空字串](#Nulls)   
 [不變性和 StringBuilder 類別](#Immutability)   
 [序數與文化特性的作業](#CultureSensitive)   
 [正規化](#Normalization)   
 [依類別目錄的字串作業](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>具現化字串物件  
 您可以具現化<xref:System.String>物件如下：  
  
-   字串常值，指派<xref:System.String>變數。 這是最常用的方法，來建立字串。 下列範例會使用指派來建立數個字串。 請注意，在 C# 中，因為反斜線 (\\) 會逸出字元、 必須逸出字串中的常值反斜線或整個字串必須是@-quoted。  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   藉由呼叫<xref:System.String>類別建構函式。 下列範例會產生字串，藉由呼叫類別建構函式。 請注意，某些建構函式會包含字元陣列或做為參數的帶正負號的位元組陣列的指標。 Visual Basic 不支援這些建構函式的呼叫。 如需詳細資訊<xref:System.String>建構函式，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   使用字串串連運算子 (+ C# 和 （& s) 或 + 在 Visual Basic 中) 從任何組合建立單一字串<xref:System.String>執行個體和字串常值。 下列範例說明如何使用字串串連運算子。  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   擷取屬性或呼叫的方法，傳回的字串。 下列範例使用的方法<xref:System.String>類別，以從較大的字串擷取子字串。  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   藉由呼叫格式化方法來將值或物件轉換為其字串表示。 下列範例會使用[複合格式](~/docs/standard/base-types/composite-formatting.md)內嵌的兩個物件的字串表示轉換為字串的功能。  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Char 物件和 Unicode 字元  
 在字串中的每個字元是由 Unicode 純量值，也稱為 Unicode 字碼指標或 Unicode 字元的序數 （數值） 定義。 每個字碼指標會使用 utf-16 編碼，編碼，而且會以編碼方式的每個元素的數值表示<xref:System.Char>物件。  
  
> [!NOTE]
>  請注意，因為<xref:System.String>執行個體包含循序集合的 utf-16 字碼單位，就可以建立<xref:System.String>不是語式正確的 Unicode 字串的物件。 比方說，就可以建立沒有對應的高 surrogate 的低 surrogate 的字串。 雖然某些方法，例如編碼和解碼中的物件的方法<xref:System.Text>命名空間，可能會執行檢查，以確保字串格式不正確，<xref:System.String>類別成員不確定字串的格式正確。  
  
 單一<xref:System.Char>物件通常代表單一字碼指標，也就是值的數值<xref:System.Char>等於字碼指標。 例如，字碼指標"的字元 a"是 u+25ce 0061。 不過，程式碼點可能需要多個編碼項目 (一個以上<xref:System.Char>物件)。 Unicode 標準會定義兩種類型的字元對應至多個<xref:System.Char>物件： graphemes，並對應至 Unicode 的增補平面中的字元的 Unicode 補充的字碼指標。  
  
-   簇被以基底字元，後面接著一或多個組合的字元。 比方說，表示的字元 ä<xref:System.Char>物件，其字碼指標為 U + 0061 後面的<xref:System.Char>物件，其字碼指標為 U + 0308年。 此字元也可以定義由單一<xref:System.Char>具有 U + 00E4 字碼指標的物件。 如下列範例所示，區分文化特性比較相等表示這些兩種表示法相等，雖然一般的序數比較則否。 不過，如果兩個字串會正規化，序數比較也會指出它們是否相等。 (如需有關如何將正規化字串的詳細資訊，請參閱[正規化](#Normalization)一節。)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   增補的字碼指標 （surrogate 字組） 由 Unicode<xref:System.Char>後面接著物件，其字碼指標為為高 surrogate<xref:System.Char>物件，其字碼指標為低 surrogate。 高 surrogate 範圍是從 U+D800 到 U + DBFF 的程式碼單元。 低 surrogate 範圍是從 u+dc00 到 U + dfff 範圍內的程式碼單位。 Surrogate 字組用來代表 16 的 Unicode 補充平面中的字元。 下列範例會建立 surrogate 字元，並將它傳遞給<xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType>方法，以判斷它是否為 surrogate 字組。  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>字串及 Unicode 標準  
 字串中的字元都由 UTF 16 編碼字碼單位，這會對應到<xref:System.Char>值。  
  
 每個字元字串中的有相關聯的 Unicode 字元分類，在.NET 中所表示<xref:System.Globalization.UnicodeCategory>列舉型別。 字元或 surrogate 字組的類別目錄可決定藉由呼叫<xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>方法。  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 此外，.NET 支援字串比較和排序以 Unicode 標準為基礎。 在.NET Framework 版本[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，.NET Framework 會維護自己的字串資料的資料表。 這也是從開始的.NET Framework 的版本，則為 true[!INCLUDE[net_v45](~/includes/net-v45-md.md)]在 Windows 7 上執行。 從開始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]執行 Windows 8 和更新版本的 Windows 作業系統上，執行階段委派字串比較和排序作業的作業系統。 在.NET Core 上的字串比較和排序資訊係由[Unicode 的國際元件](http://site.icu-project.org/)程式庫。下表列出的.NET 版本和字元比較和排序所依據的 Unicode 標準版本。  
  
|.NET 版本|Unicode Standard 版本|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Unicode Standard 4.0.0 版](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Unicode Standard 5.0.0 版](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Unicode Standard 5.0.0 版](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Unicode Standard 5.0.0 版](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] 和更新版本的 Windows 7|[Unicode Standard 5.0.0 版](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] 和更新版本的 Windows 8 和更新版本的 Windows 作業系統上|[Unicode Standard 6.3.0 版](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET Core (所有版本)|取決於基礎作業系統所支援的 Unicode Standard 版本。|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>字串和內嵌的 null 字元  
 在.NET 中，<xref:System.String>物件可以包含內嵌的 null 字元，計算字串的長度的一部分。 不過，在某些語言如 C 和 c + + 中，null 字元表示結尾的字串;它不是字串的一部分，並不會視為字串長度的一部分。 這表示，下列 C 和 c + + 程式設計師或以 C 或 c + + 撰寫的程式庫可能會讓字串的常見假設不一定有效，當套用至<xref:System.String>物件：  
  
-   所傳回的值`strlen`或是`wcslen`函式不一定等於<xref:System.String.Length%2A?displayProperty=nameWithType>。  
  
-   建立的字串`strcpy_s`或是`wcscpy_s`函式不一定等於所建立的字串<xref:System.String.Copy%2A?displayProperty=nameWithType>方法。  
  
 您應該確定該原生 C 和 c + + 程式碼具現化<xref:System.String>物件和程式碼傳遞<xref:System.String>物件透過平台叫用時，不假設內嵌的 null 字元標記字串結尾。  
  
 當字串是排序 （或相較），並搜尋字串時，在字串中的內嵌的 null 字元被也視為不同。 執行區分文化特性比較兩個字串，包括使用文化特性而異的比較時，會忽略 null 字元。 將它們視為只有的序數或不區分大小寫的序數比較。 相反地，內嵌的 null 字元時，會永遠考慮使用方法搜尋字串，例如<xref:System.String.Contains%2A>， <xref:System.String.StartsWith%2A>，和<xref:System.String.IndexOf%2A>。  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>字串和索引  
 索引是位置<xref:System.Char>中的物件 （不屬於 Unicode 字元） <xref:System.String>。 索引是以零為起始的非負數的數字從索引位置為零的字串中的第一個位置開始。 一個數字的搜尋方法，例如<xref:System.String.IndexOf%2A>和<xref:System.String.LastIndexOf%2A>、 傳回字元的索引，或在字串執行個體中子字串。  
  
 <xref:System.String.Chars%2A>屬性可讓您存取個別<xref:System.Char>依其在字串中的索引位置的物件。 因為<xref:System.String.Chars%2A>屬性 （在 Visual Basic) 的預設屬性或索引子 （在 C# 中)，您可以存取個別<xref:System.Char>使用如下所示的程式碼字串中的物件。 此程式碼會尋找泛空白字元或標點符號字元，以判斷此字串包含的幾個文字字串中。  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 因為<xref:System.String>類別會實作<xref:System.Collections.IEnumerable>介面，您可以也逐一<xref:System.Char>中所使用的字串物件`foreach`建構，如下列範例所示。  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 連續的索引值可能無法對應至連續的 Unicode 字元，因為的 Unicode 字元可能是編碼為多個<xref:System.Char>物件。 特別是，字串可能包含多字元的文字單元的基底字元後接一或多個組合的字元或 surrogate 字組所構成。 若要使用 Unicode 字元，而不是<xref:System.Char>物件，使用<xref:System.Globalization.StringInfo?displayProperty=nameWithType>和<xref:System.Globalization.TextElementEnumerator>類別。 下列範例說明可搭配使用的程式碼之間的差異<xref:System.Char>物件和與 Unicode 字元搭配運作的程式碼。 它會比較字元或在每個單字的句子中的文字項目的數目。 字串包含兩個基底字元，後面接著組合字元的序列。  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 此範例搭配使用文字項目<xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType>方法和<xref:System.Globalization.TextElementEnumerator>類別列舉字串中的所有文字項目。 您也可以擷取陣列，其中包含每個文字項目的起始的索引，藉由呼叫<xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType>方法。  
  
 如需有關使用的文字，而不是個別的單位<xref:System.Char>值，請參閱<xref:System.Globalization.StringInfo>類別。  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Null 字串和空字串  
 已宣告但尚未指派值的字串是`null`。 嘗試在該字串上呼叫方法會擲回<xref:System.NullReferenceException>。 Null 的字串是不同的空字串，也就是的字串，其值是""或<xref:System.String.Empty?displayProperty=nameWithType>。 在某些情況下，傳遞 null 字串或空字串做為引數的方法呼叫會擲回例外狀況。 例如，傳遞 null 字串，以<xref:System.Int32.Parse%2A?displayProperty=nameWithType>方法會擲回<xref:System.ArgumentNullException>，並傳遞空字串會擲回<xref:System.FormatException>。 在其他情況下，方法引數可以是 null 字串或是空字串。 例如，如果您要提供<xref:System.IFormattable>類別的實作，您想要使用一般 ("G") 格式規範，使 null 字串和空字串。  
  
 <xref:System.String>類別包含下列兩個便利的方法可讓您測試字串是否`null`或空白：  
  
-   <xref:System.String.IsNullOrEmpty%2A>表示字串是是否`null`或等於<xref:System.String.Empty?displayProperty=nameWithType>。 這個方法就不需要使用程式碼，如下所示：  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>表示字串是否`null`，等於<xref:System.String.Empty?displayProperty=nameWithType>，或只包含泛空白字元。 這個方法就不需要使用程式碼，如下所示：  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 下列範例會使用<xref:System.String.IsNullOrEmpty%2A>方法中的<xref:System.IFormattable.ToString%2A?displayProperty=nameWithType>的自訂實作`Temperature`類別。 方法支援的"G"，"C"、"F"、"K"格式字串。 如果是空白的格式字串或格式字串的值是`null`傳遞至此方法，其值變更為"G"格式字串。  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>不變性和 StringBuilder 類別  
 A<xref:System.String>物件稱為不可變 （唯讀），因為一旦建立後便無法修改其值。 若要修改顯示的方法<xref:System.String>物件實際上會傳回新<xref:System.String>包含修改的物件。  
  
 字串是不可變的因為執行的字串操作常式重複新增或刪除項目似乎是單一字串可以精確顯著的效能負面影響。 例如，下列程式碼會使用亂數產生器建立具有在範圍內以 0x052F 0x0001 1000 個字元的字串。 雖然程式碼會使用字串串連來將新的字元附加至現有的字串，名為`str`，它實際上會建立新<xref:System.String>針對每個串連作業的物件。  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 您可以使用<xref:System.Text.StringBuilder>類別而不是<xref:System.String>作業的字串值的多個變更的類別。 不同的執行個體<xref:System.String>類別，<xref:System.Text.StringBuilder>是可變動的物件; 當您串連、 附加或刪除從字串的子字串時，作業將會在單一字串。 當您完成修改的值<xref:System.Text.StringBuilder>物件，您可以呼叫其<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法將它轉換成字串。 下列範例會取代<xref:System.String>在上述範例中用來串連來使用 0x052F 0x0001 之範圍中的 1000 個隨機字元<xref:System.Text.StringBuilder>物件。  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>序數與文化特性的作業  
 成員<xref:System.String>類別上執行序數或區分文化特性 （語言） 作業<xref:System.String>物件。 序數的作業會在每個數值上<xref:System.Char>物件。 區分文化特性的作業處理程式碼的值<xref:System.String>物件，並採用特定文化特性的大小寫、 排序、 格式化和剖析規則列入考量。 明確宣告的文化特性或目前的文化特性隱含的內容中，執行區分文化特性的作業。 它們會對相同的字串時，兩種作業可能會產生非常不同的結果。  
  
.NET 也支援不區分文化特性的語言字串作業，使用文化特性而異 (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>)，以鬆散基礎區域的獨立的英文文化特性設定。 不同於其他<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>保證維持一致的單一電腦上，從系統中，而橫跨的.NET 版本的系統設定、 不區分文化特性設定。 跨所有文化特性可以看到視為一種黑色方塊，以確保穩定性的字串比較和排序文化特性而異。  
  
> [!IMPORTANT]
>  如果您的應用程式可讓安全性決策的相關符號的識別碼，例如檔案名稱或具名管道，或需保存的資料，例如 XML 檔案中以文字為基礎的資料，作業應該使用序數比較，而不是區分文化特性的比較。 這是因為區分文化特性的比較可以作用中，產生不同的結果，根據文化特性而序數比較取決於比較字元的二進位值。  
  
> [!IMPORTANT]
>  執行字串作業的大部分方法包括具有類型參數的多載<xref:System.StringComparison>，這可讓您指定方法是否執行序數或區分文化特性的作業。 一般情況下，您應該呼叫這個多載來進行的意圖，在方法呼叫清除。 最佳做法及使用序數和區分文化特性字串作業的指引，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。  
  
 作業[大小寫](#casing)，[剖析和格式化](#parsing)，[比較和排序](#comparison)，以及[測試是否相等](#equality)可以是序數或區分文化特性。 下列各節將討論每個類別的作業。  
  
> [!TIP]
>  您應該一律呼叫方法多載，可讓您的方法呼叫清除目的。 比方說，而不是呼叫<xref:System.String.Compare%28System.String%2CSystem.String%29>方法以執行區分文化特性比較兩個字串的使用目前的文化特性的慣例，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，其值為<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>如`comparisonType`引數。 如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。  

您可以下載[排序權數資料表](https://www.microsoft.com/en-us/download/details.aspx?id=10921)，該文字檔集合包含在 Windows 作業系統排序及比較作業中使用的字元權數資訊，以及下載[預設 Unicode 定序元素資料表](https://www.unicode.org/Public/UCA/latest/allkeys.txt) (適用於 Linux 和 macOS 的排序權數資料表)。

<a name="casing"></a>   
### <a name="casing"></a>大小寫  
 大小寫規則會決定如何變更大小寫的 Unicode 字元;例如，從小寫為大寫。 通常，會執行大小寫作業之前的字串比較。 例如，字串可能會轉換為大寫，以便與另一個大寫的字串。 您可以將轉換為小寫藉由呼叫字串中的字元<xref:System.String.ToLower%2A>或是<xref:System.String.ToLowerInvariant%2A>方法，而且您可以將它們轉換成大寫，藉由呼叫<xref:System.String.ToUpper%2A>或<xref:System.String.ToUpperInvariant%2A>方法。 此外，您可以使用<xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType>方法將字串轉換為字首大寫。  

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]  
  
 大小寫的作業可以根據目前文化特性、 指定的文化特性或文化特性而異的規則。 大小寫對應使用的文化特性而異，因為大小寫作業的結果可以異的文化特性。 有三種大小寫的實際差異：  
  
-   在 大小寫的 LATIN CAPITAL LETTER I 對應的差異 (u+0049)，拉丁小型字母 I (u+0069)，LATIN CAPITAL LETTER I (u+0130)，上述的點和拉丁文小型字母無點 」 (U + 0131)。 TR-TR （土耳其文 （土耳其）） 和 az-Latn-AZ （亞塞拜然，拉丁） 文化特性，在和中的 tr、 az 和 az Latn 中性文化特性，LATIN CAPITAL LETTER I 的對等小寫; 拉丁文小型字母無點 1，而拉丁文小型字母 I 的大寫對應項拉丁大寫字母我使用上述的點。 在所有其他的文化特性，包括文化特性而異，拉丁小型字母 I 與 LATIN CAPITAL LETTER 我是小寫和大寫對等項目。  
  
     下列範例示範如何設計的字串比較，以避免檔案系統存取權可能會失敗它依賴區分文化特性的大小寫比較。 （不區分文化特性的大小寫慣例應該已使用。）  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   在 大小寫對應而異的文化特性和所有其他文化特性之間的差異。 在這些情況下，使用文化特性而異的大小寫規則變更為大寫或小寫字元，將會傳回相同的字元。 對於所有其他的文化特性，它會傳回不同的字元。 某些受影響的字元都是以下列的表所述。  
  
    |字元|如果變更為|Returns|  
    |---------------|-------------------|-------------|  
    |MICRON 登 (U + 00B5)|大寫|希臘文大寫字母 MU (U +-39 C)|  
    |LATIN CAPITAL LETTER 我加上點上方 (U+0130)|小寫|拉丁文小型字母 I (U+0069)|  
    |拉丁文小寫字母無點我 (U + 0131)|大寫|拉丁大寫字母 I (U+0049)|  
    |拉丁文小寫字母長 S (U + 017F)|大寫|LATIN CAPITAL LETTER S (U + 0053)|  
    |有勾的小寫字母 Z 的拉丁大寫字母 D (U + 01C 5)|小寫|有勾的拉丁小寫字母 DZ (U + 01C 6)|  
    |結合希臘 YPOGEGRAMMENI (U + 0345)|大寫|希臘文大寫字母 IOTA (U + 0399)|  
  
-   ASCII 字元範圍中的兩個字母混合大小寫組的大小寫對應的差異。 在大部分文化中，兩個字母混合大小寫組等於的對等的兩個字母大寫或小寫組。 這不適用於下列兩個字母組中的下列的文化特性，因為在每個案例中，它們會比較到雙拼詞：  
  
    -   「 lJ"和"nJ"HR-HR （克羅埃西亞文 （克羅埃西亞）） 文化特性中。  
  
    -   「 cH"CS-CZ （捷克文 （捷克共和國）） 和 sk-SK （斯洛伐克文 （斯洛伐克）） 文化特性。  
  
    -   "aA"DA-DK （丹麥文 （丹麥）） 文化特性中。  
  
    -   "cS"、"dZ"、"dZS"、"nY"、"sZ"、"tY，"和"zs"表示 HU-HU （匈牙利文 （匈牙利）） 文化特性中。  
  
    -   「 cH"和"lL"es ES_tradnl （西班牙文 （西班牙，傳統排序）） 文化特性中。  
  
    -   「 cH"、"gI"、"kH"、"nG""nH"、"pH"，"qU'，"tH"，並在 vi VN （越南文 （越南）） 文化特性中的"tR"。  
  
     不過，很少會遇到這些字組的區分文化特性的比較會建立問題的情況下，因為這些組並不常見的固定的字串或識別項。  
  
 下列範例會說明一些在大小寫規則時將字串轉換成大寫的文化特性之間的差異。  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>剖析和格式化  
 格式化和剖析是反向作業。 格式化規則決定的值，例如日期和時間或數字，轉換成其字串表示法，而剖析規則會決定如何將轉換為值，例如日期和時間的字串表示。 格式化和剖析規則均依存於文化特性的慣例。 下列範例說明在解譯的特定文化特性的日期字串時，可能會發生模稜兩可。 而不需要知道用來產生日期字串的文化特性的慣例，不可能知道 03/01/2011年，3/1/2011，01/03/2011年代表 2011 年 1 月 3 日或 2011 年 3 月 1 日。  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 同樣地，如下列範例所示，單一字串可能會產生不同的日期，根據文化特性的慣例用於剖析作業。  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>字串比較和排序  
 比較和排序字串的慣例而異的文化。 例如，排序次序可能會根據語音 或字元的視覺表示法。 在東亞語言中，字元是依照筆劃和表意字元的巨大。 排序也取決於順序語言和文化特性使用的字母。 例如，丹麥文的 "Æ" 字元在字母順序中排列在 "Z" 之後。 此外，比較可以是區分大小寫或區分大小寫，而且在某些情況下的大小寫規則也因文化特性。 序數比較，相反地，會使用字串時比較和排序字串中的個別字元的 Unicode 字碼指標。  
  
 排序規則決定彼此的 Unicode 字元的字母順序和兩個字串比較。 例如，<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>方法會比較兩個字串，根據<xref:System.StringComparison>參數。 如果參數值<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>，如果參數值，這個方法會執行語言比較，會使用目前的文化特性; 慣例<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>，此方法會執行序數比較。 因此，如下列範例所示，如果目前的文化特性是美國英文、 第一次呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>（使用區分文化特性的比較） 的方法會考慮"a"小於"A"，但相同的方法 （使用序數比較） 的第二個呼叫會考慮"a"大於"A"。  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET 支援 word、 字串和序數排序規則：  
  
-   文字排序執行區分文化特性比較的字串，其中某些非英數字元的 Unicode 字元可能會被獲指派特殊的權重。 比方說，連字號 （-） 可能很小的權重，讓"coop"和"co-op"會相互並排顯示已排序的清單中，指派給它。 取得一份<xref:System.String>方法來比較兩個字串使用字組排序規則，請參閱[依分類的字串作業](#ByCategory)一節。  
  
-   字串排序也會執行區分文化特性的比較。 就像是文字排序，只不過沒有特殊案例，而且所有的非英數符號前面所有英數字元的 Unicode 字元。 可以藉由呼叫中使用字串的排序規則比較兩個字串<xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType>方法的多載`options`參數所提供的值<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>。 請注意，這是.NET 提供要比較兩個字串時，使用字串的排序規則的唯一方法。  
  
-   序數排序比較根據每個數值的字串<xref:System.Char>字串中的物件。 小寫和大寫字元的版本具有不同的字碼指標是，會自動區分大小寫的序數比較。 不過，如果案例並不重要，您可以指定會忽略大小寫的序數比較。 這就相當於將字串轉換成大寫使用文化特性而異，然後在結果上執行序數比較。 取得一份<xref:System.String>方法來比較兩個字串採用序數排序規則，請參閱[依分類的字串作業](#ByCategory)一節。  
  
 區分文化特性的比較是明確或隱含地使用任何比較<xref:System.Globalization.CultureInfo>物件，包括而異的文化特性由<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>屬性。 隱含的文化特性是所指定的目前文化特性<xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>和<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>屬性。 沒有相當大的差異，在排序次序的字母字元 (亦即，字元<xref:System.Char.IsLetter%2A?displayProperty=nameWithType>屬性會傳回`true`) 跨文化特性。 您可以指定使用特定文化特性的慣例，藉由提供區分文化特性比較<xref:System.Globalization.CultureInfo>這類物件的字串比較方法<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>。 您可以指定使用目前的文化特性的慣例，藉由提供區分文化特性比較<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>， <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>，或任何成員<xref:System.Globalization.CompareOptions>以外的列舉型別<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>適當多載<xref:System.String.Compare%2A>方法。 區分文化特性的比較是通常適用於排序，而不是序數比較。 序數比較是通常適用於判斷兩個字串是否相等 (也就是判斷身分識別) 而不是區分文化特性的比較。  
  
 下列範例說明區分文化特性和序數比較之間的差異。 此範例會評估三個字串、"Apple"、"Æble，"和"AEble"，使用序數比較和 DA-DK 和 EN-US 文化特性的慣例 (每個都是預設文化特性時<xref:System.String.Compare%2A>方法呼叫)。 因為丹麥文語言字元"Æ 」 視為個別的字母，而且會依字母順序的"Z"後面排序，字串"Æble 」 大於"Apple"。 不過，"Æble"是不被視為相等於"AEble 」，使"Æble 」 也是大於"AEble 」。 EN-US 文化特性不包含字母"Æ"，但會將其視為相當於"AE"，其中說明為什麼 「 Æble"小於"Apple"但為等於"AEble 」。 序數比較，相反地，會視為必須小於"Æble 」 和"Æble 「 大於 」 AEble"的"Apple"。  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 您可以使用下列指導方針來選擇適當的排序或字串比較方法：  
  
-   如果您想根據使用者的文化特性來排序字串，您應該將根據目前的文化特性的慣例加以排序。 如果使用者的文化特性變更，排序字串的順序將也會據此變更。 比方說，同義字應用程式應該一律會排序根據使用者的文化特性的字。  
  
-   如果您想要排序的字串依據特定文化特性的慣例，您應該依它們提供<xref:System.Globalization.CultureInfo>物件，表示該文化特性的比較方法。 比方說，在設計來教導學生特定語言的應用程式，您想要排序的字串根據其中一個使用該語言的文化特性的慣例。  
  
-   如果您想維持不變，跨文化特性字串順序時，您應該根據文化特性而異的慣例加以排序，或使用序數比較。 例如，您會使用序數排序來組織檔案、 處理程序、 mutex 的名稱或具名管道。  
  
-   如需牽涉到安全性決策 （例如使用者名稱是否有效） 的比較，您應該一律執行序數測試是否相等藉由呼叫的多載<xref:System.String.Equals%2A>方法。  
  
> [!NOTE]
>  區分文化特性的排序和大小寫字串比較中使用的規則視.NET 版本而定。 在.NET Framework 4.5 和更新版本上執行[!INCLUDE[win8](~/includes/win8-md.md)]操作系統、 排序、 大小寫、 正規化和 Unicode 字元資訊符合 Unicode 6.0 標準。 其他 Windows 作業系統在系統上，其符合標準的 Unicode 5.0。 在.NET Core，這取決於基礎作業系統所支援的 Unicode 標準版本。 
  
 如需 word、 字串和序數排序規則的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>主題。 如需何時使用每個規則，其他建議，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。  
  
 一般情況下，您不呼叫字串比較方法，例如<xref:System.String.Compare%2A>直接以判斷字串的排序次序。 相反地，例如排序方法會呼叫比較方法<xref:System.Array.Sort%2A?displayProperty=nameWithType>或<xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>。 下列範例執行四個不同排序作業 （使用目前文化特性、 使用區分文化特性的字組排序、 序數排序，以及使用文化特性而異的字串排序字組排序），而不需要明確呼叫字串比較方法，雖然它們指定要使用的比較類型。 請注意，每一種排序會產生唯一的字串，其陣列中所用的順序。  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  就內部而言，.NET 會使用排序索引鍵，以支援區分文化特性的字串比較。 每一個字元在字串中的提供排序權數，包括字母、 大小寫和變音符號的數個的類別。 排序索引鍵，由<xref:System.Globalization.SortKey>類別中，提供這些加權的存放庫特定的字串。 如果您的應用程式會執行大量搜尋或排序在相同的字串集合上的作業，您可以藉由產生並儲存它所使用的所有字串的排序鍵來改善其效能。 需要排序或比較運算時，您會使用的排序索引鍵，而不是字串。 如需詳細資訊，請參閱 <xref:System.Globalization.SortKey> 類別。  
  
 如果您未指定的字串比較的慣例，排序方法這類<xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>對字串執行區分文化特性，區分大小寫排序。 下列範例說明如何變更目前的文化特性會影響已排序字串陣列中的順序。 它會建立三個字串的陣列。 首先，它會設定`System.Threading.Thread.CurrentThread.CurrentCulture`屬性設為 EN-US 並呼叫<xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>方法。 產生的排序次序會根據排序的英文 （美國） 文化特性的慣例。 接下來，範例會設定`System.Threading.Thread.CurrentThread.CurrentCulture`屬性設為 DA-DK 並呼叫<xref:System.Array.Sort%2A?displayProperty=nameWithType>方法一次。 請注意如何產生的排序次序不同於 EN-US 結果因為它會使用丹麥文 （丹麥） 排序慣例。  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  如果您在比較字串的主要目的是要判斷是否相等，您應該呼叫<xref:System.String.Equals%2A?displayProperty=nameWithType>方法。 一般而言，您應該使用<xref:System.String.Equals%2A>来執行序數比較。 <xref:System.String.Compare%2A?displayProperty=nameWithType>方法主要為了排序字串。  
  
 字串搜尋方法，例如<xref:System.String.StartsWith%2A?displayProperty=nameWithType>和<xref:System.String.IndexOf%2A?displayProperty=nameWithType>，也可以執行區分文化特性或序數字串比較。 下列範例說明使用序數和區分文化特性的比較差異<xref:System.String.IndexOf%2A>方法。 中目前的文化特性是英文 （美國） 文化特性搜尋會視為 「 oe 」，以符合連音符號"œ"的子字串。 因為選擇性連字號 (U + 00AD) 是零寬度的字元，則搜尋會將選擇性連字號視為相當於<xref:System.String.Empty>和字串的開頭在找到相符項目。 序數搜尋，相反地，找不到相符項目在任一情況下。  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>搜尋字串  
 字串搜尋方法，例如<xref:System.String.StartsWith%2A?displayProperty=nameWithType>和<xref:System.String.IndexOf%2A?displayProperty=nameWithType>，也可以執行區分文化特性或指定的字串中找到的序數字串比較，以判斷是否在字元或子字串。  
  
 中的搜尋方法<xref:System.String>類別的搜尋的個別字元，例如<xref:System.String.IndexOf%2A>方法，或其中一個的一組字元，例如<xref:System.String.IndexOfAny%2A>方法中，所有執行的序數搜尋。 若要執行區分文化特性的搜尋的字元，您必須呼叫<xref:System.Globalization.CompareInfo>方法，例如<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>或<xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>。 請注意，搜尋字元，使用序數和區分文化特性比較的結果可能大不相同。 比方說，搜尋預先組成的 Unicode 字元，例如連音符號"Æ 」 (U + 00 C 6) 可能會比對出現在正確的順序，例如"AE"及其元件的任何 （U + 041U + 0045），根據文化特性。 下列範例說明之間的差異<xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType>和<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>方法搜尋的個別字元時。 連音符號"æ 」 (U + 00E6) 中找到字串"空照圖 」 時使用 EN-US 文化特性的慣例，但不是使用時 DA-DK 文化特性的慣例或執行序數比較時。  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 相反地，<xref:System.String>類別搜尋字串，而不是字元執行區分文化特性的搜尋，如果搜尋選項未明確指定類型的參數的方法<xref:System.StringComparison>。 唯一的例外狀況是<xref:System.String.Contains%2A>，會執行序數的搜尋。  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>測試相等  
 使用<xref:System.String.Compare%2A?displayProperty=nameWithType>方法，以判斷兩個字串在排序次序中的關聯性。 一般而言，這是區分文化特性的作業。 相反地，呼叫<xref:System.String.Equals%2A?displayProperty=nameWithType>方法來測試是否相等。 因為相等測試通常會比對使用者輸入一些已知的字串，例如有效的使用者名稱、 密碼或檔案系統路徑，但它通常是序數的作業。  
  
> [!WARNING]
>  可以藉由呼叫測試是否相等<xref:System.String.Compare%2A?displayProperty=nameWithType>方法，並判斷傳回的值是否為零。 不過，不建議這種做法。 若要判斷兩個字串是否相等，您應該呼叫其中一個多載<xref:System.String.Equals%2A?displayProperty=nameWithType>方法。 慣用的多載，以呼叫為任一個執行個體<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>方法或靜態<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，因為這兩種方法都包含<xref:System.StringComparison?displayProperty=nameWithType>明確指定的比較類型的參數。  
  
 下列範例說明執行區分文化特性比較相等時應該改為使用其中一個為序數的危險。 在此情況下，程式碼的意圖是禁止執行不區分大小寫的 URL，以使用字串"FILE:// 開頭比較的方式以"FILE:// 或"file:// 開頭的 Url 中的檔案系統存取權。 不過，如果以"file:// 開頭的 URL 上使用土耳其文 （土耳其） 文化特性執行區分文化特性的比較，相等的比較會失敗，因為土耳其文的大寫對等的小寫字母"i"為"i"而不是"I"。 如此一來，不小心允許檔案系統存取權。 相反地，如果執行序數比較，則成功的相等比較，和檔案系統存取遭到拒絕。  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>正規化  
 某些 Unicode 字元有多種表示。 例如，任何下列的字碼指標可以代表字母"ắ 」:  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 搜尋、 排序、 比對，和其他字串作業，會讓複雜的單一字元的多種表示。  
  
 Unicode 標準會定義稱為傳回一個的二進位表示法的 Unicode 字元的任何其對等的二進位表示法的正規化程序。 正規化可以使用數種演算法，稱為正規化表單，可遵循不同的規則。 .NET 支援的 Unicode 正規化表單 C、 D、 KC 和 KD。 當字串已經正規化成相同的正規化格式時，他們可以使用序數比較來比較。  
  
 序數比較是對應的 Unicode 純量值的二進位比較<xref:System.Char>每個字串中的物件。 <xref:System.String>類別包含數種方法，可以執行序數比較，包括下列：  
  
-   任何多載<xref:System.String.Compare%2A>， <xref:System.String.Equals%2A>， <xref:System.String.StartsWith%2A>， <xref:System.String.EndsWith%2A>， <xref:System.String.IndexOf%2A>，和<xref:System.String.LastIndexOf%2A>方法，其中包含<xref:System.StringComparison>參數。 如果您提供的值，這個方法會執行序數比較<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase>此參數。  
  
-   多載<xref:System.String.CompareOrdinal%2A>方法。  
  
-   根據預設，使用序數比較，例如的方法<xref:System.String.Contains%2A>， <xref:System.String.Replace%2A>，和<xref:System.String.Split%2A>。  
  
-   搜尋的方法<xref:System.Char>值或中的項目<xref:System.Char>字串執行個體中的陣列。 這類方法包括<xref:System.String.IndexOf%28System.Char%29>和<xref:System.String.Split%28System.Char%5B%5D%29>。  
  
 您可以判斷字串是否會正規化為正規化格式 C 藉由呼叫<xref:System.String.IsNormalized?displayProperty=nameWithType>方法，或者您可以呼叫<xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType>方法，以判斷是否要將字串標準化為指定的正規化格式。 您也可以呼叫<xref:System.String.Normalize?displayProperty=nameWithType>方法，以將字串轉換為正規化格式 C，或您可以呼叫<xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType>方法，以將字串轉換為指定的正規化格式。 逐步將正規化和比較字串的詳細資訊，請參閱<xref:System.String.Normalize>和<xref:System.String.Normalize%28System.Text.NormalizationForm%29>方法。  
  
 下列的簡單範例說明字串正規化。 它會以三個不同的方式，在三個不同的字串，定義字母"ố 」，並使用以判斷每個字串，不同於其他兩個字串的序數比較相等。 它接著將每個字串轉換成支援的正規化格式，並再次執行每個字串的序數比較，為指定的正規化格式。 在每個案例中，第二項測試相等; 會顯示字串相等。  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 如需有關正規化和正規化表單的詳細資訊，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>，以及[Unicode 標準附錄 #15:Unicode Normalization Forms](https://unicode.org/reports/tr15/)而[正規化常見問題集](https://www.unicode.org/faq/normalization.html)unicode.org 網站上。  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>依類別目錄的字串作業  
 <xref:System.String>類別提供成員來比較測試字串是否相等，尋找的字元或在字串中，修改字串，擷取來自字串、 組合字串，格式化的值，複製字串的子字串的子字串的字串和正規化字串。  
  
### <a name="comparing-strings"></a>比較字串  
 您可以比較字串，以判斷兩者在排序次序中的相對位置，使用下列<xref:System.String>方法：  
  
-   <xref:System.String.Compare%2A> 傳回一個整數，表示要在排序次序中的第二個字串的一個字串的關聯性。  
  
-   <xref:System.String.CompareOrdinal%2A> 傳回一個整數，表示一個字串，以根據其字碼指標比較的第二個字串的關聯性。  
  
-   <xref:System.String.CompareTo%2A> 傳回一個整數，表示目前的字串執行個體在排序次序中的第二個字串的關聯性。 <xref:System.String.CompareTo%28System.String%29>方法會提供<xref:System.IComparable>並<xref:System.IComparable%601>實作<xref:System.String>類別。  
  
### <a name="testing-strings-for-equality"></a>測試字串相等  
 您呼叫<xref:System.String.Equals%2A>方法，以判斷兩個字串是否相等。 執行個體<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>和 靜態<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>多載可讓您指定比較是否區分文化特性或序數，以及案例是考慮或忽略。 大部分的測試相等為序數，並比較相等，以決定系統資源 （例如檔案系統物件） 的存取權應該一律是序數。  
  
### <a name="finding-characters-in-a-string"></a>尋找字串中的字元  
 <xref:System.String>類別包含兩種類型的搜尋方法：  
  
-   方法會傳回<xref:System.Boolean>可指出特定的子字串是否出現在字串執行個體的值。 其中包括<xref:System.String.Contains%2A>， <xref:System.String.EndsWith%2A>，和<xref:System.String.StartsWith%2A>方法。  
  
-   表示字串執行個體中的子字串開始位置的方法。 其中包括<xref:System.String.IndexOf%2A>， <xref:System.String.IndexOfAny%2A>， <xref:System.String.LastIndexOf%2A>，和<xref:System.String.LastIndexOfAny%2A>方法。  
  
> [!WARNING]
>  如果您想要搜尋特定的模式，而不是特定的子字串的字串，您應該使用規則運算式。 如需詳細資訊，請參閱 < [.NET 規則運算式](~/docs/standard/base-types/regular-expressions.md)。  
  
### <a name="modifying-a-string"></a>修改字串  
 <xref:System.String>類別包含下列方法看似修改字串的值：  
  
-   <xref:System.String.Insert%2A> 將字串插入至目前<xref:System.String>執行個體。  
  
-   <xref:System.String.PadLeft%2A> 將指定之字元的一個或多個插入字串的開頭。  
  
-   <xref:System.String.PadRight%2A> 將指定之字元的一個或多個插入字串的結尾。  
  
-   <xref:System.String.Remove%2A> 刪除從目前的子字串<xref:System.String>執行個體。  
  
-   <xref:System.String.Replace%2A> 使用在目前的另一個子字串取代子字串<xref:System.String>執行個體。  
  
-   <xref:System.String.ToLower%2A> 和<xref:System.String.ToLowerInvariant%2A>將字串中的所有字元都轉換成小寫。  
  
-   <xref:System.String.ToUpper%2A> 和<xref:System.String.ToUpperInvariant%2A>字串中的所有字元都轉換成大寫。  
  
-   <xref:System.String.Trim%2A> 移除開頭和結尾字串的所有出現的字元。  
  
-   <xref:System.String.TrimEnd%2A> 從字串的結尾移除所有出現的字元。  
  
-   <xref:System.String.TrimStart%2A> 從移除所有出現的字元字串的開頭。  
  
> [!IMPORTANT]
>  字串修改的所有方法都會都傳回新<xref:System.String>物件。 它們不會修改目前的執行個體的值。  
  
### <a name="extracting-substrings-from-a-string"></a>從字串擷取子字串  
 <xref:System.String.Split%2A?displayProperty=nameWithType>方法會將單一字串分隔成多個字串。 方法的多載可讓您指定多個分隔符號，來判斷擷取方法的子字串的最大數目，以及判斷空字串 （這就是相鄰的分隔符號時，就會發生） 是否包含在所傳回的字串。  
  
### <a name="combining-strings"></a>結合字串  
 下列<xref:System.String>方法可用於字串串連：  
  
-   <xref:System.String.Concat%2A> 結合成單一字串的一或多個子字串。  
  
-   <xref:System.String.Join%2A> 串連成單一元素的一或多個子字串，並將每一個子字串之間的分隔符號。  
  
### <a name="formatting-values"></a>格式化的值  
 <xref:System.String.Format%2A?displayProperty=nameWithType>方法使用複合格式功能的某些物件或值的字串表示取代字串中的一或多個預留位置。 <xref:System.String.Format%2A>方法通常用來執行下列動作：  
  
-   若要在字串中內嵌之數值的字串表示。  
  
-   若要在字串中內嵌的日期和時間值的字串表示。  
  
-   若要在字串中內嵌的列舉值的字串表示。  
  
-   若要內嵌支援某些物件的字串表示<xref:System.IFormattable>字串中的介面。  
  
-   若要靠右對齊或子字串在較大的字串內的欄位中靠左對齊。  
  
 如需格式化作業和範例的詳細資訊，請參閱<xref:System.String.Format%2A>多載摘要。  
  
### <a name="copying-a-string"></a>複製字串  
 您可以呼叫下列<xref:System.String>方法來建立一份字串：  
  
-   <xref:System.String.Clone%2A> 傳回參考現有<xref:System.String>物件。  
  
-   <xref:System.String.Copy%2A> 建立一份現有的字串。  
  
-   <xref:System.String.CopyTo%2A> 將字串的一部分複製到字元陣列。  
  
### <a name="normalizing-a-string"></a>正規化字串  
 在 Unicode 中，單一字元可以有多個字碼指標。 正規化會將這些對等的字元轉換成相同的二進位表示法。 <xref:System.String.Normalize%2A?displayProperty=nameWithType>方法會執行正規化和<xref:System.String.IsNormalized%2A?displayProperty=nameWithType>方法會判斷字串是否已標準化。  
  
 如需詳細資訊和範例，請參閱 <<c0> [ 正規化](#Normalization)稍早在本主題中的區段。  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/en-us/download/details.aspx?id=10921">排序資料表的權數的 Windows 作業系統</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">預設 Unicode 定序 Elemeent 資料表中，適用於 Linux 和 macOS</related>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">在 .NET Framework 中使用字串的最佳作法</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.String" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本節內容：  
  
 [多載的建構函式語法](#Syntax)   
 [參數](#Params)   
 [例外狀況](#Exceptions)   
 [我呼叫的方法？](#Tasks)   
 [建立字串](#Creating_Strings)   
 [處理重複的字串](#Repetitive)   
 具現化字串的範例：   
 [使用字串指派](#Ctor1_Example)  
 [使用的字元陣列](#Ctor2_Example)  
 [使用字元陣列中的部分，並重複單一字元](#Ctor3_Example)  
 [使用字元陣列的指標](#Ctor4_Example)  
 [使用指標和陣列的範圍](#Ctor5_Example)  
 [使用帶正負號的位元組陣列的指標](#Ctor6_Example)  
[版本資訊](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>多載的建構函式語法  
 String 建構函式分為兩類： 不使用指標參數，以及使用指標參數。 使用指標的建構函式不符合 CLS 標準。 此外，Visual Basic 不支援使用指標，而且 C# 需要會使用指標，在不安全的內容中執行的程式碼。 如需詳細資訊，請參閱 [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md)。  
  
 如需其他指引選擇多載的詳細資訊，請參閱[執行呼叫的方法？](#Tasks)  
  
 `String(Char[] value)`  
 初始化新的執行個體的 Unicode 字元陣列所指示的值。 這個建構函式會將複製的 Unicode 字元 ([範例](#Ctor2_Example))。  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 初始化新的執行個體的 Unicode 字元，該陣列中，且長度內起始字元位置陣列所指示的值 ([範例](#Ctor3_Example))。  
  
 `String(Char c, Int32 count)`  
 初始化新的執行個體的值以指定的 Unicode 字元重複指定的次數 ([範例](#Ctor3_Example))。  
  
 `String(char* value)`  
 **（不符合 CLS 規範）** 初始化新的執行個體終止的 null 字元的 Unicode 字元陣列的指標所指示的值 (u+0000 或 '\0')。 ([範例](#Ctor4_Example))。  
  
 權限： <xref:System.Security.SecurityCriticalAttribute>，立即呼叫端需要受到完全信任。 此成員不能由部分信任或不透明的程式碼。  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **（不符合 CLS 規範）** 初始化新的執行個體的 Unicode 字元，該陣列中，且長度內起始字元位置陣列的指標所指示的值。 建構函式會將複製的 Unicode 字元`value`的索引開始`startIndex`並結束於索引`startIndex`  +  `length` -1 ([範例](#Ctor5_Example))。  
  
 權限： <xref:System.Security.SecurityCriticalAttribute>，立即呼叫端需要受到完全信任。 此成員不能由部分信任或不透明的程式碼。  
  
 `String(SByte* value)`  
 **（不符合 CLS 規範）** 初始化新的執行個體的 8 位元帶正負號的整數陣列的指標所指示的值。 陣列會假設為代表使用目前的系統字碼頁編碼的字串 (也就指定的編碼<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>)。 建構函式會處理從字元`value`從 null 字元 (0x00) 為止，指標所指定的位置 ([範例](#Ctor6_Example))。  
  
 權限： <xref:System.Security.SecurityCriticalAttribute>，立即呼叫端需要受到完全信任。 此成員不能由部分信任或不透明的程式碼。  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **（不符合 CLS 規範）** 初始化新的執行個體的陣列 8 位元帶正負號的整數、 陣列、 在陣列和長度內開始位置的指標所指示的值。  陣列會假設為代表使用目前的系統字碼頁編碼的字串 (也就指定的編碼<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>)。 建構函式會處理從值開始的字元`startIndex`結尾`startIndex`  +  `length` -1 ([範例](#Ctor6_Example))。  
  
 權限： <xref:System.Security.SecurityCriticalAttribute>，立即呼叫端需要受到完全信任。 此成員不能由部分信任或不透明的程式碼。  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **（不符合 CLS 規範）** 初始化為 8 位元帶正負號的整數，長度，該陣列內開始位置陣列的指標所指示的值的新執行個體和<xref:System.Text.Encoding>物件。  
  
 權限： <xref:System.Security.SecurityCriticalAttribute>，立即呼叫端需要受到完全信任。 此成員不能由部分信任或不透明的程式碼。  
  
<a name="Params"></a>   
## <a name="parameters"></a>參數  
 以下是所使用的參數的完整清單<xref:System.String>不包括指標參數的建構函式。 每個多載所使用的參數，請參閱上述的多載語法。  
  
|參數|類型|描述|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Unicode 字元陣列。|  
|`c`|<xref:System.Char>|Unicode 字元。|  
|`startIndex`|<xref:System.Int32>|中的開始位置`value`新的字串中的第一個字元。<br /><br /> 預設值：0|  
|`length`|<xref:System.Int32>|中的字元數`value`包含在新的字串。<br /><br /> 預設值： <xref:System.Array.Length%2A?displayProperty=nameWithType> |  
|`count`|<xref:System.Int32>|數目乘以字元`c`重複新的字串中。 如果`count`為零，新物件的值是<xref:System.String.Empty?displayProperty=nameWithType>。|  
  
 以下是所使用的參數的完整清單<xref:System.String>包含指標參數的建構函式。 每個多載所使用的參數，請參閱上述的多載語法。  
  
|參數|類型|描述|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> -或-<br /><br /> <xref:System.SByte>\*|以 null 結束的 Unicode 字元陣列或 8 位元帶正負號整數的陣列指標。 如果`value`已`null`或空陣列，新的字串值為<xref:System.String.Empty?displayProperty=nameWithType>。|  
|`startIndex`|<xref:System.Int32>|定義新的字串中的第一個字元的陣列項目索引。<br /><br /> 預設值：0|  
|`length`|<xref:System.Int32>|要用來建立新的字串的陣列元素數目。 如果長度為零，建構函式會建立的字串，其值是<xref:System.String.Empty?displayProperty=nameWithType>。<br /><br /> 預設值： <xref:System.Array.Length%2A?displayProperty=nameWithType> |  
|`enc`|<xref:System.Text.Encoding>|物件，指定如何`value`陣列進行編碼。<br /><br /> 預設值： <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>，或系統的目前的 ANSI 字碼頁|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>例外狀況  
 以下是一份不包括指標參數的建構函式所擲回例外狀況。  
  
|例外|條件|藉由擲回|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` 為 `null`。|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex``length`，或`count`小於零。<br /><br /> -或-<br /><br /> `startIndex` 和 `length` 的總和大於 `value` 中的項目數。<br /><br /> -或-<br /><br /> `count` 小於零。|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 以下是包含指標參數的建構函式所擲回例外狀況的清單。  
  
|例外|條件|藉由擲回|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` 指定包含無效的 Unicode 字元的陣列。<br /><br /> -或-<br /><br /> `value` 或是`value`  +  `startIndex`指定的位址小於 64k。<br /><br /> -或-<br /><br /> 新<xref:System.String>無法初始化執行個體，從`value`位元組陣列，因為`value`不會使用預設字碼頁編碼。|具有指標的所有建構函式。|  
|<xref:System.ArgumentNullException>|`value` 為 null。|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|目前的處理序沒有讀取所有定址字元的權限。<br /><br /> -或-<br /><br /> `startIndex` 或 `length` 小於零、`value` + `startIndex` 導致指標溢位，或目前的處理序沒有所有定址字元的讀取權限。<br /><br /> -或-<br /><br /> 新字串長度太大而無法配置。|具有指標的所有建構函式。|  
|<xref:System.AccessViolationException>|`value`或`value`  +  `startIndex`  +  `length` -1，指定了無效的位址。|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>我呼叫的方法？  
  
|以|呼叫或使用|  
|--------|-----------------|  
|建立字串。|從字串常值或現有的字串指派 ([範例](#Ctor1_Example))|  
|從整個字元陣列建立字串。|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([範例](#Ctor2_Example))|  
|從字元陣列的一部分建立的字串。|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([範例](#Ctor3_Example))|  
|建立重複多次的相同字元的字串。|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([範例](#Ctor3_Example))|  
|從指標建立字串，以 Unicode 或寬字元陣列。|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|使用它的指標，從 Unicode 或寬字元陣列的一部分建立的字串。|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|從 c + + 建立字串`char`陣列。|<xref:System.String.%23ctor%28System.SByte%2A%29>、 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> -或-<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|建立從 ASCII 字元的字串。|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>建立字串  
 最常使用的技術以程式設計方式建立字串是簡單指派，如所示[本例](#Ctor1_Example)。 <xref:System.String>類別也包含四種類型的建構函式多載，可讓您從下列值建立字串：  
  
-   從字元陣列 （UTF 16 編碼的字元陣列）。 您可以建立新<xref:System.String>物件中整個陣列或其中一部分的字元。 <xref:System.String.%23ctor%28System.Char%5B%5D%29>建構函式陣列中的所有字元都複製到新的字串。 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>建構函式會複製索引中的字元`startIndex`至索引`startIndex`  +  `length` -1，以新的字串。 如果`length`為零，新的字串值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
     如果您的程式碼重複具現化具有相同值的字串，您可以使用替代方式來建立字串來改善應用程式的效能。 如需詳細資訊，請參閱 <<c0> [ 處理重複的字串](#Repetitive)。  
  
-   從單一字元也就是重複的零，一個或一次，使用<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>建構函式。 如果`count`為零，新的字串值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
-   以 null 結束的字元陣列指標，從使用<xref:System.String.%23ctor%28System.Char%2A%29>或<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>建構函式。 整個陣列或指定的範圍，都可以用來初始化的字串。 建構函式會複製啟動從指定的指標，或從指定的指標加上的 Unicode 字元序列`startIndex`並且一直傳到結尾的陣列，或針對`length`字元。 如果`value`為 null 指標或`length`為零，建構函式會建立的字串，其值是<xref:System.String.Empty?displayProperty=nameWithType>。 如果複製作業繼續進行陣列的結尾，而且陣列不是以 null 終止，建構函式的行為會與系統相關。 這種情況可能會造成存取違規。  
  
     如果陣列包含任何內嵌的 null 字元 (U + 0000 或 '\0') 和<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>多載會呼叫後，會包含字串執行個體`length`字元，包括任何內嵌的 null。 下列範例會顯示 10 個項目的陣列，其中包含兩個 null 字元的指標傳遞至時，會發生什麼事<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>方法。 因為位址是陣列的開頭，而且可以加入至字串陣列中的所有項目，建構函式具現化具有 10 個字元，包括兩個內嵌的 null 的字串。 另一方面，如果相同的陣列傳遞給<xref:System.String.%23ctor%28System.Char%2A%29>建構函式，結果是不含第一個 null 字元的四個字元字串。  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     陣列必須包含 Unicode 字元。 在 c + +，這表示的字元陣列必須是定義為 managed <xref:System.Char>[] 型別或未受管理`wchar_t`[] 型別。  
  
     如果<xref:System.String.%23ctor%28System.Char%2A%29>多載會呼叫和陣列不是以 null 終止，或如果<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>多載會呼叫並`startIndex`  +  `length`-1 包含範圍順序的字元，而外部記憶體配置建構函式的行為是系統而定，並可能會發生存取違規。 此外，Intel Itanium 處理器上，呼叫<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>建構函式可能會擲回<xref:System.DataMisalignedException>例外狀況。 如果發生這種情況，呼叫<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>改。  
  
-   從帶正負號的位元組陣列的指標。 整個陣列或指定的範圍，都可以用來初始化的字串。 使用預設字碼頁編碼方式，可解譯的位元組序列，或可以指定建構函式呼叫中的編碼方式。 如果建構函式嘗試具現化不是以 null 終止的是整個陣列的字串，或是如果從陣列的範圍`value`  +  `startIndex`要`value`  +  `startIndex`  +  `length` -1 會在配置給陣列的記憶體之外，這個建構函式的行為是系統而定，可能會發生存取違規。  
  
     包含帶正負號的位元組陣列，做為參數的三個建構函式的主要用途為轉換 c + +`char`陣列為字串，在此範例中所示：  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     如果陣列包含其值為 0 的任何 null 字元 ('\0') 或位元組，<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>多載呼叫，字串執行個體包含`length`字元，包括任何內嵌的 null。 下列範例會顯示 10 個項目的陣列，其中包含兩個 null 字元的指標傳遞至時，會發生什麼事<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>方法。 因為位址是陣列的開頭，而且可以加入至字串陣列中的所有項目，建構函式具現化具有 10 個字元，包括兩個內嵌的 null 的字串。 另一方面，如果相同的陣列傳遞給<xref:System.String.%23ctor%28System.SByte%2A%29>建構函式，結果是不含第一個 null 字元的四個字元字串。  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     因為<xref:System.String.%23ctor%28System.SByte%2A%29>並<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>建構函式解譯`value`藉由使用的預設 ANSI 字碼頁，在呼叫這些建構函式具有相同的位元組陣列可能會建立在不同系統有不同的值的字串。  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>處理重複的字串  
 應用程式的剖析，或將解碼之文字資料流時，通常會使用<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>建構函式或<xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法，以將字元序列轉換為字串。 重複使用相同的值，而不是建立及重複使用一個字串建立新字串，就會浪費記憶體。 如果您可能會重複建立相同的字串值，藉由呼叫<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>建構函式，即使您不知道在進入這些相同的字串值可能是，您可以改為使用查閱資料表。  
  
 例如，假設您讀取及剖析從包含 XML 標記和屬性檔案的字元資料流。 當您剖析的資料流時，您重複遇到特定的權杖 （也就是有符號的意義的字元序列）。 相當於"0"，"1"，"true"和"false"字串的語彙基元很可能經常發生在 XML 資料流中。  
  
 而不是將每個語彙基元轉換成新的字串，您可以建立<xref:System.Xml.NameTable?displayProperty=nameWithType>物件來保存經常出現的字串。 <xref:System.Xml.NameTable>物件可改善效能，因為它會擷取儲存的字串，而不需配置暫時的記憶體。 當您遇到的語彙基元時，使用<xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法，以從資料表中擷取語彙基元。 如果權杖存在，則方法會傳回對應的字串。 如果權杖不存在，使用<xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法插入資料表中的權杖，並取得對應的字串。  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>範例 1：使用字串指派  
 下列範例會建立新的字串指派給字串常值。 它會建立第二個字串的第一個字串值，指派給它。 這些是兩個最常用的方式來具現化新<xref:System.String>物件。  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>範例 2：使用的字元陣列  
 下列範例示範如何建立新<xref:System.String>字元陣列中的物件。  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>範例 3：使用字元陣列中的部分，並重複單一字元  
 下列範例示範如何建立新<xref:System.String>物件，從字元陣列，以及如何建立新的一部份<xref:System.String>物件，其中包含單一字元的多個項目。  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>範例 4：使用字元陣列的指標  
 下列範例示範如何建立新<xref:System.String>從指標到字元陣列中的物件。 必須編譯 C# 範例使用`/unsafe`編譯器參數。  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>範例 5:具現化的字串指標和陣列的範圍  
 下列範例會檢查期間或驚嘆號字元陣列的項目。 如果有找到，它會具現化前面標點符號的字元陣列中的字串。 如果沒有，它會具現化的字串陣列的整個內容。 必須編譯 C# 範例，使用`/unsafe`編譯器參數。  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>範例 6:從指標到帶正負號的位元組陣列的字串具現化  
 下列範例示範如何建立執行個體<xref:System.String>類別搭配<xref:System.String.%23ctor%28System.SByte%2A%29>建構函式。  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>版本資訊  
 .NET Framework  
 所有多載支援：4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 所有多載支援：4，3.5 SP1  
  
 可攜式類別庫  
 而不需要的所有多載<xref:System.SByte>`*`參數支援  
  
 適用於 Windows 市集應用程式的 .NET  
 而不需要的所有多載<xref:System.SByte>`*`中支援參數：Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 字元之 Null 終端陣列的指標</param>
        <summary>將 <see cref="T:System.String" /> 類別的新執行個體初始化為 Unicode 字元陣列的指定指標所指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">目前的處理序沒有讀取所有定址字元的權限。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 指定包含無效 Unicode 字元的陣列，或 <paramref name="value" /> 指定小於 64000 的位址。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 字元陣列。</param>
        <summary>將 <see cref="T:System.String" /> 類別的新執行個體初始化為 Unicode 字元陣列所指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">以 null 結束之 8 位元帶正負號整數的陣列指標。 整數會使用目前的系統字碼頁編碼來解譯 (也就是由 <see cref="P:System.Text.Encoding.Default" /> 所指定的編碼)。</param>
        <summary>將 <see cref="T:System.String" /> 類別的新執行個體初始化為 8 位元帶正負號整數 (Signed Integer) 陣列的指標所指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">無法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新執行個體，假設 <paramref name="value" /> 是 ANSI 編碼。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">要初始化的新字串長度，由 <paramref name="value" /> 之 null 結束字元所決定，該長度太長而無法配置。</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" /> 指定了無效的位址。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Unicode 字元。</param>
        <param name="count"><paramref name="c" /> 發生的次數。</param>
        <summary>將 <see cref="T:System.String" /> 類別的新執行個體初始化為由重複指定次數的指定 Unicode 字元所指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 小於零。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 字元陣列的指標。</param>
        <param name="startIndex">開始位置在 <paramref name="value" /> 內。</param>
        <param name="length"><paramref name="value" /> 內要使用的字元數。</param>
        <summary>將 <see cref="T:System.String" /> 類別的新執行個體初始化為 Unicode 字元陣列、在陣列內起始字元的位置以及長度等等的指定指標所指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零、<paramref name="value" /> + <paramref name="startIndex" /> 導致指標溢位，或目前的處理序沒有所有定址字元的讀取權限。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 指定包含無效 Unicode 字元的陣列，或 <paramref name="value" /> + <paramref name="startIndex" /> 指定小於 64000 的位址。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 字元陣列。</param>
        <param name="startIndex">開始位置在 <paramref name="value" /> 內。</param>
        <param name="length"><paramref name="value" /> 內要使用的字元數。</param>
        <summary>將 <see cref="T:System.String" /> 類別的新執行個體初始化為 Unicode 字元陣列、在陣列內起始字元的位置和長度等等所指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。  
  
-或- 
<paramref name="startIndex" /> 和 <paramref name="length" /> 的總和大於 <paramref name="value" /> 中的項目數。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">8 位元帶正負號整數陣列的指標。 整數會使用目前的系統字碼頁編碼來解譯 (也就是由 <see cref="P:System.Text.Encoding.Default" /> 所指定的編碼)。</param>
        <param name="startIndex">開始位置在 <paramref name="value" /> 內。</param>
        <param name="length"><paramref name="value" /> 內要使用的字元數。</param>
        <summary>將 <see cref="T:System.String" /> 類別的新執行個體初始化為 8 位元帶正負號整數的陣列、在該陣列內開始位置和長度的指定指標所指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。  
  
-或- 
<paramref name="value" /> + <paramref name="startIndex" /> 指定的位址對於目前的平台而言太大，也就是位址計算溢位。  
  
-或- 
要初始化的新字串長度太大而無法配置。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> + <paramref name="startIndex" /> 指定的位址小於 64K。  
  
-或- 
無法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新執行個體，假設 <paramref name="value" /> 是 ANSI 編碼。</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />、<paramref name="startIndex" /> 和 <paramref name="length" /> 共同指定了無效的位址。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">8 位元帶正負號整數陣列的指標。</param>
        <param name="startIndex">開始位置在 <paramref name="value" /> 內。</param>
        <param name="length"><paramref name="value" /> 內要使用的字元數。</param>
        <param name="enc">物件，指定以 <paramref name="value" /> 參考之陣列的編碼方式。 如果 <paramref name="enc" /> 為 <see langword="null" />，則假設使用 ANSI 編碼方式。</param>
        <summary>將 <see cref="T:System.String" /> 類別的新執行個體初始化為 8 位元帶正負號整數的陣列、在該陣列內開始位置、長度和 <see cref="T:System.Text.Encoding" /> 物件的指定指標所指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。  
  
-或- 
<paramref name="value" /> + <paramref name="startIndex" /> 指定的位址對於目前的平台而言太大，也就是位址計算溢位。  
  
-或- 
要初始化的新字串長度太大而無法配置。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> + <paramref name="startIndex" /> 指定的位址小於 64K。  
  
-或- 
無法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新執行個體，假設 <paramref name="value" /> 是依照 <paramref name="enc" /> 的指定所編碼。</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />、<paramref name="startIndex" /> 和 <paramref name="length" /> 共同指定了無效的位址。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">目前字串中的位置。</param>
        <summary>取得目前 <see cref="T:System.Char" /> 物件中指定位置的 <see cref="T:System.String" /> 物件。</summary>
        <value>在 <paramref name="index" /> 位置的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index`參數是以零為起始。  
  
 這個屬性會傳回<xref:System.Char>物件中所指定的位置`index`參數。 不過，您可能會將 Unicode 字元表示由多個<xref:System.Char>。 使用<xref:System.Globalization.StringInfo?displayProperty=nameWithType>類別來使用 Unicode 字元，而非<xref:System.Char>物件。 如需詳細資訊，請參閱中的 < Char 物件和 Unicode 字元 > 一節<xref:System.String>類別概觀。  
  
 在 C# 中，<xref:System.String.Chars%2A>屬性是索引子。 在 Visual Basic 中，它是預設屬性<xref:System.String>類別。 每個<xref:System.Char>可以使用下列程式碼存取字串中的物件。  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 下列範例會示範如何使用這個索引子常式中驗證字串。  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> 大於或等於此物件的長度或小於零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回對 <see cref="T:System.String" /> 這個執行個體的參考。</summary>
        <returns><see cref="T:System.String" /> 的這個執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回的值不是這個執行個體; 的獨立複本它是只是另一個檢視相同的資料。 使用<xref:System.String.Copy%2A>或是<xref:System.String.CopyTo%2A>方法來建立個別<xref:System.String>物件具有相同的值與這個執行個體。  
  
 因為<xref:System.String.Clone%2A>方法只會傳回現有的字串執行個體，不太需要直接呼叫它。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>比較兩個指定的 <see cref="T:System.String" /> 物件，並傳回一個整數，指出它們在排序順序中的相對位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Compare%2A> 方法的所有多載會傳回 32 位元帶正負號整數，指出兩個比較元之間的語彙關係。  
  
|值|條件|  
|-----------|---------------|  
|小於零|第一個子字串在排序次序中之前的第二個的子字串。|  
|零|子字串出現在排序次序中的相同位置，或 `length` 為零。|  
|大於零|第一個子字串會遵循第二個的子字串在排序次序。|  
  
> [!WARNING]
>  可能的話，您應該呼叫的多載<xref:System.String.Compare%2A>方法，其中包含<xref:System.StringComparison>參數。 如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">在 .NET Framework 中使用字串的最佳作法</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">要比較的第一個字串。</param>
        <param name="strB">要比較的第二個字串。</param>
        <summary>比較兩個指定的 <see cref="T:System.String" /> 物件，並傳回一個整數，指出它們在排序順序中的相對位置。</summary>
        <returns>32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="strA" /> 出現在排序次序中的位置和 <paramref name="strB" /> 相同。  
  
 </description></item><item><term> 大於零 
 </term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。 例如，某些字元的組合視為單一字元，或以特定的方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元，或跟隨它。  
  
 使用字組排序規則來進行比較。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
> [!WARNING]
>  當比較字串，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，它會要求您明確指定此方法會使用的字串比較的型別。 如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。  
  
 一或兩個比較元可以是`null`。 根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。  
  
 當探索到的不等比較，或這兩個字串都比較之後，就會結束比較。 不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，然後其餘字元的字串被視為較大。 傳回的值是執行的最後一個比對的結果。  
  
 比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。 例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 比較路徑名稱為"file"使用序數比較。 若要這樣做正確的程式碼如下所示：  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.String.Compare%28System.String%2CSystem.String%29>方法來比較三個集合的字串。  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 在下列範例中，`ReverseStringComparer`類別會示範如何評估兩個字串<xref:System.String.Compare%2A>方法。  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元。 <see cref="M:System.String.Compare(System.String,System.String)" />方法執行區分文化特性比較時不會考慮這類字元。 例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，區分文化特性的比較"animal"與"ani-惡意程式 」 （使用選擇性連字號或 U + 00AD） 表示兩個字串相等。  
  
[!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />方法，並提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或是<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如`comparisonType`參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">要比較的第一個字串。</param>
        <param name="strB">要比較的第二個字串。</param>
        <param name="ignoreCase"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</param>
        <summary>比較兩個指定的 <see cref="T:System.String" /> 物件，忽略或區分兩者的大小寫，並傳回一個整數，表示兩者在排序順序中的相對位置。</summary>
        <returns>32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="strA" /> 出現在排序次序中的位置和 <paramref name="strB" /> 相同。  
  
 </description></item><item><term> 大於零 
 </term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。 例如，某些字元的組合視為單一字元，或以特定的方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元，或跟隨它。  
  
 使用字組排序規則來進行比較。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
> [!WARNING]
>  當比較字串，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，它會要求您明確指定此方法會使用的字串比較的型別。 如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。  
  
 一或兩個比較元可以是`null`。 根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。  
  
 當探索到的不等比較，或這兩個字串都比較之後，就會結束比較。 不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，然後其餘字元的字串被視為較大。 傳回的值是執行的最後一個比對的結果。  
  
 比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。 例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 比較路徑名稱為"file"使用序數比較。 若要這樣做正確的程式碼如下所示：  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 下列範例示範<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29>方法就相當於使用<xref:System.String.ToUpper%2A>或<xref:System.String.ToLower%2A>比較字串時。  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元。 <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" />方法執行區分文化特性比較時不會考慮這類字元。 例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，區分文化特性、 不區分大小寫的比較"animal"與"Ani-惡意程式 」 （使用選擇性連字號或 U + 00AD） 表示兩個字串相等。  
  
[!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />方法，並提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或是<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">要比較的第一個字串。</param>
        <param name="strB">要比較的第二個字串。</param>
        <param name="comparisonType">其中一個列舉值，指定要用於比較的規則。</param>
        <summary>使用指定的規則比較兩個指定的 <see cref="T:System.String" /> 物件，並傳回一個整數，表示兩者在排序順序中的相對位置。</summary>
        <returns>32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="strA" /> 在排序次序中的位置和 <paramref name="strB" /> 相同。  
  
 </description></item><item><term> 大於零 
 </term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType`參數會指出是否比較應該使用目前或而異的文化特性，接受或忽略大小寫的比較元，或使用 word （區分文化特性） 或序數 （不區分文化特性） 的排序規則。  
  
 一或兩個比較元可以是`null`。 根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。  
  
 當探索到的不等比較，或這兩個字串都比較之後，就會結束比較。 不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，其餘字元的字串被視為較大。 傳回的值是執行的最後一個比對的結果。  
  
 比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。 例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 比較路徑名稱為"file"使用序數比較。 若要這樣做正確的程式碼如下所示：  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 下列範例會比較三個版本的字母"I"。 文化特性、 是否忽略大小寫，以及是否執行序數比較的選擇會影響結果。  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <exception cref="T:System.NotSupportedException">不支援 <see cref="T:System.StringComparison" />。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元。 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />方法執行區分文化特性比較時不會考慮這類字元。 若要識別可忽略的字元在比較中，提供的值<see cref="F:System.StringComparison.Ordinal" />或是<see cref="F:System.StringComparison.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">要比較的第一個字串。</param>
        <param name="strB">要比較的第二個字串。</param>
        <param name="ignoreCase"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</param>
        <param name="culture">物件，提供文化特性相關的比較資訊。</param>
        <summary>比較兩個指定的 <see cref="T:System.String" /> 物件，忽略或區分兩者的大小寫，並使用特定文化特性資訊來影響比較，然後傳回一個整數，表示兩者在排序順序中的相對位置。</summary>
        <returns>32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="strA" /> 出現在排序次序中的位置和 <paramref name="strB" /> 相同。  
  
 </description></item><item><term> 大於零 
 </term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較使用`culture`參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。 例如，某些字元的組合視為單一字元，或以特定的方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元，或跟隨它。  
  
 使用字組排序規則來進行比較。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
 一或兩個比較元可以是`null`。 根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。  
  
 當探索到的不等比較，或這兩個字串都比較之後，就會結束比較。 不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，然後其餘字元的字串被視為較大。 傳回的值是執行的最後一個比對的結果。  
  
 比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。 例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 比較路徑名稱為"file"使用序數比較。 若要這樣做正確的程式碼如下所示：  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 下列範例示範文化特性如何影響比較。 捷克文-捷克共和國文化特性，在 「 ch"會是單一字元，超過"d"。 不過，在英文-美國文化特性，"ch"所組成兩個字元，而且"c"小於"d"。  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元。 <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />方法執行區分文化特性比較時不會考慮這類字元。 例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，"animal"與"Ani-惡意程式 」 （使用選擇性連字號或 U + 00AD） 的不區分大小寫比較使用不區分文化特性會指出兩個字串相等。  
  
[!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法，並提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或是<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="options" />參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">要比較的第一個字串。</param>
        <param name="strB">要比較的第二個字串。</param>
        <param name="culture">提供特定文化特性之比較資訊的文化特性。</param>
        <param name="options">執行比較時要使用的選項 (例如忽略大小寫或符號)。</param>
        <summary>比較兩個指定的 <see cref="T:System.String" /> 物件，使用指定的比較選項及特定文化特性資訊影響比較，然後傳回整數，這個整數表示這兩個字串在排序次序中彼此的關聯性。</summary>
        <returns>32 位元帶正負號的整數，這個整數表示 <paramref name="strA" /> 和 <paramref name="strB" /> 之間的語彙關係，如下表所示。 
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="strA" /> 出現在排序次序中的位置和 <paramref name="strB" /> 相同。  
  
 </description></item><item><term> 大於零 
 </term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較使用`culture`參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。 例如，某些字元的組合，視為單一字元、 大寫和小寫字元要比較以特定的方式，可以指定特定文化特性或字元的排序次序取決於字元，與其前面或後面。  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>方法主要針對用於排序或依字母順序排列的作業。 此外，它不應該使用時呼叫方法的主要目的是要判斷兩個字串是否相等 （也就是當方法呼叫的目的是要測試傳回的值為零）。 若要判斷兩個字串是否相等，請呼叫<xref:System.String.Equals%2A>方法。  
  
 比較可以進一步指定`options`參數，其中包含一個或多個成員<xref:System.Globalization.CompareOptions>列舉型別。 不過，這個方法的目的是要進行區分文化特性字串比較，因為<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>和<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>值沒有任何作用。  
  
 可以是任一個或兩個比較元`null`。 根據定義，任何字串，其中包括<xref:System.String.Empty?displayProperty=nameWithType>，彼此相等比較大於 null 參考，且兩個 null 參考。  
  
 當探索到的不等比較，或這兩個字串都比較之後，就會結束比較。 不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，其餘字元的字串被視為較大。  
  
   
  
## Examples  
 下列範例會比較兩個字串中有三種： 使用 EN-US 文化特性; 的語言比較會使用 EN-US 文化特性; 語言區分大小寫的比較並使用序數比較。 它會說明如何比較的三種方法會產生三個不同的結果。  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 不是 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。 <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法執行區分文化特性比較時不會考慮這類字元。 若要識別可忽略的字元在比較中，提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或是<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="options" />參數。</para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">要用於比較中的第一個字串。</param>
        <param name="indexA"><paramref name="strA" /> 中子字串的位置。</param>
        <param name="strB">要用於比較的第二個字串。</param>
        <param name="indexB"><paramref name="strB" /> 中子字串的位置。</param>
        <param name="length">要比較之子字串的字元數上限。</param>
        <summary>比較兩個指定的 <see cref="T:System.String" /> 物件子字串，並傳回一個整數，指出它們在排序順序中的相對位置。</summary>
        <returns>32 位元帶正負號整數，指出兩比較元的語彙關係。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。  
  
 </description></item><item><term> 零 
 </term><description> 子字串出現在排序次序中的相同位置，或 <paramref name="length" /> 為零。  
  
 </description></item><item><term> 大於零 
 </term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要比較之子字串開始`strA`位於`indexA`然後在`strB`在`indexB`。 兩者`indexA`並`indexB`之以零起始的是，也就是中的第一個字元`strA`和`strB`位在位置零。 第一個子字串的長度等於長度`strA`減`indexA`再加 1。 第二個的子字串長度會等於長度`strB`減`indexB`再加 1。  
  
 要比較的字元數是較小的兩個子字串，長度和`length`。 `indexA`， `indexB`，和`length`參數不可為負值。  
  
 比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。 例如，某些字元的組合視為單一字元，或以特定的方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元，或跟隨它。  
  
 使用字組排序規則來進行比較。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
> [!WARNING]
>  當比較字串，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>方法，它會要求您明確指定此方法會使用的字串比較的型別。 如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。  
  
 一或兩個比較元可以是`null`。 根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。  
  
 當探索到的不等比較，或兩個子字串都比較之後，將會結束比較。 不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，然後其餘字元的字串被視為較大。 傳回的值是執行的最後一個比對的結果。  
  
 比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。 例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 比較路徑名稱為"file"使用序數比較。 若要這樣做正確的程式碼如下所示：  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 下列範例會比較這兩個子字串。  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。  
  
-或- 
 <paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。  
  
-或- 
 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。  
  
-或- 
<paramref name="indexA" /> 或 <paramref name="indexB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />方法執行語言或文化特性的比較時不會考慮這些字元。 若要識別可忽略的字元在比較中，呼叫<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />方法，並提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">要用於比較中的第一個字串。</param>
        <param name="indexA"><paramref name="strA" /> 中子字串的位置。</param>
        <param name="strB">要用於比較的第二個字串。</param>
        <param name="indexB"><paramref name="strB" /> 中子字串的位置。</param>
        <param name="length">要比較之子字串的字元數上限。</param>
        <param name="ignoreCase"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</param>
        <summary>比較兩個指定之 <see cref="T:System.String" /> 物件的子字串，忽略或區分兩者的大小寫，並傳回一個整數，表示兩者在排序順序中的相對位置。</summary>
        <returns>32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。  
  
 </description></item><item><term> 零 
 </term><description> 子字串出現在排序次序中的相同位置，或 <paramref name="length" /> 為零。  
  
 </description></item><item><term> 大於零 
 </term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要比較之子字串開始`strA`位於`indexA`，然後在`strB`在`indexB`。 兩者`indexA`並`indexB`之以零起始的是，也就是中的第一個字元`strA`和`strB`位在位置零。 第一個子字串的長度等於長度`strA`減`indexA`再加 1。 第二個的子字串長度會等於長度`strB`減`indexB`再加 1。  
  
 要比較的字元數是較小的兩個子字串，長度和`length`。 `indexA`， `indexB`，和`length`參數不可為負值。  
  
 比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。 例如，某些字元的組合視為單一字元，或以特定的方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元，或跟隨它。  
  
 使用字組排序規則來進行比較。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
> [!WARNING]
>  當比較字串，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>方法，它會要求您明確指定此方法會使用的字串比較的型別。 如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。  
  
 一或兩個比較元可以是`null`。 根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。  
  
 當探索到的不等比較，或兩個子字串都比較之後，將會結束比較。 不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，然後其餘字元的字串被視為較大。 傳回的值是執行的最後一個比對的結果。  
  
 比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。 例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 路徑名稱必須以不變的方式進行比較。 若要這樣做正確的程式碼如下所示。  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 下列範例會在案例中的兩個比較的兩個只有不同的子字串。 第一個比較會忽略大小寫，第二個比較會考慮大小寫。  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。  
  
-或- 
 <paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。  
  
-或- 
 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。  
  
-或- 
<paramref name="indexA" /> 或 <paramref name="indexB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />方法執行語言或文化特性的比較時不會考慮這些字元。 若要識別可忽略的字元在比較中，呼叫<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />方法，並提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">要用於比較中的第一個字串。</param>
        <param name="indexA"><paramref name="strA" /> 中子字串的位置。</param>
        <param name="strB">要用於比較的第二個字串。</param>
        <param name="indexB"><paramref name="strB" /> 中子字串的位置。</param>
        <param name="length">要比較之子字串的字元數上限。</param>
        <param name="comparisonType">其中一個列舉值，指定要用於比較的規則。</param>
        <summary>使用指定的規則比較兩個指定之 <see cref="T:System.String" /> 物件的子字串，並傳回一個整數，表示兩者在排序順序中的相對位置。</summary>
        <returns>32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。  
  
 </description></item><item><term> 零 
 </term><description> 相同排序次序中相同位置出現的子字串，或 <paramref name="length" /> 參數為零。  
  
 </description></item><item><term> 大於零 
 </term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要比較之子字串開始`strA`位於`indexA`然後在`strB`在`indexB`。 兩者`indexA`並`indexB`是以零為起始，也就是中的第一個字元`strA`和`strB`是在位置零、 放在其中一個。 第一個子字串的長度等於長度`strA`減`indexA`再加 1。 第二個的子字串長度會等於長度`strB`減`indexB`再加 1。  
  
 要比較的字元數是較小的兩個子字串，長度和`length`。 `indexA`， `indexB`，和`length`參數不可為負值。  
  
 `comparisonType`參數會指出是否比較應該使用目前或而異的文化特性，接受或忽略大小寫的比較元，或使用 word （區分文化特性） 或序數 （不區分文化特性） 的排序規則。  
  
 一或兩個比較元可以是`null`。 根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。  
  
 當探索到的不等比較，或兩個子字串都比較之後，將會結束比較。 不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，其餘字元的字串被視為較大。 傳回的值是執行的最後一個比對的結果。  
  
 比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。 例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 比較路徑名稱為"file"使用序數比較。 若要這樣做正確的程式碼如下所示：  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 下列範例會比較這兩個子字串。  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。  
  
-或- 
 <paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。  
  
-或- 
 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。  
  
-或- 
<paramref name="indexA" /> 或 <paramref name="indexB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />方法執行語言或文化特性的比較時不會考慮這些字元。 若要識別可忽略的字元在比較中，提供的值<see cref="F:System.StringComparison.Ordinal" />或是<see cref="F:System.StringComparison.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">要用於比較中的第一個字串。</param>
        <param name="indexA"><paramref name="strA" /> 中子字串的位置。</param>
        <param name="strB">要用於比較的第二個字串。</param>
        <param name="indexB"><paramref name="strB" /> 中子字串的位置。</param>
        <param name="length">要比較之子字串的字元數上限。</param>
        <param name="ignoreCase"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</param>
        <param name="culture">物件，提供文化特性相關的比較資訊。</param>
        <summary>比較兩個指定之 <see cref="T:System.String" /> 物件的子字串，忽略或區分兩者的大小寫，並使用文化特性資訊來影響比較，然後傳回一個整數，表示兩者在排序順序中的相對位置。</summary>
        <returns>整數，表示兩個比較元 (Comparand) 之間的語彙關係。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。  
  
 </description></item><item><term> 零 
 </term><description> 子字串出現在排序次序中的相同位置，或 <paramref name="length" /> 為零。  
  
 </description></item><item><term> 大於零 
 </term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要比較之子字串開始`strA`位於`indexA`，然後在`strB`在`indexB`。 兩者`indexA`並`indexB`是以零為起始，也就是中的第一個字元`strA`和`strB`是在位置零、 放在其中一個。 第一個子字串的長度等於長度`strA`減`indexA`再加 1。 第二個的子字串長度會等於長度`strB`減`indexB`再加 1。  
  
 要比較的字元數是較小的兩個子字串，長度和`length`。 `indexA`， `indexB`，和`length`參數不可為負值。  
  
 比較使用`culture`參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。 例如，某些字元的組合視為單一字元，或以特定的方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元，或跟隨它。  
  
 使用字組排序規則來進行比較。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
 一或兩個比較元可以是`null`。 根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。  
  
 當探索到的不等比較，或兩個子字串都比較之後，將會結束比較。 不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，然後其餘字元的字串被視為較大。 傳回的值是執行的最後一個比對的結果。  
  
 比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。 例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 比較路徑名稱為"file"使用序數比較。 若要這樣做正確的程式碼如下所示：  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 下列範例會比較這兩個子字串使用不同的文化特性並忽略大小寫的子字串。 文化特性的選擇會影響如何字母"I"是比較。  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。  
  
-或- 
 <paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。  
  
-或- 
 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。  
  
-或- 
<paramref name="strA" /> 或 <paramref name="strB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />方法執行語言或文化特性的比較時不會考慮這些字元。 若要識別可忽略的字元在比較中，呼叫<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法，並提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="options" />參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">要用於比較中的第一個字串。</param>
        <param name="indexA"><paramref name="strA" /> 中子字串的開始位置。</param>
        <param name="strB">要用於比較的第二個字串。</param>
        <param name="indexB"><paramref name="strB" /> 中子字串的開始位置。</param>
        <param name="length">要比較之子字串的字元數上限。</param>
        <param name="culture">物件，提供文化特性相關的比較資訊。</param>
        <param name="options">執行比較時要使用的選項 (例如忽略大小寫或符號)。</param>
        <summary>比較兩個指定的 <see cref="T:System.String" /> 物件的子字串，使用指定的比較選項及特定文化特性資訊影響比較，然後傳回整數，這個整數表示這兩個子字串在排序次序中彼此的關聯性。</summary>
        <returns>整數，這個整數表示兩個子字串之間的語彙關係，如下表所示。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。  
  
 </description></item><item><term> 零 
 </term><description> 子字串出現在排序次序中的相同位置，或 <paramref name="length" /> 為零。  
  
 </description></item><item><term> 大於零 
 </term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要比較之子字串開始`strA`位置處`indexA`然後在`strB`位置`indexB`。 第一個子字串的長度是長度`strA`減`indexA`。 第二個的子字串的長度是長度`strB`減`indexB`。  
  
 要比較的字元數是較小的兩個子字串，長度和`length`。 `indexA`， `indexB`，和`length`參數不可為負值。  
  
 比較使用`culture`參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。 例如，某些字元的組合，視為單一字元、 大寫和小寫字元要比較以特定的方式，可以指定特定文化特性或字元的排序次序取決於字元，與其前面或後面。  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>方法主要針對用於排序或依字母順序排列的作業。 此外，它不應該使用時呼叫方法的主要目的是要判斷這兩個子字串是否相等 （也就是當方法呼叫的目的是要測試傳回的值為零）。 若要判斷兩個字串是否相等，請呼叫<xref:System.String.Equals%2A>方法。  
  
 其中一個或多個`strA`並`strB`可以是`null`。 根據定義，任何字串，其中包括<xref:System.String.Empty?displayProperty=nameWithType>，彼此相等比較大於 null 參考，且兩個 null 參考。  
  
 比較可以進一步指定`options`參數，其中包含一個或多個成員<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。 不過，這個方法的目的是要進行區分文化特性字串比較，因為<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>和<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>值沒有任何作用。  
  
 當探索到的不等比較，或兩個子字串都比較之後，將會結束比較。 不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，其餘字元的字串被視為較大。 傳回的值是執行的最後一個比對的結果。  
  
   
  
## Examples  
 下列範例會使用<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>方法來比較兩個人員的姓氏。 然後它會列出它們依字母順序。  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 不是 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> 大於 <paramref name="strA" /><see langword=".Length" />。  
  
-或- 
 <paramref name="indexB" /> 大於 <paramref name="strB" /><see langword=".Length" />。  
  
-或- 
 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。  
  
-或- 
<paramref name="strA" /> 或 <paramref name="strB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法執行語言或文化特性的比較時不會考慮這些字元。 若要識別可忽略的字元在比較中，提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或是<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="options" />參數。</para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>藉由評估每個字串中對應的 <see cref="T:System.String" /> 物件之數字值，比較兩個 <see cref="T:System.Char" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">要比較的第一個字串。</param>
        <param name="strB">要比較的第二個字串。</param>
        <summary>藉由評估每個字串中對應的 <see cref="T:System.String" /> 物件之數字值，比較兩個指定 <see cref="T:System.Char" /> 物件。</summary>
        <returns>整數，表示兩個比較元 (Comparand) 之間的語彙關係。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description><paramref name="strA" /> 小於 <paramref name="strB" />。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="strA" /> 和 <paramref name="strB" /> 相等。  
  
 </description></item><item><term> 大於零 
 </term><description><paramref name="strA" /> 大於 <paramref name="strB" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會執行區分大小寫比較，使用序數排序規則。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。 若要執行不區分大小寫比較，使用序數排序規則，請呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法`comparisonType`引數設定為<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>。  
  
 因為<xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>是一種靜態方法，`strA`並`strB`可以是`null`。 如果這兩個值都是`null`，方法會傳回 0 （零），表示`strA`和`strB`相等。 如果只有其中一個值為`null`，此方法會考慮較大的非 null 值。  
  
   
  
## Examples  
 下列範例會執行與序數比較兩個字串只有大小寫不同。  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">要用於比較中的第一個字串。</param>
        <param name="indexA"><paramref name="strA" /> 中子字串的起始索引。</param>
        <param name="strB">要用於比較的第二個字串。</param>
        <param name="indexB"><paramref name="strB" /> 中子字串的起始索引。</param>
        <param name="length">要比較之子字串的字元數上限。</param>
        <summary>藉由評估每個子字串中對應的 <see cref="T:System.String" /> 物件之數字值，比較兩個指定的 <see cref="T:System.Char" /> 物件之子字串。</summary>
        <returns>32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description> <paramref name="strA" /> 中的子字串小於 <paramref name="strB" /> 中的子字串。  
  
 </description></item><item><term> 零 
 </term><description> 子字串相等，或者 <paramref name="length" /> 為零。  
  
 </description></item><item><term> 大於零 
 </term><description> <paramref name="strA" /> 中的子字串大於 <paramref name="strB" /> 中的子字串。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indexA`， `indexB`，和`length`參數不可為負值。  
  
 相較的字元數是較小的長度`strA`少`indexA`，長度`strB`較少`indexB`，和`length`。  
  
 這個方法會執行區分大小寫比較，使用序數排序規則。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。 若要執行不區分大小寫比較，使用序數排序規則，請呼叫<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>方法`comparisonType`引數設定為<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>。  
  
 因為<xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>是一種靜態方法，`strA`並`strB`可以是`null`。 如果這兩個值都是`null`，方法會傳回 0 （零），表示`strA`和`strB`相等。 如果只有其中一個值為`null`，此方法會考慮較大的非 null 值。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.CompareOrdinal%2A>和<xref:System.String.Compare%2A>使用不同的排序次序。  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strA" /> 不是 <see langword="null" /> 且 <paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。  
  
-或- 
 <paramref name="strB" /> 不是 <see langword="null" /> 且 <paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。  
  
-或- 
 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>比較這個執行個體與指定的物件或 <see cref="T:System.String" />，並傳回一個整數，指出這個執行個體在排序次序中，位於指定物件或 <see cref="T:System.String" /> 之前、之後或相同位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這兩個多載<xref:System.String.CompareTo%2A>方法執行區分文化特性和區分大小寫的比較。 您無法使用這個方法來執行不區分文化特性或序數比較。 為了讓程式碼，我們建議您避免<xref:System.String.CompareTo%2A>方法，並呼叫<xref:System.String.Compare%2A>方法改為。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">評估為 <see cref="T:System.String" /> 的物件。</param>
        <summary>比較這個執行個體與指定的 <see cref="T:System.Object" />，並且指出這個執行個體在排序次序中，位於所指定 <see cref="T:System.Object" /> 之前、之後或相同位置。</summary>
        <returns>32 位元帶正負號的整數，指出這個執行個體在排序次序中，位於 <paramref name="value" /> 參數之前、之後或相同位置。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description> 這個執行個體位於 <paramref name="value" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description> 這個執行個體在排序次序中的位置與 <paramref name="value" /> 相同。  
  
 </description></item><item><term> 大於零 
 </term><description> 這個執行個體位於 <paramref name="value" /> 之後。  
  
-或- 
 <paramref name="value" /> 為 <see langword="null" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 必須是<xref:System.String>物件。  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A>方法依設計主要是用於排序或依字母順序排列的作業。 此外，它不應該使用時呼叫方法的主要目的是要判斷兩個字串是否相等。 若要判斷兩個字串是否相等，請呼叫<xref:System.String.Equals%2A>方法。  
  
 這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
 這個方法的行為的相關詳細資訊，請參閱 < 備註 > 一節<xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例會使用<xref:System.String.CompareTo%2A>方法使用<xref:System.Object>。 因為它會嘗試比較<xref:System.String>執行個體`TestClass`物件，方法會擲回<xref:System.ArgumentException>。  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 不是 <see cref="T:System.String" />。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元。 <see cref="M:System.String.CompareTo(System.Object)" />方法執行區分文化特性比較時不會考慮這類字元。 例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，"animal"與"ani-惡意程式 」 （使用選擇性連字號或 U + 00AD） 的比較，指出兩個字串相等。  
  
[!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.CompareOrdinal(System.String,System.String)" />方法。</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">要和這個執行個體比較的字串。</param>
        <summary>比較這個執行個體與指定的 <see cref="T:System.String" /> 物件，並且表示這個執行個體在排序次序中，位於所指定字串之前、之後或相同位置。</summary>
        <returns>32 位元帶正負號的整數，指出這個執行個體在排序次序中，位於 <paramref name="strB" /> 參數之前、之後或相同位置。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description> 這個執行個體位於 <paramref name="strB" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description> 這個執行個體在排序次序中的位置與 <paramref name="strB" /> 相同。  
  
 </description></item><item><term> 大於零 
 </term><description> 這個執行個體位於 <paramref name="strB" /> 之後。  
  
-或- 
 <paramref name="strB" /> 為 <see langword="null" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A>方法依設計主要是用於排序或依字母順序排列的作業。 此外，它不應該使用時呼叫方法的主要目的是要判斷兩個字串是否相等。 若要判斷兩個字串是否相等，請呼叫<xref:System.String.Equals%2A>方法。  
  
 這個方法的行為的相關詳細資訊，請參閱 < 備註 > 一節<xref:System.String.Compare%28System.String%2CSystem.String%29>方法。  
  
 這個方法會實作<xref:System.IComparable%601?displayProperty=nameWithType>介面並執行稍微優於<xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType>方法，因為它不能以判斷是否`strB`引數是可變動的實值型別，必須要經過 boxing 處理，而且不需要轉型其從參數<xref:System.Object>至<xref:System.String>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.String.CompareTo%2A>方法來比較目前的字串執行個體，以另一個字串。  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 下列範例示範數個值和參考類型的 CompareTo 方法的泛型和非泛型版本。  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元。 <see cref="M:System.String.CompareTo(System.String)" />方法執行區分文化特性比較時不會考慮這類字元。 例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，"animal"與"ani-惡意程式 」 （使用選擇性連字號或 U + 00AD） 的比較，指出兩個字串相等。  
  
[!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.CompareOrdinal(System.String,System.String)" />方法。</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>串連一或多個 <see cref="T:System.String" /> 執行個體，或者一或多個 <see cref="T:System.String" /> 執行個體值的 <see cref="T:System.Object" /> 表示。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values">集合物件，這個物件實作 <see cref="T:System.Collections.Generic.IEnumerable`1" />，且其泛型類型引數為 <see cref="T:System.String" />。</param>
        <summary>串連類型 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 之已建構的 <see cref="T:System.String" /> 集合的成員。</summary>
        <returns><paramref name="values" /> 中的串連字串，或如果 <paramref name="values" /> 是空白的 <see langword="IEnumerable(Of String)" />則為 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法會串連每個物件在`values`; 它不會新增任何分隔符號。 若要指定每個成員之間的分隔符號`values`，呼叫<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法。  
  
 <xref:System.String.Empty>替代任何 null 的項目中使用字串`values`。  
  
 如果`values`為空`IEnumerable(Of String)`，則方法會傳回<xref:System.String.Empty?displayProperty=nameWithType>。 如果`values`已`null`，方法會擲回<xref:System.ArgumentNullException>例外狀況。  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 是一種便利方法，可讓您串連每個項目`IEnumerable(Of String)`集合，而不先將項目轉換成字串陣列。 它特別適合使用 Language-Integrated Query (LINQ) 查詢運算式。 下列範例會傳遞`List(Of String)`物件，包含 lambda 運算式會選取等於或大於特定字母 （即，在範例中，"M"） 的字母英文字母大寫或小寫字母。 `IEnumerable(Of String)`所傳回的集合<xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>方法會傳遞至<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法來顯示結果，以單一字串。  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。 它會將結果指派<xref:System.Collections.Generic.List%601>類型的物件<xref:System.String>，這會接著傳遞給<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法。  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">要表示的物件，或 <see langword="null" />。</param>
        <summary>建立指定之物件的字串表示。</summary>
        <returns><paramref name="arg0" /> 值的字串表示；如果 <see cref="F:System.String.Empty" /> 為 <paramref name="arg0" />，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Concat%28System.Object%29>方法代表`arg0`做為字串，藉由呼叫其無參數`ToString`方法。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.Concat%2A>方法。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">包含要串連之項目的物件陣列。</param>
        <summary>串連指定之 <see cref="T:System.Object" /> 陣列中項目的字串表示法。</summary>
        <returns><paramref name="args" /> 中之項目值的串連字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法會串連每個物件在`args`藉由呼叫無參數`ToString`方法，該物件; 它不會新增任何分隔符號。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> 用來在陣列中的任何 null 物件取代。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.String.Concat%2A>方法使用<xref:System.Object>陣列。  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OutOfMemoryException">記憶體不足。</exception>
        <block subset="none" type="usage"><para>這個方法不會由 c + + 程式碼呼叫。 C + + 編譯器會呼叫<see cref="Overload:System.String.Concat" />有四個或多個物件參數與呼叫<see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />。</para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">字串執行個體的陣列。</param>
        <summary>串連指定 <see cref="T:System.String" /> 陣列中的項目。</summary>
        <returns><paramref name="values" /> 的串連項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法會串連每個物件在`values`; 它不會新增任何分隔符號。  
  
 <xref:System.String.Empty>字串來取代陣列中的任何 null 物件。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.String.Concat%2A>方法使用<xref:System.String>陣列。  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.OutOfMemoryException">記憶體不足。</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">要串連的第一個物件。</param>
        <param name="arg1">要串連的第二個物件。</param>
        <summary>串連兩個指定之物件的字串表示。</summary>
        <returns><paramref name="arg0" /> 和 <paramref name="arg1" /> 之值的串連字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法會串連`arg0`並`arg1`藉由呼叫無參數`ToString`方法`arg0`和`arg1`; 它不會新增任何分隔符號。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> 用來取代任何 null 引數。  
  
 如果是引數的陣列參考，此方法會串連字串，表示該陣列，而不是其成員 (例如，"System.String[]")。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.Concat%2A>方法。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">要串連的第一個字串。</param>
        <param name="str1">要串連的第二個字串。</param>
        <summary>串連 <see cref="T:System.String" /> 的兩個指定執行個體。</summary>
        <returns><paramref name="str0" /> 和 <paramref name="str1" /> 的串連。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法會串連`str0`和`str1`; 它不會新增任何分隔符號。  
  
> [!NOTE]
>  您可以也使用您語言的字串串連運算子，例如`+`在 C# 中，或是`&`和`+`在 Visual Basic)  
>   
>  來串連字串。  
  
 <xref:System.String.Empty>字串來取代任何 null 引數。  
  
   
  
## Examples  
 下列範例會串連個人的名字、 中間名和姓氏的名稱。  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">要串連的第一個物件。</param>
        <param name="arg1">要串連的第二個物件。</param>
        <param name="arg2">要串連的第三個物件。</param>
        <summary>串連三個指定之物件的字串表示。</summary>
        <returns><paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 之值的串連字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法會串連`arg0`， `arg1`，並`arg2`藉由呼叫無參數`ToString`方法的每個物件; 它不會新增任何分隔符號。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> 用來取代任何 null 引數。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.Concat%2A>方法。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <param name="str2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">要串連的第一個字串。</param>
        <param name="str1">要串連的第二個字串。</param>
        <param name="str2">要串連的第三個字串。</param>
        <summary>串連 <see cref="T:System.String" /> 的三個指定執行個體。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" /> 和 <paramref name="str2" /> 的串連。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法會串連`str0`， `str1`，和`str2`; 它不會新增任何分隔符號。  
  
> [!NOTE]
>  您可以也使用您語言的字串串連運算子，例如`+`在 C# 中，或是`&`和`+`在 Visual Basic)  
>   
>  來串連字串。  
  
 <xref:System.String.Empty>字串來取代任何 null 引數。  
  
   
  
## Examples  
 下列範例會使用<xref:System.String.Concat%2A>方法來串連三個字串，並顯示結果。  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">要串連的第一個物件。</param>
        <param name="arg1">要串連的第二個物件。</param>
        <param name="arg2">要串連的第三個物件。</param>
        <param name="arg3">要串連的第四個物件。</param>
        <summary>串連四個指定的物件之字串表示和選擇性變數長度參數清單中所指定的任何物件。</summary>
        <returns>參數清單中每個值的已串連字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此應用程式開發介面不符合 CLS 標準。 符合 CLS 標準的替代項目為 <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>。 C# 和 Visual Basic 編譯器會自動解決呼叫這個方法與呼叫<xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>。  
  
 方法會在參數清單中的每個物件串連藉由呼叫其無參數`ToString`方法; 它不會新增任何分隔符號。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> 用來取代任何 null 引數。  
  
> [!NOTE]
>  最後一個參數<xref:System.String.Concat%2A>方法是一或多個串連的其他物件的選擇性逗號分隔清單。  
  
   
  
## Examples  
 下列範例示範如何將<xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法來串連變數參數清單。 在此情況下，方法被呼叫九個參數。  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>這個方法標記著<see langword="vararg" />關鍵字，這表示它支援不同數量的參數。 可以從 Visual c + + 中，呼叫此方法，但不能從 C# 或 Visual Basic 程式碼呼叫它。 C# 和 Visual Basic 編譯器呼叫解析為<see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />做為呼叫<see cref="M:System.String.Concat(System.Object[])" />。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <param name="str2">To be added.</param>
        <param name="str3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">要串連的第一個字串。</param>
        <param name="str1">要串連的第二個字串。</param>
        <param name="str2">要串連的第三個字串。</param>
        <param name="str3">要串連的第四個字串。</param>
        <summary>串連 <see cref="T:System.String" /> 的四個指定執行個體。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" /> 和 <paramref name="str3" /> 的串連。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法會串連`str0`， `str1`， `str2`，和`str3`; 它不會新增任何分隔符號。  
  
> [!NOTE]
>  您可以也使用您語言的字串串連運算子，例如`+`在 C# 中，或是`&`和`+`在 Visual Basic)  
>   
>  來串連字串。  
  
 <xref:System.String.Empty>字串來取代陣列中的任何 null 物件。  
  
   
  
## Examples  
 下列範例定義四個字母構成的單字的陣列，並將其個別的字母字串陣列來儲存才能弄亂它們。 然後它會呼叫<xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29>早先變碼的字組的方法。  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> 之成員的類型。</typeparam>
        <param name="values">集合物件，這個物件實作 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 介面。</param>
        <summary>串連 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 實作的成員。</summary>
        <returns><paramref name="values" /> 中的串連成員。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法會串連每個物件在`values`; 它不會新增任何分隔符號。  
  
 <xref:System.String.Empty>字串來取代任何 null 引數。  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 是一種便利方法，可讓您串連每個項目<xref:System.Collections.Generic.IEnumerable%601>而不先將項目轉換成字串的集合。 如範例所示，它是使用 Language-Integrated Query (LINQ) 查詢運算式，特別有用。 在每個物件的字串表示<xref:System.Collections.Generic.IEnumerable%601>集合藉由呼叫該物件衍生`ToString`方法。  
  
   
  
## Examples  
 下列範例會定義一個非常簡單`Animal`類別，其中包含針對 animal 和其所屬的順序的名稱。 然後它會定義<xref:System.Collections.Generic.List%601>物件包含的數字`Animal`物件。 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>會呼叫擴充方法來擷取`Animal`物件，而其`Order`屬性等於"齧齒動物 」。 結果會傳遞至<xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法和顯示到主控台。  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字串。</param>
        <summary>傳回值，這個值表示指定的子字串是否會出現在這個字串內。</summary>
        <returns>如果 <see langword="true" /> 參數出現在這個字串內，或是 <paramref name="value" /> 為空字串 ("")，則為 <paramref name="value" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會執行序數 （區分大小寫且區分文化特性） 比較。 搜尋這個字串的第一個字元位置開始，然後繼續進行到最後一個字元位置。  
  
 若要判斷字串是否包含指定的子字串使用序數比較 （例如，區分文化特性的比較或不區分大小寫的序數比較） 以外的項目，您可以建立自訂的方法。 下列範例說明這類方法之一。 它會定義<xref:System.String>擴充方法，其中包含<xref:System.StringComparison>參數，並指出字串是否包含子字串，使用指定的格式的字串比較時。  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 下列範例會接著呼叫`Contains`延伸模組方法，以判斷子字串是否要使用序數比較和區分大小寫的序數比較時的字串中找到。  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 如果您有興趣的子字串的位置`value`在目前的執行個體，您可以呼叫<xref:System.String.IndexOf%2A>可以呼叫方法來取得其第一個項目，或您的開始位置<xref:System.String.LastIndexOf%2A>方法來取得的起始位置及其上一次。 此範例包括呼叫<xref:System.String.IndexOf%28System.String%29>方法如果在字串執行個體中找到的子字串。  
  
   
  
## Examples  
 下列範例會判斷熟悉引號的子字串是否包含"fox"的字串。 如果字串中找到"fox"，它也會顯示其起始位置。  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="str">要複製的字串。</param>
        <summary>使用與指定的 <see cref="T:System.String" /> 相同的值，建立 <see cref="T:System.String" /> 的新執行個體。</summary>
        <returns>具有與 <paramref name="str" /> 相同值的新字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Copy%2A>方法會傳回<xref:System.String>原始字串值相同，但代表不同的物件參考的物件。 不同於指派運算，會將現有的字串參考其他物件變數指派。 此範例說明的差異。  
  
   
  
## Examples  
 下列範例會建立兩個字串物件，使用不同的值。 當呼叫<xref:System.String.Copy%2A>方法來將第一個值指派給第二個字串，所以輸出指出雖然其值現在是相等的字串，代表不同的物件參考。 相反地，當第一個字串指派給第二個字串時，兩個字串具有相同的值，因為它們代表相同的物件參考。  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">這個要複製的執行個體中第一個字元的索引。</param>
        <param name="destination">複製這個執行個體之字元的目標 Unicode 字元陣列。</param>
        <param name="destinationIndex">在 <paramref name="destination" /> 中開始複製作業的索引。</param>
        <param name="count">這個執行個體中要複製到 <paramref name="destination" /> 的字元數。</param>
        <summary>將字元的指定數目從這個執行個體的指定位置，複製到 Unicode 字元陣列的指定位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會複製`count`字元`sourceIndex`位置，這個執行個體`destinationIndex`位置`destination`字元陣列。 這個方法不會不會調整大小`destination`字元陣列; 它必須有足夠數目的項目，以容納複製的字元，或方法會擲回<xref:System.ArgumentOutOfRangeException>。  
  
 `sourceIndex` 和`destinationIndex`是以零起始。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.CopyTo%2A>方法。  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />、<paramref name="destinationIndex" /> 或 <paramref name="count" /> 為負。 
-或- 
 <paramref name="sourceIndex" /> 未識別目前執行個體中的位置。  
  
-或- 
 <paramref name="destinationIndex" /> 未識別 <paramref name="destination" /> 陣列中的有效索引。  
  
-或- 
 <paramref name="count" /> 大於從 <paramref name="sourceIndex" /> 到這個執行個體結尾的子字串長度。 
-或- 
 <paramref name="count" /> 大於從 <paramref name="destinationIndex" /> 到 <paramref name="destination" /> 陣列結尾的子陣列長度。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示空字串。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個欄位的值是零長度字串，""。  
  
 在應用程式程式碼，這個欄位是最常用於指派中初始化為空字串的字串變數。 若要測試是否為字串的值是`null`或是<xref:System.String.Empty?displayProperty=nameWithType>，使用<xref:System.String.IsNullOrEmpty%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷這個字串執行個體的結尾是否符合指定的字串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要在這個執行個體結束時，與子字串比較的字串。</param>
        <summary>判斷這個字串執行個體的結尾是否符合指定的字串。</summary>
        <returns>如果 <see langword="true" /> 符合這個執行個體的結尾，則為 <paramref name="value" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會比較`value`結尾的這個執行個體的長度相同的子字串`value`，並傳回指示它們是否相等。 為相等，`value`必須是這個相同的執行個體的參考，或比對這個執行個體的結尾。  
  
 這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。  
  
   
  
## Examples  
 下列範例指出陣列中的每個字串是否以句號結尾 ("。")。  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 下列範例會定義`StripEndTags`方法，以使用<xref:System.String.EndsWith%28System.String%29>方法來移除行尾的 HTML 結尾標記。 請注意，`StripEndTags`呼叫方法以遞迴方式來確認已移除行結尾的多個 HTML 結尾標記。  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。 若要判斷字串是否以結束特定的子字串使用目前文化特性的字串比較規則，請呼叫<see cref="M:System.String.EndsWith(System.String,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要在這個執行個體結束時，與子字串比較的字串。</param>
        <param name="comparisonType">列舉值之一，指定這個字串和 <paramref name="value" /> 的比較方式。</param>
        <summary>判斷當使用指定的比較選項進行比較時，這個字串執行個體的結尾是否符合指定的字串。</summary>
        <returns>如果 <see langword="true" /> 參數符合這個字串的結尾，則為 <paramref name="value" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.EndsWith%2A>方法會比較`value`在這個字串的結尾的子字串的參數和傳回值，這個值，指出它們是否相等。 為相等，`value`必須為這個相同字串的參考，必須是空字串 ("")，或必須符合這個字串的結尾。 所執行的比較的型別<xref:System.String.EndsWith%2A>方法而定的值`comparisonType`參數。  
  
   
  
## Examples  
 下列範例會判斷字串是否以特定的子字串結束。 文化特性、 是否忽略大小寫，以及是否執行序數比較的選擇會影響結果。  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要在這個執行個體結束時，與子字串比較的字串。</param>
        <param name="ignoreCase"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</param>
        <param name="culture">判斷如何比較此執行個體和 <paramref name="value" /> 的文化特性資訊。 如果 <paramref name="culture" /> 是 <see langword="null" />，則會使用目前的文化特性。</param>
        <summary>判斷當使用指定之文化特性進行比較時，這個字串執行個體的結尾是否符合指定的字串。</summary>
        <returns>如果 <see langword="true" /> 參數符合這個字串的結尾，則為 <paramref name="value" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會比較`value`參數的長度相同，這個字串結尾的子字串`value`，並傳回值，指出它們是否相等。 為相等，`value`必須是這個相同的執行個體的參考，或符合這個字串的結尾。  
  
 這個方法會執行使用指定的大小寫和文化特性的字 （區分文化特性） 比較。  
  
   
  
## Examples  
 下列範例會判斷字串是否發生在另一個字串結尾。 <xref:System.String.EndsWith%2A>方法呼叫數次使用區分大小寫、 不區分大小寫和不同的文化特性會影響搜尋的結果。  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷兩個 <see cref="T:System.String" /> 物件是否具有相同的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要與這個執行個體比較的字串。</param>
        <summary>判斷這個執行個體和指定的物件 (同時還必須是 <see cref="T:System.String" /> 物件) 是否具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 是 <paramref name="obj" />，且其值與這個執行個體相同，則為 <see cref="T:System.String" />，否則為 <see langword="false" />。  如果 <paramref name="obj" /> 是 <see langword="null" />，則方法會傳回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會執行序數 （區分大小寫且區分文化特性） 比較。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.Equals%2A>方法。  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要與這個執行個體比較的字串。</param>
        <summary>判斷這個執行個體和另一個指定的 <see cref="T:System.String" /> 物件是否具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 參數的值與這個執行個體的值相同，則為 <paramref name="value" />，否則為 <see langword="false" />。 如果 <paramref name="value" /> 是 <see langword="null" />，則方法會傳回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會執行序數 （區分大小寫且區分文化特性） 比較。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.Equals%2A>方法。 它會比較標題式大小寫字組"File"對等的 word、 其小寫的對等項目、 其大寫對等項目，和包含 LATIN 小型字母無點 I 字 (U + 0131) 而非拉丁文小型字母 I (u+0069)。 因為<xref:System.String.Equals%28System.String%29>方法會執行序數比較，傳回相同的字組比較`true`。  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">要比較的第一個字串，或是 <see langword="null" />。</param>
        <param name="b">要比較的第二個字串，或 <see langword="null" />。</param>
        <summary>判斷兩個指定的 <see cref="T:System.String" /> 物件是否具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 的值與 <paramref name="a" /> 的值相同，則為 <paramref name="b" />，否則為 <see langword="false" />。 如果 <paramref name="a" /> 和 <paramref name="b" /> 都是 <see langword="null" />，則這個方法會傳回 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會執行序數 （區分大小寫且區分文化特性） 比較。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.Equals%2A>方法。  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要與這個執行個體比較的字串。</param>
        <param name="comparisonType">其中一個列舉值，指定字串的比較方式。</param>
        <summary>判斷這個字串和指定的 <see cref="T:System.String" /> 物件是否具有相同的值。 參數可指定用於比較的文化特性、大小寫及排序規則。</summary>
        <returns>如果 <see langword="true" /> 參數的值與這個字串相同，則為 <paramref name="value" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType`參數會指出是否比較應該使用目前或而異的文化特性，接受或忽略大小寫的兩個字串進行比較，或使用 word 或序數排序規則。  
  
   
  
## Examples  
 下列範例會建立包含以大寫"I"、"i"，以小寫及無點的"ı"的字串陣列。 然後它會呼叫<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>方法來比較它們使用每一個可能的<xref:System.StringComparison>列舉值。  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 下列範例會比較四字組所使用的每個成員<xref:System.StringComparison>列舉型別。  比較使用英文 （美國） 和沙米文 （上方瑞典） 文化特性的慣例。 請注意，字串"encyclopædia"和"百科全書"會被視為對等項目在 EN-US 文化特性，但不是在沙米文 （北瑞典） 文化特性。  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a">要比較的第一個字串，或是 <see langword="null" />。</param>
        <param name="b">要比較的第二個字串，或 <see langword="null" />。</param>
        <param name="comparisonType">其中一個列舉值，指定比較的規則。</param>
        <summary>判斷兩個指定的 <see cref="T:System.String" /> 物件是否具有相同的值。 參數可指定用於比較的文化特性、大小寫及排序規則。</summary>
        <returns>如果 <see langword="true" /> 參數的值等於 <paramref name="a" /> 參數的值，則為 <paramref name="b" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType`參數會指出是否比較應該使用目前或而異的文化特性，接受或忽略大小寫的兩個字串進行比較，或使用 word 或序數排序規則。  
  
   
  
## Examples  
 下列範例會比較四字組所使用的每個成員<xref:System.StringComparison>列舉型別。  比較使用英文 （美國） 和沙米文 （上方瑞典） 文化特性的慣例。 請注意，字串"encyclopædia"和"百科全書"會被視為對等項目在 EN-US 文化特性，但不是在沙米文 （北瑞典） 文化特性。  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>根據指定的格式將物件的值轉換為字串，並將它們插入到另一個字串。  
  
如果您不熟悉 `String.Format` 方法，請參閱 [String.Format 方法入門](#Starting)一節以取得快速概觀。  
  
如需 `String.Format` 方法的一般文件，請參閱[備註](#remarks-top)一節。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 本節內容：  
  
 [String.Format 方法入門](#Starting)   
 [我呼叫的方法？](#FTaskList)   
 [Format 方法簡介](#Format_Brief)   
 [格式項目](#FormatItem)   
 [引數格式化的方式](#HowFormatted)   
 [具有相同索引的格式項目](#SameIndex)   
 [格式設定和文化特性](#Format_Culture)   
 [自訂格式化作業](#Format_Custom)   
 [String.Format Q & A](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>String.Format 方法入門  
 使用<xref:System.String.Format%2A?displayProperty=nameWithType>如果您需要將物件、 變數或運算式的值插入至另一個字串。 例如，您可以在其中插入的值<xref:System.Decimal>為字串，以顯示給使用者以單一字串值：  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 您可以控制該值格式：  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 除了格式設定，您也可以控制對齊及間距。  
  
 ### <a name="inserting-a-string"></a>插入字串  

 <xref:System.String.Format%2A?displayProperty=nameWithType> 開始使用的格式字串，後面接著一個或多個物件會轉換為字串，並插入格式字串中的指定位置的運算式。 例如：  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 `{0}`格式字串是一個格式項目。 `0` 為其字串值會在該位置插入物件的索引。 （索引從 0 開始。）如果要插入的物件不是字串，其`ToString`呼叫方法，將它轉換成其中一個，再將其插入結果字串中。  
  
 在 [物件] 清單中會使用兩個格式項目和兩個物件的另一個範例如下︰  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 您可以有多個格式項目，並想與您的 [物件] 清單中的多個物件，只要每個格式項目的索引物件清單中有相符的物件。 您也不需要擔心有關哪個多載您呼叫;編譯器會選取適合您。  
  
 ### <a name="controlling-formatting"></a>控制格式  
 您可以遵循以格式字串來控制如何格式化物件的格式項目中的索引。 比方說， `{0:d}` "d"格式字串套用至物件清單中的第一個物件。 以下是具有單一物件的範例，以及兩個格式項目：  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 幾個型別支援的格式字串，包括所有數字類型 (兩者[標準](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂](~/docs/standard/base-types/custom-numeric-format-strings.md)格式字串)，所有日期和時間 (同時[標準](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自訂](~/docs/standard/base-types/custom-date-and-time-format-strings.md)格式字串) 和時間間隔 (同時[標準](~/docs/standard/base-types/standard-timespan-format-strings.md)並[自訂](~/docs/standard/base-types/custom-timespan-format-strings.md)格式字串)，所有的列舉型別[列舉型別](~/docs/standard/base-types/enumeration-format-strings.md)，並[Guid](https://msdn.microsoft.com/library/97af8hh4.aspx)。 您也可以將格式字串的支援加入自己的型別中。  
  
 ### <a name="controlling-spacing"></a>控制間距  
 您可以定義使用下列語法會插入至結果字串的字串寬度`{0,12}`，其插入 12 個字元的字串。 在此情況下，第一個物件的字串表示是靠右對齊在 12 個字元的欄位。  （如果第一個物件的字串表示的長度超過 12 個字元，不過，慣用的欄位寬度會被忽略，和整個字串插入至結果字串。）  
  
 下列範例定義了 6 個字元的欄位來容納字串 「 年 」 和部份年的字串，以及 15 個字元的欄位來容納字串 「 母體擴展 」 以及一些人口資料。 請注意，字元會靠右對齊欄位中。  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>控制對齊方式  
 根據預設，字串會靠右對齊其欄位內如果您指定欄位寬度。 若要靠左對齊欄位中的字串，您前加上負號，將欄位寬度這類`{0,-12}`定義 12 個字元，靠左對齊的欄位。  
  
 下列範例是類似於上一個，不同之處在於它靠左對齊的標籤和資料。  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> 利用複合格式功能。 如需詳細資訊，請參閱[複合格式設定](~/docs/standard/base-types/composite-formatting.md)。  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>我呼叫的方法？  
  
|以|Call|  
|--------|----------|  
|使用目前的文化特性的慣例格式化一個或多個物件。|除了包含的多載`provider`參數，其餘<xref:System.String.Format%2A>多載包含<xref:System.String>參數後面接著一或多個物件的參數。 基於這個原因，您不需要判斷哪些<xref:System.String.Format%2A>您想要呼叫的多載。 您的語言編譯器會選取從沒有多載中的適當多載`provider`參數，根據您的引數清單。 例如，如果您的引數清單有五個引數，編譯器會呼叫<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>方法。|  
|使用特定文化特性的慣例格式化一個或多個物件。|每個<xref:System.String.Format%2A>開頭的多載`provider`後面接著參數<xref:System.String>參數和一個或多個物件的參數。 基於這個原因，您不需要判斷哪一項特定<xref:System.String.Format%2A>您想要呼叫的多載。 您的語言編譯器會選取具有多載，從適當的多載`provider`參數，根據您的引數清單。 例如，如果您的引數清單有五個引數，編譯器會呼叫<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法。|  
|不論是透過執行自訂的格式設定操作<xref:System.ICustomFormatter>實作或<xref:System.IFormattable>實作。|任何具有四個多載`provider`參數。 編譯器會選擇適當的多載，從多載`provider`參數，根據您的引數清單。|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Format 方法簡介 

 每個多載<xref:System.String.Format%2A>方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)若要包含以零為起始的索引的位置，呼叫*項目的格式*，複合格式字串中。 在執行階段，每個格式項目會取代對應的引數在參數清單的字串表示。 引數的值是否`null`，將格式項目會取代<xref:System.String.Empty?displayProperty=nameWithType>。 例如，下列呼叫來<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法包含三個格式項目 中，格式字串{0}， {1}，和{2}，和包含三個項目的引數清單。  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>格式項目  
 格式項目具有此語法：  
  
```  
{index[,alignment][:formatString]}  
```  
 
 方括號表示選擇性的項目。 左和右大括號是必要。 (包含常值的開頭或結尾大括號在格式字串中，請參閱[逸出大括號](~/docs/standard/base-types/composite-formatting.md#escaping-braces)一節[複合格式化](~/docs/standard/base-types/composite-formatting.md)文章。)  
  
 比方說，若要格式化為貨幣值的格式項目可能如下所示：  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 格式項目具有下列項目：  
  
 *index*  
 起始的索引，要為其字串表示的引數包含在字串中的這個位置。 如果這個引數是`null`，空字串會包含在字串中的這個位置。  
  
 *alignment*  
 選擇性。 帶正負號的整數，指出欄位的總長度的引數會插入和它會靠右對齊 （正整數），或靠左對齊 （負整數）。 如果您省略*對齊*，不含前置或尾端空格的欄位會插入對應的引數的字串表示。  
  
 如果的值*對齊*是要插入的引數的長度小於*對齊*會被忽略，並用引數的字串表示的長度當做欄位寬度。  
  
 *formatString*  
 選擇性。 字串，指定對應的引數的結果字串的格式。 如果您省略*formatString*，對應的引數的無參數`ToString`呼叫方法來產生它的字串表示。 如果您指定*formatString*，將格式項目所參考的引數必須實作<xref:System.IFormattable>介面。 支援格式字串的類型包括：  
  
-   所有的整數和浮點數型別。 (請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。)  
  
-   <xref:System.DateTime> 和 <xref:System.DateTimeOffset>。 (請參閱[標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。)  
  
-   所有列舉類型。 (請參閱[列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。)  
  
-   <xref:System.TimeSpan> 值。 (請參閱[標準 TimeSpan 格式字串](~/docs/standard/base-types/standard-timespan-format-strings.md)並[自訂 TimeSpan 格式字串](~/docs/standard/base-types/custom-timespan-format-strings.md)。)  
  
-   GUID。 (請參閱<xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>方法。)  
  
 不過，請注意，可以實作任何自訂的型別<xref:System.IFormattable>擴充現有的類型或<xref:System.IFormattable>實作。  
  
 下列範例會使用`alignment`和`formatString`来產生格式化的輸出引數。  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>引數格式化的方式  
 格式項目會依序處理，從字串的開頭。 每個格式項目有對應至方法的引數清單中之物件的索引。 <xref:System.String.Format%2A>方法會擷取引數，並衍生其字串表示，如下所示：  
  
-   如果引數`null`，此方法會插入<xref:System.String.Empty?displayProperty=nameWithType>至結果字串。 您不必擔心處理<xref:System.NullReferenceException>null 引數。 
  
-   如果您呼叫<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>多載，而`provider`物件的<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>實作會傳回非 null<xref:System.ICustomFormatter>實作中，引數傳遞至其<xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。 如果格式項目包含*formatString*傳遞引數，它是做為第一個引數的方法。 如果<xref:System.ICustomFormatter>實作可用，而且會產生一個非 null 字串，會傳回字串作為引數的字串表示; 否則下一個步驟執行。  
  
-   如果引數會實作<xref:System.IFormattable>介面，其<xref:System.IFormattable.ToString%2A?displayProperty=nameWithType>實作稱為。  
  
-   引數的無參數`ToString`方法，它會覆寫或繼承自基底類別實作，會呼叫。  
  
 如需範例，會呼叫攔截<xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>方法，並可讓您查看哪些資訊<xref:System.String.Format%2A>方法傳遞至格式的方法，以便在複合格式字串中，每個格式項目請參閱[範例：截距，提供者和羅馬字母數字格式子](#Format7_Example)。  

 如需詳細資訊，請參閱 <<c0> [ 處理順序](~/docs/standard/base-types/composite-formatting.md##processing-order)一節[複合格式化](~/docs/standard/base-types/composite-formatting.md)文章。  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>具有相同索引的格式項目  
 <xref:System.String.Format%2A>方法會擲回<xref:System.FormatException>索引的索引項目是否大於或等於引數清單中的引數的例外狀況。 不過，`format`可以包含有引數，超過的格式項目，為多個格式項目具有相同的索引。 在呼叫<xref:System.String.Format%28System.String%2CSystem.Object%29>在下列範例中，引數清單的方法有單一引數，但在格式字串包含兩個格式項目： 一個會顯示數字的十進位值與另一個則顯示其十六進位值。  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>格式設定和文化特性  
 一般而言，引數清單中的物件會轉換成其字串表示法傳回使用目前的文化特性的慣例<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>屬性。 您可以控制此行為，藉由呼叫其中一個多載<xref:System.String.Format%2A>，其中包含`provider`參數。 `provider`參數是<xref:System.IFormatProvider>實作，提供自訂和特定文化特性格式資訊用來調節格式處理。  
  
 <xref:System.IFormatProvider>介面具有單一成員， <xref:System.IFormatProvider.GetFormat%2A>，它會負責傳回提供格式設定資訊的物件。 .NET 有三個<xref:System.IFormatProvider>實作，以提供特定文化特性：  
  
-   <xref:System.Globalization.CultureInfo>. 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法會傳回特定文化特性<xref:System.Globalization.NumberFormatInfo>格式化數值和特定文化特性的物件<xref:System.Globalization.DateTimeFormatInfo>格式化日期和時間值的物件。  
  
-   <xref:System.Globalization.DateTimeFormatInfo>它用於文化特性專屬格式的日期和時間值。 其<xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A>方法會傳回本身。  
  
-   <xref:System.Globalization.NumberFormatInfo>用於特定文化特性的數值格式。 其<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>屬性會傳回本身。 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>自訂格式化作業  
 您也可以呼叫任何多載<xref:System.String.Format%2A>方法具有`provider`型別的參數<xref:System.IFormatProvider>執行自訂的格式設定作業。 比方說，您可以格式化整數作為身分證號碼或電話號碼。 若要執行自訂的格式，您`provider`引數必須同時實作<xref:System.IFormatProvider>和<xref:System.ICustomFormatter>介面。 時<xref:System.String.Format%2A>傳遞給方法<xref:System.ICustomFormatter>做為實作`provider`引數，<xref:System.String.Format%2A>方法呼叫其<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>實作，並要求型別的物件<xref:System.ICustomFormatter>。 然後它會呼叫傳回<xref:System.ICustomFormatter>物件的<xref:System.ICustomFormatter.Format%2A>方法來格式化複合字串中的每個格式項目傳遞給它。  
  
 如需有關如何提供自訂格式解決方案的詳細資訊，請參閱[How to:定義和使用自訂數值格式提供者](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)和<xref:System.ICustomFormatter>。 如需將整數轉換為格式化的自訂數字的範例，請參閱[範例：自訂的格式設定操作](#Format6_Example)。 如需將不帶正負號的位元組轉換成羅馬數字的範例，請參閱[範例：截距，提供者和羅馬字母數字格式子](#Format7_Example)。  
  
<a name="Format6_Example"></a>   
### <a name="example-a-custom-formatting-operation"></a>範例：自訂格式化作業  
 這個範例會定義為以表單為 x-xxxxx-xx 的客戶帳戶編號格式的整數值的格式提供者。  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>範例：截距，提供者和羅馬數字格式器  
 這個範例會定義自訂的格式提供者可實作<xref:System.ICustomFormatter>和<xref:System.IFormatProvider>介面做兩件事：  
  
-   它會顯示參數傳遞至其<xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>實作。 這可讓我們看到哪些參數<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法將傳遞給每個物件，它會嘗試格式化自訂的格式化實作。 當您偵錯您的應用程式，這非常有用。  
  
-   要格式化的物件是否為使用"R"標準格式字串格式化的不帶正負號的位元組值，將自訂格式器會格式化為羅馬字母數字的數字的值。  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String.Format 問與答  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>為什麼建議字串內插補點透過呼叫`String.Format`方法？

字串插補是：

- 更有彈性。 它可以是任何字串中不需要使用支援複合格式方法的呼叫。 否則，您必須呼叫<xref:System.String.Format%2A>方法或另一個方法，支援複合格式設定，例如<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>。 

- 更容易閱讀。 因為要插入至字串的運算式會出現在插入運算式中，而不是引數清單中，字串插值是最容易的程式碼和讀取。 因為其更高的可讀性，字串插值可以取代不只呼叫複合格式方法，但它們也可用在字串串連作業以產生更簡潔、 更清楚的程式碼。 

下列兩個程式碼範例的比較會說明字串插值的優勢，透過字串串連 」 和 「 複合格式化方法的呼叫。 在下列範例中的多個字串串連作業將會產生詳細資訊] 及 [硬讀取的程式碼。

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

相較之下，使用插入字串，在下列範例會產生比字串串連陳述式和呼叫要清楚得多、 更簡潔的程式碼<xref:System.String.Format%2A>在上述範例中的方法。

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>哪裡可以找到預先定義的格式字串可以搭配格式項目清單？  
  
-   對於所有的整數和浮點數類型，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   日期和時間值，請參閱[標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。  
  
-   列舉值，請參閱[列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
-   針對<xref:System.TimeSpan>值，請參閱[標準 TimeSpan 格式字串](~/docs/standard/base-types/standard-timespan-format-strings.md)並[自訂 TimeSpan 格式字串](~/docs/standard/base-types/custom-timespan-format-strings.md)。  
  
-   針對<xref:System.Guid>值，請參閱 < 備註 > 一節<xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>參考頁面。  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>如何控制結果字串時，將格式項目的對齊方式？  
 格式項目的一般語法如下：  
  
```  
{index[,alignment][: formatString]}  
```  
  
 何處*對齊*是帶正負號的整數，定義欄位寬度。 如果此值為負數，欄位中的文字會靠左對齊。 如果它是正數，則文字會靠右對齊。  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>如何控制小數分隔符號後的數字數目？  
 所有[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)除外 （這會只顯示整數） 的"D"、"G"、"R"和"X"允許的有效位數規範定義結果字串中的小數位數。 下列範例會使用標準數值格式字串來控制結果字串中的小數位數。  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 如果您使用[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)，使用"0"的格式規範來控制在結果字串中，如下列範例所示的小數位數數目。  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>如何控制整數位數數的字？  
 根據預設，格式化作業只會顯示非零的整數位數。 如果您要格式化的整數，您可以使用精確度規範"D"和"X"標準格式字串來控制的位數。  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 您可以填補整數或浮點數，加上前置零來使用 「 0 」 產生的結果字串會以指定的數字的整數位數[自訂數值格式規範](~/docs/standard/base-types/custom-numeric-format-strings.md)，如下列範例所示。  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>是否可以在 [格式] 清單中包含多少個項目？  
 沒有任何實際的限制。 第二個參數<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法會標記為<xref:System.ParamArrayAttribute>屬性，可讓您包含分隔的清單或物件陣列做為您的格式清單。  
  
<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>我該如何包含常值大括號 ("{"和"}") 結果字串中？  
 比方說，如何執行您避免下列方法呼叫擲回<xref:System.FormatException>例外狀況？  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 單一的左或右大括號一律會解譯為開頭或結尾的格式項目中。 若要解譯為常值，則必須逸出。 您新增另一個大括號逸出大括號 ("{{"和"}} 」 而不是"{"和"}")，如下列方法呼叫：  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 不過，即使逸出大括號會輕易地譯。 我們建議您在 [格式] 清單中包含大括號，並使用將其插入在結果字串中，如下列範例所示的格式項目。  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>為什麼我呼叫 String.Format 方法擲回 FormatException？  
 最常見的例外狀況的原因是格式項目的索引未對應至 [格式] 清單中的物件。 通常這表示您已 misnumbered 格式項目的索引，或是您忘記在 [格式] 清單中包含的物件。 嘗試將包含未逸出的左或右括弧字元也會擲回<xref:System.FormatException>。 有時候，例外狀況是打錯字; 的結果例如，典型的錯誤是打錯"["（左括號） 而不是"{"（左括號）。  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>如果 Format(System.IFormatProvider,System.String,System.Object[]) 方法支援參數陣列，為何沒有我的程式碼時擲回例外狀況使用陣列嗎？  
 例如，下列程式碼會擲回<xref:System.FormatException>例外狀況：  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 這是編譯器多載解析的問題。 因為編譯器無法將整數的陣列轉換成物件陣列，它會將整數陣列視為單一引數，因此它會呼叫<xref:System.String.Format%28System.String%2CSystem.Object%29>方法。 因為有四個格式項目，但單一項目格式 清單中的，則會擲回例外狀況。  
  
 由於 Visual Basic 和 C# 都不可以轉換成物件陣列的整數陣列，您必須自行執行轉換，然後再呼叫<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>方法。 下列範例提供一個實作。  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

呼叫的數個範例<xref:System.String.Format%2A>方法透過相互穿插[備註](#remarks)一節。  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

您也可以下載一組完整的`String.Format`範例中，也就是包含[適用於 C# 的.NET Core 2.0 專案](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip)並[適用於 Visual Basic.NET Core 2.0 專案](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip)，從[dotnet /範例 GitHub 儲存機制](https://github.com/dotnet/samples)。

以下是一些文章中隨附的範例：

### <a name="create-a-format-string"></a>建立格式字串

[插入字串](#inserting-a-string)  
[格式項目](#the-format-item)  
[具有相同索引的格式項目](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>控制格式化的輸出

[控制格式](#controlling-formatting)  
[控制間距](#controlling-spacing)  
[控制對齊方式](#controlling-alignment)  
[控制數目的整數位數](#how-do-i-control-the-number-of-integral-digits)  
[控制的位數，小數分隔符號之後的](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[在結果字串中包括常值大括號](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>進行區分文化特性的格式字串

[區分文化特性格式](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>自訂格式化作業

[自訂格式化作業](#example-a-custom-formatting-operation)  
[截距，提供者和羅馬數字格式器](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">要格式化的物件。</param>
        <summary>以指定物件的字串表示，取代字串中的一或多個格式項目。</summary>
        <returns><paramref name="format" /> 的複本，其中的所有格式項目已由 <paramref name="arg0" /> 的字串表示取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將運算式的值轉換為其字串表示，並在字串中內嵌該表示法。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>範例：格式化的單一引數  
 
 下列範例會使用<xref:System.String.Format%28System.String%2CSystem.Object%29>內嵌在字串當中的個人的年齡的方法。  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 中的格式項目無效。  
  
-或- 
格式項目的索引不是零。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="args">物件陣列，包含零或多個要格式化的物件。</param>
        <summary>以指定陣列中對應物件的字串表示，取代指定之字串中的格式項目。</summary>
        <returns><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="args" /> 中對應物件的字串表示取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)四個或多個運算式的值轉換成其字串表示法，並內嵌在字串中的那些表示法。 由於`args`參數會標示<xref:System.ParamArrayAttribute?displayProperty=nameWithType>屬性，您可以將物件傳遞至方法做為個別引數，或為<xref:System.Object>陣列。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>範例：設定格式化的三個以上的引數  
 
 這個範例會建立包含在特定日期的高低溫度資料的字串。 複合格式字串有五個格式項目，在 C# 範例和六個 in Visual Basic 範例。 兩個格式項目定義及其對應值的字串表示法，寬度，而且第一個格式項目，也包含的標準日期和時間格式字串。  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 您也可以傳遞要格式化為陣列，而不是做為引數清單的物件。  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 或 <paramref name="args" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引小於零，或大於等於 <paramref name="args" /> 陣列的長度。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <param name="format">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">要格式化的物件。</param>
        <summary>以對應物件的字串表示，取代指定之字串中的一或多個格式項目。 參數提供特定文化特性格式資訊。</summary>
        <returns><paramref name="format" /> 的複本，其中的一或多個格式項目已由 <paramref name="arg0" /> 的字串表示取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將運算式的值轉換為其字串表示，並在字串中內嵌該表示法。 在執行轉換，該方法會使用區分文化特性格式，或自訂格式器。 方法會將轉換`arg0`為其字串表示，藉由呼叫其**ToString(IFormatProvider)** 方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其**ToString (String，IFormatProvider）** 方法。 如果這些方法不存在，則會呼叫物件的無參數**ToString**方法。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引不是零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <param name="format">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="args">物件陣列，包含零或多個要格式化的物件。</param>
        <summary>以指定陣列中對應物件的字串表示，取代字串中的格式項目。 參數提供特定文化特性格式資訊。</summary>
        <returns><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="args" /> 中對應物件的字串表示取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將四個或多個運算式轉換成其字串表示法，並內嵌在字串中的那些表示法。 在執行轉換，該方法會使用區分文化特性格式，或自訂格式器。 方法會將每個<xref:System.Object>引數為其字串表示，藉由呼叫其**ToString(IFormatProvider)** 方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其**ToString(String,IFormatProvider)** 方法。 如果這些方法不存在，則會呼叫物件的無參數**ToString**方法。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>範例：區分文化特性格式  
 這個範例會使用<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法，以使用數個不同的文化特性顯示一些日期和時間值和數字值的字串表示。  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 或 <paramref name="args" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引小於零，或大於等於 <paramref name="args" /> 陣列的長度。</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">要格式化的第一個物件。</param>
        <param name="arg1">要格式化的第二個物件。</param>
        <summary>以兩個指定物件的字串表示，取代字串中的格式項目。</summary>
        <returns><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="arg0" /> 和 <paramref name="arg1" /> 的字串表示取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將兩個運算式的值轉換成其字串表示法，並內嵌在字串中的那些表示法。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>範例：格式化的兩個引數  
 
 這個範例會使用<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29>方法，以顯示儲存在一般時間和溫度資料<xref:System.Collections.Generic.Dictionary%602>物件。 請注意，格式字串會有三個格式項目，雖然只有兩個要格式化的物件。 這是因為在清單中 （日期和時間值） 的第一個物件由兩個格式項目：第一個格式項目會顯示第二個情況下，就會顯示日期。  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引不是零或一。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <param name="format">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">要格式化的第一個物件。</param>
        <param name="arg1">要格式化的第二個物件。</param>
        <summary>以兩個指定物件的字串表示，取代字串中的格式項目。 參數提供特定文化特性格式資訊。</summary>
        <returns><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="arg0" /> 和 <paramref name="arg1" /> 的字串表示取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將兩個運算式轉換成其字串表示法，並內嵌在字串中的那些表示法。 在執行轉換，該方法會使用區分文化特性格式，或自訂格式器。 方法會將每個<xref:System.Object>引數為其字串表示，藉由呼叫其**ToString(IFormatProvider)** 方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其**ToString(String,IFormatProvider)** 方法。 如果這些方法不存在，則會呼叫物件的無參數**ToString**方法。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引不是零或一。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">要格式化的第一個物件。</param>
        <param name="arg1">要格式化的第二個物件。</param>
        <param name="arg2">要格式化的第三個物件。</param>
        <summary>以三個指定物件的字串表示，取代字串中的格式項目。</summary>
        <returns><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的字串表示取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)三個運算式的值轉換成其字串表示法，並內嵌在字串中的那些表示法。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>範例：格式的三個引數  
 
 這個範例會使用<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法來建立說明的布林值結果字串`And`與兩個整數值的作業。 請注意，格式字串包含六個格式項目，但方法具有三個項目在其參數清單中，因為每個項目兩種不同方式格式化。  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引小於零或大於二。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <param name="format">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">要格式化的第一個物件。</param>
        <param name="arg1">要格式化的第二個物件。</param>
        <param name="arg2">要格式化的第三個物件。</param>
        <summary>以三個指定物件的字串表示，取代字串中的格式項目。 參數提供特定文化特性格式資訊。</summary>
        <returns><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的字串表示取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將三個運算式轉換成其字串表示法，並內嵌在字串中的那些表示法。 在執行轉換，該方法會使用區分文化特性格式，或自訂格式器。 方法會將每個<xref:System.Object>引數為其字串表示，藉由呼叫其**ToString(IFormatProvider)** 方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其**ToString(String,IFormatProvider)** 方法。 如果這些方法不存在，則會呼叫物件的無參數**ToString**方法。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引小於零或大於二。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>擷取可以逐一查看這個字串中個別字元的物件。</summary>
        <returns>列舉程式物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> 而不是呼叫<xref:System.String.GetEnumerator%2A>方法來擷取<xref:System.CharEnumerator>物件，然後使用列舉字串，您應該改為使用您語言的反覆項目建構 (在 C# 中，在 C + + /cli CLR，並在 Visual Basic 中)。 [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md)在 C# 中，[每個](/cpp/dotnet/for-each-in)C + /cli CLR，和[每個](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)Visual Basic 中)。
  
 這個方法可讓您逐一查看字串中的個別字元。 例如，Visual Basic`For Each`和 C#`foreach`陳述式會叫用此方法以傳回<xref:System.CharEnumerator>可唯讀存取這個字串執行個體中的字元的物件。  
  
   
  
## Examples  
 下列範例會逐一查看數個字串中的字元，並顯示其個別字元的相關資訊。 它會使用語言的反覆項目建構，而不是呼叫<xref:System.String.GetEnumerator%2A>方法。  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個字串的雜湊碼。</summary>
        <returns>32 位元帶正負號的整數雜湊碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 行為<xref:System.String.GetHashCode%2A>取決於它的實作，可能會變更到另一個版本的 common language runtime。 這種情形的原因是要提升的效能<xref:System.String.GetHashCode%2A>。  
  
> [!IMPORTANT]
>  如果兩個字串物件是否相等，<xref:System.String.GetHashCode%2A>方法會傳回相同的值。 不過，沒有每個唯一的字串值的唯一雜湊程式碼值。 不同的字串可能會傳回相同的雜湊碼。  
>   
>  不保證雜湊程式碼本身是穩定的。 跨.NET 實作、 跨.NET 版本和跨.NET 平台 （例如 32 位元和 64 位元） 的單一.NET 版本，可以不同於相同字串的雜湊碼。 在某些情況下，它們甚至可以與應用程式定義域。 這表示兩個後續執行相同的程式可能會傳回不同的雜湊碼。  
>   
>  如此一來，雜湊程式碼應該永遠不會使用外部應用程式定義域中他們所建立，它們應該永遠不會當做索引鍵的欄位，在集合中，使用，以及它們應該永遠不會保存。  
>   
>  最後，不使用的雜湊程式碼而不是在您需要強式密碼編譯雜湊時密碼編譯雜湊函式所傳回的值。 密碼編譯雜湊，使用一個衍生自類別<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>或<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>類別。  
>   
>  如需有關雜湊碼的詳細資訊，請參閱<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。  
  
 在桌面應用程式，您可以使用[ \<UseRandomizedStringHashAlgorithm > 項目](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)來產生唯一的雜湊程式碼在每個應用程式定義域為基準。 這可減少衝突的數目，並改善整體效能的插入和使用雜湊表的查詢。 下列範例示範如何使用[ \<UseRandomizedStringHashAlgorithm > 項目](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。 它會定義產生唯一的雜湊程式碼在每個應用程式定義域為基準。 這可減少衝突的數目，並改善整體效能的插入和使用雜湊表的查詢。 下列範例示範如何使用。 它會定義`DisplayString`類別，其中包含私用的字串常數， `s`，其值為"This is 字串"。 它也包含 `ShowStringHashCode` 方法，這個方法會將字串值及其雜湊碼與方法執行所在之應用程式定義域的名稱一起顯示。  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 當您在沒有提供組態檔的情況下執行此範例，它會顯示類似下列的輸出。 請注意，字串的雜湊碼在兩個應用程式定義域中相同。  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 不過，如果您將下列組態檔加入至範例的目錄，然後執行這個範例，相同字串的雜湊碼將會因為應用程式定義域不同而有所不同。  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 當組態檔存在時，這個範例會顯示下列輸出：  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  雜湊程式碼用來插入並有效率地擷取雜湊資料表的索引鍵的物件。 不過，雜湊程式碼沒有可唯一識別字串。 相同的字串具有相同的雜湊碼，但 common language runtime 也可以將相同的雜湊程式碼指派給不同的字串。 此外，雜湊程式碼可能會不同的.NET 版本、 平台內的單一版本，和應用程式定義域。 基於這個原因，您不應該序列化，或保存雜湊程式碼的值，也不應該使用它們做為索引鍵的雜湊表或字典中。  
  
 如需使用雜湊碼的其他資訊和`GetHashCode`方法，請參閱<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.GetHashCode%2A>使用不同的方法輸入字串。  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>所傳回的值<see cref="M:System.String.GetHashCode" />平台而異。 不同於 32 位元和 64 位元版本的.NET Framework。 它也可以與不同版本的.NET Framework 和.NET Core 之間。</para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt;項目</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回類別 <see cref="T:System.TypeCode" /> 的 <see cref="T:System.String" />。</summary>
        <returns>列舉常數 <see cref="F:System.TypeCode.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會顯示<xref:System.TypeCode>列舉的常數，<xref:System.String>型別。  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>報告這個執行個體中指定之 Unicode 字元或字串第一次出現時的所在索引 (以零為起始)。 如果在此執行個體中找不到該字元或字串，此方法會傳回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的 Unicode 字元。</param>
        <summary>報告這個字串中指定之 Unicode 字元第一次出現時的所在索引 (以零為起始)。</summary>
        <returns>如果找到該字元，則為 <paramref name="value" /> 以零為起始的索引位置，如果找不到為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。  
  
 這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。 若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。  
  
   
  
## Examples  
 下列範例示範如何搜尋<xref:System.String>字元，使用<xref:System.String.IndexOf%2A>方法。  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字串。</param>
        <summary>回報這個執行個體中指定之字串第一次出現時的所在索引 (以零為起始)。</summary>
        <returns>如果找到該字串，則為 <paramref name="value" /> 以零為起始的索引位置，如未找到，則為 -1。 如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。  
  
 這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。 搜尋這個執行個體的第一個字元位置開始，並接著直到最後一個字元位置。  
  
 字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。 執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。 如果`value`只包含一個或多個可忽略的字元，<xref:System.String.IndexOf%28System.String%29>方法一律會傳回 0 （零），以指出找到相符項目時，會在目前的執行個體的開頭。 在下列範例中，<xref:System.String.IndexOf%28System.String%29>方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)，後面接著"n"，選擇性連字號和選擇性的連字號後面接著"m"）。 只有其中一個字串包含選擇性連字號。 如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在每個案例中，因為選擇性連字號是可忽略的字元，如果結果為相同因為選擇性連字號不包含在`value`。 搜尋的軟連字號只能時，則方法會傳回 0 （零），指出它已在字串的開頭找到相符項目。  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 下列範例會搜尋"n"在"animal"。 由於字串索引從零，而不是一個開始<xref:System.String.IndexOf%28System.String%29>方法指出"n"是在位置 1。  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 下列範例會使用<xref:System.String.IndexOf%2A>方法，以判斷動物的名稱在句子中的開始位置。 然後會使用這個位置插入句子描述動物形容詞。  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。 若要尋找的字串執行個體中子字串的第一個索引，使用目前文化特性的比較規則，呼叫<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其`comparisonType`參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的 Unicode 字元。</param>
        <param name="startIndex">搜尋開始位置。</param>
        <summary>報告這個字串中指定之 Unicode 字元第一次出現時的所在索引 (以零為起始)。 搜尋從指定的字元位置開始。</summary>
        <returns>如果找到該字元，則為從字串起始處之 <paramref name="value" /> 的以零為起始索引位置，如果找不到，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引編號從 0 開始。 `startIndex` 參數的範圍可以從 0 到字串執行個體的長度。 如果`startIndex`等於字串執行個體的長度，則方法會傳回-1。  
  
 搜尋範圍是從`startIndex`到字串結尾。  
  
 這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。 若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.IndexOf%2A>方法。  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 小於 0 (零) 或大於字串的長度。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字元。</param>
        <param name="comparisonType">列舉值，其指定搜尋規則。</param>
        <summary>報告這個字串中指定 Unicode 字元第一次出現時的所在索引 (以零為起始)。 參數會指定要用於指定字元的搜尋類型。</summary>
        <returns>如果找到該字元，則為 <paramref name="value" /> 以零為起始的索引；如果找不到，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

編號從零開始編製索引。  
  
`comparisonType`參數是<xref:System.StringComparison>列舉的成員，指定是否搜尋`value`引數會使用目前或而異的文化特性，區分大小寫或區分大小寫，或使用 word 或序數比較規則。
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字串。</param>
        <param name="startIndex">搜尋開始位置。</param>
        <summary>回報這個執行個體中指定之字串第一次出現時的所在索引 (以零為起始)。 搜尋從指定的字元位置開始。</summary>
        <returns>如果找到該字串，則為從目前執行個體起始處之 <paramref name="value" /> 的以零為起始索引位置；如果找不到，則為 -1。 如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引編號從 0 開始。 `startIndex` 參數的範圍可以從 0 到字串執行個體的長度。 如果`startIndex`等於字串執行個體的長度，則方法會傳回-1。  
  
 這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。 搜尋開始`startIndex`字元位置，這個執行個體，並接著直到最後一個字元位置。  
  
 字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。 執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。 如果`value`只包含一個或多個可忽略的字元，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>方法一律會傳回`startIndex`，這是搜尋開始處的字元位置。 在下列範例中，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>方法用來尋找後面接著"m"兩個字串中選擇性連字號 (U + 00AD) 的位置。 只有其中一個字串包含必要的子字串。 如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引。 請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 下列範例會搜尋指定的字串，在目標字串內的所有項目。  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 小於 0 (零) 或大於這個字串的長度。</exception>
        <block subset="none" type="usage"><para>中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。 若要尋找特定的字元位置之後，就會發生子字串的第一個索引，使用目前文化特性的比較規則，請呼叫<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其`comparisonType`參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字串。</param>
        <param name="comparisonType">其中一個列舉值，指定搜尋規則。</param>
        <summary>報告目前 <see cref="T:System.String" /> 物件中指定之字串第一次出現時的所在索引 (以零為起始)。 參數會指定要用於指定字串的搜尋類型。</summary>
        <returns>如果找到該字串，則為 <paramref name="value" /> 的索引位置，如果沒有找到，則為 -1。 如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。  
  
 `comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用 word 或序數比較規則。  
  
   
  
## Examples  
 下列範例示範三個多載<xref:System.String.IndexOf%2A>找出第一個字串在字串中使用的不同值的另一個字串的方法<xref:System.StringComparison>列舉型別。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。 執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。 如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />方法一律會傳回 0 （零），以指出找到相符項目時，會在目前的執行個體的開頭。  
  
在下列範例中，<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)，後面接著"n"，選擇性連字號和選擇性的連字號後面接著"m"）。 只有其中一個字串包含選擇性連字號。 如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，因為選擇性連字號是可忽略的字元，區分文化特性的搜尋會傳回相同的值，它會傳回選擇性連字號所不包含搜尋字串中。 序數搜尋，不過，成功於一個字串中找到選擇性連字號，並報告它不存在從第二個字串。  
  
[!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的 Unicode 字元。</param>
        <param name="startIndex">搜尋開始位置。</param>
        <param name="count">要檢視的字元位置數目。</param>
        <summary>報告這個執行個體中指定之字元第一次出現時的所在索引 (以零為起始)。 搜尋從指定的字元位置開始，並檢視指定數目的字元位置。</summary>
        <returns>如果找到該字元，則為從字串起始處之 <paramref name="value" /> 的以零為起始索引位置，如果找不到，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋開始於`startIndex`，並持續`startIndex`  +  `count` -1。 在字元`startIndex`  +  `count`不會包含在搜尋中。  
  
 編號從 0 （零） 的開始索引。 `startIndex` 參數的範圍可以從 0 到字串執行個體的長度。  
  
 這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。 若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.IndexOf%2A>方法。  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 或 <paramref name="startIndex" /> 為負。  
  
-或- 
 <paramref name="startIndex" /> 大於這個字串的長度。  
  
-或- 
 <paramref name="count" /> 大於這個字串減 <paramref name="startIndex" /> 的長度。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字串。</param>
        <param name="startIndex">搜尋開始位置。</param>
        <param name="count">要檢視的字元位置數目。</param>
        <summary>回報這個執行個體中指定之字串第一次出現時的所在索引 (以零為起始)。 搜尋從指定的字元位置開始，並檢視指定數目的字元位置。</summary>
        <returns>如果找到該字串，則為從目前執行個體起始處之 <paramref name="value" /> 的以零為起始索引位置；如果找不到，則為 -1。 如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從 0 （零） 的開始索引。 `startIndex` 參數的範圍可以從 0 到字串執行個體的長度。  
  
 這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。 搜尋開始於`startIndex`，並持續`startIndex`  +  `count` -1。 在字元`startIndex`  +  `count`不會包含在搜尋中。  
  
 字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。 執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。 如果`value`只包含一個或多個可忽略的字元，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法一律會傳回`startIndex`，這是搜尋開始處的字元位置。 在下列範例中，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法用來尋找選擇性連字號 (U + 00AD) 後面接著"m"中的第三個透過兩個字串中的第六個字元位置開始的位置。 只有其中一個字串包含必要的子字串。 如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。 請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 下列範例會尋找所有出現字串的索引"he"另一個字串的子字串內。 請注意要搜尋的字元數，必須重新計算針對每個搜尋反覆項目。  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 或 <paramref name="startIndex" /> 為負。  
  
-或- 
 <paramref name="startIndex" /> 大於這個字串的長度。  
  
-或- 
 <paramref name="count" /> 大於這個字串減 <paramref name="startIndex" /> 的長度。</exception>
        <block subset="none" type="usage"><para>中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。 若要使用目前文化特性的比較規則，執行這項作業，呼叫<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其`comparisonType`參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字串。</param>
        <param name="startIndex">搜尋開始位置。</param>
        <param name="comparisonType">其中一個列舉值，指定搜尋規則。</param>
        <summary>報告目前 <see cref="T:System.String" /> 物件中指定之字串第一次出現時的所在索引 (以零為起始)。 參數會指定目前字串中的開始搜尋位置和要用於指定字串的搜尋類型。</summary>
        <returns>如果找到該字串，則為從目前執行個體起始處之 <paramref name="value" /> 參數的以零為起始索引位置；如果找不到，則為 -1。 如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引編號從 0 開始。 `startIndex` 參數的範圍可以從 0 到字串執行個體的長度。 如果`startIndex`等於字串執行個體的長度，則方法會傳回-1。  
  
 `comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用 word 或序數比較規則。  
  
   
  
## Examples  
 下列 exampledemonstrates 三個多載<xref:System.String.IndexOf%2A>找出第一個字串在字串中使用的不同值的另一個字串的方法<xref:System.StringComparison>列舉型別。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 小於 0 (零) 或大於這個字串的長度。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。 執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。 如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />方法一律會傳回<paramref name="startIndex" />，這是搜尋開始處的字元位置。  
  
在下列範例中，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />方法用來尋找選擇性連字號 (U + 00AD) 後面接著"m"從兩個字串中的第三個字元位置開始的位置。 只有其中一個字串包含必要的子字串。如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。 請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。 只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。  
  
[!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字串。</param>
        <param name="startIndex">搜尋開始位置。</param>
        <param name="count">要檢視的字元位置數目。</param>
        <param name="comparisonType">其中一個列舉值，指定搜尋規則。</param>
        <summary>報告目前 <see cref="T:System.String" /> 物件中指定之字串第一次出現時的所在索引 (以零為起始)。 參數會指定目前字串中的開始搜尋位置、目前字串中要搜尋的字元數目，以及要用於指定字串的搜尋類型。</summary>
        <returns>如果找到該字串，則為從目前執行個體起始處之 <paramref name="value" /> 參數的以零為起始索引位置；如果找不到，則為 -1。 如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從 0 （零） 的開始索引。 `startIndex` 參數的範圍可以從 0 到字串執行個體的長度。  
  
 搜尋開始於`startIndex`，並持續`startIndex`  +  `count` -1。 在字元`startIndex`  +  `count`不會包含在搜尋中。  
  
 `comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用 word 或序數比較規則。  
  
   
  
## Examples  
 下列 exampledemonstrates 三個多載<xref:System.String.IndexOf%2A>找出第一個字串在字串中使用的不同值的另一個字串的方法<xref:System.StringComparison>列舉型別。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 或 <paramref name="startIndex" /> 為負。  
  
-或- 
 <paramref name="startIndex" /> 大於這個執行個體的長度。  
  
-或- 
 <paramref name="count" /> 大於這個字串減 <paramref name="startIndex" /> 的長度。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。 執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。 如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法一律會傳回<paramref name="startIndex" />，這是搜尋開始處的字元位置。  
  
在下列範例中，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法用來尋找選擇性連字號 (U + 00AD) 後面接著"m"中的第三個透過兩個字串中的第六個字元位置開始的位置。 只有其中一個字串包含必要的子字串。 如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。 當它執行序數比較時，不過，它會尋找子字串只在第一個字串中。 請注意，第一個字串，其中包含選擇性的連字號後面接著"m"，如果方法無法傳回選擇性連字號的索引，但改為傳回"m"的索引，當它執行區分文化特性的比較。 只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。  
  
[!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>報告指定 Unicode 字元陣列中的任何字元於這個執行個體中第一個符合項目的索引。 如果在此執行個體中找不到陣列中的字元，此方法會傳回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字元陣列，含有一或多個要搜尋的字元。</param>
        <summary>報告指定的 Unicode 字元陣列中，任何字元在這個執行個體中第一次出現時的所在索引 (以零為起始)。</summary>
        <returns>在此執行個體中，<paramref name="anyOf" /> 中的任何字元第一次出現的所在索引位置 (以零為起始)，如果找不到 <paramref name="anyOf" /> 中的字元，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。  
  
 搜尋`anyOf`會區分大小寫。 如果`anyOf`是空的陣列，字串的開頭比對方法找到 （亦即，索引位置為零）。  
  
 這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。 若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。  
  
   
  
## Examples  
 下列範例會尋找字串中的第一個母音。  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字元陣列，含有一或多個要搜尋的字元。</param>
        <param name="startIndex">搜尋開始位置。</param>
        <summary>報告指定的 Unicode 字元陣列中，任何字元在這個執行個體中第一次出現時的所在索引 (以零為起始)。 搜尋從指定的字元位置開始。</summary>
        <returns>在此執行個體中，<paramref name="anyOf" /> 中的任何字元第一次出現的所在索引位置 (以零為起始)，如果找不到 <paramref name="anyOf" /> 中的字元，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。 `startIndex`參數的範圍可以從 0 到小於字串執行個體的長度。  
  
 搜尋範圍是從`startIndex`到字串結尾。  
  
 搜尋`anyOf`會區分大小寫。  
  
 這個方法會執行序數 （不區分文化特性） 搜尋，其中只有當其 Unicode 純量值都是相同字元即視為相當於另一個字元。 若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。  
  
   
  
## Examples  
 下列範例會尋找相符項目的任何字元字串的索引"is"另一個字串的子字串內。  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 為負。  
  
-或- 
 <paramref name="startIndex" /> 大於這個執行個體的字元數。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字元陣列，含有一或多個要搜尋的字元。</param>
        <param name="startIndex">搜尋開始位置。</param>
        <param name="count">要檢視的字元位置數目。</param>
        <summary>報告指定的 Unicode 字元陣列中，任何字元在這個執行個體中第一次出現時的所在索引 (以零為起始)。 搜尋從指定的字元位置開始，並檢視指定數目的字元位置。</summary>
        <returns>在此執行個體中，<paramref name="anyOf" /> 中的任何字元第一次出現的所在索引位置 (以零為起始)，如果找不到 <paramref name="anyOf" /> 中的字元，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋開始於`startIndex`，並持續`startIndex`  +  `count` -1。 在字元`startIndex`  +  `count`不會包含在搜尋中。  
  
 編號從零開始編製索引。 `startIndex`參數的範圍可以從 0 到小於字串執行個體的長度。  
  
 搜尋`anyOf`會區分大小寫。  
  
 這個方法會執行序數 （不區分文化特性） 搜尋，其中只有當其 Unicode 純量值都是相同字元即視為相當於另一個字元。 若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。  
  
   
  
## Examples  
 下列範例會尋找另一個字串的子字串內的任何字元的字串"aid"的相符項目索引。  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 或 <paramref name="startIndex" /> 為負。  
  
-或- 
 <paramref name="count" /> + <paramref name="startIndex" /> 大於這個執行個體的字元數。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">插入的索引位置 (以零為起始)。</param>
        <param name="value">要插入的字串。</param>
        <summary>傳回新字串，其中已在這個執行個體中指定的索引位置插入指定的字串。</summary>
        <returns>與這個執行個體相等的新字串，但是在 <paramref name="value" /> 位置插入了 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`startIndex`等於這個執行個體，長度`value`附加至這個執行個體的結尾。  
  
> [!NOTE]
>  這個方法不會修改目前的執行個體的值。 相反地，它會傳回新字串，其中`value`插入至目前的執行個體。  
  
 例如，傳回值的`"abc".Insert(2, "XYZ")`是 「 abXYZc"。  
  
   
  
## Examples  
 下列範例會插入空格字元在字串的第四個字元位置 （位於索引 3 的字元）。  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 下列主控台應用程式會提示使用者輸入來描述兩個動物的一或多個形容詞。 然後它會呼叫<xref:System.String.Insert%2A>方法以將使用者輸入字串的文字。  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 是負值或大於這個執行個體的長度。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="str">要在保留集區中搜尋的字串。</param>
        <summary>擷取指定的 <see cref="T:System.String" /> 的系統參考。</summary>
        <returns>如果已經保留，則為系統的 <paramref name="str" /> 參考，否則為具有 <paramref name="str" /> 值之字串的新參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通用語言執行平台讓維護稱為保留集區，包含每個唯一的常值字串，宣告或以程式設計方式建立您的程式中的單一參考的資料表，以節省字串儲存體。 因此，含有特定值的常值字串的執行個體只存在於一次在系統中。  
  
 比方說，如果您將相同的常值字串指派給數個變數時，執行階段擷取的常值字串來保留集區從相同的參考，並將它指派給每個變數。  
  
 <xref:System.String.Intern%2A>方法會保留集區使用的值相等的字串搜尋`str`。 如果這類字串已存在，則會傳回其在保留集區的參考。 如果字串不存在，參考`str`保留集區，則會傳回該參考加入。  
  
 在下列範例中，字串 s1，其 「 MyTest"的值，是已經被保留，因為它是在程式中的常值。 <xref:System.Text.StringBuilder?displayProperty=nameWithType>類別會產生新的字串物件，其與 s1 相同的值。 該字串的參考，則指派給 s2。 <xref:System.String.Intern%2A>方法搜尋字串具有相同的值為 s2。 因為有這樣的字串，這個方法會傳回相同的參考指派至 s1。 接著，該參考會指派給 s3。 參考 s1 和 s2 比較相等因為它們參考不同的物件;參考 s1 與 s3 比較相等，因為它們參考相同的字串。  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 比較這個方法，以<xref:System.String.IsInterned%2A>方法。  
  
## <a name="version-considerations"></a>版本的考量  
 在  [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]，則<xref:System.String.Intern%2A>方法還原成其行為在.NET Framework 1.0 和 1.1 方面暫留空字串。 在下列範例中，變數`str1`參考會指派給<xref:System.String.Empty>，和變數`str2`指派參考<xref:System.String.Empty>藉由呼叫傳回<xref:System.String.Intern%2A>方法之後轉換<xref:System.Text.StringBuilder>物件，其值為<xref:System.String.Empty>為字串。 然後參考包含在`str1`和`str2`會比較是否相等。  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 在  [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]， [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]，並[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]，`str1`和`str2`相等。 在 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]並[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]，`str1`和`str2`是否不相等。  
  
## <a name="performance-considerations"></a>效能考量  
 如果您嘗試降低記憶體總數量會配置您的應用程式，請記住，暫留 」 字串有兩個不必要的副作用。 首先，記憶體配置的暫留<xref:System.String>物件可能不會發行到 common language runtime (CLR) 結束為止。 原因是保留的 CLR 參考<xref:System.String>物件可以保存您的應用程式或甚至是您的應用程式定義域之後，會終止。 其次，若 intern 字串，您必須先建立字串。 所使用的記憶體<xref:System.String>物件必須仍配置，即使記憶體最終將會回收。  
  
 .NET Framework 2.0 版導入了<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType>列舉成員。 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>成員標示為不需要字串常值暫留 」 組件。 您可以套用<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>使用的組件<xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute>屬性。 此外，當您使用[Ngen.exe （原生映像產生器）](~/docs/framework/tools/ngen-exe-native-image-generator.md)編譯組件之前 執行階段，字串不暫留在模組。  
  
   
  
## Examples  
 下列範例使用三個相等值，以判斷是否為新建立的字串中的字串，並保留的字串相等。  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="str">要在保留集區中搜尋的字串。</param>
        <summary>擷取對指定 <see cref="T:System.String" /> 的參考。</summary>
        <returns>如果是在 Common Language Runtime 保留集區中，則為 <paramref name="str" /> 的參考，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Common language runtime 會自動維護的資料表，稱為保留集區，其中包含宣告的程式，以及任何唯一的執行個體的每個唯一的常值字串常數的單一執行個體<xref:System.String>藉由呼叫以程式設計方式新增<xref:System.String.Intern%2A>方法。  
  
 保留集區可節省的字串存放區。 如果您將常值的字串常數指派給數個變數時，每個變數會設定為參考相同的常數在保留集區，而不是參考的數個不同的執行個體<xref:System.String>有相同的值。  
  
 這個方法會查詢`str`在保留集區。 如果`str`已經過暫留，該執行個體的參考會傳回; 否則即為`null`會傳回。  
  
 比較這個方法，以<xref:System.String.Intern%2A>方法。  
  
 這個方法不會傳回布林值。 如果您呼叫方法，因為您想要的布林值，指出是否要暫留的特定字串，您可以使用如下所示的程式碼。  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  從.NET Framework 2.0 版開始，您可以覆寫保留集區使用當您使用[Ngen.exe （原生映像產生器）](~/docs/framework/tools/ngen-exe-native-image-generator.md)組件安裝至本機電腦的原生映像快取。 如需詳細資訊，請參閱 < 備註 > 一節中的效能考量<xref:System.String.Intern%2A>屬性。  
  
   
  
## Examples  
 下列範例會示範，常值字串暫留會自動由編譯器。  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指出這個字串是否為特定的 Unicode 正規化格式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指出這個字串是否為 Unicode 正規化格式 C。</summary>
        <returns>如果這個字串為正規化格式 C，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些 Unicode 字元有多個對等的二進位表示，其中包含結合的集合及/或複合的 Unicode 字元。 搜尋、 排序、 比對，以及其他作業，則存在單一字元的多種表示法變得非常複雜。  
  
 Unicode 標準會定義稱為傳回一個二進位表示法指定任何對等的二進位表示的字元時的正規化程序。 可使用數種演算法，稱為正規化表單，可遵循不同的規則執行正規化。 .NET 目前支援的正規化表單 C、 D、 KC 和 KD。  
  
 如需支援的 Unicode 正規化格式的說明，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例會判斷字串是否成功正規化各種的正規化形式。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的執行個體包含無效的 Unicode 字元。</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" />方法會傳回<see langword="false" />當它遇到第一個非標準化字元在字串中的。 因此，如果字串包含非標準化的字元，後面接著無效的 Unicode 字元<see cref="Overload:System.String.Normalize" />方法會擲回<see cref="T:System.ArgumentException" />雖然<see cref="Overload:System.String.IsNormalized" />傳回<see langword="false" />。</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Unicode 正規化格式。</param>
        <summary>指出這個字串是否為指定的 Unicode 正規化格式。</summary>
        <returns>如果這個字串為 <see langword="true" /> 參數指定的正規化格式，則為 <paramref name="normalizationForm" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些 Unicode 字元有多個對等的二進位表示，其中包含結合的集合及/或複合的 Unicode 字元。 搜尋、 排序、 比對，以及其他作業，則存在單一字元的多種表示法變得非常複雜。  
  
 Unicode 標準會定義稱為傳回一個二進位表示法指定任何對等的二進位表示的字元時的正規化程序。 可使用數種演算法，稱為正規化表單，可遵循不同的規則執行正規化。 .NET 目前支援的正規化表單 C、 D、 KC 和 KD。  
  
 如需支援的 Unicode 正規化格式的說明，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.IsNormalized%2A>和<xref:System.String.Normalize%2A>方法。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的執行個體包含無效的 Unicode 字元。</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" />方法會傳回<see langword="false" />當它遇到第一個非標準化字元在字串中的。 因此，如果字串包含非標準化的字元，後面接著無效的 Unicode 字元<see cref="Overload:System.String.Normalize" />方法會擲回<see cref="T:System.ArgumentException" />雖然<see cref="Overload:System.String.IsNormalized" />傳回<see langword="false" />。</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要測試的字串。</param>
        <summary>表示指定的字串是否為 <see langword="null" /> 或空字串 ("")。</summary>
        <returns>如果 <see langword="true" /> 參數為 <paramref name="value" /> 或空字串 ("")，則為 <see langword="null" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> 是一種便利方法，可讓您以同時測試是否<xref:System.String>已`null`或其值為<xref:System.String.Empty?displayProperty=nameWithType>。 相當於下列程式碼：  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 您可以使用<xref:System.String.IsNullOrWhiteSpace%2A>方法來測試字串是否`null`，其值是<xref:System.String.Empty?displayProperty=nameWithType>，或它只包含泛空白字元。  
  
## <a name="what-is-a-null-string"></a>什麼是 null 字串？

字串是`null`如果它尚未指派的值 （以 c + + 和 Visual Basic），或如果已明確地被指派值為`null`。 雖然[複合格式](~/docs/standard/base-types/composite-formatting.md)功能可以正常處理 null 的字串，如下列範例所示，嘗試呼叫其中一個，如果其成員擲回<xref:System.NullReferenceException>。  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>什麼是空字串？  

字串是空明確指派為空字串 ("") 或<xref:System.String.Empty?displayProperty=nameWithType>。 空的字串具有<xref:System.String.Length%2A>為 0。  下列範例會建立空的字串，並顯示它的值，它的長度。  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 下列範例會檢查三個字串，並判斷每個字串的值、 為空字串，或為`null`。  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要測試的字串。</param>
        <summary>表示指定的字串是否為 <see langword="null" />、空白，或只由空白字元組成的字串。</summary>
        <returns>如果 <see langword="true" /> 參數是 <paramref name="value" /> 或 <see langword="null" />，或者 <see cref="F:System.String.Empty" /> 完全由空白字元組成，則為 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> 是很便利的方法大致如下列程式碼中，不同之處在於它提供更優異的效能：  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 泛空白字元是由 Unicode 標準定義。 <xref:System.String.IsNullOrWhiteSpace%2A>方法會傳回值的任何字元將解譯`true`則會傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>為空格字元的方法。  
  
   
  
## Examples  
 下列範例會建立字串陣列，並接著將傳遞至陣列的每個項目<xref:System.String.IsNullOrWhiteSpace%2A>方法。  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>串連指定之陣列的項目或集合的成員，並在每個項目或成員之間使用指定的分隔符號。</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">要當作分隔符號的字串。<paramref name="separator" /> 只有在 <paramref name="values" /> 有一個以上的項目時，才會包含在傳回的字串中。</param>
        <param name="values">包含要串連之字串的集合。</param>
        <summary>串連類型 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 之已建構的 <see cref="T:System.String" /> 集合的成員，並在每個成員之間使用指定的分隔符號。</summary>
        <returns>字串，由 <paramref name="values" /> 中的成員組成，且每個成員之間都會以 <paramref name="separator" /> 字串分隔。 如果 <paramref name="values" /> 沒有成員，方法會傳回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`separator`已`null`、 空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 會改為使用。 如果任何屬於`values`是`null`，改為使用空字串。  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 是一種便利方法，可讓您串連每個項目`IEnumerable(Of String)`集合，而不先將項目轉換成字串陣列。 它特別適合使用 Language-Integrated Query (LINQ) 查詢運算式。 下列範例會傳遞`List(Of String)`物件，包含 lambda 運算式會選取等於或大於特定字母 （即，在範例中，"M"） 的字母英文字母大寫或小寫字母。 `IEnumerable(Of String)`所傳回的集合<xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>方法會傳遞至<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法來顯示結果，以單一字串。  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。 它會將結果指派<xref:System.Collections.Generic.List%601>類型的物件<xref:System.String>，這會接著傳遞給<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法。  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">要當做分隔符號的字串。 只有在 <paramref name="values" /> 的元素有一個以上時，<paramref name="separator" /> 才會包含在傳回的字串中。</param>
        <param name="values">含有要串連之項目的陣列。</param>
        <summary>串連物件陣列的項目，並在每個項目之間使用指定的分隔符號。</summary>
        <returns>字串，由 <paramref name="values" /> 的項目組成，且每個項目之間都會以 <paramref name="separator" /> 字串分隔。 如果 <paramref name="values" /> 為空陣列，則方法會傳回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`separator`是`null`或任何項目`values`以外的第一個元素不`null`，空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 會改為使用。 請參閱呼叫端一節的資訊，如果第一個項目`values`是`null`。  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> 是一種便利方法，可讓您串連物件陣列中的每個項目，而不需要明確地將其項目轉換為字串。 藉由呼叫該物件的陣列中的每個物件的字串表示衍生`ToString`方法。  
  
   
  
## Examples  
 下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。 它會將結果指派到的整數陣列，然後將傳遞給<xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>方法。  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>如果第一個項目<paramref name="values" />是<see langword="null" />，則<see cref="M:System.String.Join(System.String,System.Object[])" />方法不會串連中的項目<paramref name="values" />而是傳回<see cref="F:System.String.Empty" />。 提供此問題的因應措施的數目。 若要指派的值的最簡單的方法是<see cref="F:System.String.Empty" />陣列的第一個元素，如下列範例所示。  
  
[!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">要當做分隔符號的字串。 只有在 <paramref name="value" /> 的元素有一個以上時，<paramref name="separator" /> 才會包含在傳回的字串中。</param>
        <param name="value">含有要串連之項目的陣列。</param>
        <summary>串連字串陣列的所有項目，並在每個項目之間使用指定的分隔符號。</summary>
        <returns>字串，由 <paramref name="value" /> 中的項目組成，且每個項目之間都會以 <paramref name="separator" /> 字串分隔。 如果 <paramref name="value" /> 為空陣列，則方法會傳回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比方說，如果`separator`是"，"的項目和`value`是"apple"、 「 橙色 」、 「 grape 處理 」 和 「 西洋梨"`Join(separator, value)`傳回 「 apple、 orange、 grape 處理、 西洋梨"。  
  
 如果`separator`已`null`、 空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 會改為使用。 如果在任何項目`value`是`null`，改為使用空字串。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.Join%2A>方法。  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">要當做分隔符號的字串。 只有在 <paramref name="value" /> 的元素有一個以上時，<paramref name="separator" /> 才會包含在傳回的字串中。</param>
        <param name="value">含有要串連之項目的陣列。</param>
        <param name="startIndex"><paramref name="value" /> 中要使用的第一個項目。</param>
        <param name="count">要使用的 <paramref name="value" /> 項目數目。</param>
        <summary>串連字串陣列的指定項目，並在每個項目之間使用指定的分隔符號。</summary>
        <returns>由 <paramref name="value" /> 中之字串組成的字串，每個字串之間都以 <paramref name="separator" /> 字串隔開。  
  
-或- 
 如果 <see cref="F:System.String.Empty" /> 為零、<paramref name="count" /> 沒有任何項目，或 <paramref name="value" /> 和 <paramref name="separator" /> 的所有項目都是 <paramref name="value" />，則為 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比方說，如果`separator`是"，"的項目和`value`是"apple"、 「 橙色 」、 「 grape 處理 」 和 「 西洋梨"`Join(separator, value, 1, 2)`傳回 「 橙色，grape 處理 」。  
  
 如果`separator`已`null`、 空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 會改為使用。 如果在任何項目`value`是`null`，改為使用空字串。  
  
   
  
## Examples  
 下列範例會串連兩個項目從水果名稱陣列。  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="count" /> 小於 0。  
  
-或- 
 <paramref name="startIndex" /> 加上 <paramref name="count" /> 大於 <paramref name="value" /> 中的項目數。</exception>
        <exception cref="T:System.OutOfMemoryException">記憶體不足。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> 之成員的類型。</typeparam>
        <param name="separator">要當作分隔符號的字串。<paramref name="separator" /> 只有在 <paramref name="values" /> 有一個以上的項目時，才會包含在傳回的字串中。</param>
        <param name="values">包含要串連之物件的集合。</param>
        <summary>串連集合的成員，並在每個成員之間使用指定的分隔符號。</summary>
        <returns>字串，由 <paramref name="values" /> 中的成員組成，且每個成員之間都會以 <paramref name="separator" /> 字串分隔。 如果 <paramref name="values" /> 沒有成員，方法會傳回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`separator`已`null`、 空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 會改為使用。 如果任何屬於`values`是`null`，改為使用空字串。  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 是一種便利方法，可讓您串連的每個成員<xref:System.Collections.Generic.IEnumerable%601>而不先將它們轉換成字串的集合。 在每個物件的字串表示<xref:System.Collections.Generic.IEnumerable%601>集合藉由呼叫該物件衍生`ToString`方法。  
  
 這個方法是在特定使用 Language-Integrated Query (LINQ) 查詢運算式很有用。 例如，下列程式碼定義非常簡單`Animal`類別，其中包含針對 animal 和其所屬的順序的名稱。 然後它會定義<xref:System.Collections.Generic.List%601>物件，其中包含許多`Animal`物件。 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>會呼叫擴充方法來擷取`Animal`物件，而其`Order`屬性等於"齧齒動物 」。 結果會傳遞至<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法。  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。 它會將結果指派<xref:System.Collections.Generic.List%601>物件的整數類型，這會接著傳遞給<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法。  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>報告這個執行個體中指定之 Unicode 字元或字串最後一次出現時的所在索引 (以零為起始)。 如果在此執行個體中找不到該字元或字串，此方法會傳回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的 Unicode 字元。</param>
        <summary>報告這個執行個體中指定之 Unicode 字元最後一次出現時的所在索引 (以零為起始)。</summary>
        <returns>如果找到該字元，則為 <paramref name="value" /> 以零為起始的索引位置，如果找不到為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。 也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。  
  
 這個方法會在這個執行個體的最後一個字元位置開始搜尋，然後反向朝直到開始`value`找到或已經檢查的第一個字元位置。 搜尋會區分大小寫。  
  
 這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。 若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。  
  
   
  
## Examples  
 下列範例會定義`ExtractFilename`方法，以使用<xref:System.String.LastIndexOf%28System.Char%29>方法來尋找字串中的最後一個目錄分隔符號字元，並擷取字串的檔案名稱。 如果檔案存在，則方法會傳回不包含其路徑的檔案名稱。  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字串。</param>
        <summary>回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。</summary>
        <returns>如果找到該字串，則為 <paramref name="value" /> 以零為起始的起始索引位置，如未找到，則為 -1。 如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值為這個執行個體中的最後一個索引位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。 也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。  
  
 搜尋這個執行個體的最後一個字元位置開始，然後反向朝直到開始`value`找到或已經檢查的第一個字元位置。  
  
 這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。  
  
 字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。 執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。 如果`value`只包含一個或多個可忽略的字元，<xref:System.String.LastIndexOf%28System.String%29>方法一律會傳回<xref:System.String.Length%2A?displayProperty=nameWithType>-1，表示目前執行個體之最後索引位置。 在下列範例中，<xref:System.String.LastIndexOf%28System.String%29>方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)，後面接著"n"，選擇性連字號和選擇性的連字號後面接著"m"）。 只有其中一個字串包含選擇性連字號。 如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在每個案例中，因為選擇性連字號是可忽略的字元，如果結果為相同因為選擇性連字號不包含在`value`。 搜尋的軟連字號只能時，這個方法會傳回 6 和 5。 這些值會對應至兩個字串中的最後一個字元索引。  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 下列範例會移除開頭和結尾的字串，如果標記開始與結束字串的 HTML 標記。 如果字串的結尾的右括弧字元 (">")，此範例會使用<xref:System.String.LastIndexOf%2A>方法來找出的結束標記開頭。  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。 若要尋找的字串執行個體中子字串的最後一個索引，使用目前文化特性的比較規則，呼叫<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的 Unicode 字元。</param>
        <param name="startIndex">搜尋的開始位置。 搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</param>
        <summary>報告這個執行個體中指定之 Unicode 字元最後一次出現時的所在索引 (以零為起始)。 搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</summary>
        <returns>如果找到該字元，則為 <paramref name="value" /> 的以零為起始索引位置，如果找不到該字元或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。 也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1.此方法會在開始搜尋`startIndex`字元位置，這個執行個體與繼續回溯直到目前的執行個體開頭`value`找到或已經檢查的第一個字元位置。 例如，如果`startIndex`是<xref:System.String.Length%2A>-1，該方法會搜尋字串中要開始從最後一個字元的每個字元。 搜尋會區分大小寫。  
  
 這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。 若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。  
  
   
  
## Examples  
 下列範例會尋找所有出現的字元索引，在字串中，使用從字串的結尾字串的開頭。  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於零，或者大於或等於這個執行個體的長度。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字串。</param>
        <param name="startIndex">搜尋開始位置。 搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</param>
        <summary>回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。 搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</summary>
        <returns>如果找到該字串，則為 <paramref name="value" /> 的以零為起始索引位置，如果找不到該字串或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。 如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" /> 或這個執行個體之最後索引位置，取兩者中較小者。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。 也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。  
  
 搜尋開始於`startIndex`字元位置，這個執行個體與繼續回溯直到開始朝向`value`找到或已經檢查的第一個字元位置。 例如，如果`startIndex`是<xref:System.String.Length%2A>-1，該方法會搜尋字串中要開始從最後一個字元的每個字元。  
  
 這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。  
  
 字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。 執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。 如果`value`只包含一個或多個可忽略的字元，<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>方法一律會傳回`startIndex`，這是搜尋開始處的字元位置。 在下列範例中，<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>方法用來尋找子字串，其中包含選擇性連字號 (U + 00AD)，以及之前或在字串中加入的最後一個的"m"。 如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，搜尋字串中的選擇性連字號會被忽略，因為呼叫方法來尋找子字串，包含選擇性連字號和"m"會傳回"m"的位置在字串中，而呼叫它來尋找 substring 包含選擇性連字號和"n"會傳回"n"的位置。 當搜尋字串不包含只選擇性連字號時，方法會傳回"m"，其代表的值索引`startIndex`。  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 下列範例會尋找所有出現的字串的索引，在目標字串中，從目標字串的結尾努力的目標字串的開頭。  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於零或大於目前執行個體的長度。  
  
-或- 
目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於 -1 或大於零。</exception>
        <block subset="none" type="usage"><para>中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。 若要尋找特定的字元位置之前使用目前文化特性的比較規則的子字串的索引，請呼叫<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字串。</param>
        <param name="comparisonType">其中一個列舉值，指定搜尋規則。</param>
        <summary>報告目前 <see cref="T:System.String" /> 物件中指定之字串最後一次出現時的所在索引 (以零為起始)。 參數會指定要用於指定字串的搜尋類型。</summary>
        <returns>如果找到該字串，則為 <paramref name="value" /> 參數的以零為起始的起始索引位置，否則為 -1。 如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值為這個執行個體中的最後一個索引位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。 也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。  
  
 `comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用 word 或序數比較規則。  
  
 搜尋這個執行個體的最後一個字元位置開始，然後反向朝直到開始`value`找到或已經檢查的第一個字元位置。  
  
   
  
## Examples  
 下列 exampledemonstrates 三個多載<xref:System.String.LastIndexOf%2A>尋找使用的不同值的另一個字串內的字串中的最後一次出現的方法<xref:System.StringComparison>列舉型別。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。 執行區分文化特性的搜尋 (也就是說，如果 <paramref name="options" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。 如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />方法一律會傳回<see cref="P:System.String.Length" />-1，表示目前執行個體之最後索引位置。  
  
在下列範例中，<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)，後面接著"n"，選擇性連字號和選擇性的連字號後面接著"m"）。 只有其中一個字串包含選擇性連字號。 如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，因為選擇性連字號是可忽略的字元，區分文化特性的搜尋會傳回相同的值，它會傳回選擇性連字號所不包含搜尋字串中。 序數搜尋，不過，成功於一個字串中找到選擇性連字號，並報告它不存在從第二個字串。  
  
[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的 Unicode 字元。</param>
        <param name="startIndex">搜尋的開始位置。 搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</param>
        <param name="count">要檢視的字元位置數目。</param>
        <summary>報告這個執行個體的子字串中，指定的 Unicode 字元最後一次出現時的所在索引 (以零為起始)。 搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</summary>
        <returns>如果找到該字元，則為 <paramref name="value" /> 的以零為起始索引位置，如果找不到該字元或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。 也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。  
  
 這個方法會在開始搜尋`startIndex`字元的位置和進行回溯朝這個執行個體的開頭，直到`value`找到或`count`已檢查的字元位置。 例如，如果`startIndex`是<xref:System.String.Length%2A>-1，此方法會向後搜尋`count`從字串中的最後一個字元的字元。 搜尋會區分大小寫。  
  
 這個方法會執行序數 （不區分文化特性） 搜尋，其中只有當其 Unicode 純量值都是相同字元即視為相當於另一個字元。 若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。  
  
   
  
## Examples  
 下列範例會尋找所有出現的字元的索引中的子字串中，然後再從子字串的結尾努力的子字串起點。  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於零，或者大於或等於這個執行個體的長度。  
  
-或- 
目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> - <paramref name="count" /> + 1 小於零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字串。</param>
        <param name="startIndex">搜尋開始位置。 搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</param>
        <param name="count">要檢視的字元位置數目。</param>
        <summary>回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。 搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</summary>
        <returns>如果找到該字串，則為 <paramref name="value" /> 的以零為起始索引位置，如果找不到該字串或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。 如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" /> 或這個執行個體之最後索引位置，取兩者中較小者。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。 也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。  
  
 搜尋開始於`startIndex`字元位置，這個執行個體與繼續回溯直到開始朝向`value`找到或`count`已檢查的字元位置。 例如，如果`startIndex`是<xref:System.String.Length%2A>-1，此方法會向後搜尋`count`從字串中的最後一個字元的字元。  
  
 這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。  
  
 字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。 執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。 如果`value`只包含一個或多個可忽略的字元，<xref:System.String.LastIndexOf%2A>方法一律會傳回`startIndex`，這是搜尋開始處的字元位置。 在下列範例中，<xref:System.String.LastIndexOf%2A>方法用來尋找在前面兩個字串的最後一個"m"的兩個字元的選擇性連字號 (U + 00AD) 的位置。 只有其中一個字串包含必要的子字串。 如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。 請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 下列範例會尋找所有出現的字串的索引中的子字串，從子字串的結尾努力的子字串起點。  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 為負。  
  
-或- 
目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 為負。  
  
-或- 
目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 大於這個執行個體的長度。  
  
-或- 
目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> - <paramref name="count" />+ 1 指定的位置不在此執行個體之內。  
  
-或- 
目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="start" /> 小於 -1 或大於零。  
  
-或- 
目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="count" /> 大於 1。</exception>
        <block subset="none" type="usage"><para>中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。 若要使用目前文化特性的比較規則，以執行這項作業，請呼叫<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字串。</param>
        <param name="startIndex">搜尋開始位置。 搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</param>
        <param name="comparisonType">其中一個列舉值，指定搜尋規則。</param>
        <summary>報告目前 <see cref="T:System.String" /> 物件中指定之字串最後一次出現時的所在索引 (以零為起始)。 搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。 參數會指定搜尋指定字串時要執行的比較類型。</summary>
        <returns>如果找到該字串，則為 <paramref name="value" /> 參數以零為起始的索引位置，如果找不到該字串或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。 如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" /> 或這個執行個體之最後索引位置，取兩者中較小者。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。 也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。  
  
 搜尋開始於`startIndex`字元位置與繼續回溯直到`value`找到或已經檢查的第一個字元位置。 例如，如果`startIndex`是<xref:System.String.Length%2A>-1，該方法會搜尋字串中要開始從最後一個字元的每個字元。  
  
 `comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用 word 或序數比較規則。  
  
   
  
## Examples  
 下列 exampledemonstrates 三個多載<xref:System.String.LastIndexOf%2A>尋找使用的不同值的另一個字串內的字串中的最後一次出現的方法<xref:System.StringComparison>列舉型別。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於零或大於目前執行個體的長度。  
  
-或- 
目前的執行個體等於 <see cref="F:System.String.Empty" /> 且 <paramref name="startIndex" /> 小於 -1 或大於零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。 執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。 如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />方法一律會傳回<paramref name="startIndex" />，這是搜尋開始處的字元位置。  
  
在下列範例中，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />方法用來尋找後面接著"m"，開頭為兩個字串中的"m"最後一個選擇性連字號 (U + 00AD) 的位置。 只有其中一個字串包含必要的子字串。 如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。 請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。 只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。  
  
[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜尋的字串。</param>
        <param name="startIndex">搜尋開始位置。 搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</param>
        <param name="count">要檢視的字元位置數目。</param>
        <param name="comparisonType">其中一個列舉值，指定搜尋規則。</param>
        <summary>回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。 搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。 參數會指定搜尋指定字串時要執行的比較類型。</summary>
        <returns>如果找到該字串，則為 <paramref name="value" /> 參數以零為起始的索引位置，如果找不到該字串或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。 如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" /> 或這個執行個體之最後索引位置，取兩者中較小者。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。 也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。  
  
 搜尋開始於`startIndex`字元位置與繼續回溯直到`value`找到或`count`已檢查的字元位置。 例如，如果`startIndex`是<xref:System.String.Length%2A>-1，此方法會向後搜尋`count`從字串中的最後一個字元的字元。  
  
 `comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用 word 或序數比較規則。  
  
   
  
## Examples  
 下列 exampledemonstrates 三個多載<xref:System.String.LastIndexOf%2A>尋找使用的不同值的另一個字串內的字串中的最後一次出現的方法<xref:System.StringComparison>列舉型別。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 為負。  
  
-或- 
目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 為負。  
  
-或- 
目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 大於這個執行個體的長度。  
  
-或- 
目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> + 1 - <paramref name="count" /> 指定的位置不在此執行個體之內。  
  
-或- 
目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="start" /> 小於 -1 或大於零。  
  
-或- 
目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="count" /> 大於 1。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。 執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。 如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法一律會傳回<paramref name="startIndex" />，這是搜尋開始處的字元位置。  
  
在下列範例中，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法用來在兩個字串中尋找的選擇性連字號 (U + 00AD) 後面接著"m"中所有的位置，但第一個字元位置之前的最終"m"。 只有其中一個字串包含必要的子字串。 如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。 當它執行序數比較時，不過，它會尋找子字串只在第一個字串中。 請注意，第一個字串，其中包含選擇性的連字號後面接著"m"，如果方法無法傳回選擇性連字號的索引，但改為傳回"m"的索引，當它執行區分文化特性的比較。 只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。  
  
[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。 如果在此執行個體中找不到陣列中的字元，此方法會傳回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字元陣列，含有一或多個要搜尋的字元。</param>
        <summary>報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。</summary>
        <returns>這個執行個體中最後項目的索引位置，其中找到了 <paramref name="anyOf" /> 中的任何字元，如果 <paramref name="anyOf" /> 中沒有找到任何字元，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。  
  
 這個方法會在這個執行個體的最後一個字元位置開始搜尋，然後反向朝中任一個字元之前開頭`anyOf`找到或已經檢查的第一個字元位置。 搜尋會區分大小寫。  
  
 這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。 若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。  
  
   
  
## Examples  
 下列範例會尋找索引的任何字元字串中最後一次出現 「 是 」 在另一個字串。  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字元陣列，含有一或多個要搜尋的字元。</param>
        <param name="startIndex">搜尋開始位置。 搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</param>
        <summary>報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。 搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</summary>
        <returns>所找到之 <paramref name="anyOf" /> 的任何字元，在這個執行個體中最後一次出現的索引位置；如果找不到 <paramref name="anyOf" /> 中的字元，或目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。  
  
 這個方法會在開始搜尋`startIndex`字元位置，這個執行個體與回溯到中的任一個字元之前開頭繼續`anyOf`找到或已經檢查的第一個字元位置。 搜尋會區分大小寫。  
  
 這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。 若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。  
  
   
  
## Examples  
 下列範例會尋找任何字元字串中最後一個出現的索引"is"另一個字串的子字串內。  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 指定的位置不在這個執行個體之內。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字元陣列，含有一或多個要搜尋的字元。</param>
        <param name="startIndex">搜尋開始位置。 搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</param>
        <param name="count">要檢視的字元位置數目。</param>
        <summary>報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。 搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</summary>
        <returns>所找到之 <paramref name="anyOf" /> 的任何字元，在這個執行個體中最後一次出現的索引位置；如果找不到 <paramref name="anyOf" /> 中的字元，或目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編號從零開始編製索引。  
  
 這個方法會在開始搜尋`startIndex`字元位置，這個執行個體與繼續回溯直到中任一個的字元開頭`anyOf`找到或`count`已檢查的字元位置。 搜尋會區分大小寫。  
  
 這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。 若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。  
  
   
  
## Examples  
 下列範例會尋找另一個字串的子字串內最後一個相符的字串"輔助工具 」 中的任何字元的索引。  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="count" /> 或 <paramref name="startIndex" /> 為負。  
  
-或- 
目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> - <paramref name="count" /> + 1 小於零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see cref="T:System.String" /> 物件中字元的數目。</summary>
        <value>目前字串中的字元數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Length%2A>屬性傳回的數目<xref:System.Char>這個執行個體中的物件，不是 Unicode 字元的數目。 原因是 Unicode 字元可能會表示由多個<xref:System.Char>。 使用<xref:System.Globalization.StringInfo?displayProperty=nameWithType>類別來使用每個 Unicode 字元，而不是每個<xref:System.Char>。  
  
 在某些語言，例如 C 和 c + +，null 字元表示字串的結尾。 在.NET 中，可以在字串中內嵌的 null 字元。 當字串包含一或多個 null 字元時，它們會包含在總字串的長度。 例如，在下列字串"abc"和"def"會以 null 字元分隔的子字串。 <xref:System.String.Length%2A>屬性會傳回 7，這表示它包含六個字母的字元，以及 null 字元。  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 下列範例示範<xref:System.String.Length%2A>屬性。  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回新的字串，其二進位表示為特定的 Unicode 正規化格式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回新的字串，其文字值與這個字串相同，但是其二進位表示為 Unicode 正規化格式 C。</summary>
        <returns>新的正規化字串，其文字值與這個字串相同，但是其二進位表示為正規化格式 C。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些 Unicode 字元有多個對等的二進位表示，其中包含結合的集合及/或複合的 Unicode 字元。 例如，任何下列的字碼指標可以代表字母"ắ 」:  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 搜尋、 排序、 比對，以及其他作業，則存在單一字元的多種表示法變得非常複雜。  
  
 Unicode 標準會定義稱為傳回一個二進位表示法指定任何對等的二進位表示的字元時的正規化程序。 可使用數種演算法，稱為正規化表單，可遵循不同的規則執行正規化。 .NET 支援的四個正規化表單 （C、 D、 KC 和 KD） 由 Unicode 標準所定義。 當兩個字串會以相同的正規化形式表示時，他們可以使用序數比較來比較。  
  
 若要正常化，並比較兩個字串，執行下列作業：  
  
1.  取得可用來從輸入來源，例如檔案或使用者的輸入的裝置要比較的字串。  
  
2.  呼叫<xref:System.String.Normalize>方法，以將字串標準化為正規化格式 c。  
  
3.  若要比較兩個字串，呼叫的方法，支援的序數字串比較，例如<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，並提供的值<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>做為<xref:System.StringComparison>引數。 若要排序的正規化字串陣列，請傳遞`comparer`的值<xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType>或<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType>的適當多載來<xref:System.Array.Sort%2A?displayProperty=nameWithType>。  
  
4.  發出根據上一個步驟所指示的順序排序的輸出中的字串。  
  
 如需支援的 Unicode 正規化格式的說明，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例會將字串標準化為每個四種的正規化形式，、 確認字串已標準化為指定的正規化表單，然後列出的正規化字串中的字碼指標。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的執行個體包含無效的 Unicode 字元。</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" />方法會傳回<see langword="false" />當它遇到第一個非標準化字元在字串中的。 因此，如果字串包含非標準化的字元，後面接著無效的 Unicode 字元<see cref="Overload:System.String.Normalize" />方法會擲回<see cref="T:System.ArgumentException" />雖然<see cref="Overload:System.String.IsNormalized" />傳回<see langword="false" />。</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Unicode 正規化格式。</param>
        <summary>傳回新的字串，其文字值與這個字串相同，但是其二進位表示為特定的 Unicode 正規化格式。</summary>
        <returns>新的字串，其文字值與這個字串相同，但是其二進位表示為 <paramref name="normalizationForm" /> 參數指定的正規化格式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些 Unicode 字元有多個對等的二進位表示，其中包含結合的集合及/或複合的 Unicode 字元。 搜尋、 排序、 比對，以及其他作業，則存在單一字元的多種表示法變得非常複雜。  
  
 Unicode 標準會定義稱為傳回一個二進位表示法指定任何對等的二進位表示的字元時的正規化程序。 可使用數種演算法，稱為正規化表單，可遵循不同的規則執行正規化。 .NET 支援的四個正規化表單 （C、 D、 KC 和 KD） 由 Unicode 標準所定義。 當兩個字串會以相同的正規化形式表示時，他們可以使用序數比較來比較。  
  
 若要正常化，並比較兩個字串，執行下列作業：  
  
1.  取得可用來從輸入來源，例如檔案或使用者的輸入的裝置要比較的字串。  
  
2.  呼叫<xref:System.String.Normalize%28System.Text.NormalizationForm%29>方法，以將字串標準化為指定的正規化格式。  
  
3.  若要比較兩個字串，呼叫的方法，支援的序數字串比較，例如<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，並提供的值<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>做為<xref:System.StringComparison>引數。 若要排序的正規化字串陣列，請傳遞`comparer`的值<xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType>或<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType>的適當多載來<xref:System.Array.Sort%2A?displayProperty=nameWithType>。  
  
4.  發出根據上一個步驟所指示的順序排序的輸出中的字串。  
  
 如需支援的 Unicode 正規化格式的說明，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例會將字串標準化為每個四種的正規化形式，、 確認字串已標準化為指定的正規化表單，然後列出的正規化字串中的字碼指標。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的執行個體包含無效的 Unicode 字元。</exception>
        <block subset="none" type="usage"><para><see cref="Overload:System.String.IsNormalized" />方法會傳回<see langword="false" />當它遇到第一個非標準化字元在字串中的。 因此，如果字串包含非標準化的字元，後面接著無效的 Unicode 字元<see cref="Overload:System.String.Normalize" />方法可能會擲回<see cref="T:System.ArgumentException" />雖然<see cref="Overload:System.String.IsNormalized" />傳回<see langword="false" />。</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">要比較的第一個字串，或是 <see langword="null" />。</param>
        <param name="b">要比較的第二個字串，或 <see langword="null" />。</param>
        <summary>判斷兩個指定的字串是否具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 的值與 <paramref name="a" /> 的值相同，則為 <paramref name="b" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Equality%2A>方法來定義等號比較運算子的營運<xref:System.String>類別。 它可讓程式碼，例如，範例 > 一節所示。 運算子，再轉而呼叫靜態<xref:System.String.Equals%28System.String%2CSystem.String%29>方法，這個方法會執行序數 （區分大小寫且區分文化特性） 比較。  
  
> [!NOTE]
>  Visual Basic 編譯器不會解析為對進行呼叫的等號比較運算子<xref:System.String.op_Equality%2A>方法。 相反地，等號比較運算子會包裝對呼叫<xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例示範等號比較運算子。  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">要比較的第一個字串，或是 <see langword="null" />。</param>
        <param name="b">要比較的第二個字串，或 <see langword="null" />。</param>
        <summary>判斷兩個指定的字串是否具有不同的值。</summary>
        <returns>如果 <see langword="true" /> 的值與 <paramref name="a" /> 的值不同，則為 <paramref name="b" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Inequality%2A>方法定義的不等比較運算子的營運<xref:System.String>類別。   它可讓程式碼，例如，範例 > 一節所示。  
  
 <xref:System.String.op_Inequality%2A>運算子會接著呼叫靜態<xref:System.String.Equals%28System.String%2CSystem.String%29>方法，這個方法會執行序數 （區分大小寫且區分文化特性） 比較。  
  
> [!NOTE]
>  Visual Basic 編譯器不會解析為對進行呼叫的不等比較運算子<xref:System.String.op_Inequality%2A>方法。 相反地，不等比較運算子會包裝對呼叫<xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例示範不等比較運算子。  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回指定之長度的新字串，其中目前字串的開頭將以空白和或指定的 Unicode 字元填補。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</param>
        <summary>傳回新字串，此字串會以空格填補左側至指定的總長度，靠右對齊這個執行個體中的字元。</summary>
        <returns>與這個執行個體相等的新字串，但為靠右對齊，並在左側視需要填補若干空間來建立 <paramref name="totalWidth" /> 的長度。 但是，如果 <paramref name="totalWidth" /> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。 如果 <paramref name="totalWidth" /> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unicode 空間會定義為十六進位 0x0020。  
  
 <xref:System.String.PadLeft%28System.Int32%29>方法會傳回字串的開頭來填補。 這表示，用於由右至左的語言，它會填補字串的右邊部分。  
  
> [!NOTE]
>  如果<xref:System.String.PadLeft%2A>方法填補空格字元，目前的執行個體，這個方法不會修改目前的執行個體的值。 相反地，它會傳回新字串，使其總長度前置空白字元填補`totalWidth`字元。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.PadLeft%2A>方法。  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> 小於零。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</param>
        <param name="paddingChar">Unicode 填補字元。</param>
        <summary>傳回新字串，此字串會以指定的 Unicode 字元填補左側至指定的總長度，靠右對齊這個執行個體中的字元。</summary>
        <returns>與這個執行個體相等的新字串，但為靠右對齊，並在左側視需要填補若干 <paramref name="paddingChar" /> 字元來建立 <paramref name="totalWidth" /> 的長度。 但是，如果 <paramref name="totalWidth" /> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。 如果 <paramref name="totalWidth" /> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29>方法會傳回字串的開頭來填補。 這表示，用於由右至左的語言，它會填補字串的右邊部分。  
  
> [!NOTE]
>  如果<xref:System.String.PadLeft%2A>方法填補空格字元，目前的執行個體，這個方法不會修改目前的執行個體的值。 相反地，它會傳回新字串，會使用前置填補`paddingChar`個字元，使其總長度`totalWidth`字元。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.PadLeft%2A>方法。  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> 小於零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回指定之長度的新字串，其中目前字串的結尾將以空白和或指定的 Unicode 字元填補。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</param>
        <summary>傳回新字串，此字串會以空格填補右側至指定的總長度，靠左對齊這個字串中的字元。</summary>
        <returns>與這個執行個體相等的新字串，但為靠左對齊，並在右側視需要填補若干空間來建立 <paramref name="totalWidth" /> 的長度。 但是，如果 <paramref name="totalWidth" /> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。 如果 <paramref name="totalWidth" /> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unicode 空間會定義為十六進位 0x0020。  
  
 <xref:System.String.PadRight%28System.Int32%29>方法會傳回字串的結尾來填補。 這表示，用於由右至左的語言，它會填補字串的左側的部分。  
  
> [!NOTE]
>  如果<xref:System.String.PadRight%2A>方法填補空格字元，目前的執行個體，這個方法不會修改目前的執行個體的值。 相反地，它會傳回新字串，使其總長度，以尾端的空白字元會填補`totalWidth`字元。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.PadRight%2A>方法。  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> 小於零。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</param>
        <param name="paddingChar">Unicode 填補字元。</param>
        <summary>傳回新字串，此字串會以指定的 Unicode 字元填補右側至指定的總長度，靠左對齊這個字串中的字元。</summary>
        <returns>與這個執行個體相等的新字串，但為靠左對齊，並在右側視需要填補若干 <paramref name="paddingChar" /> 字元來建立 <paramref name="totalWidth" /> 的長度。 但是，如果 <paramref name="totalWidth" /> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。 如果 <paramref name="totalWidth" /> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29>方法會傳回字串的結尾來填補。 這表示，用於由右至左的語言，它會填補字串的左側的部分。  
  
> [!NOTE]
>  如果<xref:System.String.PadRight%2A>方法填補空格字元，目前的執行個體，這個方法不會修改目前的執行個體的值。 相反地，它會傳回新字串，會以尾端填補`paddingChar`個字元，使其總長度`totalWidth`字元。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.PadRight%2A>方法。  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> 小於零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回新字串，其中刪除了目前字串中指定的字元數目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex">要開始刪除字元之以零為起始的位置。</param>
        <summary>傳回新字串，其中已刪除目前執行個體中的所有字元 (從指定位置開始到最後一個位置為止)。</summary>
        <returns>新字串，除了已移除的字元以外，其餘部分都與這個字串相等。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在  [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]，字串是以零為起始。 值`startIndex`參數的範圍可以介於零到字串執行個體的長度大於或等於。  
  
> [!NOTE]
>  這個方法不會修改目前的執行個體的值。 相反地，它會傳回新的字串中的所有字元位置`startIndex`原始字串的結尾已移除。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.Remove%2A>方法。 下一步 倒數第二個案例中，會移除從指定的索引，到字串結尾的所有文字。 最後這個情況下會移除從指定的索引開始的三個字元。  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 小於零。  
  
-或- 
 <paramref name="startIndex" /> 指定不在此字串內的位置。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">要開始刪除字元之以零為起始的位置。</param>
        <param name="count">要刪除的字元數。</param>
        <summary>傳回新字串，其中已刪除在目前執行個體中指定位置開始之指定數目的字元。</summary>
        <returns>新字串，除了已移除的字元以外，其餘部分都與這個執行個體相等。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在  [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]，字串是以零為起始。 值`startIndex`參數的範圍可以介於零到字串執行個體的長度大於或等於。  
  
> [!NOTE]
>  這個方法不會修改目前的執行個體的值。 相反地，它會傳回新字串的字元數所指定`count`已移除參數。 字元會在所指定的位置移除`startIndex`。  
  
   
  
## Examples  
 下列範例會示範如何移除中間名的完整名稱。  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="count" /> 小於零。  
  
-或- 
 <paramref name="startIndex" /> 加上 <paramref name="count" /> 指定的位置超出此執行個體。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回新字串，其中目前字串中指定之 Unicode 字元或 <see cref="T:System.String" /> 的所有項目，全都會被取代成另一個指定的 Unicode 字元或 <see cref="T:System.String" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">要被取代的 Unicode 字元。</param>
        <param name="newChar">要用來取代所有出現之 <paramref name="oldChar" /> 的 Unicode 字元。</param>
        <summary>傳回新字串，其中這個執行個體中所有出現的指定 Unicode 字元都取代成其他指定的 Unicode 字元。</summary>
        <returns>相當於這個執行個體的字串，只是 <paramref name="oldChar" /> 的所有執行個體都會取代成 <paramref name="newChar" />。 如果在目前的執行個體中找不到 <paramref name="oldChar" />，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會執行序數 （區分大小寫且區分文化特性） 搜尋來尋找`oldChar`。  
  
> [!NOTE]
>  這個方法不會修改目前的執行個體的值。 相反地，它會傳回新的字串中的所有項目`oldChar`會取代`newChar`。  
  
 因為這個方法會傳回已修改的字串，您可以鏈結在一起後續呼叫<xref:System.String.Replace%2A>方法，以在原始字串上執行多個替代項目。 方法呼叫從左到右執行。 下列範例提供一個實例。  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 下列範例會建立以逗號分隔值清單所得到的一系列數字之間的空白。  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">要被取代的字串。</param>
        <param name="newValue">用來取代所有出現之 <paramref name="oldValue" /> 的字串。</param>
        <summary>傳回新字串，其中目前執行個體中所有出現的指定字串，都取代成其他指定的字串。</summary>
        <returns>相當於目前字串的字串，只是 <paramref name="oldValue" /> 的所有執行個體都會取代成 <paramref name="newValue" />。 如果在目前的執行個體中找不到 <paramref name="oldValue" />，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`newValue`已`null`，所有出現的`oldValue`會移除。  
  
> [!NOTE]
>  這個方法不會修改目前的執行個體的值。 相反地，它會傳回新的字串中的所有項目`oldValue`會取代`newValue`。  
  
 這個方法會執行序數 （區分大小寫且區分文化特性） 搜尋來尋找`oldValue`。  
  
 因為這個方法會傳回已修改的字串，您可以鏈結在一起後續呼叫<xref:System.String.Replace%2A>方法，以在原始字串上執行多個替代項目。 方法呼叫從左到右執行。 下列範例提供一個實例。  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.String.Replace%2A>更正拼字錯誤的方法。  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> 為空字串 ("")。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回字串陣列，這個陣列包含這個執行個體中，由指定的字串或 Unicode 字元陣列之項目所分隔的子字串。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> 用來 break 分隔的字串成子字串。 您可用來指定零個、 一個或多個分隔字元的字元陣列 (<xref:System.String.Split%28System.Char%5B%5D%29>方法)，或者您可以使用的字元陣列，指定零個、 一個或多個分隔的字串。 多載<xref:System.String.Split%2A>方法可讓您限制的方法所傳回的子字串數目 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29>方法)，以判斷傳回的子字串中是否包含空字串 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29>和<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>方法，或以這兩種 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>和<xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>方法)。  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>String.Split 的替代方案

 <xref:System.String.Split%2A>方法永遠不是將分隔的字串成子字串的最佳方式。 如果您不想要擷取所有的子字串分隔的字串，或如果您想要剖析字串，而不是一組分隔符號字元的模式為基礎，請考慮下列的替代方案。  
  
### <a name="regular-expressions"></a>規則運算式  
 如果您的字串符合固定的模式，您可以使用規則運算式以擷取並處理其項目。 比方說，如果字串的形式 」*數字**運算元**數目*「 您可以使用[規則運算式](~/docs/standard/base-types/regular-expressions.md)擷取及處理字串的項目。 以下為範例：  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 規則運算式模式`(\d+)\s+([-+*/])\s+(\d+)`定義如下：  
  
|模式|描述|  
|-------------|-----------------|  
|`(\d+)`|比對一個或多個十進位數字。 這是第一個擷取群組。|  
|`\s+`|比對一或多個空格字元。|  
|`([-+*/])`|比對的算術運算子號 (+、-、 *，或 /)。 這是第二個擷取群組。|  
|`\s+`|比對一或多個空格字元。|  
|`(\d+)`|比對一個或多個十進位數字。 這是第三個擷取群組。|  
  
 您也可以使用規則運算式來擷取基礎模式，而不是一組固定的字元字串的子字串。 當任一條件發生時，這是常見的案例：  
  
-   一或多個分隔符號字元不一定服務做為分隔符號，以在<xref:System.String>執行個體。  
  
-   順序及分隔符號字元數目為變數或未知。  
  
 例如，<xref:System.String.Split%2A>方法不能將下列字串中，因為數目`\n`（在 C# 中) 或`vbCrLf`（在 Visual Basic) 字元是變數，而且它們不一定會做為分隔符號。  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 規則運算式可以輕鬆地，如下列範例所示分割此字串。  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 規則運算式模式`\[([^\[\]]+)\]`定義如下：  
  
|模式|描述|  
|-------------|-----------------|  
|`\[`|比對左括號。|  
|`([^\[\]]+)`|比對任何不是左或右括號一次以上的字元。 這是第一個擷取群組。|  
|`\]`|比對右括號。|  
  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方式幾乎完全相同<xref:System.String.Split%2A?displayProperty=nameWithType>，只不過它會根據規則運算式模式，而不是固定的字元集的字串。 例如，下列範例會使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法，將包含各種組合的連字號和其他字元來分隔的子字串的字串。  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 規則運算式模式`\s-\s?[+*]?\s?-\s`定義如下：  
  
|模式|描述|  
|-------------|-----------------|  
|`\s-`|比對空白字元後面接著連字號。|  
|`\s?`|比對零個或一個空白字元。|  
|`[+*]?`|比對零個或一個出現的 + 或 * 字元。|  
|`\s?`|比對零個或一個空白字元。|  
|`-\s`|比對連字號後面接著空格字元。|  
  
### <a name="search-methods-and-the-substring-method"></a>搜尋方法和 Substring 方法  
 如果您不想要在字串中子字串的所有項目，您可能想要使用其中一個傳回相符項目開始處的索引的字串比較方法。 您可以接著呼叫<xref:System.String.Substring%2A>方法來擷取您想要的子字串。 字串比較方法包括：  
  
-   <xref:System.String.IndexOf%2A>傳回字元或字串第一次出現的以零起始的索引中的字串執行個體。  
  
-   <xref:System.String.IndexOfAny%2A>它會以零為起始的索引傳回在目前的字元陣列中的任何字元第一次出現的字串執行個體。  
  
-   <xref:System.String.LastIndexOf%2A>其中的字串執行個體傳回的字元或字串最後一次出現的以零起始的索引。  
  
-   <xref:System.String.LastIndexOfAny%2A>它會以零為起始的索引傳回在目前的最後一個出現的字元陣列中的任何字元的字串執行個體。  
  
 下列範例會使用<xref:System.String.IndexOf%2A>方法來尋找字串中的句點。 然後它會使用<xref:System.String.Substring%2A>方法，以傳回完整的句子。  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</param>
        <summary>根據陣列中的字元分割字串成子字串。</summary>
        <returns>陣列，其項目中包含了這個執行個體中的子字串，由 <paramref name="separator" /> 內的一或多個字元分隔。 如需詳細資訊，請參閱＜備註＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當已知的一組字元所分隔的字串時，您可以使用<xref:System.String.Split%28System.Char%5B%5D%29>分隔成子字串的方法。   
  
### <a name="return-value-details"></a>傳回值的詳細資料  
 在傳回陣列中的項目不包含分隔符號字元。 例如，如果分隔符號的陣列包含字元"-"和目前的字串執行個體的值是"aa-bb-cc"，方法會傳回陣列，其中包含三個項目:"aa"、"bb"和"cc"。  
  
 如果這個執行個體不包含任何字元在`separator`，傳回的陣列是由單一元素，其中包含這個執行個體所組成。  
  
 每個項目的`separator`定義不同的分隔符號字元。 如果兩個分隔符號是相鄰的或分隔符號位於開頭或結尾的這個執行個體，傳回的陣列中對應的項目包含<xref:System.String.Empty>。 以下是一些範例：  
  
|字串值|Separator|傳回的陣列|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|new Char[] {',', ' '} (C#)<br /><br /> Char() = {","c, " "c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|新 Char [] {'。 '} (C#)<br /><br /> Char （) = {"。"c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Banana"|新 Char [] {'。 '} (C#)<br /><br /> Char （) = {"。"c} (Visual Basic)|{"Banana"}|  
|「 Darb\nSmarba"(C#)<br /><br /> 「 Darb"vbLf &"Smarba 」 (Visual Basic)|新 Char [] {} (C#)<br /><br /> Char （) = {} (Visual Basic)|{"Darb", "Smarba"}|  
|「 Darb\nSmarba"(C#)<br /><br /> 「 Darb"vbLf &"Smarba 」 (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
### <a name="the-separator-array"></a>分隔符號的陣列  
 每個項目分隔符號的定義不同的分隔符號所組成的單一字元。 如果`separator`引數是`null`或不包含任何字元，方法會將空白字元視為分隔符號。 泛空白字元是由 Unicode 標準; 定義它們會傳回`true`如果將它們傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>String.Split(Char[]) 和編譯器多載解析  
 雖然這個多載的單一參數<xref:System.String.Split%2A?displayProperty=nameWithType>是字元陣列中，您可以使用單一字元中, 呼叫它，如下列範例所示。  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 因為`separator`參數以裝飾<xref:System.ParamArrayAttribute>屬性，編譯器會解譯為單一元素字元陣列的單一字元。 這不是適用於其他案例<xref:System.String.Split%2A?displayProperty=nameWithType>包含的多載`separator`參數，您必須明確傳遞這些多載的字元陣列，做為`separator`引數。  
  
### <a name="comparison-details"></a>比較詳細資料  
 <xref:System.String.Split%28System.Char%5B%5D%29>方法會擷取這個字串中，由一或多個中的字元所分隔的子字串`separator`陣列，並傳回這些子字串，做為陣列的項目。  
  
 <xref:System.String.Split%28System.Char%5B%5D%29>方法會尋找分隔符號執行使用區分大小寫的序數排序規則比較的方式。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。  
  
### <a name="performance-considerations"></a>效能考量  
 <xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。 如果您的應用程式需要最佳效能，或管理記憶體配置很重要，在您的應用程式，請考慮使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法。 您也可以選擇使用<xref:System.String.Compare%2A>方法來找出字串內子字串。  
  
 若要分割的分隔字元字串，請使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法在字串中尋找是分隔符號字元。 若要分割的分隔符號字串的字串，請使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出的分隔符號字串的第一個字元。 然後使用<xref:System.String.Compare%2A>方法，以判斷該第一個字元之後的字元是否相等的分隔符號字串的其餘字元。  
  
 此外，如果相同設定的字元用來分隔在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。 這會大幅降低每個方法呼叫的額外負荷。  
  
## Examples  
 下列範例示範如何擷取文字區塊中的個別單字，藉由將做為分隔符號的泛空白字元和標點符號。 字元陣列傳遞給`separator`參數<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法包含空格字元和定位字元，以及一些常見的標點符號。  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法會傳遞<paramref name="separator" />也就是<see langword="null" />或不包含任何字元，該方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪的字串。 從.NET Framework 4 開始，這兩種方法會使用一組完全相同的泛空白字元的 Unicode 字元。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</param>
        <param name="count">要傳回的子字串之最大數目。</param>
        <summary>根據陣列中的字元分割字串成最大數目的子字串。 您也要指定傳回的子字串之最大數目。</summary>
        <returns>陣列，其項目中包含了這個執行個體中的子字串，由 <paramref name="separator" /> 內的一或多個字元分隔。 如需詳細資訊，請參閱＜備註＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在傳回陣列中的項目不包含分隔符號字元。  
  
 如果這個執行個體不包含任何字元在`separator`，傳回的陣列是由單一元素，其中包含這個執行個體所組成。 如果`count`為零，則傳回空的陣列。  
  
 如果`separator`參數是`null`不包含任何字元，或空格字元，會假設為分隔符號。 泛空白字元由 Unicode 標準並返回`true`如果將它們傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。  
  
 每個項目的`separator`定義不同的分隔符號字元。 如果兩個分隔符號是相鄰的或分隔符號位於開頭或結尾的這個執行個體，對應的陣列元素包含<xref:System.String.Empty>。  
  
 如果有多個`count`在這種情況的子字串第一`count`減 1 的子字串會傳回在第一個`count`減 1 的傳回值，以及剩餘的字元，這個執行個體中的項目會傳回在過去傳回值的項目。  
  
 如果`count`數目大於可用的子字串會傳回子字串，並擲回任何例外狀況。  
  
 下表提供範例。  
  
|字串值|Separator|計數|傳回的陣列|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|new Char[] {',', ' '} (C#)<br /><br /> Char() = {","c, " "c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|新 Char [] {'。 '} (C#)<br /><br /> Char （) = {"。"c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Banana"|新 Char [] {'。 '} (C#)<br /><br /> Char （) = {"。"c} (Visual Basic)|2|{"Banana"}|  
|「 Darb\nSmarba"(C#)<br /><br /> 「 Darb"vbLf &"Smarba 」 (Visual Basic)|新 Char [] {} (C#)<br /><br /> Char （) = {} (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> 「 Darb"vbLf &"Smarba 」 (Visual Basic)|  
|「 Darb\nSmarba"(C#)<br /><br /> 「 Darb"vbLf &"Smarba 」 (Visual Basic)|新 Char [] null (C#)<br /><br /> Char() = Nothing|2|{"Darb", "Smarba"}|  
|「 Darb\nSmarba"(C#)<br /><br /> 「 Darb"vbLf &"Smarba 」 (Visual Basic)|新 Char [] null (C#)<br /><br /> Char() = Nothing|100|{"Darb", "Smarba"}|  
  
### <a name="performance-considerations"></a>效能考量  
 <xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。 如果您的應用程式需要最佳效能，或管理記憶體配置很重要，在您的應用程式，請考慮使用<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出字串內子字串。  
  
 如果您要分割的分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法在字串中尋找是分隔符號字元。 如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出的分隔符號字串的第一個字元。 然後使用<xref:System.String.Compare%2A>方法，以判斷該第一個字元之後的字元是否相等的分隔符號字串的其餘字元。  
  
 此外，如果相同設定的字元用來分隔在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。 這會大幅降低每個方法呼叫的額外負荷。  
  
   
  
## Examples  
 下列範例示範如何`count`會影響所傳回的字串數目<xref:System.String.Split%2A>。  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 為負。</exception>
        <block subset="none" type="usage"><para>在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法會傳遞<paramref name="separator" />也就是<see langword="null" />或不包含任何字元，該方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪的字串。 從.NET Framework 4 開始，這兩種方法會使用一組完全相同的泛空白字元的 Unicode 字元。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> 表示要省略傳回陣列中的空陣列項目，否則 <see cref="F:System.StringSplitOptions.None" /> 表示要包含傳回陣列中的空陣列項目。</param>
        <summary>根據陣列中的字元分割字串成子字串。 您可以指定子字串是否包含空的陣列元素。</summary>
        <returns>陣列，其項目包含了這個字串中由 <paramref name="separator" /> 內的一或多個字元所分隔的子字串。 如需詳細資訊，請參閱＜備註＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>傳回值的詳細資料  
 分隔符號字元 (字元`separator`陣列) 不包含在傳回陣列中的項目。 例如，如果`separator`陣列包含字元"-"和目前的字串執行個體的值是"aa-bb-cc"，方法會傳回陣列，其中包含三個項目:"aa"、"bb"和"cc"。  
  
 如果這個執行個體不包含任何字元在`separator`，傳回的陣列是由單一元素，其中包含這個執行個體所組成。  
  
 如果`options`參數是<xref:System.StringSplitOptions.RemoveEmptyEntries>和這個執行個體的長度為零，方法會傳回空陣列。  
  
 每個項目的`separator`定義不同的分隔符號所組成的單一字元。 如果`options`引數<xref:System.StringSplitOptions.None>，和是相鄰的兩個分隔符號或分隔符號位於開頭或結尾的這個執行個體，對應的陣列項目包含<xref:System.String.Empty?displayProperty=nameWithType>。 比方說，如果`separator`包含兩個元素，"-"和"\_"，字串執行個體的值是"-\_aa 位\_"，和值`options`引數是<xref:System.StringSplitOptions.None>，方法會傳回的字串陣列下列五個項目：  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>表示空字串"-"字元位於索引 0。  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>表示之間的空白字串"-"字元在索引 0 和 1 的索引處的"_"字元。  
  
3.  "aa"，  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>表示遵循索引 4 的"_"字元的空字串。  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>用來表示空字串，會遵循 「-」 中 5 的索引處的字元。  
  
### <a name="the-separator-array"></a>分隔符號的陣列  
 如果`separator`參數是`null`不包含任何字元，或空格字元，會假設為分隔符號。 泛空白字元由 Unicode 標準並返回`true`如果將它們傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。  
  
 如果`separator`這個方法多載的呼叫中的參數是`null`，編譯器多載解析失敗。 若要明確地識別所呼叫的方法，您的程式碼必須指出的型別`null`。 下列範例示範數種方式可明確地識別這個多載。  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>比較詳細資料  
 <xref:System.String.Split%2A>方法會擷取這個字串中，由一或多個中的字元所分隔的子字串`separator`參數，並傳回這些子字串，做為陣列的項目。  
  
 <xref:System.String.Split%2A>方法會尋找分隔符號執行使用區分大小寫的序數排序規則比較的方式。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。  
  
### <a name="performance-considerations"></a>效能考量  
 <xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。 如果您的應用程式需要最佳效能，或管理記憶體配置很重要，在您的應用程式，請考慮使用<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出字串內子字串。  
  
 如果您要分割的分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法在字串中尋找是分隔符號字元。 如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出的分隔符號字串的第一個字元。 然後使用<xref:System.String.Compare%2A>方法，以判斷該第一個字元之後的字元是否相等的分隔符號字串的其餘字元。  
  
 此外，如果相同設定的字元用來分隔在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。 這會大幅降低每個方法呼叫的額外負荷。  
  
   
  
## Examples  
 下列範例會使用<xref:System.StringSplitOptions>列舉型別，要包含或排除所產生的子字串<xref:System.String.Split%2A>方法。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 不是其中一個 <see cref="T:System.StringSplitOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法會傳遞<paramref name="separator" />也就是<see langword="null" />或不包含任何字元，該方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪的字串。 從.NET Framework 4 開始，這兩種方法會使用一組完全相同的泛空白字元的 Unicode 字元。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> 表示要省略傳回陣列中的空陣列項目，否則 <see cref="F:System.StringSplitOptions.None" /> 表示要包含傳回陣列中的空陣列項目。</param>
        <summary>根據陣列中的字串分割字串成子字串。 您可以指定子字串是否包含空的陣列元素。</summary>
        <returns>陣列，其項目包含了這個字串中由 <paramref name="separator" /> 內的一或多個字串所分隔的子字串。 如需詳細資訊，請參閱＜備註＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當一組已知的字串所分隔的字串時，您可以使用<xref:System.String.Split%2A>分隔成子字串的方法。  
  
### <a name="return-value-details"></a>傳回值的詳細資料  
 在傳回陣列中的項目不包含分隔符號的字串。 例如，如果`separator`陣列包含字串"-"和目前的字串執行個體的值為"aa-bb cc 」，方法會傳回陣列，其中包含三個項目:"aa"、"bb"和"cc"。  
  
 如果這個執行個體不包含任何在字串`separator`，傳回的陣列是由單一元素，其中包含這個執行個體所組成。  
  
 如果`options`參數是<xref:System.StringSplitOptions.RemoveEmptyEntries>和這個執行個體的長度為零，方法會傳回空陣列。  
  
 每個項目的`separator`定義不同的分隔符號，其中包含一個或多個字元。 如果`options`引數<xref:System.StringSplitOptions.None>，和是相鄰的兩個分隔符號或分隔符號位於開頭或結尾的這個執行個體，對應的陣列項目包含<xref:System.String.Empty?displayProperty=nameWithType>。 比方說，如果`separator`包含兩個元素，"-"和"\_"，字串執行個體的值是"-\_aa 位\_"，和值`options`引數是<xref:System.StringSplitOptions.None>，方法會傳回的字串陣列下列五個項目：  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>表示空字串"-"索引 0 處的子字串。  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>表示之間的空白字串"-"索引為 0，位於索引 1 的"_"子字串的子字串。  
  
3.  "aa"，  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>表示索引 4 的"_"子字串的空白字串。  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>表示空字串，會遵循 「-」 中 5 的索引處的子字串。  
  
### <a name="the-separator-array"></a>分隔符號的陣列  
 如果有任何項目中`separator`包含多個字元，將整個子字串會被視為分隔符號。 比方說，如果一個項目的`separator`是"10"，嘗試將字串"This10is10a10string。 」 傳回下列四個元素的陣列: {"This"，"is"，"a"、"string"。 }.  
  
 如果`separator`參數是`null`不包含任何字元，或空格字元，會假設為分隔符號。 泛空白字元由 Unicode 標準並返回`true`如果將它們傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。  
  
 如果`separator`這個方法多載的呼叫中的參數是`null`，編譯器多載解析失敗。 若要明確地識別所呼叫的方法，您的程式碼必須指出的型別`null`。 下列範例示範數種方式可明確地識別這個多載。  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>比較詳細資料  
 <xref:System.String.Split%2A>方法會擷取這個字串中，由一或多個中的字串所分隔的子字串`separator`參數，並傳回這些子字串，做為陣列的項目。  
  
 <xref:System.String.Split%2A>方法會尋找分隔符號執行使用區分大小寫的序數排序規則比較的方式。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。  
  
 <xref:System.String.Split%2A>方法會忽略的任何項目`separator`的值是`null`或空字串 ("")。  
  
 若要避免模稜兩可的結果時中字串`separator`通字元<xref:System.String.Split%2A>作業就會開始從一開始的執行個體中，值的結尾並且比對中的第一個項目`separator`等於中的分隔符號執行個體。 中子字串執行個體中發生的順序優先於中項目的順序`separator`。  
  
 例如，請考慮執行個體，其值是"abcdef"。 如果中的第一個項目`separator`"ef"，而第二個元素是"bcde"、 split 作業的結果會是字串陣列，其中包含兩個元素，"a"和"f"。 這是因為發生中的執行個體，"bcde"，之子字串，而且比對中的項目`separator`遇到"f"的子字串之前。  
  
 不過，如果第一個項目`separator`"bcd"，而第二個元素是"bc"、 split 作業的結果會是字串陣列，其中包含兩個元素，"a"和"ef"。 這是因為"bcd"中的第一個分隔符號`separator`符合執行個體中的分隔符號。 如果分隔符號的順序相反，因此第一個項目"bc"，而且第二個元素是"bcd"，則結果會是字串陣列，其中包含兩個元素，"a"和"def"。  
  
### <a name="performance-considerations"></a>效能考量  
 <xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。 如果您的應用程式需要最佳效能，或管理記憶體配置很重要，在您的應用程式，請考慮使用<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出字串內子字串。  
  
 如果您要分割的分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法在字串中尋找是分隔符號字元。 如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出的分隔符號字串的第一個字元。 然後使用<xref:System.String.Compare%2A>方法，以判斷該第一個字元之後的字元是否相等的分隔符號字串的其餘字元。  
  
 此外，如果相同設定的字元用來分隔在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。 這會大幅降低每個方法呼叫的額外負荷。  
  
   
  
## Examples  
 下列範例說明如何藉由呼叫的字串所傳回之陣列的差異<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType>方法有其`options`參數等於<xref:System.StringSplitOptions.None?displayProperty=nameWithType>和<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>。  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 下列範例會定義包含標點符號和空格字元的分隔符號的陣列。 將此陣列的值以及傳遞<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>至<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>方法會傳回從字串的個別文字所組成的陣列。  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 請注意，這個方法會呼叫`options`引數設定為<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>。 這可防止傳回的陣列包括<xref:System.String.Empty?displayProperty=nameWithType>表示空的子字串比對標點符號和空格字元之間的值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 不是其中一個 <see cref="T:System.StringSplitOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法會傳遞<paramref name="separator" />也就是<see langword="null" />或不包含任何字元，該方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪的字串。 從.NET Framework 4 開始，這兩種方法會使用一組完全相同的泛空白字元的 Unicode 字元。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</param>
        <param name="count">要傳回的子字串之最大數目。</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> 表示要省略傳回陣列中的空陣列項目，否則 <see cref="F:System.StringSplitOptions.None" /> 表示要包含傳回陣列中的空陣列項目。</param>
        <summary>根據陣列中的字元分割字串成最大數目的子字串。</summary>
        <returns>陣列，其項目包含了這個字串中由 <paramref name="separator" /> 內的一或多個字元所分隔的子字串。 如需詳細資訊，請參閱＜備註＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在傳回陣列中的項目不包含分隔符號字元。  
  
 如果這個執行個體不包含任何字元`separator`，或`count`參數為 1，傳回的陣列是由單一元素，其中包含這個執行個體所組成。 如果`separator`參數是`null`不包含任何字元，或空格字元，會假設為分隔符號。 泛空白字元由 Unicode 標準並返回`true`如果將它們傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。 不過，如果`separator`這個方法多載的呼叫中的參數是`null`，編譯器多載解析失敗。 若要明確地識別所呼叫的方法，您的程式碼必須指出 null 的型別。 下列範例示範數種方式可明確地識別這個多載。  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 如果`count`參數為零，則`options`參數是<xref:System.StringSplitOptions.RemoveEmptyEntries>和這個執行個體的長度為零，則傳回空的陣列。  
  
 每個項目的`separator`定義不同的分隔符號字元。 如果`options`參數是<xref:System.StringSplitOptions.None>，和是相鄰的兩個分隔符號或分隔符號位於開頭或結尾的這個執行個體，對應的陣列項目包含<xref:System.String.Empty>。  
  
 如果有多個`count`在這種情況的子字串第一`count`減 1 的子字串會傳回在第一個`count`減 1 的傳回值，以及剩餘的字元，這個執行個體中的項目會傳回在過去傳回值的項目。  
  
 如果`count`數目大於可用的子字串會傳回子字串，並擲回任何例外狀況。  
  
### <a name="performance-considerations"></a>效能考量  
 <xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。 如果您的應用程式需要最佳效能，或管理記憶體配置很重要，在您的應用程式，請考慮使用<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出字串內子字串。  
  
 如果您要分割的分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法在字串中尋找是分隔符號字元。 如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出的分隔符號字串的第一個字元。 然後使用<xref:System.String.Compare%2A>方法，以判斷該第一個字元之後的字元是否相等的分隔符號字串的其餘字元。  
  
 此外，如果相同設定的字元用來分隔在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。 這會大幅降低每個方法呼叫的額外負荷。  
  
   
  
## Examples  
 下列範例會使用<xref:System.StringSplitOptions>列舉型別，要包含或排除所產生的子字串<xref:System.String.Split%2A>方法。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 為負。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 不是其中一個 <see cref="T:System.StringSplitOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法會傳遞<paramref name="separator" />也就是<see langword="null" />或不包含任何字元，該方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪的字串。 從.NET Framework 4 開始，這兩種方法會使用一組完全相同的泛空白字元的 Unicode 字元。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</param>
        <param name="count">要傳回的子字串之最大數目。</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> 表示要省略傳回陣列中的空陣列項目，否則 <see cref="F:System.StringSplitOptions.None" /> 表示要包含傳回陣列中的空陣列項目。</param>
        <summary>根據陣列中的字串分割字串成最大數目的子字串。 您可以指定子字串是否包含空的陣列元素。</summary>
        <returns>陣列，其項目包含了這個字串中由 <paramref name="separator" /> 內的一或多個字串所分隔的子字串。 如需詳細資訊，請參閱＜備註＞一節。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>傳回值的詳細資料  
 在傳回陣列中的項目不包含分隔符號的字串。  
  
 如果這個執行個體不包含在字串的任何`separator`，或`count`參數為 1，傳回的陣列是由單一元素，其中包含這個執行個體所組成。 如果`separator`參數是`null`不包含任何字元，或空格字元，會假設為分隔符號。 泛空白字元由 Unicode 標準並返回`true`如果將它們傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。 不過，如果`separator`這個方法多載的呼叫中的參數是`null`，編譯器多載解析失敗。 若要明確地識別所呼叫的方法，您的程式碼必須指出的型別`null`。 下列範例示範數種方式可明確地識別這個多載。  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 如果`count`參數為零，則`options`參數是<xref:System.StringSplitOptions.RemoveEmptyEntries>和這個執行個體的長度為零，則傳回空的陣列。  
  
 每個項目的`separator`定義不同的分隔符號，其中包含一個或多個字元。 如果`options`參數是<xref:System.StringSplitOptions.None>，和是相鄰的兩個分隔符號或分隔符號位於開頭或結尾的這個執行個體，對應的陣列項目包含<xref:System.String.Empty>。  
  
 如果有多個`count`在這種情況的子字串第一`count`減 1 的子字串會傳回在第一個`count`減 1 的傳回值，以及剩餘的字元，這個執行個體中的項目會傳回在過去傳回值的項目。  
  
 如果`count`數目大於可用的子字串會傳回子字串，並擲回任何例外狀況。  
  
### <a name="the-separator-array"></a>分隔符號的陣列  
 如果有任何項目中`separator`包含多個字元，將整個子字串會被視為分隔符號。 比方說，如果一個項目的`separator`是"10"，嘗試將字串"This10is10a10string。 」 傳回此四個元素的陣列: {"This"，"is"，"a"、"string"。 }.  
  
### <a name="comparison-details"></a>比較詳細資料  
 <xref:System.String.Split%2A>方法會擷取這個字串中，由一或多個中的字串所分隔的子字串`separator`參數，並傳回這些子字串，做為陣列的項目。  
  
 <xref:System.String.Split%2A>方法會尋找分隔符號執行使用區分大小寫的序數排序規則比較的方式。 如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。  
  
 <xref:System.String.Split%2A>方法會忽略的任何項目`separator`的值是`null`或空字串 ("")。  
  
 若要避免模稜兩可的結果時字串中`separator`通字元<xref:System.String.Split%2A>方法就會開始從一開始的執行個體中，值的結尾並且比對中的第一個項目`separator`等於中的分隔符號執行個體。 中子字串執行個體中發生的順序優先於中項目的順序`separator`。  
  
 例如，請考慮執行個體，其值是"abcdef"。 如果中的第一個項目`separator`"ef"，而第二個元素是"bcde"、 split 作業的結果會是"a"和"f"。 這是因為發生中的執行個體，"bcde"，之子字串，而且比對中的項目`separator`遇到"f"的子字串之前。  
  
 不過，如果第一個項目`separator`"bcd"，而第二個元素是"bc"、 split 作業的結果會是"a"和"ef"。 這是因為"bcd"中的第一個分隔符號`separator`符合執行個體中的分隔符號。 如果分隔符號的順序相反，因此第一個項目"bc"，而且第二個元素是"bcd"，則結果會是"a"和"def"。  
  
### <a name="performance-considerations"></a>效能考量  
 <xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。 如果您的應用程式需要最佳效能，或管理記憶體配置很重要，在您的應用程式，請考慮使用<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出字串內子字串。  
  
 如果您要分割的分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法在字串中尋找是分隔符號字元。 如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出的分隔符號字串的第一個字元。 然後使用<xref:System.String.Compare%2A>方法，以判斷該第一個字元之後的字元是否相等的分隔符號字串的其餘字元。  
  
 此外，如果相同設定的字元用來分隔在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。 這會大幅降低每個方法呼叫的額外負荷。  
  
   
  
## Examples  
 下列範例會使用<xref:System.StringSplitOptions>列舉型別，要包含或排除所產生的子字串<xref:System.String.Split%2A>方法。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 為負。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 不是其中一個 <see cref="T:System.StringSplitOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法會傳遞<paramref name="separator" />也就是<see langword="null" />或不包含任何字元，該方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪的字串。 從.NET Framework 4 開始，這兩種方法會使用一組完全相同的泛空白字元的 Unicode 字元。</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷這個字串執行個體的開頭是否符合指定的字串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要比較的字串。</param>
        <summary>判斷這個字串執行個體的開頭是否符合指定的字串。</summary>
        <returns>如果 <see langword="true" /> 符合這個字串的開頭，則為 <paramref name="value" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會比較`value`長度相同，這個執行個體的開頭的子字串`value`，並傳回指示它們是否相等。 為相等，`value`必須是空字串 (<xref:System.String.Empty?displayProperty=nameWithType>)，必須是這個相同的執行個體的參考，或必須符合這個執行個體的開頭。  
  
 這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。  
  
   
  
## Examples  
 下列範例會定義`StripStartTags`方法，以使用<xref:System.String.StartsWith%28System.String%29>移除 HTML 的方法從字串開頭開始標記。 請注意，`StripStartTags`呼叫方法以遞迴方式來確認已移除多個 HTML 開始標記，在一行的開頭。 此範例不會移除內嵌在字串中的 HTML 標記。  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。 若要判斷字串開頭是否為特定的子字串使用目前文化特性的字串比較規則，請呼叫<see cref="M:System.String.StartsWith(System.String,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要比較的字串。</param>
        <param name="comparisonType">列舉值之一，指定這個字串和 <paramref name="value" /> 的比較方式。</param>
        <summary>判斷當使用指定之比較選項進行比較時，這個字串執行個體的開頭是否符合指定的字串。</summary>
        <returns>如果這個執行個體以 <see langword="true" /> 為開頭，則為 <paramref name="value" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.StartsWith%2A>方法會比較`value`在這個字串的開頭的子字串的參數和傳回值，這個值，指出它們是否相等。 為相等，`value`必須為這個相同字串的參考，必須是空字串 ("")，或必須符合這個字串的開頭。 所執行的比較的型別<xref:System.String.StartsWith%2A>方法而定的值`comparisonType`參數。 比較可以使用目前的文化特性的慣例 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>並<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) 或文化特性而異 (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>並<xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>)，也可以包含的字碼指標的逐字元比較 (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). 比較也可以是區分大小寫 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>， <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>，或<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>)，或它可以忽略大小寫 (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>， <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>， <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>)。  
  
   
  
## Examples  
 下列範例會搜尋字串"the"開頭的較長的字串開頭的字組"The"。 如輸出所範例所示，呼叫<xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29>方法，執行區分大小寫，但不區分文化特性的比較無法比對字串，而執行的文化特性和 case insensitive 比較呼叫符合字串。  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 下列範例會判斷字串是否以特定的子字串開始。 它會初始化二維字串陣列。 第二個維度中的第一個項目包含為字串，和第二個元素包含要搜尋的第一個字串開頭的字串。 文化特性、 是否忽略大小寫，以及是否執行序數比較的選擇會影響結果。 請注意，當字串執行個體包含連音符號，其連續字元的區分文化特性比較成功比對。  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要比較的字串。</param>
        <param name="ignoreCase"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</param>
        <param name="culture">判斷如何比較此字串和 <paramref name="value" /> 的文化特性資訊。 如果 <paramref name="culture" /> 是 <see langword="null" />，則會使用目前的文化特性。</param>
        <summary>判斷當使用指定之文化特性進行比較時，這個字串執行個體的開頭是否符合指定的字串。</summary>
        <returns>如果 <see langword="true" /> 參數符合這個字串的開頭，則為 <paramref name="value" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會比較`value`參數的長度相同，這個字串開頭的子字串`value`，並傳回值，指出它們是否相等。 為相等，`value`必須是空字串 (<xref:System.String.Empty?displayProperty=nameWithType>)，必須是這個相同的執行個體的參考，或必須符合這個執行個體的開頭。  
  
 這個方法會執行使用指定的大小寫和文化特性的比較。  
  
   
  
## Examples  
 下列範例會判斷字串是否發生在另一個字串的開頭。 <xref:System.String.StartsWith%2A>方法呼叫數次使用區分大小寫、 不區分大小寫和不同的文化特性會影響搜尋的結果。  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從這個執行個體擷取子字串。  
  
這個成員是多載的。 如需這個成員的完整資訊，包含語法、使用方式和範例，請按一下多載清單中的名稱。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">這個執行個體中子字串之以零為起始的起始字元位置。</param>
        <summary>從這個執行個體擷取子字串。 子字串會在指定的字元位置開始並繼續到字串的結尾。</summary>
        <returns>與這個執行個體中從 <paramref name="startIndex" /> 開始之子字串相等的字串；如果 <see cref="F:System.String.Empty" /> 等於這個執行個體的長度，則為 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您呼叫<xref:System.String.Substring%28System.Int32%29>從指定的字元位置開始，並在字串結尾結束的字串擷取子字串的方法。 起始字元位置以零為起始的;換句話說，在字串中的第一個字元位於索引 0，索引 1。 若要擷取指定的字元位置開始，並結束字串的結尾之前，請呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法。  
  
> [!NOTE]
>  這個方法不會修改目前的執行個體的值。 相反地，它會傳回新的字串起始於`startIndex`目前字串中的位置。  
  
 若要擷取特定字元或字元序列的開頭的子字串，呼叫方法這類<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOf%2A>若要取得的值`startIndex`。 第二個範例說明這方面它會擷取金鑰的值之後的"="的字元開始一個字元位置。  
  
 如果`startIndex`等於零，則方法會傳回原封不動的原始字串。  
   
  
## Examples  
 下列範例示範如何取得從字串的子字串。  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 下列範例會使用<xref:System.String.Substring%2A>方法，以不同的以等號分隔的索引鍵/值配對 （"="） 字元。  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A>方法用來取得的等號字元的字串中的位置。 若要在呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法會擷取金鑰的名稱，從字串中的第一個字元開始，並擴充的呼叫所傳回的字元數<xref:System.String.IndexOf%2A>方法。 若要呼叫<xref:System.String.Substring%28System.Int32%29>方法則會擷取指派給索引鍵的值。 它等於字元之外的一個字元位置開始，並延伸至字串結尾。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 小於零或大於此執行個體的長度。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">這個執行個體中子字串之以零為起始的起始字元位置。</param>
        <param name="length">子字串中的字元數。</param>
        <summary>從這個執行個體擷取子字串。 子字串起始於指定的字元位置，並且具有指定的長度。</summary>
        <returns>與長度為 <paramref name="length" /> 且在這個執行個體中從 <paramref name="startIndex" /> 開始之子字串相等的字串；如果 <see cref="F:System.String.Empty" /> 等於這個執行個體的長度且 <paramref name="startIndex" /> 為零，則為 <paramref name="length" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法，可從指定的字元位置開始和結束的字串結尾之前的字串擷取子字串。 起始字元位置以零為起始的;換句話說，在字串中的第一個字元位於索引 0，索引 1。 若要擷取指定的字元位置開始，並以字串的結尾會繼續，請呼叫<xref:System.String.Substring%28System.Int32%29>方法。  
  
> [!NOTE]
>  這個方法不會修改目前的執行個體的值。 相反地，它會傳回新字串與字串`length`字元從`startIndex`目前字串中的位置。  
  
 `length`參數代表要從目前的字串執行個體中擷取的字元總數。 這包括起始的字元索引，請參閱`startIndex`。  亦即<xref:System.String.Substring%2A>方法會嘗試從索引擷取字元`startIndex`至索引`startIndex`  +  `length` -1。  
  
 若要擷取特定字元或字元序列的開頭的子字串，呼叫方法這類<xref:System.String.IndexOf%2A>或是<xref:System.String.LastIndexOf%2A>若要取得的值`startIndex`。  
  
 如果從子字串延伸`startIndex`在指定的字元順序，您可以呼叫方法例如<xref:System.String.IndexOf%2A>或<xref:System.String.LastIndexOf%2A>取得結束的字元或字元序列的索引。  您可以接著將該值轉換成字串中的索引位置，如下所示：  
  
-   如果您搜尋過的單一字元，是要標記的子字串的結尾`length`參數等於`endIndex`  -  `startIndex` + 1，其中`endIndex`是傳回的值<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOf%2A>方法。 下列範例會從字串擷取"b"字元的連續的區塊。  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   如果您搜尋過的多個要標示的子字串的結尾的字元`length`參數等於`endIndex`  +  `endMatchLength`  -  `startIndex`，其中`endIndex`的傳回值<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOf%2A>方法，和`endMatchLength`標記的子字串結尾的字元序列的長度。 下列範例會擷取包含 XML 的文字區塊`<definition>`項目。  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   如果字元或字元序列未包含的子字串，最後`length`參數等於`endIndex`  -  `startIndex`，其中`endIndex`是傳回的值<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOf%2A>方法。  
  
 如果`startIndex`等於零且等於目前的字串，該方法的長度會傳回未變更的原始字串。  
  
   
  
## Examples  
 下列範例說明的簡單呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>從第六個字元位置開始的字串擷取兩個字元的方法 （也就是在索引 5）。  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 下列範例會使用<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>在下列三種情況下，隔離在字串內的子字串的方法。 在兩個情況下的子字串會用來比較，並在第三個情況下會擲回例外狀況因為無效的參數會指定。  
  
-   它會擷取單一字元和字串 （位於索引 2） 中的第三個位置，並比較它與"c"。 此比較傳回`true`。  
  
-   它會擷取第四個位置中 （位於索引 3） 的字串開始的零個字元，並將它傳遞給<xref:System.String.IsNullOrEmpty%2A>方法。 這個傳回 true，因為呼叫<xref:System.String.Substring%2A>方法會傳回<xref:System.String.Empty?displayProperty=nameWithType>。  
  
-   它會嘗試擷取一個字元在字串中第四個位置開始。 因為在該位置沒有任何字元，方法呼叫會擲回<xref:System.ArgumentOutOfRangeException>例外狀況。  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 下列範例會使用<xref:System.String.Substring%2A>方法，以不同的以等號分隔的索引鍵/值配對 （"="） 字元。  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A>方法用來取得的等號字元的字串中的位置。 若要在呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法會擷取金鑰的名稱，從字串中的第一個字元開始，並擴充的呼叫所傳回的字元數<xref:System.String.IndexOf%2A>方法。 若要呼叫<xref:System.String.Substring%28System.Int32%29>方法則會擷取指派給索引鍵的值。 它等於字元之外的一個字元位置開始，並延伸至字串結尾。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 加上 <paramref name="length" /> 表示不在此執行個體中的位置。  
  
-或- 
 <paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回列舉值，可逐一查看目前的 <see cref="T:System.String" /> 物件。</summary>
        <returns>強型別列舉值，可用來逐一查看目前的 <see cref="T:System.String" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 它可用時，才<xref:System.String>執行個體轉換成<xref:System.Collections.Generic.IEnumerable%601>介面物件。 如需詳細資訊，請參閱 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回列舉值，可逐一查看目前的 <see cref="T:System.String" /> 物件。</summary>
        <returns>可用來逐一查看目前字串的列舉程式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.Collections.IEnumerable> 介面時，才能使用這個成員。 如需詳細資訊，請參閱 <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />。</summary>
        <returns>如果目前字串的值為 <see langword="true" />，則為 <see cref="F:System.Boolean.TrueString" />；如果目前字串的值為 <see langword="false" />，則為 <see cref="F:System.Boolean.FalseString" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">目前字串的值不是 <see cref="F:System.Boolean.TrueString" /> 或 <see cref="F:System.Boolean.FalseString" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件的轉換值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">無法剖析目前 <see cref="T:System.String" /> 物件的值。</exception>
        <exception cref="T:System.OverflowException">目前 <see cref="T:System.String" /> 物件的值是大於 <see cref="F:System.Byte.MaxValue" /> 或小於 <see cref="F:System.Byte.MinValue" /> 的數字。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件中位於索引 0 的字元。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件的轉換值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件的轉換值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">無法剖析目前 <see cref="T:System.String" /> 物件的值。</exception>
        <exception cref="T:System.OverflowException">目前 <see cref="T:System.String" /> 物件的值是小於 <see cref="F:System.Decimal.MinValue" /> 或大於 <see cref="F:System.Decimal.MaxValue" /> 的數字。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件的轉換值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">無法剖析目前 <see cref="T:System.String" /> 物件的值。</exception>
        <exception cref="T:System.OverflowException">目前 <see cref="T:System.String" /> 物件的值是小於 <see cref="F:System.Double.MinValue" /> 或大於 <see cref="F:System.Double.MaxValue" /> 的數字。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件的轉換值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">無法剖析目前 <see cref="T:System.String" /> 物件的值。</exception>
        <exception cref="T:System.OverflowException">目前 <see cref="T:System.String" /> 物件的值是大於 <see cref="F:System.Int16.MaxValue" /> 或小於 <see cref="F:System.Int16.MinValue" /> 的數字。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件的轉換值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件的轉換值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件的轉換值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">無法剖析目前 <see cref="T:System.String" /> 物件的值。</exception>
        <exception cref="T:System.OverflowException">目前 <see cref="T:System.String" /> 物件的值是大於 <see cref="F:System.SByte.MaxValue" /> 或小於 <see cref="F:System.SByte.MinValue" /> 的數字。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件的轉換值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">傳回的物件之類型。</param>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件的轉換值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ChangeType%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidCastException">無法將目前 <see cref="T:System.String" /> 物件的值轉換成 <paramref name="type" /> 參數所指定的類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件的轉換值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">無法剖析目前 <see cref="T:System.String" /> 物件的值。</exception>
        <exception cref="T:System.OverflowException">目前 <see cref="T:System.String" /> 物件的值是大於 <see cref="F:System.UInt16.MaxValue" /> 或小於 <see cref="F:System.UInt16.MinValue" /> 的數字。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件的轉換值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">無法剖析目前 <see cref="T:System.String" /> 物件的值。</exception>
        <exception cref="T:System.OverflowException">目前 <see cref="T:System.String" /> 物件的值是大於 <see cref="F:System.UInt32.MaxValue" /> 或小於 <see cref="F:System.UInt32.MinValue" /> 的數字</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />。</summary>
        <returns>目前 <see cref="T:System.String" /> 物件的轉換值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將這個執行個體中的字元複製到 Unicode 字元陣列中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將這個執行個體中的字元複製到 Unicode 字元陣列中。</summary>
        <returns>Unicode 字元陣列，其項目是這個執行個體的個別字元。 如果這個執行個體是空字串，則傳回的陣列會是空的且長度為零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會複製每個字元 (亦即，每個<xref:System.Char>物件) 中的字元陣列的字串。 複製的第一個字元是索引位置為零的傳回的字元陣列;複製的最後一個字元位於索引<xref:System.Array.Length%2A?displayProperty=nameWithType>-1。  
  
 若要建立字元陣列中的字元字串，呼叫<xref:System.String.%23ctor%28System.Char%5B%5D%29>建構函式。  
  
 若要建立位元組陣列，包含字串中編碼的字元，執行個體化適當<xref:System.Text.Encoding>物件並呼叫其<xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType>方法。 在.NET 中可用之標準編碼的下列部分：  
  
|編碼|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 如需詳細資訊，請參閱 < [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.String.ToCharArray%2A>来擷取其字元陣列的字串中字元的方法。 它接著會顯示原始的字串和元素陣列中。  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 下列範例會定義字串，包含做為分隔符號分隔的字串中的字元。 然後它會呼叫<xref:System.String.ToCharArray%2A>方法用來建立字元陣列可傳遞至<xref:System.String.Split%28System.Char%5B%5D%29>分隔的字串分成其個別的子字串的方法。  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">這個執行個體中的子字串開始位置。</param>
        <param name="length">這個執行個體中的子字串長度。</param>
        <summary>將這個執行個體的指定子字串字元複製到 Unicode 字元陣列。</summary>
        <returns>Unicode 字元陣列，其項目是從 <paramref name="length" /> 字元位置起始的這個執行個體中的 <paramref name="startIndex" /> 字元數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會複製到字元陣列中字串的一部分的字元。 若要建立一個範圍的字元陣列中的字元字串，呼叫<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>建構函式。  
  
 `startIndex`參數是以零為起始。 也就是說，在字串執行個體中的第一個字元的索引為零。  
  
 如果`length`為零，傳回的陣列是空的長度為零。 如果這個執行個體`null`或空字串 ("")，傳回的陣列是空的長度為零。  
  
 若要建立位元組陣列，其中包含編碼的字元字串的一部分，產生適當<xref:System.Text.Encoding>物件並呼叫其<xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29>方法。 在.NET 中可用之標準編碼的部分包括：  
  
|編碼|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 如需詳細資訊，請參閱 < [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)。  
  
   
  
## Examples  
 下列範例會將字串內子字串轉換為陣列的字元，則列舉並顯示陣列的元素。  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。  
  
-或- 
 <paramref name="startIndex" /> 加上 <paramref name="length" /> 大於這個執行個體的長度。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回此字串轉換為小寫的版本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回此字串轉換為小寫的版本。</summary>
        <returns>小寫的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會考量目前的文化特性的大小寫規則。  
  
> [!NOTE]
>  這個方法不會修改目前的執行個體的值。 相反地，它會傳回目前的執行個體中的所有字元都轉換成小寫的新字串。  
  
## <a name="security-considerations"></a>安全性考量  
 呼叫結果大小寫作業<xref:System.String.ToLower>方法會將目前的文化特性的大小寫慣例列入考量。 如果您需要大寫或小寫版本的作業系統識別項，例如檔案名稱，具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。 這會產生每個文化特性相同的結果 (不同於<xref:System.String.ToLower>方法)，並更有效率地執行。  
  
   
  
## Examples  
 下列範例會將數個混合大小寫的字串轉換成小寫。  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串大小寫方法，來替代預設值，並改為呼叫需要明確指定參數的方法。 若要將字元轉換為小寫使用目前文化特性的大小寫慣例，呼叫<see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />的值的方法多載<see cref="P:System.Globalization.CultureInfo.CurrentCulture" />針對其<paramref name="culture" />參數。</para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="culture">提供文化特性大小寫規則的物件。</param>
        <summary>使用指定之文化特性的大小寫規則，傳回這個字串轉換成小寫的複本。</summary>
        <returns>目前字串的小寫對應項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的文化特性的大小寫規則`culture`參數可讓您判斷變更的字串大小寫的方式。  
  
> [!NOTE]
>  這個方法不會修改目前的執行個體的值。 相反地，它會傳回目前的執行個體中的所有字元都轉換成小寫的新字串。  
  
## <a name="security-considerations"></a>安全性考量  
 如果您傳遞<xref:System.String.ToLower%28System.Globalization.CultureInfo%29>方法<xref:System.Globalization.CultureInfo>以外的其他物件<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>，大小寫作業將會納入考量的特定文化特性的規則。 如果您需要大寫或小寫版本的作業系統識別項，例如檔案名稱，具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。 這樣會產生每個文化特性相同的結果，並更有效率地執行。  
  
   
  
## Examples  
 下列範例會將轉換為小寫字元，使用英文-美國及土耳其文的文化特性的大寫字元的兩個字串，然後比較小寫的字串。 大寫的字串完全相同，不同之處在於 Unicode LATIN CAPITAL LETTER 我在一個字串中的每個項目，另一個字串包含 LATIN CAPITAL LETTER I 與點上方。  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用不因文化特性而異的大小寫規則，傳回轉換成小寫的這個 <see cref="T:System.String" /> 物件之複本。</summary>
        <returns>目前字串的小寫對應項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文化特性而異表示不區分文化特性的文化特性。 相關聯的英文語言使用，但不是能搭配特定國家或地區。 如需詳細資訊，請參閱 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 屬性 (Property)。  
  
 如果您的應用程式相依於大小寫的字串，變更不會受到目前文化特性使用的可預測方式<xref:System.String.ToLowerInvariant%2A>方法。 <xref:System.String.ToLowerInvariant%2A>方法就相當於`ToLower(CultureInfo.InvariantCulture)`。 字串集合必須出現在使用者介面控制項中可預測的順序時，建議的方法。  
  
> [!NOTE]
>  這個方法不會修改目前的執行個體的值。 相反地，它會傳回目前的執行個體中的所有字元都轉換成小寫的新字串。  
  
## <a name="security-considerations"></a>安全性考量  
 如果您需要大寫或小寫版本的作業系統識別項，例如檔案名稱，具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。  
  
   
  
## Examples  
 下列範例會定義包含有多種語言中的一個字的字串陣列。 <xref:System.String.ToLowerInvariant%2A>方法用來填入每個單字的不區分大小寫版本的平行陣列元素。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法用來排序依據以確保項目，會出現在相同的順序，不論語言為何小寫的陣列中項目順序的區分大小寫陣列。  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將這個執行個體的值轉換為 <see cref="T:System.String" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.String" /> 執行個體；不會實際執行轉換。</summary>
        <returns>目前的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只會傳回目前的字串不變，因為沒有需要直接呼叫它。 它通常隱含地呼叫中的複合格式化作業，如範例所示。  
  
   
  
## Examples  
 下列範例示範<xref:System.String.ToString%2A>方法。請注意，此範例不會明確呼叫<xref:System.String.ToString%2A>方法。 相反地，呼叫該方法所隱含[複合格式](~/docs/standard/base-types/composite-formatting.md)功能。  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">(保留) 物件，提供特定文化特性格式資訊。</param>
        <summary>傳回這個 <see cref="T:System.String" /> 執行個體；不會實際執行轉換。</summary>
        <returns>目前的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` 為保留字，以及目前參與這項作業。  
  
 這個方法只會傳回目前的字串不變，因為沒有需要直接呼叫它。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回此字串轉換為大寫的版本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回此字串轉換為大寫的版本。</summary>
        <returns>目前字串的大寫對應項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法會使用目前文化特性的大小寫規則，將目前的執行個體中的每個字元轉換成其對等大寫。 如果字元沒有對等大寫，它會原封不動包含在傳回的字串。  
  
> [!NOTE]
>  這個方法不會修改目前的執行個體的值。 相反地，它會傳回目前的執行個體中的所有字元都轉換成大寫的新字串。  
  
 <xref:System.String.ToUpper%2A>方法通常用來將字串轉換成大寫，這樣就可以使用不區分大小寫的比較。 更好的方法，以執行不區分大小寫的比較是呼叫字串比較方法具有<xref:System.StringComparison>參數設為其值<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>進行區分文化特性、 不區分大小寫的比較。  
  
## <a name="security-considerations"></a>安全性考量  
 呼叫結果大小寫作業<xref:System.String.ToUpper>方法會將目前的文化特性的大小寫慣例列入考量。 如果您需要大寫或小寫版本的作業系統識別項，例如檔案名稱，具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。 這會產生每個文化特性相同的結果 (不同於<xref:System.String.ToUpper>方法)，並更有效率地執行。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.String.ToUpper%2A>方法，將一系列的單字元字串包含基本拉丁、 拉丁文 1 補充和拉丁文擴充-A 字元集中的每個字元的轉換。 然後，它會顯示每個字串，其大寫的字元是不同於其小寫的字元。  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串大小寫方法，來替代預設值，並改為呼叫需要明確指定參數的方法。 若要將字串轉換為大寫使用目前文化特性的大小寫慣例，呼叫<see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" />的值的方法多載<see cref="P:System.Globalization.CultureInfo.CurrentCulture" />針對其<paramref name="culture" />參數。</para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="culture">提供文化特性大小寫規則的物件。</param>
        <summary>使用指定之文化特性的大小寫規則，傳回這個字串轉換成大寫的複本。</summary>
        <returns>目前字串的大寫對應項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的文化特性的大小寫規則`culture`參數可讓您判斷變更的字串大小寫的方式。  
  
> [!NOTE]
>  這個方法不會修改目前的執行個體的值。 相反地，它會傳回目前的執行個體中的所有字元都轉換成大寫的新字串。  
  
## <a name="security-considerations"></a>安全性考量  
 如果您傳遞<xref:System.String.ToUpper%28System.Globalization.CultureInfo%29>方法<xref:System.Globalization.CultureInfo>以外的其他物件<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>，大小寫作業將會納入考量的特定文化特性的規則。 如果您需要大寫或小寫版本的作業系統識別項，例如檔案名稱，具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。 這樣會產生每個文化特性相同的結果，並更有效率地執行。  
  
   
  
## Examples  
 下列範例會將小寫字元的字串轉換成大寫字元，使用英文-美國及土耳其文的文化特性的兩個字串，然後比較大寫的字串。 大寫的字串完全相同，不同之處在於 Unicode LATIN CAPITAL LETTER 我在一個字串中的每個項目，另一個字串包含 LATIN CAPITAL LETTER I 與點上方。  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用不因文化特性而異的大小寫規則，傳回轉換成大寫的這個 <see cref="T:System.String" /> 物件之複本。</summary>
        <returns>目前字串的大寫對應項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文化特性而異表示不區分文化特性的文化特性。 相關聯的英文語言使用，但不是能搭配特定國家或地區。 如需詳細資訊，請參閱 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 屬性 (Property)。  
  
 如果您的應用程式相依於大小寫的字串，變更不會受到目前文化特性使用的可預測方式<xref:System.String.ToUpperInvariant%2A>方法。 <xref:System.String.ToUpperInvariant%2A>方法就相當於`ToUpper(CultureInfo.InvariantCulture)`。 字串集合必須出現在使用者介面控制項中可預測的順序時，建議的方法。  
  
> [!NOTE]
>  這個方法不會修改目前的執行個體的值。 相反地，它會傳回目前的執行個體中的所有字元都轉換成大寫的新字串。  
  
## <a name="security-considerations"></a>安全性考量  
 如果您需要大寫或小寫版本的作業系統識別項，例如檔案名稱，具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。  
  
   
  
## Examples  
 下列範例會定義包含有多種語言中的一個字的字串陣列。 <xref:System.String.ToUpperInvariant%2A>方法用來填入每個單字的不區分大小寫版本的平行陣列元素。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法用來排序依據以確保項目，會出現在相同的順序，不論語言為何大寫的陣列中項目順序的區分大小寫陣列。  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回新字串，其中已經移除出現在目前 <see cref="T:System.String" /> 物件中之所有開頭與結尾的一組指定的字元。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從目前的 <see cref="T:System.String" /> 物件中移除所有的開頭和結尾空白字元。</summary>
        <returns>從目前字串的開頭和結尾移除所有空白字元後，所保留下來的字串。 如果在目前的執行個體中無法修剪任何字元，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A>方法從目前字串中移除所有開頭和尾端空白字元。 發現非空格字元時，每個前置和尾端的修剪作業就會停止。 例如，如果目前字串為"abc xyz"，<xref:System.String.Trim%2A>方法會傳回"abc xyz"。 若要移除字串中的字組之間的空格字元，請使用[.NET 規則運算式](~/docs/standard/base-types/regular-expressions.md)。  
  
> [!NOTE]
>  如果<xref:System.String.Trim%2A>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。 相反地，它會傳回新字串，在目前的執行個體中找到之所有開頭和尾端的空格字元都會被移除。  
  
 如果目前字串等於<xref:System.String.Empty>或空格字元，包含目前的執行個體中的所有字元，則方法會傳回<xref:System.String.Empty>。  
  
 泛空白字元是由 Unicode 標準定義。 <xref:System.String.Trim>方法會移除任何產生傳回值的開頭和尾端字元`true`傳遞至時<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例會使用<xref:System.String.Trim?displayProperty=nameWithType>方法，以從使用者輸入再將它們串連的字串中移除任何額外的空白字元。  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本維護的內部清單，這個方法會修剪的空格字元。 開頭[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，方法會修剪所有 Unicode 泛空白字元 (也就是個字元產生<see langword="true" />傳回值時傳遞至<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。 這項變更，因為<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本中移除兩個字元，零寬度的空格 (U + 200B) 和零寬度的不分行空格 (U + FEFF)，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，以及更新版本無法移除。 颾魤 ㄛ<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本不會修剪三種 Unicode 空白字元：蒙古文母音分隔符號 (U + 180E) 」、 「 窄的不中斷空格 (U + 202F)，以及 「 媒體數學空間 (U + 205F) 」。</para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">要移除的 Unicode 字元陣列或 <see langword="null" />。</param>
        <summary>從目前的 <see cref="T:System.String" /> 物件中移除陣列中指定之一組字元的所有開頭和結尾指定項目。</summary>
        <returns>從目前的字串開頭和結尾處移除 <paramref name="trimChars" /> 參數中所有出現的字元後，所保留下來的字串。 如果 <paramref name="trimChars" /> 是 <see langword="null" /> 或空陣列，則反而會移除空白字元。 如果在目前的執行個體中無法修剪任何字元，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A>方法會移除目前的字串中的所有開頭和尾端字元`trimChars`參數。 每個前置和尾端空白位置修剪作業停駐點時不在字元`trimChars`為止。 比方說，如果目前字串為"123abc456xyz789 」 以及`trimChars`包含的數字"1"到"9"，從<xref:System.String.Trim%2A>方法會傳回"abc456xyz 」。  
  
> [!NOTE]
>  如果<xref:System.String.Trim%2A>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。 相反地，它會傳回新的字串中所有開頭和尾端`trimChars`在目前的執行個體中找到的字元會被移除。  
  
 如果目前字串等於<xref:System.String.Empty>中的字元，包含目前的執行個體中的所有字元`trimChars`陣列，此方法會傳回<xref:System.String.Empty>。  
  
 如果`trimChars`已`null`或空陣列，這個方法會移除會導致方法傳回的任何前置或尾端字元`true`傳遞至時<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法  
  
   
  
## Examples  
 下列範例會使用<xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType>方法來移除字串中的空間、 星號 （*） 和所有格符號 （'） 字元。  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本維護的內部清單，這個方法會修剪如果的空格字元<paramref name="trimChars" />是<see langword="null" />或空陣列。 開頭[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，如果<paramref name="trimChars" />是<see langword="null" />或空陣列，此方法會修剪所有 Unicode 泛空白字元 (也就是個字元產生<see langword="true" />傳回的值時傳遞至<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。 這項變更，因為<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本中移除兩個字元，零寬度的空格 (U + 200B) 和零寬度的不分行空格 (U + FEFF)，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，以及更新版本無法移除。 颾魤 ㄛ<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本不會修剪三種 Unicode 空白字元：蒙古文母音分隔符號 (U + 180E) 」、 「 窄的不中斷空格 (U + 202F)，以及 「 媒體數學空間 (U + 205F) 」。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">要移除的 Unicode 字元陣列或 <see langword="null" />。</param>
        <summary>從目前的 <see cref="T:System.String" /> 物件中移除陣列中指定之一組字元的所有結尾指定項目。</summary>
        <returns>從目前的字串結尾處移除 <paramref name="trimChars" /> 參數中所有出現的字元後，所保留下來的字串。 如果 <paramref name="trimChars" /> 是 <see langword="null" /> 或空陣列，則反而會移除 Unicode 空白字元。 如果在目前的執行個體中無法修剪任何字元，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimEnd%2A>方法會移除目前的字串中的所有行尾字元`trimChars`參數。 修剪作業停止時的第一個字元不在`trimChars`發生在字串結尾。 比方說，如果目前字串為"123abc456xyz789 」 以及`trimChars`包含的數字"1"到"9"，從<xref:System.String.TrimEnd%2A>方法會傳回"123abc456xyz 」。  
  
> [!NOTE]
>  如果<xref:System.String.TrimEnd%2A>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。 相反地，它會傳回新字串中找到的所有尾端字元`trimChars`會從目前字串中移除。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.String.TrimEnd%28System.Char%5B%5D%29>修剪空白字元或標點符號，從字串結尾的方法。  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本維護的內部清單，這個方法會修剪如果的空格字元<paramref name="trimChars" />是<see langword="null" />或空陣列。 開頭[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，如果<paramref name="trimChars" />是<see langword="null" />或空陣列，此方法會修剪所有 Unicode 泛空白字元 (也就是個字元產生<see langword="true" />傳回的值時傳遞至<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。 這項變更，因為<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本中移除兩個字元，零寬度的空格 (U + 200B) 和零寬度的不分行空格 (U + FEFF)，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，以及更新版本無法移除。 颾魤 ㄛ<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本不會修剪三種 Unicode 空白字元：蒙古文母音分隔符號 (U + 180E) 」、 「 窄的不中斷空格 (U + 202F)，以及 「 媒體數學空間 (U + 205F) 」。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">要移除的 Unicode 字元陣列或 <see langword="null" />。</param>
        <summary>從目前的 <see cref="T:System.String" /> 物件中移除陣列中指定之一組字元的所有開頭指定項目。</summary>
        <returns>從目前的字串開頭處移除 <paramref name="trimChars" /> 參數中所有出現的字元後，所保留下來的字串。 如果 <paramref name="trimChars" /> 是 <see langword="null" /> 或空陣列，則反而會移除空白字元。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimStart%2A>方法會移除目前的字串中的所有前置字元`trimChars`參數。 修剪作業停止時不在字元`trimChars`為止。 比方說，如果目前字串為"123abc456xyz789 」 以及`trimChars`包含的數字"1"到"9"，從<xref:System.String.TrimStart%2A>方法會傳回"abc456xyz789 」。  
  
> [!NOTE]
>  如果<xref:System.String.TrimStart%2A>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。 相反地，它會傳回新字串，在目前的執行個體中找到的所有前置空白字元字元會被移除。  
  
   
  
## Examples  
 下列範例示範基本功能的<xref:System.String.TrimStart%2A>方法：

 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

 下列範例會使用<xref:System.String.TrimStart%2A>修剪空白字元和註解字元的原始程式碼程式行的方法。 `StripComments`方法會包裝對<xref:System.String.TrimStart%2A>並將它傳遞字元陣列，包含空格和註解字元，也就是單引號 （'） 在 Visual Basic 和 C# 中的斜線 （/）。 <xref:System.String.TrimStart%2A>也會呼叫方法來評估的字串是否為註解時，請移除前置空白字元。  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 下列範例說明如何呼叫 `StripComments` 方法。  
  
 [!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
 [!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本維護的內部清單，這個方法會修剪如果的空格字元<paramref name="trimChars" />是<see langword="null" />或空陣列。 開頭[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，如果<paramref name="trimChars" />是<see langword="null" />或空陣列，此方法會修剪所有 Unicode 泛空白字元 (也就是個字元產生<see langword="true" />傳回的值時傳遞至<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。 這項變更，因為<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本中移除兩個字元，零寬度的空格 (U + 200B) 和零寬度的不分行空格 (U + FEFF)，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，以及更新版本無法移除。 颾魤 ㄛ<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本不會修剪三種 Unicode 空白字元：蒙古文母音分隔符號 (U + 180E) 」、 「 窄的不中斷空格 (U + 202F)，以及 「 媒體數學空間 (U + 205F) 」。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>