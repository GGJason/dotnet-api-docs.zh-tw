<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2c88c30ffa35750968f7aaa452806739fc48db98" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="59355185" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ada9e-101">以一連串的 UTF-16 字碼單位表示文字。</span><span class="sxs-lookup"><span data-stu-id="ada9e-101">Represents text as a sequence of UTF-16 code units.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="ada9e-102">字串是用來代表文字字元的循序集合。</span><span class="sxs-lookup"><span data-stu-id="ada9e-102">A string is a sequential collection of characters that is used to represent text.</span></span> <span data-ttu-id="ada9e-103">A<xref:System.String>物件是循序集合<xref:System.Char?displayProperty=nameWithType>物件來代表的字串;<xref:System.Char?displayProperty=nameWithType>物件會對應至的 utf-16 字碼單位。</span><span class="sxs-lookup"><span data-stu-id="ada9e-103">A <xref:System.String> object is a sequential collection of <xref:System.Char?displayProperty=nameWithType> objects that represent a string; a <xref:System.Char?displayProperty=nameWithType> object corresponds to a UTF-16 code unit.</span></span> <span data-ttu-id="ada9e-104">值<xref:System.String>物件是循序集合的內容<xref:System.Char?displayProperty=nameWithType>物件和值是不可變 （亦即，它是唯讀）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-104">The value of the <xref:System.String> object is the content of the sequential collection of <xref:System.Char?displayProperty=nameWithType> objects, and that value is immutable (that is, it is read-only).</span></span> <span data-ttu-id="ada9e-105">字串的不變性的相關資訊，請參閱[的不變性和 StringBuilder 類別](#Immutability)本主題稍後的章節。</span><span class="sxs-lookup"><span data-stu-id="ada9e-105">For more information about the immutability of strings, see the [Immutability and the StringBuilder class](#Immutability) section later in this topic.</span></span> <span data-ttu-id="ada9e-106">大小上限<xref:System.String>物件在記憶體中的是 2 GB 的資料或大約 1 億個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-106">The maximum size of a <xref:System.String> object in memory is 2GB, or about 1 billion characters.</span></span>  
  
[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 <span data-ttu-id="ada9e-107">本節內容：</span><span class="sxs-lookup"><span data-stu-id="ada9e-107">In this section:</span></span>  
  
 <span data-ttu-id="ada9e-108">[具現化字串物件](#Instantiation) </span><span class="sxs-lookup"><span data-stu-id="ada9e-108">[Instantiating a String object](#Instantiation) </span></span>  
 <span data-ttu-id="ada9e-109">[Char 物件和 Unicode 字元](#Characters) </span><span class="sxs-lookup"><span data-stu-id="ada9e-109">[Char objects and Unicode characters](#Characters) </span></span>  
 <span data-ttu-id="ada9e-110">[字串及 Unicode 標準](#Unicode) </span><span class="sxs-lookup"><span data-stu-id="ada9e-110">[Strings and The Unicode Standard](#Unicode) </span></span>  
 <span data-ttu-id="ada9e-111">[字串和內嵌的 null 字元](#EmbeddedNulls) </span><span class="sxs-lookup"><span data-stu-id="ada9e-111">[Strings and embedded null characters](#EmbeddedNulls) </span></span>  
 <span data-ttu-id="ada9e-112">[字串和索引](#Indexes) </span><span class="sxs-lookup"><span data-stu-id="ada9e-112">[Strings and indexes](#Indexes) </span></span>  
 <span data-ttu-id="ada9e-113">[Null 字串和空字串](#Nulls) </span><span class="sxs-lookup"><span data-stu-id="ada9e-113">[Null strings and empty strings](#Nulls) </span></span>  
 <span data-ttu-id="ada9e-114">[不變性和 StringBuilder 類別](#Immutability) </span><span class="sxs-lookup"><span data-stu-id="ada9e-114">[Immutability and the StringBuilder class](#Immutability) </span></span>  
 <span data-ttu-id="ada9e-115">[序數與文化特性的作業](#CultureSensitive) </span><span class="sxs-lookup"><span data-stu-id="ada9e-115">[Ordinal vs. culture-sensitive operations](#CultureSensitive) </span></span>  
 <span data-ttu-id="ada9e-116">[正規化](#Normalization) </span><span class="sxs-lookup"><span data-stu-id="ada9e-116">[Normalization](#Normalization) </span></span>  
 [<span data-ttu-id="ada9e-117">依類別目錄的字串作業</span><span class="sxs-lookup"><span data-stu-id="ada9e-117">String operations by category</span></span>](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a><span data-ttu-id="ada9e-118">具現化字串物件</span><span class="sxs-lookup"><span data-stu-id="ada9e-118">Instantiating a String object</span></span>  
 <span data-ttu-id="ada9e-119">您可以具現化<xref:System.String>物件如下：</span><span class="sxs-lookup"><span data-stu-id="ada9e-119">You can instantiate a <xref:System.String> object in the following ways:</span></span>  
  
-   <span data-ttu-id="ada9e-120">字串常值，指派<xref:System.String>變數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-120">By assigning a string literal to a <xref:System.String> variable.</span></span> <span data-ttu-id="ada9e-121">這是最常用的方法，來建立字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-121">This is the most commonly used method for creating a string.</span></span> <span data-ttu-id="ada9e-122">下列範例會使用指派來建立數個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-122">The following example uses assignment to create several strings.</span></span> <span data-ttu-id="ada9e-123">請注意，在 C# 中，因為反斜線 (\\) 會逸出字元、 必須逸出字串中的常值反斜線或整個字串必須是@-quoted。</span><span class="sxs-lookup"><span data-stu-id="ada9e-123">Note that in C#, because the backslash (\\) is an escape character, literal backslashes in a string must be escaped or the entire string must be @-quoted.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp-interactive[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   <span data-ttu-id="ada9e-124">藉由呼叫<xref:System.String>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-124">By calling a <xref:System.String> class constructor.</span></span> <span data-ttu-id="ada9e-125">下列範例會產生字串，藉由呼叫類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-125">The following example instantiates strings by calling several class constructors.</span></span> <span data-ttu-id="ada9e-126">請注意，某些建構函式會包含字元陣列或做為參數的帶正負號的位元組陣列的指標。</span><span class="sxs-lookup"><span data-stu-id="ada9e-126">Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters.</span></span> <span data-ttu-id="ada9e-127">Visual Basic 不支援這些建構函式的呼叫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-127">Visual Basic does not support calls to these constructors.</span></span> <span data-ttu-id="ada9e-128">如需詳細資訊<xref:System.String>建構函式，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-128">For detailed information about <xref:System.String> constructors, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp-interactive[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   <span data-ttu-id="ada9e-129">使用字串串連運算子 (+ C# 和 （& s) 或 + 在 Visual Basic 中) 從任何組合建立單一字串<xref:System.String>執行個體和字串常值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-129">By using the string concatenation operator (+ in C# and & or + in Visual Basic) to create a single string from any combination of <xref:System.String> instances and string literals.</span></span> <span data-ttu-id="ada9e-130">下列範例說明如何使用字串串連運算子。</span><span class="sxs-lookup"><span data-stu-id="ada9e-130">The following example illustrates the use of the string concatenation operator.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp-interactive[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   <span data-ttu-id="ada9e-131">擷取屬性或呼叫的方法，傳回的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-131">By retrieving a property or calling a method that returns a string.</span></span> <span data-ttu-id="ada9e-132">下列範例使用的方法<xref:System.String>類別，以從較大的字串擷取子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-132">The following example uses the methods of the <xref:System.String> class to extract a substring from a larger string.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp-interactive[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   <span data-ttu-id="ada9e-133">藉由呼叫格式化方法來將值或物件轉換為其字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-133">By calling a formatting method to convert a value or object to its string representation.</span></span> <span data-ttu-id="ada9e-134">下列範例會使用[複合格式](~/docs/standard/base-types/composite-formatting.md)內嵌的兩個物件的字串表示轉換為字串的功能。</span><span class="sxs-lookup"><span data-stu-id="ada9e-134">The following example uses the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature to embed the string representation of two objects into a string.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp-interactive[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a><span data-ttu-id="ada9e-135">Char 物件和 Unicode 字元</span><span class="sxs-lookup"><span data-stu-id="ada9e-135">Char objects and Unicode characters</span></span>  
 <span data-ttu-id="ada9e-136">在字串中的每個字元是由 Unicode 純量值，也稱為 Unicode 字碼指標或 Unicode 字元的序數 （數值） 定義。</span><span class="sxs-lookup"><span data-stu-id="ada9e-136">Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character.</span></span> <span data-ttu-id="ada9e-137">每個字碼指標會使用 utf-16 編碼，編碼，而且會以編碼方式的每個元素的數值表示<xref:System.Char>物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-137">Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <xref:System.Char> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-138">請注意，因為<xref:System.String>執行個體包含循序集合的 utf-16 字碼單位，就可以建立<xref:System.String>不是語式正確的 Unicode 字串的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-138">Note that, because a <xref:System.String> instance consists of a sequential collection of UTF-16 code units, it is possible to create a <xref:System.String> object that is not a well-formed Unicode string.</span></span> <span data-ttu-id="ada9e-139">比方說，就可以建立沒有對應的高 surrogate 的低 surrogate 的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-139">For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate.</span></span> <span data-ttu-id="ada9e-140">雖然某些方法，例如編碼和解碼中的物件的方法<xref:System.Text>命名空間，可能會執行檢查，以確保字串格式不正確，<xref:System.String>類別成員不確定字串的格式正確。</span><span class="sxs-lookup"><span data-stu-id="ada9e-140">Although some methods, such as the methods of encoding and decoding objects in the <xref:System.Text> namespace, may performs checks to ensure that strings are well-formed, <xref:System.String> class members don't ensure that a string is well-formed.</span></span>  
  
 <span data-ttu-id="ada9e-141">單一<xref:System.Char>物件通常代表單一字碼指標，也就是值的數值<xref:System.Char>等於字碼指標。</span><span class="sxs-lookup"><span data-stu-id="ada9e-141">A single <xref:System.Char> object usually represents a single code point; that is, the numeric value of the <xref:System.Char> equals the code point.</span></span> <span data-ttu-id="ada9e-142">例如，字碼指標"的字元 a"是 u+25ce 0061。</span><span class="sxs-lookup"><span data-stu-id="ada9e-142">For example, the code point for the character "a" is U+0061.</span></span> <span data-ttu-id="ada9e-143">不過，程式碼點可能需要多個編碼項目 (一個以上<xref:System.Char>物件)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-143">However, a code point might require more than one encoded element (more than one <xref:System.Char> object).</span></span> <span data-ttu-id="ada9e-144">Unicode 標準會定義兩種類型的字元對應至多個<xref:System.Char>物件： graphemes，並對應至 Unicode 的增補平面中的字元的 Unicode 補充的字碼指標。</span><span class="sxs-lookup"><span data-stu-id="ada9e-144">The Unicode standard defines two types of characters that correspond to multiple <xref:System.Char> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.</span></span>  
  
-   <span data-ttu-id="ada9e-145">簇被以基底字元，後面接著一或多個組合的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-145">A grapheme is represented by a base character followed by one or more combining characters.</span></span> <span data-ttu-id="ada9e-146">比方說，表示的字元 ä<xref:System.Char>物件，其字碼指標為 U + 0061 後面的<xref:System.Char>物件，其字碼指標為 U + 0308年。</span><span class="sxs-lookup"><span data-stu-id="ada9e-146">For example, the character ä is represented by a <xref:System.Char> object whose code point is U+0061 followed by a <xref:System.Char> object whose code point is U+0308.</span></span> <span data-ttu-id="ada9e-147">此字元也可以定義由單一<xref:System.Char>具有 U + 00E4 字碼指標的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-147">This character can also be defined by a single <xref:System.Char> object that has a code point of U+00E4.</span></span> <span data-ttu-id="ada9e-148">如下列範例所示，區分文化特性比較相等表示這些兩種表示法相等，雖然一般的序數比較則否。</span><span class="sxs-lookup"><span data-stu-id="ada9e-148">As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not.</span></span> <span data-ttu-id="ada9e-149">不過，如果兩個字串會正規化，序數比較也會指出它們是否相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-149">However, if the two strings are normalized, an ordinal comparison also indicates that they are equal.</span></span> <span data-ttu-id="ada9e-150">(如需有關如何將正規化字串的詳細資訊，請參閱[正規化](#Normalization)一節。)</span><span class="sxs-lookup"><span data-stu-id="ada9e-150">(For more information on normalizing strings, see the [Normalization](#Normalization) section.)</span></span>  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   <span data-ttu-id="ada9e-151">增補的字碼指標 （surrogate 字組） 由 Unicode<xref:System.Char>後面接著物件，其字碼指標為為高 surrogate<xref:System.Char>物件，其字碼指標為低 surrogate。</span><span class="sxs-lookup"><span data-stu-id="ada9e-151">A Unicode supplementary code point (a surrogate pair) is represented by a <xref:System.Char> object whose code point is a high surrogate followed by a <xref:System.Char> object whose code point is a low surrogate.</span></span> <span data-ttu-id="ada9e-152">高 surrogate 範圍是從 U+D800 到 U + DBFF 的程式碼單元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-152">The code units of high surrogates range from U+D800 to U+DBFF.</span></span> <span data-ttu-id="ada9e-153">低 surrogate 範圍是從 u+dc00 到 U + dfff 範圍內的程式碼單位。</span><span class="sxs-lookup"><span data-stu-id="ada9e-153">The code units of low surrogates range from U+DC00 to U+DFFF.</span></span> <span data-ttu-id="ada9e-154">Surrogate 字組用來代表 16 的 Unicode 補充平面中的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-154">Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes.</span></span> <span data-ttu-id="ada9e-155">下列範例會建立 surrogate 字元，並將它傳遞給<xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType>方法，以判斷它是否為 surrogate 字組。</span><span class="sxs-lookup"><span data-stu-id="ada9e-155">The following example creates a surrogate character and passes it to the <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> method to determine whether it is a surrogate pair.</span></span>  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp-interactive[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a><span data-ttu-id="ada9e-156">字串及 Unicode 標準</span><span class="sxs-lookup"><span data-stu-id="ada9e-156">Strings and the Unicode Standard</span></span>  
 <span data-ttu-id="ada9e-157">字串中的字元都由 UTF 16 編碼字碼單位，這會對應到<xref:System.Char>值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-157">Characters in a string are represented by UTF-16 encoded code units, which correspond to <xref:System.Char> values.</span></span>  
  
 <span data-ttu-id="ada9e-158">每個字元字串中的有相關聯的 Unicode 字元分類，在.NET 中所表示<xref:System.Globalization.UnicodeCategory>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-158">Each character in a string has an associated Unicode character category, which is represented in .NET by the <xref:System.Globalization.UnicodeCategory> enumeration.</span></span> <span data-ttu-id="ada9e-159">字元或 surrogate 字組的類別目錄可決定藉由呼叫<xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-159">The category of a character or a surrogate pair can be determined by calling the <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> method.</span></span>  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 <span data-ttu-id="ada9e-160">此外，.NET 支援字串比較和排序以 Unicode 標準為基礎。</span><span class="sxs-lookup"><span data-stu-id="ada9e-160">In addition, .NET supports string comparison and sorting based on the Unicode standard.</span></span> <span data-ttu-id="ada9e-161">在.NET Framework 版本[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，.NET Framework 會維護自己的字串資料的資料表。</span><span class="sxs-lookup"><span data-stu-id="ada9e-161">In versions of the .NET Framework through the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the .NET Framework maintains its own table of string data.</span></span> <span data-ttu-id="ada9e-162">這也是從開始的.NET Framework 的版本，則為 true[!INCLUDE[net_v45](~/includes/net-v45-md.md)]在 Windows 7 上執行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-162">This is also true of versions of the .NET Framework starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Windows 7.</span></span> <span data-ttu-id="ada9e-163">從開始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]執行 Windows 8 和更新版本的 Windows 作業系統上，執行階段委派字串比較和排序作業的作業系統。</span><span class="sxs-lookup"><span data-stu-id="ada9e-163">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system.</span></span> <span data-ttu-id="ada9e-164">在.NET Core 上的字串比較和排序資訊係由[Unicode 的國際元件](http://site.icu-project.org/)程式庫。下表列出的.NET 版本和字元比較和排序所依據的 Unicode 標準版本。</span><span class="sxs-lookup"><span data-stu-id="ada9e-164">On .NET Core, string comparison and sorting information is provided by  [International Components for Unicode](http://site.icu-project.org/) libraries.The following table lists the versions of .NET and the versions of the Unicode Standard on which character comparison and sorting are based.</span></span>  
  
|<span data-ttu-id="ada9e-165">.NET 版本</span><span class="sxs-lookup"><span data-stu-id="ada9e-165">.NET version</span></span>|<span data-ttu-id="ada9e-166">Unicode Standard 版本</span><span class="sxs-lookup"><span data-stu-id="ada9e-166">Version of the Unicode Standard</span></span>|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[<span data-ttu-id="ada9e-167">Unicode Standard 4.0.0 版</span><span class="sxs-lookup"><span data-stu-id="ada9e-167">The Unicode Standard, Version 4.0.0</span></span>](https://www.unicode.org/versions/Unicode4.0.0/)|  
|<span data-ttu-id="ada9e-168">.NET Framework 2.0</span><span class="sxs-lookup"><span data-stu-id="ada9e-168">The .NET Framework 2.0</span></span>|[<span data-ttu-id="ada9e-169">Unicode Standard 5.0.0 版</span><span class="sxs-lookup"><span data-stu-id="ada9e-169">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[<span data-ttu-id="ada9e-170">Unicode Standard 5.0.0 版</span><span class="sxs-lookup"><span data-stu-id="ada9e-170">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[<span data-ttu-id="ada9e-171">Unicode Standard 5.0.0 版</span><span class="sxs-lookup"><span data-stu-id="ada9e-171">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] <span data-ttu-id="ada9e-172">和更新版本的 Windows 7</span><span class="sxs-lookup"><span data-stu-id="ada9e-172">and later on Windows 7</span></span>|[<span data-ttu-id="ada9e-173">Unicode Standard 5.0.0 版</span><span class="sxs-lookup"><span data-stu-id="ada9e-173">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] <span data-ttu-id="ada9e-174">和更新版本的 Windows 8 和更新版本的 Windows 作業系統上</span><span class="sxs-lookup"><span data-stu-id="ada9e-174">and later on Windows 8 and later Windows operating systems</span></span>|[<span data-ttu-id="ada9e-175">Unicode Standard 6.3.0 版</span><span class="sxs-lookup"><span data-stu-id="ada9e-175">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  
|<span data-ttu-id="ada9e-176">.NET Core (所有版本)</span><span class="sxs-lookup"><span data-stu-id="ada9e-176">.NET Core (all versions)</span></span>|<span data-ttu-id="ada9e-177">取決於基礎作業系統所支援的 Unicode Standard 版本。</span><span class="sxs-lookup"><span data-stu-id="ada9e-177">Depends on the version of the Unicode Standard supported by the underlying operating system.</span></span>|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a><span data-ttu-id="ada9e-178">字串和內嵌的 null 字元</span><span class="sxs-lookup"><span data-stu-id="ada9e-178">Strings and embedded null characters</span></span>  
 <span data-ttu-id="ada9e-179">在.NET 中，<xref:System.String>物件可以包含內嵌的 null 字元，計算字串的長度的一部分。</span><span class="sxs-lookup"><span data-stu-id="ada9e-179">In .NET, a <xref:System.String> object can include embedded null characters, which count as a part of the string's length.</span></span> <span data-ttu-id="ada9e-180">不過，在某些語言如 C 和C++，null 字元表示的字串; 字串結尾它不是字串的一部分，並不會視為字串長度的一部分。</span><span class="sxs-lookup"><span data-stu-id="ada9e-180">However, in some languages such as C and C++, a null character indicates the end of a string; it is not considered a part of the string and is not counted as part of the string's length.</span></span> <span data-ttu-id="ada9e-181">這表示下列常見的假設該 C 和C++程式設計人員或以 C 撰寫的程式庫或C++可能會使相關字串不一定有效，當套用至<xref:System.String>物件：</span><span class="sxs-lookup"><span data-stu-id="ada9e-181">This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to <xref:System.String> objects:</span></span>  
  
-   <span data-ttu-id="ada9e-182">所傳回的值`strlen`或是`wcslen`函式不一定等於<xref:System.String.Length%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-182">The value returned by the `strlen` or `wcslen` functions does not necessarily equal <xref:System.String.Length%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="ada9e-183">建立的字串`strcpy_s`或是`wcscpy_s`函式不一定等於所建立的字串<xref:System.String.Copy%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-183">The string created by the `strcpy_s` or `wcscpy_s` functions is not necessarily identical to the string created by the <xref:System.String.Copy%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ada9e-184">您應該確定該原生 C 和C++會具現化的程式碼<xref:System.String>物件和程式碼，傳遞<xref:System.String>物件透過平台叫用時，不假設內嵌的 null 字元標記字串結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-184">You should ensure that native C and C++ code that instantiates <xref:System.String> objects, and code that is passed <xref:System.String> objects through platform invoke, don't assume that an embedded null character marks the end of the string.</span></span>  
  
 <span data-ttu-id="ada9e-185">當字串是排序 （或相較），並搜尋字串時，在字串中的內嵌的 null 字元被也視為不同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-185">Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched.</span></span> <span data-ttu-id="ada9e-186">執行區分文化特性比較兩個字串，包括使用文化特性而異的比較時，會忽略 null 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-186">Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture.</span></span> <span data-ttu-id="ada9e-187">將它們視為只有的序數或不區分大小寫的序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-187">They are considered only for ordinal or case-insensitive ordinal comparisons.</span></span> <span data-ttu-id="ada9e-188">相反地，內嵌的 null 字元時，會永遠考慮使用方法搜尋字串，例如<xref:System.String.Contains%2A>， <xref:System.String.StartsWith%2A>，和<xref:System.String.IndexOf%2A>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-188">On the other hand, embedded null characters are always considered when searching a string with methods such as <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.IndexOf%2A>.</span></span>  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a><span data-ttu-id="ada9e-189">字串和索引</span><span class="sxs-lookup"><span data-stu-id="ada9e-189">Strings and indexes</span></span>  
 <span data-ttu-id="ada9e-190">索引是位置<xref:System.Char>中的物件 （不屬於 Unicode 字元） <xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-190">An index is the position of a <xref:System.Char> object (not a Unicode character) in a <xref:System.String>.</span></span> <span data-ttu-id="ada9e-191">索引是以零為起始的非負數的數字從索引位置為零的字串中的第一個位置開始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-191">An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero.</span></span> <span data-ttu-id="ada9e-192">一個數字的搜尋方法，例如<xref:System.String.IndexOf%2A>和<xref:System.String.LastIndexOf%2A>、 傳回字元的索引，或在字串執行個體中子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-192">A number of search methods, such as <xref:System.String.IndexOf%2A> and <xref:System.String.LastIndexOf%2A>, return the index of a character or substring in the string instance.</span></span>  
  
 <span data-ttu-id="ada9e-193"><xref:System.String.Chars%2A>屬性可讓您存取個別<xref:System.Char>依其在字串中的索引位置的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-193">The <xref:System.String.Chars%2A> property lets you access individual <xref:System.Char> objects by their index position in the string.</span></span> <span data-ttu-id="ada9e-194">因為<xref:System.String.Chars%2A>屬性 （在 Visual Basic) 的預設屬性或索引子 （在 C# 中)，您可以存取個別<xref:System.Char>使用如下所示的程式碼字串中的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-194">Because the <xref:System.String.Chars%2A> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <xref:System.Char> objects in a string by using code such as the following.</span></span> <span data-ttu-id="ada9e-195">此程式碼會尋找泛空白字元或標點符號字元，以判斷此字串包含的幾個文字字串中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-195">This code looks for white space or punctuation characters in a string to determine how many words the string contains.</span></span>  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp-interactive[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 <span data-ttu-id="ada9e-196">因為<xref:System.String>類別會實作<xref:System.Collections.IEnumerable>介面，您可以也逐一<xref:System.Char>中所使用的字串物件`foreach`建構，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-196">Because the <xref:System.String> class implements the <xref:System.Collections.IEnumerable> interface, you can also iterate through the <xref:System.Char> objects in a string by using a `foreach` construct, as the following example shows.</span></span>  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp-interactive[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 <span data-ttu-id="ada9e-197">連續的索引值可能無法對應至連續的 Unicode 字元，因為的 Unicode 字元可能是編碼為多個<xref:System.Char>物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-197">Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <xref:System.Char> object.</span></span> <span data-ttu-id="ada9e-198">特別是，字串可能包含多字元的文字單元的基底字元後接一或多個組合的字元或 surrogate 字組所構成。</span><span class="sxs-lookup"><span data-stu-id="ada9e-198">In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs.</span></span> <span data-ttu-id="ada9e-199">若要使用 Unicode 字元，而不是<xref:System.Char>物件，使用<xref:System.Globalization.StringInfo?displayProperty=nameWithType>和<xref:System.Globalization.TextElementEnumerator>類別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-199">To work with Unicode characters instead of <xref:System.Char> objects, use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> and <xref:System.Globalization.TextElementEnumerator> classes.</span></span> <span data-ttu-id="ada9e-200">下列範例說明可搭配使用的程式碼之間的差異<xref:System.Char>物件和與 Unicode 字元搭配運作的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-200">The following example illustrates the difference between code that works with <xref:System.Char> objects and code that works with Unicode characters.</span></span> <span data-ttu-id="ada9e-201">它會比較字元或在每個單字的句子中的文字項目的數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-201">It compares the number of characters or text elements in each word of a sentence.</span></span> <span data-ttu-id="ada9e-202">字串包含兩個基底字元，後面接著組合字元的序列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-202">The string includes two sequences of a base character followed by a combining character.</span></span>  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp-interactive[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 <span data-ttu-id="ada9e-203">此範例搭配使用文字項目<xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType>方法和<xref:System.Globalization.TextElementEnumerator>類別列舉字串中的所有文字項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-203">This example works with text elements by using the <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> method and the <xref:System.Globalization.TextElementEnumerator> class to enumerate all the text elements in a string.</span></span> <span data-ttu-id="ada9e-204">您也可以擷取陣列，其中包含每個文字項目的起始的索引，藉由呼叫<xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-204">You can also retrieve an array that contains the starting index of each text element by calling the <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ada9e-205">如需有關使用的文字，而不是個別的單位<xref:System.Char>值，請參閱<xref:System.Globalization.StringInfo>類別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-205">For more information about working with units of text rather than individual <xref:System.Char> values, see the <xref:System.Globalization.StringInfo> class.</span></span>  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a><span data-ttu-id="ada9e-206">Null 字串和空字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-206">Null strings and empty strings</span></span>  
 <span data-ttu-id="ada9e-207">已宣告但尚未指派值的字串是`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-207">A string that has been declared but has not been assigned a value is `null`.</span></span> <span data-ttu-id="ada9e-208">嘗試在該字串上呼叫方法會擲回<xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-208">Attempting to call methods on that string throws a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="ada9e-209">Null 的字串是不同的空字串，也就是的字串，其值是""或<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-209">A null string is different from an empty string, which is a string whose value is "" or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-210">在某些情況下，傳遞 null 字串或空字串做為引數的方法呼叫會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ada9e-210">In some cases, passing either a null string or an empty string as an argument in a method call throws an exception.</span></span> <span data-ttu-id="ada9e-211">例如，傳遞 null 字串，以<xref:System.Int32.Parse%2A?displayProperty=nameWithType>方法會擲回<xref:System.ArgumentNullException>，並傳遞空字串會擲回<xref:System.FormatException>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-211">For example, passing a null string to the <xref:System.Int32.Parse%2A?displayProperty=nameWithType> method throws an <xref:System.ArgumentNullException>, and passing an empty string throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="ada9e-212">在其他情況下，方法引數可以是 null 字串或是空字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-212">In other cases, a method argument can be either a null string or an empty string.</span></span> <span data-ttu-id="ada9e-213">例如，如果您要提供<xref:System.IFormattable>類別的實作，您想要使用一般 ("G") 格式規範，使 null 字串和空字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-213">For example, if you are providing an <xref:System.IFormattable> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.</span></span>  
  
 <span data-ttu-id="ada9e-214"><xref:System.String>類別包含下列兩個便利的方法可讓您測試字串是否`null`或空白：</span><span class="sxs-lookup"><span data-stu-id="ada9e-214">The <xref:System.String> class includes the following two convenience methods that enable you to test whether a string is `null` or empty:</span></span>  
  
-   <span data-ttu-id="ada9e-215"><xref:System.String.IsNullOrEmpty%2A>表示字串是是否`null`或等於<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-215"><xref:System.String.IsNullOrEmpty%2A>, which indicates whether a string is either `null` or is equal to  <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-216">這個方法就不需要使用程式碼，如下所示：</span><span class="sxs-lookup"><span data-stu-id="ada9e-216">This method eliminates the need to use code such as the following:</span></span>  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <span data-ttu-id="ada9e-217"><xref:System.String.IsNullOrWhiteSpace%2A>表示字串是否`null`，等於<xref:System.String.Empty?displayProperty=nameWithType>，或只包含泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-217"><xref:System.String.IsNullOrWhiteSpace%2A>, which indicates whether a string is `null`, equals <xref:System.String.Empty?displayProperty=nameWithType>, or consists exclusively of white-space characters.</span></span> <span data-ttu-id="ada9e-218">這個方法就不需要使用程式碼，如下所示：</span><span class="sxs-lookup"><span data-stu-id="ada9e-218">This method eliminates the need to use code such as the following:</span></span>  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 <span data-ttu-id="ada9e-219">下列範例會使用<xref:System.String.IsNullOrEmpty%2A>方法中的<xref:System.IFormattable.ToString%2A?displayProperty=nameWithType>的自訂實作`Temperature`類別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-219">The following example uses the <xref:System.String.IsNullOrEmpty%2A> method in the <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation of a custom `Temperature` class.</span></span> <span data-ttu-id="ada9e-220">方法支援的"G"，"C"、"F"、"K"格式字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-220">The method supports the "G", "C", "F", and "K" format strings.</span></span> <span data-ttu-id="ada9e-221">如果是空白的格式字串或格式字串的值是`null`傳遞至此方法，其值變更為"G"格式字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-221">If an empty format string or a format string whose value is `null` is passed to the method, its value is changed to the "G" format string.</span></span>  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a><span data-ttu-id="ada9e-222">不變性和 StringBuilder 類別</span><span class="sxs-lookup"><span data-stu-id="ada9e-222">Immutability and the StringBuilder class</span></span>  
 <span data-ttu-id="ada9e-223">A<xref:System.String>物件稱為不可變 （唯讀），因為一旦建立後便無法修改其值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-223">A <xref:System.String> object is called immutable (read-only), because its value cannot be modified after it has been created.</span></span> <span data-ttu-id="ada9e-224">若要修改顯示的方法<xref:System.String>物件實際上會傳回新<xref:System.String>包含修改的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-224">Methods that appear to modify a <xref:System.String> object actually return a new <xref:System.String> object that contains the modification.</span></span>  
  
 <span data-ttu-id="ada9e-225">字串是不可變的因為執行的字串操作常式重複新增或刪除項目似乎是單一字串可以精確顯著的效能負面影響。</span><span class="sxs-lookup"><span data-stu-id="ada9e-225">Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty.</span></span> <span data-ttu-id="ada9e-226">例如，下列程式碼會使用亂數產生器建立具有在範圍內以 0x052F 0x0001 1000 個字元的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-226">For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F.</span></span> <span data-ttu-id="ada9e-227">雖然程式碼會使用字串串連來將新的字元附加至現有的字串，名為`str`，它實際上會建立新<xref:System.String>針對每個串連作業的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-227">Although the code appears to use string concatenation to append a new character to the existing string named `str`, it actually creates a new <xref:System.String> object for each concatenation operation.</span></span>  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 <span data-ttu-id="ada9e-228">您可以使用<xref:System.Text.StringBuilder>類別而不是<xref:System.String>作業的字串值的多個變更的類別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-228">You can use the <xref:System.Text.StringBuilder> class instead of the <xref:System.String> class for operations that make multiple changes to the value of a string.</span></span> <span data-ttu-id="ada9e-229">不同的執行個體<xref:System.String>類別，<xref:System.Text.StringBuilder>是可變動的物件; 當您串連、 附加或刪除從字串的子字串時，作業將會在單一字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-229">Unlike instances of the <xref:System.String> class, <xref:System.Text.StringBuilder> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string.</span></span> <span data-ttu-id="ada9e-230">當您完成修改的值<xref:System.Text.StringBuilder>物件，您可以呼叫其<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法將它轉換成字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-230">When you have finished modifying the value of a <xref:System.Text.StringBuilder> object, you can call its <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> method to convert it to a string.</span></span> <span data-ttu-id="ada9e-231">下列範例會取代<xref:System.String>在上述範例中用來串連來使用 0x052F 0x0001 之範圍中的 1000 個隨機字元<xref:System.Text.StringBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-231">The following example replaces the <xref:System.String> used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <xref:System.Text.StringBuilder> object.</span></span>  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a><span data-ttu-id="ada9e-232">序數與文化特性的作業</span><span class="sxs-lookup"><span data-stu-id="ada9e-232">Ordinal vs. culture-sensitive operations</span></span>  
 <span data-ttu-id="ada9e-233">成員<xref:System.String>類別上執行序數或區分文化特性 （語言） 作業<xref:System.String>物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-233">Members of the <xref:System.String> class perform either ordinal or culture-sensitive (linguistic) operations on a <xref:System.String> object.</span></span> <span data-ttu-id="ada9e-234">序數的作業會在每個數值上<xref:System.Char>物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-234">An ordinal operation acts on the numeric value of each <xref:System.Char> object.</span></span> <span data-ttu-id="ada9e-235">區分文化特性的作業處理程式碼的值<xref:System.String>物件，並採用特定文化特性的大小寫、 排序、 格式化和剖析規則列入考量。</span><span class="sxs-lookup"><span data-stu-id="ada9e-235">A culture-sensitive operation acts on the value of the <xref:System.String> object, and takes culture-specific casing, sorting, formatting, and parsing rules into account.</span></span> <span data-ttu-id="ada9e-236">明確宣告的文化特性或目前的文化特性隱含的內容中，執行區分文化特性的作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-236">Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture.</span></span> <span data-ttu-id="ada9e-237">它們會對相同的字串時，兩種作業可能會產生非常不同的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-237">The two kinds of operations can produce very different results when they are performed on the same string.</span></span>  
  
<span data-ttu-id="ada9e-238">.NET 也支援不區分文化特性的語言字串作業，使用文化特性而異 (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>)，以鬆散基礎區域的獨立的英文文化特性設定。</span><span class="sxs-lookup"><span data-stu-id="ada9e-238">.NET also supports culture-insensitive linguistic string operations by using the invariant culture (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), which is loosely based on the culture settings of the English language independent of region.</span></span> <span data-ttu-id="ada9e-239">不同於其他<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>保證維持一致的單一電腦上，從系統中，而橫跨的.NET 版本的系統設定、 不區分文化特性設定。</span><span class="sxs-lookup"><span data-stu-id="ada9e-239">Unlike other <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of .NET.</span></span> <span data-ttu-id="ada9e-240">跨所有文化特性可以看到視為一種黑色方塊，以確保穩定性的字串比較和排序文化特性而異。</span><span class="sxs-lookup"><span data-stu-id="ada9e-240">The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ada9e-241">如果您的應用程式可讓安全性決策的相關符號的識別碼，例如檔案名稱或具名管道，或需保存的資料，例如 XML 檔案中以文字為基礎的資料，作業應該使用序數比較，而不是區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-241">If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-242">這是因為區分文化特性的比較可以作用中，產生不同的結果，根據文化特性而序數比較取決於比較字元的二進位值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-242">This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ada9e-243">執行字串作業的大部分方法包括具有類型參數的多載<xref:System.StringComparison>，這可讓您指定方法是否執行序數或區分文化特性的作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-243">Most methods that perform string operations include an overload that has a parameter of type <xref:System.StringComparison>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation.</span></span> <span data-ttu-id="ada9e-244">一般情況下，您應該呼叫這個多載來進行的意圖，在方法呼叫清除。</span><span class="sxs-lookup"><span data-stu-id="ada9e-244">In general, you should call this overload to make the intent of your method call clear.</span></span> <span data-ttu-id="ada9e-245">最佳做法及使用序數和區分文化特性字串作業的指引，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-245">For best practices and guidance for using ordinal and culture-sensitive operations on strings, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ada9e-246">作業[大小寫](#casing)，[剖析和格式化](#parsing)，[比較和排序](#comparison)，以及[測試是否相等](#equality)可以是序數或區分文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-246">Operations for [casing](#casing), [parsing and formatting](#parsing), [comparison and sorting](#comparison), and [testing for equality](#equality) can be either ordinal or culture-sensitive.</span></span> <span data-ttu-id="ada9e-247">下列各節將討論每個類別的作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-247">The following sections discuss each category of operation.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="ada9e-248">您應該一律呼叫方法多載，可讓您的方法呼叫清除目的。</span><span class="sxs-lookup"><span data-stu-id="ada9e-248">You should always call a method overload that makes the intent of your method call clear.</span></span> <span data-ttu-id="ada9e-249">比方說，而不是呼叫<xref:System.String.Compare%28System.String%2CSystem.String%29>方法以執行區分文化特性比較兩個字串的使用目前的文化特性的慣例，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，其值為<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>如`comparisonType`引數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-249">For example, instead of calling the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with a value of <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> for the `comparisonType` argument.</span></span> <span data-ttu-id="ada9e-250">如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-250">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  

<span data-ttu-id="ada9e-251">您可以下載[排序權數資料表](https://www.microsoft.com/en-us/download/details.aspx?id=10921)，該文字檔集合包含在 Windows 作業系統排序及比較作業中使用的字元權數資訊，以及下載[預設 Unicode 定序元素資料表](https://www.unicode.org/Public/UCA/latest/allkeys.txt) (適用於 Linux 和 macOS 的排序權數資料表)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-251">You can download the [Sorting Weight Tables](https://www.microsoft.com/en-us/download/details.aspx?id=10921), a set of text files that contain information on the character weights used in sorting and comparison operations for Windows operating systems, and the [Default Unicode Collation Element Table](https://www.unicode.org/Public/UCA/latest/allkeys.txt), the sort weight table for Linux and macOS.</span></span>

<a name="casing"></a>   
### <a name="casing"></a><span data-ttu-id="ada9e-252">大小寫</span><span class="sxs-lookup"><span data-stu-id="ada9e-252">Casing</span></span>  
 <span data-ttu-id="ada9e-253">大小寫規則會決定如何變更大小寫的 Unicode 字元;例如，從小寫為大寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-253">Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase.</span></span> <span data-ttu-id="ada9e-254">通常，會執行大小寫作業之前的字串比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-254">Often, a casing operation is performed before a string comparison.</span></span> <span data-ttu-id="ada9e-255">例如，字串可能會轉換為大寫，以便與另一個大寫的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-255">For example, a string might be converted to uppercase so that it can be compared with another uppercase string.</span></span> <span data-ttu-id="ada9e-256">您可以將轉換為小寫藉由呼叫字串中的字元<xref:System.String.ToLower%2A>或是<xref:System.String.ToLowerInvariant%2A>方法，而且您可以將它們轉換成大寫，藉由呼叫<xref:System.String.ToUpper%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-256">You can convert the characters in a string to lowercase by calling the <xref:System.String.ToLower%2A> or <xref:System.String.ToLowerInvariant%2A> method, and you can convert them to uppercase by calling the <xref:System.String.ToUpper%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ada9e-257">此外，您可以使用<xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType>方法將字串轉換為字首大寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-257">In addition, you can use the <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> method to convert a string to title case.</span></span>  

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]  
  
 <span data-ttu-id="ada9e-258">大小寫的作業可以根據目前文化特性、 指定的文化特性或文化特性而異的規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-258">Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture.</span></span> <span data-ttu-id="ada9e-259">大小寫對應使用的文化特性而異，因為大小寫作業的結果可以異的文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-259">Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture.</span></span> <span data-ttu-id="ada9e-260">有三種大小寫的實際差異：</span><span class="sxs-lookup"><span data-stu-id="ada9e-260">The actual differences in casing are of three kinds:</span></span>  
  
-   <span data-ttu-id="ada9e-261">在 大小寫的 LATIN CAPITAL LETTER I 對應的差異 (u+0049)，拉丁小型字母 I (u+0069)，LATIN CAPITAL LETTER I (u+0130)，上述的點和拉丁文小型字母無點 」 (U + 0131)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-261">Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131).</span></span> <span data-ttu-id="ada9e-262">TR-TR （土耳其文 （土耳其）） 和 az-Latn-AZ （亞塞拜然，拉丁） 文化特性，在和中的 tr、 az 和 az Latn 中性文化特性，LATIN CAPITAL LETTER I 的對等小寫; 拉丁文小型字母無點 1，而拉丁文小型字母 I 的大寫對應項拉丁大寫字母我使用上述的點。</span><span class="sxs-lookup"><span data-stu-id="ada9e-262">In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span> <span data-ttu-id="ada9e-263">在所有其他的文化特性，包括文化特性而異，拉丁小型字母 I 與 LATIN CAPITAL LETTER 我是小寫和大寫對等項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-263">In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.</span></span>  
  
     <span data-ttu-id="ada9e-264">下列範例示範如何設計的字串比較，以避免檔案系統存取權可能會失敗它依賴區分文化特性的大小寫比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-264">The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison.</span></span> <span data-ttu-id="ada9e-265">（不區分文化特性的大小寫慣例應該已使用。）</span><span class="sxs-lookup"><span data-stu-id="ada9e-265">(The casing conventions of the invariant culture should have been used.)</span></span>  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   <span data-ttu-id="ada9e-266">在 大小寫對應而異的文化特性和所有其他文化特性之間的差異。</span><span class="sxs-lookup"><span data-stu-id="ada9e-266">Differences in case mappings between the invariant culture and all other cultures.</span></span> <span data-ttu-id="ada9e-267">在這些情況下，使用文化特性而異的大小寫規則變更為大寫或小寫字元，將會傳回相同的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-267">In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character.</span></span> <span data-ttu-id="ada9e-268">對於所有其他的文化特性，它會傳回不同的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-268">For all other cultures, it returns a different character.</span></span> <span data-ttu-id="ada9e-269">某些受影響的字元都是以下列的表所述。</span><span class="sxs-lookup"><span data-stu-id="ada9e-269">Some of the affected characters are listed in the following table.</span></span>  
  
    |<span data-ttu-id="ada9e-270">字元</span><span class="sxs-lookup"><span data-stu-id="ada9e-270">Character</span></span>|<span data-ttu-id="ada9e-271">如果變更為</span><span class="sxs-lookup"><span data-stu-id="ada9e-271">If changed to</span></span>|<span data-ttu-id="ada9e-272">Returns</span><span class="sxs-lookup"><span data-stu-id="ada9e-272">Returns</span></span>|  
    |---------------|-------------------|-------------|  
    |<span data-ttu-id="ada9e-273">MICRON 登 (U + 00B5)</span><span class="sxs-lookup"><span data-stu-id="ada9e-273">MICRON SIGN (U+00B5)</span></span>|<span data-ttu-id="ada9e-274">大寫</span><span class="sxs-lookup"><span data-stu-id="ada9e-274">Uppercase</span></span>|<span data-ttu-id="ada9e-275">希臘文大寫字母 MU (U +-39 C)</span><span class="sxs-lookup"><span data-stu-id="ada9e-275">GREEK CAPITAL LETTER MU (U+-39C)</span></span>|  
    |<span data-ttu-id="ada9e-276">LATIN CAPITAL LETTER 我加上點上方 (U+0130)</span><span class="sxs-lookup"><span data-stu-id="ada9e-276">LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</span></span>|<span data-ttu-id="ada9e-277">小寫</span><span class="sxs-lookup"><span data-stu-id="ada9e-277">Lowercase</span></span>|<span data-ttu-id="ada9e-278">拉丁文小型字母 I (U+0069)</span><span class="sxs-lookup"><span data-stu-id="ada9e-278">LATIN SMALL LETTER I (U+0069)</span></span>|  
    |<span data-ttu-id="ada9e-279">拉丁文小寫字母無點我 (U + 0131)</span><span class="sxs-lookup"><span data-stu-id="ada9e-279">LATIN SMALL LETTER DOTLESS I (U+0131)</span></span>|<span data-ttu-id="ada9e-280">大寫</span><span class="sxs-lookup"><span data-stu-id="ada9e-280">Uppercase</span></span>|<span data-ttu-id="ada9e-281">拉丁大寫字母 I (U+0049)</span><span class="sxs-lookup"><span data-stu-id="ada9e-281">LATIN CAPITAL LETTER I (U+0049)</span></span>|  
    |<span data-ttu-id="ada9e-282">拉丁文小寫字母長 S (U + 017F)</span><span class="sxs-lookup"><span data-stu-id="ada9e-282">LATIN SMALL LETTER LONG S (U+017F)</span></span>|<span data-ttu-id="ada9e-283">大寫</span><span class="sxs-lookup"><span data-stu-id="ada9e-283">Uppercase</span></span>|<span data-ttu-id="ada9e-284">LATIN CAPITAL LETTER S (U + 0053)</span><span class="sxs-lookup"><span data-stu-id="ada9e-284">LATIN CAPITAL LETTER S (U+0053)</span></span>|  
    |<span data-ttu-id="ada9e-285">有勾的小寫字母 Z 的拉丁大寫字母 D (U + 01C 5)</span><span class="sxs-lookup"><span data-stu-id="ada9e-285">LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)</span></span>|<span data-ttu-id="ada9e-286">小寫</span><span class="sxs-lookup"><span data-stu-id="ada9e-286">Lowercase</span></span>|<span data-ttu-id="ada9e-287">有勾的拉丁小寫字母 DZ (U + 01C 6)</span><span class="sxs-lookup"><span data-stu-id="ada9e-287">LATIN SMALL LETTER DZ WITH CARON (U+01C6)</span></span>|  
    |<span data-ttu-id="ada9e-288">結合希臘 YPOGEGRAMMENI (U + 0345)</span><span class="sxs-lookup"><span data-stu-id="ada9e-288">COMBINING GREEK YPOGEGRAMMENI (U+0345)</span></span>|<span data-ttu-id="ada9e-289">大寫</span><span class="sxs-lookup"><span data-stu-id="ada9e-289">Uppercase</span></span>|<span data-ttu-id="ada9e-290">希臘文大寫字母 IOTA (U + 0399)</span><span class="sxs-lookup"><span data-stu-id="ada9e-290">GREEK CAPITAL LETTER IOTA (U+0399)</span></span>|  
  
-   <span data-ttu-id="ada9e-291">ASCII 字元範圍中的兩個字母混合大小寫組的大小寫對應的差異。</span><span class="sxs-lookup"><span data-stu-id="ada9e-291">Differences in case mappings of two-letter mixed-case pairs in the ASCII character range.</span></span> <span data-ttu-id="ada9e-292">在大部分文化中，兩個字母混合大小寫組等於的對等的兩個字母大寫或小寫組。</span><span class="sxs-lookup"><span data-stu-id="ada9e-292">In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair.</span></span> <span data-ttu-id="ada9e-293">這不適用於下列兩個字母組中的下列的文化特性，因為在每個案例中，它們會比較到雙拼詞：</span><span class="sxs-lookup"><span data-stu-id="ada9e-293">This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:</span></span>  
  
    -   <span data-ttu-id="ada9e-294">「 lJ"和"nJ"HR-HR （克羅埃西亞文 （克羅埃西亞）） 文化特性中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-294">"lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture.</span></span>  
  
    -   <span data-ttu-id="ada9e-295">「 cH"CS-CZ （捷克文 （捷克共和國）） 和 sk-SK （斯洛伐克文 （斯洛伐克）） 文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-295">"cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.</span></span>  
  
    -   <span data-ttu-id="ada9e-296">"aA"DA-DK （丹麥文 （丹麥）） 文化特性中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-296">"aA" in the da-DK (Danish (Denmark)) culture.</span></span>  
  
    -   <span data-ttu-id="ada9e-297">"cS"、"dZ"、"dZS"、"nY"、"sZ"、"tY，"和"zs"表示 HU-HU （匈牙利文 （匈牙利）） 文化特性中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-297">"cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture.</span></span>  
  
    -   <span data-ttu-id="ada9e-298">「 cH"和"lL"es ES_tradnl （西班牙文 （西班牙，傳統排序）） 文化特性中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-298">"cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.</span></span>  
  
    -   <span data-ttu-id="ada9e-299">「 cH"、"gI"、"kH"、"nG""nH"、"pH"，"qU'，"tH"，並在 vi VN （越南文 （越南）） 文化特性中的"tR"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-299">"cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture.</span></span>  
  
     <span data-ttu-id="ada9e-300">不過，很少會遇到這些字組的區分文化特性的比較會建立問題的情況下，因為這些組並不常見的固定的字串或識別項。</span><span class="sxs-lookup"><span data-stu-id="ada9e-300">However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.</span></span>  
  
 <span data-ttu-id="ada9e-301">下列範例會說明一些在大小寫規則時將字串轉換成大寫的文化特性之間的差異。</span><span class="sxs-lookup"><span data-stu-id="ada9e-301">The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.</span></span>  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a><span data-ttu-id="ada9e-302">剖析和格式化</span><span class="sxs-lookup"><span data-stu-id="ada9e-302">Parsing and formatting</span></span>  
 <span data-ttu-id="ada9e-303">格式化和剖析是反向作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-303">Formatting and parsing are inverse operations.</span></span> <span data-ttu-id="ada9e-304">格式化規則決定的值，例如日期和時間或數字，轉換成其字串表示法，而剖析規則會決定如何將轉換為值，例如日期和時間的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-304">Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time.</span></span> <span data-ttu-id="ada9e-305">格式化和剖析規則均依存於文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="ada9e-305">Both formatting and parsing rules are dependent on cultural conventions.</span></span> <span data-ttu-id="ada9e-306">下列範例說明在解譯的特定文化特性的日期字串時，可能會發生模稜兩可。</span><span class="sxs-lookup"><span data-stu-id="ada9e-306">The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string.</span></span> <span data-ttu-id="ada9e-307">而不需要知道用來產生日期字串的文化特性的慣例，不可能知道 03/01/2011年，3/1/2011，01/03/2011年代表 2011 年 1 月 3 日或 2011 年 3 月 1 日。</span><span class="sxs-lookup"><span data-stu-id="ada9e-307">Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.</span></span>  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 <span data-ttu-id="ada9e-308">同樣地，如下列範例所示，單一字串可能會產生不同的日期，根據文化特性的慣例用於剖析作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-308">Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.</span></span>  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a><span data-ttu-id="ada9e-309">字串比較和排序</span><span class="sxs-lookup"><span data-stu-id="ada9e-309">String comparison and sorting</span></span>  
 <span data-ttu-id="ada9e-310">比較和排序字串的慣例而異的文化。</span><span class="sxs-lookup"><span data-stu-id="ada9e-310">Conventions for comparing and sorting strings vary from culture to culture.</span></span> <span data-ttu-id="ada9e-311">例如，排序次序可能會根據語音 或字元的視覺表示法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-311">For example, the sort order may be based on phonetics or on the visual representation of characters.</span></span> <span data-ttu-id="ada9e-312">在東亞語言中，字元是依照筆劃和表意字元的巨大。</span><span class="sxs-lookup"><span data-stu-id="ada9e-312">In East Asian languages, characters are sorted by the stroke and radical of ideographs.</span></span> <span data-ttu-id="ada9e-313">排序也取決於順序語言和文化特性使用的字母。</span><span class="sxs-lookup"><span data-stu-id="ada9e-313">Sorting also depends on the order languages and cultures use for the alphabet.</span></span> <span data-ttu-id="ada9e-314">例如，丹麥文的 "Æ" 字元在字母順序中排列在 "Z" 之後。</span><span class="sxs-lookup"><span data-stu-id="ada9e-314">For example, the Danish language has an "Æ" character that it sorts after "Z" in the alphabet.</span></span> <span data-ttu-id="ada9e-315">此外，比較可以是區分大小寫或區分大小寫，而且在某些情況下的大小寫規則也因文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-315">In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture.</span></span> <span data-ttu-id="ada9e-316">序數比較，相反地，會使用字串時比較和排序字串中的個別字元的 Unicode 字碼指標。</span><span class="sxs-lookup"><span data-stu-id="ada9e-316">Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.</span></span>  
  
 <span data-ttu-id="ada9e-317">排序規則決定彼此的 Unicode 字元的字母順序和兩個字串比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-317">Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other.</span></span> <span data-ttu-id="ada9e-318">例如，<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>方法會比較兩個字串，根據<xref:System.StringComparison>參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-318">For example, the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method compares two strings based on the <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="ada9e-319">如果參數值<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>，如果參數值，這個方法會執行語言比較，會使用目前的文化特性; 慣例<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>，此方法會執行序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-319">If the parameter value is <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, the method performs an ordinal comparison.</span></span> <span data-ttu-id="ada9e-320">因此，如下列範例所示，如果目前的文化特性是美國英文、 第一次呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>（使用區分文化特性的比較） 的方法會考慮"a"小於"A"，但相同的方法 （使用序數比較） 的第二個呼叫會考慮"a"大於"A"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-320">Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".</span></span>  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 <span data-ttu-id="ada9e-321">.NET 支援 word、 字串和序數排序規則：</span><span class="sxs-lookup"><span data-stu-id="ada9e-321">.NET supports word, string, and ordinal sort rules:</span></span>  
  
-   <span data-ttu-id="ada9e-322">文字排序執行區分文化特性比較的字串，其中某些非英數字元的 Unicode 字元可能會被獲指派特殊的權重。</span><span class="sxs-lookup"><span data-stu-id="ada9e-322">A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them.</span></span> <span data-ttu-id="ada9e-323">比方說，連字號 （-） 可能很小的權重，讓"coop"和"co-op"會相互並排顯示已排序的清單中，指派給它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-323">For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list.</span></span> <span data-ttu-id="ada9e-324">取得一份<xref:System.String>方法來比較兩個字串使用字組排序規則，請參閱[依分類的字串作業](#ByCategory)一節。</span><span class="sxs-lookup"><span data-stu-id="ada9e-324">For a list of the <xref:System.String> methods that compare two strings using word sort rules, see the [String operations by category](#ByCategory) section.</span></span>  
  
-   <span data-ttu-id="ada9e-325">字串排序也會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-325">A string sort also performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-326">就像是文字排序，只不過沒有特殊案例，而且所有的非英數符號前面所有英數字元的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-326">It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters.</span></span> <span data-ttu-id="ada9e-327">可以藉由呼叫中使用字串的排序規則比較兩個字串<xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType>方法的多載`options`參數所提供的值<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-327">Two strings can be compared using string sort rules by calling the <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> method overloads that have an `options` parameter that is supplied a value of <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-328">請注意，這是.NET 提供要比較兩個字串時，使用字串的排序規則的唯一方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-328">Note that this is the only method that .NET provides to compare two strings using string sort rules.</span></span>  
  
-   <span data-ttu-id="ada9e-329">序數排序比較根據每個數值的字串<xref:System.Char>字串中的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-329">An ordinal sort compares strings based on the numeric value of each <xref:System.Char> object in the string.</span></span> <span data-ttu-id="ada9e-330">小寫和大寫字元的版本具有不同的字碼指標是，會自動區分大小寫的序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-330">An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points.</span></span> <span data-ttu-id="ada9e-331">不過，如果案例並不重要，您可以指定會忽略大小寫的序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-331">However, if case is not important, you can specify an ordinal comparison that ignores case.</span></span> <span data-ttu-id="ada9e-332">這就相當於將字串轉換成大寫使用文化特性而異，然後在結果上執行序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-332">This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result.</span></span> <span data-ttu-id="ada9e-333">取得一份<xref:System.String>方法來比較兩個字串採用序數排序規則，請參閱[依分類的字串作業](#ByCategory)一節。</span><span class="sxs-lookup"><span data-stu-id="ada9e-333">For a list of the <xref:System.String> methods that compare two strings using ordinal sort rules, see the [String operations by category](#ByCategory) section.</span></span>  
  
 <span data-ttu-id="ada9e-334">區分文化特性的比較是明確或隱含地使用任何比較<xref:System.Globalization.CultureInfo>物件，包括而異的文化特性由<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-334">A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <xref:System.Globalization.CultureInfo> object, including the invariant culture that is specified by the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ada9e-335">隱含的文化特性是所指定的目前文化特性<xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>和<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-335">The implicit culture is the current culture, which is specified by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="ada9e-336">沒有相當大的差異，在排序次序的字母字元 (亦即，字元<xref:System.Char.IsLetter%2A?displayProperty=nameWithType>屬性會傳回`true`) 跨文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-336">There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> property returns `true`) across cultures.</span></span> <span data-ttu-id="ada9e-337">您可以指定使用特定文化特性的慣例，藉由提供區分文化特性比較<xref:System.Globalization.CultureInfo>這類物件的字串比較方法<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-337">You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <xref:System.Globalization.CultureInfo> object to a string comparison method such as <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>.</span></span> <span data-ttu-id="ada9e-338">您可以指定使用目前的文化特性的慣例，藉由提供區分文化特性比較<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>， <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>，或任何成員<xref:System.Globalization.CompareOptions>以外的列舉型別<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>適當多載<xref:System.String.Compare%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-338">You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, or any member of the <xref:System.Globalization.CompareOptions> enumeration other than <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> or <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> to an appropriate overload of the <xref:System.String.Compare%2A> method.</span></span> <span data-ttu-id="ada9e-339">區分文化特性的比較是通常適用於排序，而不是序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-339">A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not.</span></span> <span data-ttu-id="ada9e-340">序數比較是通常適用於判斷兩個字串是否相等 (也就是判斷身分識別) 而不是區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-340">An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.</span></span>  
  
 <span data-ttu-id="ada9e-341">下列範例說明區分文化特性和序數比較之間的差異。</span><span class="sxs-lookup"><span data-stu-id="ada9e-341">The following example illustrates the difference between culture-sensitive and ordinal comparison.</span></span> <span data-ttu-id="ada9e-342">此範例會評估三個字串、"Apple"、"Æble，"和"AEble"，使用序數比較和 DA-DK 和 EN-US 文化特性的慣例 (每個都是預設文化特性時<xref:System.String.Compare%2A>方法呼叫)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-342">The example evaluates three strings, "Apple", "Æble", and "AEble", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <xref:System.String.Compare%2A> method is called).</span></span> <span data-ttu-id="ada9e-343">因為丹麥文語言字元"Æ 」 視為個別的字母，而且會依字母順序的"Z"後面排序，字串"Æble 」 大於"Apple"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-343">Because the Danish language treats the character "Æ" as an individual letter and sorts it after "Z" in the alphabet, the string "Æble" is greater than "Apple".</span></span> <span data-ttu-id="ada9e-344">不過，"Æble"是不被視為相等於"AEble 」，使"Æble 」 也是大於"AEble 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-344">However, "Æble" is not considered equivalent to "AEble", so "Æble" is also greater than "AEble".</span></span> <span data-ttu-id="ada9e-345">EN-US 文化特性不包含字母"Æ"，但會將其視為相當於"AE"，其中說明為什麼 「 Æble"小於"Apple"但為等於"AEble 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-345">The en-US culture doesn't include the letter"Æ" but treats it as equivalent to "AE", which explains why  "Æble" is less than "Apple" but equal to "AEble".</span></span> <span data-ttu-id="ada9e-346">序數比較，相反地，會視為必須小於"Æble 」 和"Æble 「 大於 」 AEble"的"Apple"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-346">Ordinal comparison, on the other hand, considers "Apple" to be less than "Æble", and "Æble" to be greater than "AEble".</span></span>  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 <span data-ttu-id="ada9e-347">您可以使用下列指導方針來選擇適當的排序或字串比較方法：</span><span class="sxs-lookup"><span data-stu-id="ada9e-347">Use the following general guidelines to choose an appropriate sorting or string comparison method:</span></span>  
  
-   <span data-ttu-id="ada9e-348">如果您想根據使用者的文化特性來排序字串，您應該將根據目前的文化特性的慣例加以排序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-348">If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture.</span></span> <span data-ttu-id="ada9e-349">如果使用者的文化特性變更，排序字串的順序將也會據此變更。</span><span class="sxs-lookup"><span data-stu-id="ada9e-349">If the user's culture changes, the order of sorted strings will also change accordingly.</span></span> <span data-ttu-id="ada9e-350">比方說，同義字應用程式應該一律會排序根據使用者的文化特性的字。</span><span class="sxs-lookup"><span data-stu-id="ada9e-350">For example, a thesaurus application should always sort words based on the user's culture.</span></span>  
  
-   <span data-ttu-id="ada9e-351">如果您想要排序的字串依據特定文化特性的慣例，您應該依它們提供<xref:System.Globalization.CultureInfo>物件，表示該文化特性的比較方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-351">If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <xref:System.Globalization.CultureInfo> object that represents that culture to a comparison method.</span></span> <span data-ttu-id="ada9e-352">比方說，在設計來教導學生特定語言的應用程式，您想要排序的字串根據其中一個使用該語言的文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="ada9e-352">For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.</span></span>  
  
-   <span data-ttu-id="ada9e-353">如果您想維持不變，跨文化特性字串順序時，您應該根據文化特性而異的慣例加以排序，或使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-353">If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison.</span></span> <span data-ttu-id="ada9e-354">例如，您會使用序數排序來組織檔案、 處理程序、 mutex 的名稱或具名管道。</span><span class="sxs-lookup"><span data-stu-id="ada9e-354">For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.</span></span>  
  
-   <span data-ttu-id="ada9e-355">如需牽涉到安全性決策 （例如使用者名稱是否有效） 的比較，您應該一律執行序數測試是否相等藉由呼叫的多載<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-355">For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <xref:System.String.Equals%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-356">區分文化特性的排序和大小寫字串比較中使用的規則視.NET 版本而定。</span><span class="sxs-lookup"><span data-stu-id="ada9e-356">The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET.</span></span> <span data-ttu-id="ada9e-357">在.NET Framework 4.5 和更新版本上執行[!INCLUDE[win8](~/includes/win8-md.md)]操作系統、 排序、 大小寫、 正規化和 Unicode 字元資訊符合 Unicode 6.0 標準。</span><span class="sxs-lookup"><span data-stu-id="ada9e-357">In the .NET Framework 4.5 and later versions running on the [!INCLUDE[win8](~/includes/win8-md.md)] operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard.</span></span> <span data-ttu-id="ada9e-358">其他 Windows 作業系統在系統上，其符合標準的 Unicode 5.0。</span><span class="sxs-lookup"><span data-stu-id="ada9e-358">On other Windows operating systems, it conforms to the Unicode 5.0 standard.</span></span> <span data-ttu-id="ada9e-359">在.NET Core，這取決於基礎作業系統所支援的 Unicode 標準版本。</span><span class="sxs-lookup"><span data-stu-id="ada9e-359">On .NET Core, it depends on the version of the Unicode Standard supported by the underlying operating system.</span></span> 
  
 <span data-ttu-id="ada9e-360">如需 word、 字串和序數排序規則的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>主題。</span><span class="sxs-lookup"><span data-stu-id="ada9e-360">For more information about word, string, and ordinal sort rules, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> topic.</span></span> <span data-ttu-id="ada9e-361">如需何時使用每個規則，其他建議，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-361">For additional recommendations on when to use each rule, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ada9e-362">一般情況下，您不呼叫字串比較方法，例如<xref:System.String.Compare%2A>直接以判斷字串的排序次序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-362">Ordinarily, you don't call string comparison methods such as <xref:System.String.Compare%2A> directly to determine the sort order of strings.</span></span> <span data-ttu-id="ada9e-363">相反地，例如排序方法會呼叫比較方法<xref:System.Array.Sort%2A?displayProperty=nameWithType>或<xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-363">Instead, comparison methods are called by sorting methods such as <xref:System.Array.Sort%2A?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-364">下列範例執行四個不同排序作業 （使用目前文化特性、 使用區分文化特性的字組排序、 序數排序，以及使用文化特性而異的字串排序字組排序），而不需要明確呼叫字串比較方法，雖然它們指定要使用的比較類型。</span><span class="sxs-lookup"><span data-stu-id="ada9e-364">The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use.</span></span> <span data-ttu-id="ada9e-365">請注意，每一種排序會產生唯一的字串，其陣列中所用的順序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-365">Note that each type of sort produces a unique ordering of strings in its array.</span></span>  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  <span data-ttu-id="ada9e-366">就內部而言，.NET 會使用排序索引鍵，以支援區分文化特性的字串比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-366">Internally, .NET uses sort keys to support culturally sensitive string comparison.</span></span> <span data-ttu-id="ada9e-367">每一個字元在字串中的提供排序權數，包括字母、 大小寫和變音符號的數個的類別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-367">Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic.</span></span> <span data-ttu-id="ada9e-368">排序索引鍵，由<xref:System.Globalization.SortKey>類別中，提供這些加權的存放庫特定的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-368">A sort key, represented by the <xref:System.Globalization.SortKey> class, provides a repository of these weights for a particular string.</span></span> <span data-ttu-id="ada9e-369">如果您的應用程式會執行大量搜尋或排序在相同的字串集合上的作業，您可以藉由產生並儲存它所使用的所有字串的排序鍵來改善其效能。</span><span class="sxs-lookup"><span data-stu-id="ada9e-369">If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses.</span></span> <span data-ttu-id="ada9e-370">需要排序或比較運算時，您會使用的排序索引鍵，而不是字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-370">When a sort or comparison operation is required, you use the sort keys instead of the strings.</span></span> <span data-ttu-id="ada9e-371">如需詳細資訊，請參閱 <xref:System.Globalization.SortKey> 類別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-371">For more information, see the <xref:System.Globalization.SortKey> class.</span></span>  
  
 <span data-ttu-id="ada9e-372">如果您未指定的字串比較的慣例，排序方法這類<xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>對字串執行區分文化特性，區分大小寫排序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-372">If you don't specify a string comparison convention, sorting methods such as <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> perform a culture-sensitive, case-sensitive sort on strings.</span></span> <span data-ttu-id="ada9e-373">下列範例說明如何變更目前的文化特性會影響已排序字串陣列中的順序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-373">The following example illustrates how changing the current culture affects the order of sorted strings in an array.</span></span> <span data-ttu-id="ada9e-374">它會建立三個字串的陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-374">It creates an array of three strings.</span></span> <span data-ttu-id="ada9e-375">首先，它會設定`System.Threading.Thread.CurrentThread.CurrentCulture`屬性設為 EN-US 並呼叫<xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-375">First, it sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to en-US and calls the <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ada9e-376">產生的排序次序會根據排序的英文 （美國） 文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="ada9e-376">The resulting sort order is based on sorting conventions for the English (United States) culture.</span></span> <span data-ttu-id="ada9e-377">接下來，範例會設定`System.Threading.Thread.CurrentThread.CurrentCulture`屬性設為 DA-DK 並呼叫<xref:System.Array.Sort%2A?displayProperty=nameWithType>方法一次。</span><span class="sxs-lookup"><span data-stu-id="ada9e-377">Next, the example sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to da-DK and calls the <xref:System.Array.Sort%2A?displayProperty=nameWithType> method again.</span></span> <span data-ttu-id="ada9e-378">請注意如何產生的排序次序不同於 EN-US 結果因為它會使用丹麥文 （丹麥） 排序慣例。</span><span class="sxs-lookup"><span data-stu-id="ada9e-378">Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).</span></span>  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  <span data-ttu-id="ada9e-379">如果您在比較字串的主要目的是要判斷是否相等，您應該呼叫<xref:System.String.Equals%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-379">If your primary purpose in comparing strings is to determine whether they are equal, you should call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ada9e-380">一般而言，您應該使用<xref:System.String.Equals%2A>来執行序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-380">Typically, you should use <xref:System.String.Equals%2A> to perform an ordinal comparison.</span></span> <span data-ttu-id="ada9e-381"><xref:System.String.Compare%2A?displayProperty=nameWithType>方法主要為了排序字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-381">The <xref:System.String.Compare%2A?displayProperty=nameWithType> method is intended primarily to sort strings.</span></span>  
  
 <span data-ttu-id="ada9e-382">字串搜尋方法，例如<xref:System.String.StartsWith%2A?displayProperty=nameWithType>和<xref:System.String.IndexOf%2A?displayProperty=nameWithType>，也可以執行區分文化特性或序數字串比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-382">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons.</span></span> <span data-ttu-id="ada9e-383">下列範例說明使用序數和區分文化特性的比較差異<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-383">The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="ada9e-384">中目前的文化特性是英文 （美國） 文化特性搜尋會視為 「 oe 」，以符合連音符號"œ"的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-384">A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "œ".</span></span> <span data-ttu-id="ada9e-385">因為選擇性連字號 (U + 00AD) 是零寬度的字元，則搜尋會將選擇性連字號視為相當於<xref:System.String.Empty>和字串的開頭在找到相符項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-385">Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <xref:System.String.Empty> and finds a match at the beginning of the string.</span></span> <span data-ttu-id="ada9e-386">序數搜尋，相反地，找不到相符項目在任一情況下。</span><span class="sxs-lookup"><span data-stu-id="ada9e-386">An ordinal search, on the other hand, does not find a match in either case.</span></span>  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a><span data-ttu-id="ada9e-387">搜尋字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-387">Searching Strings</span></span>  
 <span data-ttu-id="ada9e-388">字串搜尋方法，例如<xref:System.String.StartsWith%2A?displayProperty=nameWithType>和<xref:System.String.IndexOf%2A?displayProperty=nameWithType>，也可以執行區分文化特性或指定的字串中找到的序數字串比較，以判斷是否在字元或子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-388">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.</span></span>  
  
 <span data-ttu-id="ada9e-389">中的搜尋方法<xref:System.String>類別的搜尋的個別字元，例如<xref:System.String.IndexOf%2A>方法，或其中一個的一組字元，例如<xref:System.String.IndexOfAny%2A>方法中，所有執行的序數搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-389">The search methods in the <xref:System.String> class that search for an individual character, such as the <xref:System.String.IndexOf%2A> method, or one of a set of characters,   such as the <xref:System.String.IndexOfAny%2A> method, all perform an ordinal search.</span></span> <span data-ttu-id="ada9e-390">若要執行區分文化特性的搜尋的字元，您必須呼叫<xref:System.Globalization.CompareInfo>方法，例如<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>或<xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-390">To perform a culture-sensitive search for a character, you must call a <xref:System.Globalization.CompareInfo> method such as <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> or <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-391">請注意，搜尋字元，使用序數和區分文化特性比較的結果可能大不相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-391">Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different.</span></span> <span data-ttu-id="ada9e-392">比方說，搜尋預先組成的 Unicode 字元，例如連音符號"Æ 」 (U + 00 C 6) 可能會比對出現在正確的順序，例如"AE"及其元件的任何 （U + 041U + 0045），根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-392">For example, a search for a precomposed Unicode character such as the ligature "Æ" (U+00C6) might match any occurrence of its components in the correct sequence, such as "AE" (U+041U+0045), depending on the culture.</span></span> <span data-ttu-id="ada9e-393">下列範例說明之間的差異<xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType>和<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>方法搜尋的個別字元時。</span><span class="sxs-lookup"><span data-stu-id="ada9e-393">The following example illustrates the difference between the <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> and <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> methods when searching for an individual character.</span></span> <span data-ttu-id="ada9e-394">連音符號"æ 」 (U + 00E6) 中找到字串"空照圖 」 時使用 EN-US 文化特性的慣例，但不是使用時 DA-DK 文化特性的慣例或執行序數比較時。</span><span class="sxs-lookup"><span data-stu-id="ada9e-394">The ligature "æ" (U+00E6) is found in the string "aerial" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 <span data-ttu-id="ada9e-395">相反地，<xref:System.String>類別搜尋字串，而不是字元執行區分文化特性的搜尋，如果搜尋選項未明確指定類型的參數的方法<xref:System.StringComparison>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-395">On the other hand, <xref:System.String> class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <xref:System.StringComparison>.</span></span> <span data-ttu-id="ada9e-396">唯一的例外狀況是<xref:System.String.Contains%2A>，會執行序數的搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-396">The sole exception is <xref:System.String.Contains%2A>, which performs an ordinal search.</span></span>  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a><span data-ttu-id="ada9e-397">測試相等</span><span class="sxs-lookup"><span data-stu-id="ada9e-397">Testing for equality</span></span>  
 <span data-ttu-id="ada9e-398">使用<xref:System.String.Compare%2A?displayProperty=nameWithType>方法，以判斷兩個字串在排序次序中的關聯性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-398">Use the <xref:System.String.Compare%2A?displayProperty=nameWithType> method to determine the relationship of two strings in the sort order.</span></span> <span data-ttu-id="ada9e-399">一般而言，這是區分文化特性的作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-399">Typically, this is a culture-sensitive operation.</span></span> <span data-ttu-id="ada9e-400">相反地，呼叫<xref:System.String.Equals%2A?displayProperty=nameWithType>方法來測試是否相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-400">In contrast, call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method to test for equality.</span></span> <span data-ttu-id="ada9e-401">因為相等測試通常會比對使用者輸入一些已知的字串，例如有效的使用者名稱、 密碼或檔案系統路徑，但它通常是序數的作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-401">Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ada9e-402">可以藉由呼叫測試是否相等<xref:System.String.Compare%2A?displayProperty=nameWithType>方法，並判斷傳回的值是否為零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-402">It is possible to test for equality by calling the <xref:System.String.Compare%2A?displayProperty=nameWithType> method and determining whether the return value is zero.</span></span> <span data-ttu-id="ada9e-403">不過，不建議這種做法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-403">However, this practice is not recommended.</span></span> <span data-ttu-id="ada9e-404">若要判斷兩個字串是否相等，您應該呼叫其中一個多載<xref:System.String.Equals%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-404">To determine whether two strings are equal, you should call one of the overloads of the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ada9e-405">慣用的多載，以呼叫為任一個執行個體<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>方法或靜態<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，因為這兩種方法都包含<xref:System.StringComparison?displayProperty=nameWithType>明確指定的比較類型的參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-405">The preferred overload to call is either the instance <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method or the static <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, because both methods include a <xref:System.StringComparison?displayProperty=nameWithType> parameter that explicitly specifies the type of comparison.</span></span>  
  
 <span data-ttu-id="ada9e-406">下列範例說明執行區分文化特性比較相等時應該改為使用其中一個為序數的危險。</span><span class="sxs-lookup"><span data-stu-id="ada9e-406">The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead.</span></span> <span data-ttu-id="ada9e-407">在此情況下，程式碼的意圖是禁止執行不區分大小寫的 URL，以使用字串"FILE:// 開頭比較的方式以"FILE:// 或"file:// 開頭的 Url 中的檔案系統存取權。</span><span class="sxs-lookup"><span data-stu-id="ada9e-407">In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://".</span></span> <span data-ttu-id="ada9e-408">不過，如果以"file:// 開頭的 URL 上使用土耳其文 （土耳其） 文化特性執行區分文化特性的比較，相等的比較會失敗，因為土耳其文的大寫對等的小寫字母"i"為"i"而不是"I"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-408">However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "İ" instead of "I".</span></span> <span data-ttu-id="ada9e-409">如此一來，不小心允許檔案系統存取權。</span><span class="sxs-lookup"><span data-stu-id="ada9e-409">As a result, file system access is inadvertently permitted.</span></span> <span data-ttu-id="ada9e-410">相反地，如果執行序數比較，則成功的相等比較，和檔案系統存取遭到拒絕。</span><span class="sxs-lookup"><span data-stu-id="ada9e-410">On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.</span></span>  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a><span data-ttu-id="ada9e-411">正規化</span><span class="sxs-lookup"><span data-stu-id="ada9e-411">Normalization</span></span>  
 <span data-ttu-id="ada9e-412">某些 Unicode 字元有多種表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-412">Some Unicode characters have multiple representations.</span></span> <span data-ttu-id="ada9e-413">例如，任何下列的字碼指標可以代表字母"ắ 」:</span><span class="sxs-lookup"><span data-stu-id="ada9e-413">For example, any of the following code points can represent the letter "ắ":</span></span>  
  
-   <span data-ttu-id="ada9e-414">U+1EAF</span><span class="sxs-lookup"><span data-stu-id="ada9e-414">U+1EAF</span></span>  
  
-   <span data-ttu-id="ada9e-415">U+0103 U+0301</span><span class="sxs-lookup"><span data-stu-id="ada9e-415">U+0103 U+0301</span></span>  
  
-   <span data-ttu-id="ada9e-416">U+0061 U+0306 U+0301</span><span class="sxs-lookup"><span data-stu-id="ada9e-416">U+0061 U+0306 U+0301</span></span>  
  
 <span data-ttu-id="ada9e-417">搜尋、 排序、 比對，和其他字串作業，會讓複雜的單一字元的多種表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-417">Multiple representations for a single character complicate searching, sorting, matching, and other string operations.</span></span>  
  
 <span data-ttu-id="ada9e-418">Unicode 標準會定義稱為傳回一個的二進位表示法的 Unicode 字元的任何其對等的二進位表示法的正規化程序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-418">The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations.</span></span> <span data-ttu-id="ada9e-419">正規化可以使用數種演算法，稱為正規化表單，可遵循不同的規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-419">Normalization can use several algorithms, called normalization forms, that follow different rules.</span></span> <span data-ttu-id="ada9e-420">.NET 支援的 Unicode 正規化表單 C、 D、 KC 和 KD。</span><span class="sxs-lookup"><span data-stu-id="ada9e-420">.NET supports Unicode normalization forms C, D, KC, and KD.</span></span> <span data-ttu-id="ada9e-421">當字串已經正規化成相同的正規化格式時，他們可以使用序數比較來比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-421">When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="ada9e-422">序數比較是對應的 Unicode 純量值的二進位比較<xref:System.Char>每個字串中的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-422">An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <xref:System.Char> objects in each string.</span></span> <span data-ttu-id="ada9e-423"><xref:System.String>類別包含數種方法，可以執行序數比較，包括下列：</span><span class="sxs-lookup"><span data-stu-id="ada9e-423">The <xref:System.String> class includes a number of methods that can perform an ordinal comparison, including the following:</span></span>  
  
-   <span data-ttu-id="ada9e-424">任何多載<xref:System.String.Compare%2A>， <xref:System.String.Equals%2A>， <xref:System.String.StartsWith%2A>， <xref:System.String.EndsWith%2A>， <xref:System.String.IndexOf%2A>，和<xref:System.String.LastIndexOf%2A>方法，其中包含<xref:System.StringComparison>參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-424">Any overload of the <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>,  <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, and <xref:System.String.LastIndexOf%2A> methods that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="ada9e-425">如果您提供的值，這個方法會執行序數比較<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase>此參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-425">The method performs an ordinal comparison if you supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase> for this parameter.</span></span>  
  
-   <span data-ttu-id="ada9e-426">多載<xref:System.String.CompareOrdinal%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-426">The overloads of the <xref:System.String.CompareOrdinal%2A> method.</span></span>  
  
-   <span data-ttu-id="ada9e-427">根據預設，使用序數比較，例如的方法<xref:System.String.Contains%2A>， <xref:System.String.Replace%2A>，和<xref:System.String.Split%2A>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-427">Methods that use ordinal comparison by default, such as <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, and <xref:System.String.Split%2A>.</span></span>  
  
-   <span data-ttu-id="ada9e-428">搜尋的方法<xref:System.Char>值或中的項目<xref:System.Char>字串執行個體中的陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-428">Methods that search for a <xref:System.Char> value or for the elements in a <xref:System.Char> array in a string instance.</span></span> <span data-ttu-id="ada9e-429">這類方法包括<xref:System.String.IndexOf%28System.Char%29>和<xref:System.String.Split%28System.Char%5B%5D%29>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-429">Such methods include <xref:System.String.IndexOf%28System.Char%29> and <xref:System.String.Split%28System.Char%5B%5D%29>.</span></span>  
  
 <span data-ttu-id="ada9e-430">您可以判斷字串是否會正規化為正規化格式 C 藉由呼叫<xref:System.String.IsNormalized?displayProperty=nameWithType>方法，或者您可以呼叫<xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType>方法，以判斷是否要將字串標準化為指定的正規化格式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-430">You can determine whether a string is normalized to normalization form C by calling the <xref:System.String.IsNormalized?displayProperty=nameWithType> method, or you can call the <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to determine whether a string is normalized to a specified normalization form.</span></span> <span data-ttu-id="ada9e-431">您也可以呼叫<xref:System.String.Normalize?displayProperty=nameWithType>方法，以將字串轉換為正規化格式 C，或您可以呼叫<xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType>方法，以將字串轉換為指定的正規化格式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-431">You can also call the <xref:System.String.Normalize?displayProperty=nameWithType> method to convert a string to normalization form C, or you can call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to convert a string to a specified normalization form.</span></span> <span data-ttu-id="ada9e-432">逐步將正規化和比較字串的詳細資訊，請參閱<xref:System.String.Normalize>和<xref:System.String.Normalize%28System.Text.NormalizationForm%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-432">For step-by-step information about normalizing and comparing strings, see the <xref:System.String.Normalize> and <xref:System.String.Normalize%28System.Text.NormalizationForm%29> methods.</span></span>  
  
 <span data-ttu-id="ada9e-433">下列的簡單範例說明字串正規化。</span><span class="sxs-lookup"><span data-stu-id="ada9e-433">The following simple example illustrates string normalization.</span></span> <span data-ttu-id="ada9e-434">它會以三個不同的方式，在三個不同的字串，定義字母"ố 」，並使用以判斷每個字串，不同於其他兩個字串的序數比較相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-434">It defines the letter "ố" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings.</span></span> <span data-ttu-id="ada9e-435">它接著將每個字串轉換成支援的正規化格式，並再次執行每個字串的序數比較，為指定的正規化格式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-435">It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form.</span></span> <span data-ttu-id="ada9e-436">在每個案例中，第二項測試相等; 會顯示字串相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-436">In each case, the second test for equality shows that the strings are equal.</span></span>  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 <span data-ttu-id="ada9e-437">如需有關正規化和正規化表單的詳細資訊，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>，以及[Unicode 標準附錄 #15:Unicode Normalization Forms](https://unicode.org/reports/tr15/)而[正規化常見問題集](https://www.unicode.org/faq/normalization.html)unicode.org 網站上。</span><span class="sxs-lookup"><span data-stu-id="ada9e-437">For more information about normalization and normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, as well as [Unicode Standard Annex #15: Unicode Normalization Forms](https://unicode.org/reports/tr15/) and the [Normalization FAQ](https://www.unicode.org/faq/normalization.html) on the unicode.org website.</span></span>  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a><span data-ttu-id="ada9e-438">依類別目錄的字串作業</span><span class="sxs-lookup"><span data-stu-id="ada9e-438">String operations by category</span></span>  
 <span data-ttu-id="ada9e-439"><xref:System.String>類別提供成員來比較測試字串是否相等，尋找的字元或在字串中，修改字串，擷取來自字串、 組合字串，格式化的值，複製字串的子字串的子字串的字串和正規化字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-439">The <xref:System.String> class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.</span></span>  
  
### <a name="comparing-strings"></a><span data-ttu-id="ada9e-440">比較字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-440">Comparing strings</span></span>  
 <span data-ttu-id="ada9e-441">您可以比較字串，以判斷兩者在排序次序中的相對位置，使用下列<xref:System.String>方法：</span><span class="sxs-lookup"><span data-stu-id="ada9e-441">You can compare strings to determine their relative position in the sort order by using the following <xref:System.String> methods:</span></span>  
  
-   <span data-ttu-id="ada9e-442"><xref:System.String.Compare%2A> 傳回一個整數，表示要在排序次序中的第二個字串的一個字串的關聯性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-442"><xref:System.String.Compare%2A> returns an integer that indicates the relationship of one string to a second string in the sort order.</span></span>  
  
-   <span data-ttu-id="ada9e-443"><xref:System.String.CompareOrdinal%2A> 傳回一個整數，表示一個字串，以根據其字碼指標比較的第二個字串的關聯性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-443"><xref:System.String.CompareOrdinal%2A> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.</span></span>  
  
-   <span data-ttu-id="ada9e-444"><xref:System.String.CompareTo%2A> 傳回一個整數，表示目前的字串執行個體在排序次序中的第二個字串的關聯性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-444"><xref:System.String.CompareTo%2A> returns an integer that indicates the relationship of the current string instance to a second string in the sort order.</span></span> <span data-ttu-id="ada9e-445"><xref:System.String.CompareTo%28System.String%29>方法會提供<xref:System.IComparable>並<xref:System.IComparable%601>實作<xref:System.String>類別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-445">The <xref:System.String.CompareTo%28System.String%29> method provides the <xref:System.IComparable> and <xref:System.IComparable%601> implementations for the <xref:System.String> class.</span></span>  
  
### <a name="testing-strings-for-equality"></a><span data-ttu-id="ada9e-446">測試字串相等</span><span class="sxs-lookup"><span data-stu-id="ada9e-446">Testing strings for equality</span></span>  
 <span data-ttu-id="ada9e-447">您呼叫<xref:System.String.Equals%2A>方法，以判斷兩個字串是否相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-447">You call the <xref:System.String.Equals%2A> method to determine whether two strings are equal.</span></span> <span data-ttu-id="ada9e-448">執行個體<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>和 靜態<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>多載可讓您指定比較是否區分文化特性或序數，以及案例是考慮或忽略。</span><span class="sxs-lookup"><span data-stu-id="ada9e-448">The instance <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> and the static <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored.</span></span> <span data-ttu-id="ada9e-449">大部分的測試相等為序數，並比較相等，以決定系統資源 （例如檔案系統物件） 的存取權應該一律是序數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-449">Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.</span></span>  
  
### <a name="finding-characters-in-a-string"></a><span data-ttu-id="ada9e-450">尋找字串中的字元</span><span class="sxs-lookup"><span data-stu-id="ada9e-450">Finding characters in a string</span></span>  
 <span data-ttu-id="ada9e-451"><xref:System.String>類別包含兩種類型的搜尋方法：</span><span class="sxs-lookup"><span data-stu-id="ada9e-451">The <xref:System.String> class includes two kinds of search methods:</span></span>  
  
-   <span data-ttu-id="ada9e-452">方法會傳回<xref:System.Boolean>可指出特定的子字串是否出現在字串執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-452">Methods that return a <xref:System.Boolean> value to indicate whether a particular substring is present in a string instance.</span></span> <span data-ttu-id="ada9e-453">其中包括<xref:System.String.Contains%2A>， <xref:System.String.EndsWith%2A>，和<xref:System.String.StartsWith%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-453">These include the <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, and <xref:System.String.StartsWith%2A> methods.</span></span>  
  
-   <span data-ttu-id="ada9e-454">表示字串執行個體中的子字串開始位置的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-454">Methods that indicate the starting position of a substring in a string instance.</span></span> <span data-ttu-id="ada9e-455">其中包括<xref:System.String.IndexOf%2A>， <xref:System.String.IndexOfAny%2A>， <xref:System.String.LastIndexOf%2A>，和<xref:System.String.LastIndexOfAny%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-455">These include the <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, and <xref:System.String.LastIndexOfAny%2A> methods.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ada9e-456">如果您想要搜尋特定的模式，而不是特定的子字串的字串，您應該使用規則運算式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-456">If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions.</span></span> <span data-ttu-id="ada9e-457">如需詳細資訊，請參閱 < [.NET 規則運算式](~/docs/standard/base-types/regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-457">For more information, see [.NET Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>  
  
### <a name="modifying-a-string"></a><span data-ttu-id="ada9e-458">修改字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-458">Modifying a string</span></span>  
 <span data-ttu-id="ada9e-459"><xref:System.String>類別包含下列方法看似修改字串的值：</span><span class="sxs-lookup"><span data-stu-id="ada9e-459">The <xref:System.String> class includes the following methods that appear to modify the value of a string:</span></span>  
  
-   <span data-ttu-id="ada9e-460"><xref:System.String.Insert%2A> 將字串插入至目前<xref:System.String>執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-460"><xref:System.String.Insert%2A> inserts a string into the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="ada9e-461"><xref:System.String.PadLeft%2A> 將指定之字元的一個或多個插入字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="ada9e-461"><xref:System.String.PadLeft%2A> inserts one or more occurrences of a specified character at the beginning of a string.</span></span>  
  
-   <span data-ttu-id="ada9e-462"><xref:System.String.PadRight%2A> 將指定之字元的一個或多個插入字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-462"><xref:System.String.PadRight%2A> inserts one or more occurrences of a specified character at the end of a string.</span></span>  
  
-   <span data-ttu-id="ada9e-463"><xref:System.String.Remove%2A> 刪除從目前的子字串<xref:System.String>執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-463"><xref:System.String.Remove%2A> deletes a substring from the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="ada9e-464"><xref:System.String.Replace%2A> 使用在目前的另一個子字串取代子字串<xref:System.String>執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-464"><xref:System.String.Replace%2A> replaces a substring with another substring in the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="ada9e-465"><xref:System.String.ToLower%2A> 和<xref:System.String.ToLowerInvariant%2A>將字串中的所有字元都轉換成小寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-465"><xref:System.String.ToLower%2A> and <xref:System.String.ToLowerInvariant%2A> convert all the characters in a string to lowercase.</span></span>  
  
-   <span data-ttu-id="ada9e-466"><xref:System.String.ToUpper%2A> 和<xref:System.String.ToUpperInvariant%2A>字串中的所有字元都轉換成大寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-466"><xref:System.String.ToUpper%2A> and <xref:System.String.ToUpperInvariant%2A> convert all the characters in a string to uppercase.</span></span>  
  
-   <span data-ttu-id="ada9e-467"><xref:System.String.Trim%2A> 移除開頭和結尾字串的所有出現的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-467"><xref:System.String.Trim%2A> removes all occurrences of a character from the beginning and end of a string.</span></span>  
  
-   <span data-ttu-id="ada9e-468"><xref:System.String.TrimEnd%2A> 從字串的結尾移除所有出現的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-468"><xref:System.String.TrimEnd%2A> removes all occurrences of a character from the end of a string.</span></span>  
  
-   <span data-ttu-id="ada9e-469"><xref:System.String.TrimStart%2A> 從移除所有出現的字元字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="ada9e-469"><xref:System.String.TrimStart%2A> removes all occurrences of a character from the beginning of a string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ada9e-470">字串修改的所有方法都會都傳回新<xref:System.String>物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-470">All string modification methods return a new <xref:System.String> object.</span></span> <span data-ttu-id="ada9e-471">它們不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-471">They don't modify the value of the current instance.</span></span>  
  
### <a name="extracting-substrings-from-a-string"></a><span data-ttu-id="ada9e-472">從字串擷取子字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-472">Extracting substrings from a string</span></span>  
 <span data-ttu-id="ada9e-473"><xref:System.String.Split%2A?displayProperty=nameWithType>方法會將單一字串分隔成多個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-473">The <xref:System.String.Split%2A?displayProperty=nameWithType> method separates a single string into multiple strings.</span></span> <span data-ttu-id="ada9e-474">方法的多載可讓您指定多個分隔符號，來判斷擷取方法的子字串的最大數目，以及判斷空字串 （這就是相鄰的分隔符號時，就會發生） 是否包含在所傳回的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-474">Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.</span></span>  
  
### <a name="combining-strings"></a><span data-ttu-id="ada9e-475">結合字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-475">Combining strings</span></span>  
 <span data-ttu-id="ada9e-476">下列<xref:System.String>方法可用於字串串連：</span><span class="sxs-lookup"><span data-stu-id="ada9e-476">The following <xref:System.String> methods can be used for string concatenation:</span></span>  
  
-   <span data-ttu-id="ada9e-477"><xref:System.String.Concat%2A> 結合成單一字串的一或多個子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-477"><xref:System.String.Concat%2A> combines one or more substrings into a single string.</span></span>  
  
-   <span data-ttu-id="ada9e-478"><xref:System.String.Join%2A> 串連成單一元素的一或多個子字串，並將每一個子字串之間的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-478"><xref:System.String.Join%2A> concatenates one or more substrings into a single element and adds a separator between each substring.</span></span>  
  
### <a name="formatting-values"></a><span data-ttu-id="ada9e-479">格式化的值</span><span class="sxs-lookup"><span data-stu-id="ada9e-479">Formatting values</span></span>  
 <span data-ttu-id="ada9e-480"><xref:System.String.Format%2A?displayProperty=nameWithType>方法使用複合格式功能的某些物件或值的字串表示取代字串中的一或多個預留位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-480">The <xref:System.String.Format%2A?displayProperty=nameWithType> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value.</span></span> <span data-ttu-id="ada9e-481"><xref:System.String.Format%2A>方法通常用來執行下列動作：</span><span class="sxs-lookup"><span data-stu-id="ada9e-481">The <xref:System.String.Format%2A> method is often used to do the following:</span></span>  
  
-   <span data-ttu-id="ada9e-482">若要在字串中內嵌之數值的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-482">To embed the string representation of a numeric value in a string.</span></span>  
  
-   <span data-ttu-id="ada9e-483">若要在字串中內嵌的日期和時間值的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-483">To embed the string representation of a date and time value in a string.</span></span>  
  
-   <span data-ttu-id="ada9e-484">若要在字串中內嵌的列舉值的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-484">To embed the string representation of an enumeration value in a string.</span></span>  
  
-   <span data-ttu-id="ada9e-485">若要內嵌支援某些物件的字串表示<xref:System.IFormattable>字串中的介面。</span><span class="sxs-lookup"><span data-stu-id="ada9e-485">To embed the string representation of some object that supports the <xref:System.IFormattable> interface in a string.</span></span>  
  
-   <span data-ttu-id="ada9e-486">若要靠右對齊或子字串在較大的字串內的欄位中靠左對齊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-486">To right-justify or left-justify a substring in a field within a larger string.</span></span>  
  
 <span data-ttu-id="ada9e-487">如需格式化作業和範例的詳細資訊，請參閱<xref:System.String.Format%2A>多載摘要。</span><span class="sxs-lookup"><span data-stu-id="ada9e-487">For detailed information about formatting operations and examples, see the <xref:System.String.Format%2A> overload summary.</span></span>  
  
### <a name="copying-a-string"></a><span data-ttu-id="ada9e-488">複製字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-488">Copying a string</span></span>  
 <span data-ttu-id="ada9e-489">您可以呼叫下列<xref:System.String>方法來建立一份字串：</span><span class="sxs-lookup"><span data-stu-id="ada9e-489">You can call the following <xref:System.String> methods to make a copy of a string:</span></span>  
  
-   <span data-ttu-id="ada9e-490"><xref:System.String.Clone%2A> 傳回參考現有<xref:System.String>物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-490"><xref:System.String.Clone%2A> returns a reference to an existing <xref:System.String> object.</span></span>  
  
-   <span data-ttu-id="ada9e-491"><xref:System.String.Copy%2A> 建立一份現有的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-491"><xref:System.String.Copy%2A> creates a copy of an existing string.</span></span>  
  
-   <span data-ttu-id="ada9e-492"><xref:System.String.CopyTo%2A> 將字串的一部分複製到字元陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-492"><xref:System.String.CopyTo%2A> copies a portion of a string to a character array.</span></span>  
  
### <a name="normalizing-a-string"></a><span data-ttu-id="ada9e-493">正規化字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-493">Normalizing a string</span></span>  
 <span data-ttu-id="ada9e-494">在 Unicode 中，單一字元可以有多個字碼指標。</span><span class="sxs-lookup"><span data-stu-id="ada9e-494">In Unicode, a single character can have multiple code points.</span></span> <span data-ttu-id="ada9e-495">正規化會將這些對等的字元轉換成相同的二進位表示法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-495">Normalization converts these equivalent characters into the same binary representation.</span></span> <span data-ttu-id="ada9e-496"><xref:System.String.Normalize%2A?displayProperty=nameWithType>方法會執行正規化和<xref:System.String.IsNormalized%2A?displayProperty=nameWithType>方法會判斷字串是否已標準化。</span><span class="sxs-lookup"><span data-stu-id="ada9e-496">The <xref:System.String.Normalize%2A?displayProperty=nameWithType> method performs the normalization, and the <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> method determines whether a string is normalized.</span></span>  
  
 <span data-ttu-id="ada9e-497">如需詳細資訊和範例，請參閱 <<c0> [ 正規化](#Normalization)稍早在本主題中的區段。</span><span class="sxs-lookup"><span data-stu-id="ada9e-497">For more information and an example, see the [Normalization](#Normalization) section earlier in this topic.</span></span>  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/en-us/download/details.aspx?id=10921"><span data-ttu-id="ada9e-498">排序資料表的權數的 Windows 作業系統</span><span class="sxs-lookup"><span data-stu-id="ada9e-498">Sorting Weight Tables for Windows operating systems</span></span></related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt"><span data-ttu-id="ada9e-499">預設 Unicode 定序項目資料表中，適用於 Linux 和 macOS</span><span class="sxs-lookup"><span data-stu-id="ada9e-499">Default Unicode Collation Element Table, for Linux and macOS</span></span></related>
    <threadsafe><span data-ttu-id="ada9e-500">此型別具備執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="ada9e-500">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ada9e-501">在 .NET 中將類型格式化</span><span class="sxs-lookup"><span data-stu-id="ada9e-501">Formatting Types in .NET</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7"><span data-ttu-id="ada9e-502">在 .NET Framework 中使用字串的最佳作法</span><span class="sxs-lookup"><span data-stu-id="ada9e-502">Best Practices for Using Strings in the .NET Framework</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-503">初始化 <see cref="T:System.String" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-503">Initializes a new instance of the <see cref="T:System.String" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-504">本節內容：</span><span class="sxs-lookup"><span data-stu-id="ada9e-504">In this section:</span></span>  
  
 <span data-ttu-id="ada9e-505">[多載的建構函式語法](#Syntax) </span><span class="sxs-lookup"><span data-stu-id="ada9e-505">[Overloaded constructor syntax](#Syntax) </span></span>  
 <span data-ttu-id="ada9e-506">[參數](#Params) </span><span class="sxs-lookup"><span data-stu-id="ada9e-506">[Parameters](#Params) </span></span>  
 <span data-ttu-id="ada9e-507">[例外狀況](#Exceptions) </span><span class="sxs-lookup"><span data-stu-id="ada9e-507">[Exceptions](#Exceptions) </span></span>  
 <span data-ttu-id="ada9e-508">[我呼叫的方法？](#Tasks) </span><span class="sxs-lookup"><span data-stu-id="ada9e-508">[Which method do I call?](#Tasks) </span></span>  
 <span data-ttu-id="ada9e-509">[建立字串](#Creating_Strings) </span><span class="sxs-lookup"><span data-stu-id="ada9e-509">[Creating strings](#Creating_Strings) </span></span>  
 <span data-ttu-id="ada9e-510">[處理重複的字串](#Repetitive) </span><span class="sxs-lookup"><span data-stu-id="ada9e-510">[Handling repetitive strings](#Repetitive) </span></span>  
 <span data-ttu-id="ada9e-511">具現化字串的範例：</span><span class="sxs-lookup"><span data-stu-id="ada9e-511">Examples of instantiating strings:</span></span>   
 [<span data-ttu-id="ada9e-512">使用字串指派</span><span class="sxs-lookup"><span data-stu-id="ada9e-512">Using string assignment</span></span>](#Ctor1_Example)  
 [<span data-ttu-id="ada9e-513">使用的字元陣列</span><span class="sxs-lookup"><span data-stu-id="ada9e-513">Using a character array</span></span>](#Ctor2_Example)  
 [<span data-ttu-id="ada9e-514">使用字元陣列中的部分，並重複單一字元</span><span class="sxs-lookup"><span data-stu-id="ada9e-514">Using a portion of a character array and repeating a single character</span></span>](#Ctor3_Example)  
 [<span data-ttu-id="ada9e-515">使用字元陣列的指標</span><span class="sxs-lookup"><span data-stu-id="ada9e-515">Using a pointer to a character array</span></span>](#Ctor4_Example)  
 [<span data-ttu-id="ada9e-516">使用指標和陣列的範圍</span><span class="sxs-lookup"><span data-stu-id="ada9e-516">Using  a pointer and a range of an array</span></span>](#Ctor5_Example)  
 [<span data-ttu-id="ada9e-517">使用帶正負號的位元組陣列的指標</span><span class="sxs-lookup"><span data-stu-id="ada9e-517">Using a pointer to a signed byte array</span></span>](#Ctor6_Example)  
[<span data-ttu-id="ada9e-518">版本資訊</span><span class="sxs-lookup"><span data-stu-id="ada9e-518">Version information</span></span>](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a><span data-ttu-id="ada9e-519">多載的建構函式語法</span><span class="sxs-lookup"><span data-stu-id="ada9e-519">Overloaded constructor syntax</span></span>  
 <span data-ttu-id="ada9e-520">String 建構函式分為兩類： 不使用指標參數，以及使用指標參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-520">String constructors fall into two categories: those without pointer parameters, and those with pointer parameters.</span></span> <span data-ttu-id="ada9e-521">使用指標的建構函式不符合 CLS 標準。</span><span class="sxs-lookup"><span data-stu-id="ada9e-521">The constructors that use pointers are not CLS-compliant.</span></span> <span data-ttu-id="ada9e-522">此外，Visual Basic 不支援使用指標，而且 C# 需要會使用指標，在不安全的內容中執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-522">In addition, Visual Basic does not support the use of pointers, and C# requires code that uses pointers to run in an unsafe context.</span></span> <span data-ttu-id="ada9e-523">如需詳細資訊，請參閱 [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-523">For more information, see [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).</span></span>  
  
 <span data-ttu-id="ada9e-524">如需其他指引選擇多載的詳細資訊，請參閱[執行呼叫的方法？](#Tasks)</span><span class="sxs-lookup"><span data-stu-id="ada9e-524">For additional guidance on choosing an overload, see [Which method do I call?](#Tasks)</span></span>  
  
 `String(Char[] value)`  
 <span data-ttu-id="ada9e-525">初始化新的執行個體的 Unicode 字元陣列所指示的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-525">Initializes the new instance to the value indicated by an array of Unicode characters.</span></span> <span data-ttu-id="ada9e-526">這個建構函式會將複製的 Unicode 字元 ([範例](#Ctor2_Example))。</span><span class="sxs-lookup"><span data-stu-id="ada9e-526">This constructor copies Unicode characters([example](#Ctor2_Example)).</span></span>  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="ada9e-527">初始化新的執行個體的 Unicode 字元，該陣列中，且長度內起始字元位置陣列所指示的值 ([範例](#Ctor3_Example))。</span><span class="sxs-lookup"><span data-stu-id="ada9e-527">Initializes the new instance to the value indicated by an array of Unicode characters, a starting character position within that array, and a length ([example](#Ctor3_Example)).</span></span>  
  
 `String(Char c, Int32 count)`  
 <span data-ttu-id="ada9e-528">初始化新的執行個體的值以指定的 Unicode 字元重複指定的次數 ([範例](#Ctor3_Example))。</span><span class="sxs-lookup"><span data-stu-id="ada9e-528">Initializes the new instance to the value indicated by a specified Unicode character repeated a specified number of times ([example](#Ctor3_Example)).</span></span>  
  
 `String(char* value)`  
 <span data-ttu-id="ada9e-529">**（不符合 CLS 規範）** 初始化新的執行個體終止的 null 字元的 Unicode 字元陣列的指標所指示的值 (u+0000 或 '\0')。</span><span class="sxs-lookup"><span data-stu-id="ada9e-529">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters that is terminated by a null character (U+0000 or '\0').</span></span> <span data-ttu-id="ada9e-530">([範例](#Ctor4_Example))。</span><span class="sxs-lookup"><span data-stu-id="ada9e-530">([example](#Ctor4_Example)).</span></span>  
  
 <span data-ttu-id="ada9e-531">權限： <xref:System.Security.SecurityCriticalAttribute>，立即呼叫端需要受到完全信任。</span><span class="sxs-lookup"><span data-stu-id="ada9e-531">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ada9e-532">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-532">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="ada9e-533">**（不符合 CLS 規範）** 初始化新的執行個體的 Unicode 字元，該陣列中，且長度內起始字元位置陣列的指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-533">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters, a starting character position within that array, and a length.</span></span> <span data-ttu-id="ada9e-534">建構函式會將複製的 Unicode 字元`value`的索引開始`startIndex`並結束於索引`startIndex`  +  `length` -1 ([範例](#Ctor5_Example))。</span><span class="sxs-lookup"><span data-stu-id="ada9e-534">The constructor copies the Unicode characters from `value` starting at index `startIndex` and ending at index `startIndex` + `length` - 1 ([example](#Ctor5_Example)).</span></span>  
  
 <span data-ttu-id="ada9e-535">權限： <xref:System.Security.SecurityCriticalAttribute>，立即呼叫端需要受到完全信任。</span><span class="sxs-lookup"><span data-stu-id="ada9e-535">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ada9e-536">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-536">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value)`  
 <span data-ttu-id="ada9e-537">**（不符合 CLS 規範）** 初始化新的執行個體的 8 位元帶正負號的整數陣列的指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-537">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers.</span></span> <span data-ttu-id="ada9e-538">陣列會假設為代表使用目前的系統字碼頁編碼的字串 (也就指定的編碼<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-538">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="ada9e-539">建構函式會處理從字元`value`從 null 字元 (0x00) 為止，指標所指定的位置 ([範例](#Ctor6_Example))。</span><span class="sxs-lookup"><span data-stu-id="ada9e-539">The constructor processes characters from `value` starting from the location specified by the pointer until a null character (0x00) is reached ([example](#Ctor6_Example)).</span></span>  
  
 <span data-ttu-id="ada9e-540">權限： <xref:System.Security.SecurityCriticalAttribute>，立即呼叫端需要受到完全信任。</span><span class="sxs-lookup"><span data-stu-id="ada9e-540">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ada9e-541">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-541">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="ada9e-542">**（不符合 CLS 規範）** 初始化新的執行個體的陣列 8 位元帶正負號的整數、 陣列、 在陣列和長度內開始位置的指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-542">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span></span>  <span data-ttu-id="ada9e-543">陣列會假設為代表使用目前的系統字碼頁編碼的字串 (也就指定的編碼<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-543">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="ada9e-544">建構函式會處理從值開始的字元`startIndex`結尾`startIndex`  +  `length` -1 ([範例](#Ctor6_Example))。</span><span class="sxs-lookup"><span data-stu-id="ada9e-544">The constructor processes characters from value starting at `startIndex` and ending at `startIndex` + `length` - 1 ([example](#Ctor6_Example)).</span></span>  
  
 <span data-ttu-id="ada9e-545">權限： <xref:System.Security.SecurityCriticalAttribute>，立即呼叫端需要受到完全信任。</span><span class="sxs-lookup"><span data-stu-id="ada9e-545">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ada9e-546">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-546">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 <span data-ttu-id="ada9e-547">**（不符合 CLS 規範）** 初始化為 8 位元帶正負號的整數，長度，該陣列內開始位置陣列的指標所指示的值的新執行個體和<xref:System.Text.Encoding>物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-547">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <xref:System.Text.Encoding> object.</span></span>  
  
 <span data-ttu-id="ada9e-548">權限： <xref:System.Security.SecurityCriticalAttribute>，立即呼叫端需要受到完全信任。</span><span class="sxs-lookup"><span data-stu-id="ada9e-548">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="ada9e-549">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-549">This member cannot be used by partially trusted or transparent code.</span></span>  
  
<a name="Params"></a>   
## <a name="parameters"></a><span data-ttu-id="ada9e-550">參數</span><span class="sxs-lookup"><span data-stu-id="ada9e-550">Parameters</span></span>  
 <span data-ttu-id="ada9e-551">以下是所使用的參數的完整清單<xref:System.String>不包括指標參數的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-551">Here is a complete list of parameters used by <xref:System.String> constructors that don't include a pointer parameter.</span></span> <span data-ttu-id="ada9e-552">每個多載所使用的參數，請參閱上述的多載語法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-552">For the parameters used by each overload, see the overload syntax above.</span></span>  
  
|<span data-ttu-id="ada9e-553">參數</span><span class="sxs-lookup"><span data-stu-id="ada9e-553">Parameter</span></span>|<span data-ttu-id="ada9e-554">類型</span><span class="sxs-lookup"><span data-stu-id="ada9e-554">Type</span></span>|<span data-ttu-id="ada9e-555">描述</span><span class="sxs-lookup"><span data-stu-id="ada9e-555">Description</span></span>|  
|---------------|----------|-----------------|  
|`value`|<span data-ttu-id="ada9e-556"><xref:System.Char>[]</span><span class="sxs-lookup"><span data-stu-id="ada9e-556"><xref:System.Char>[]</span></span>|<span data-ttu-id="ada9e-557">Unicode 字元陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-557">An array of Unicode characters.</span></span>|  
|`c`|<xref:System.Char>|<span data-ttu-id="ada9e-558">Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-558">A Unicode character.</span></span>|  
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="ada9e-559">中的開始位置`value`新的字串中的第一個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-559">The starting position in `value` of the first character in the new string.</span></span><br /><br /> <span data-ttu-id="ada9e-560">預設值：0</span><span class="sxs-lookup"><span data-stu-id="ada9e-560">Default value: 0</span></span>|  
|`length`|<xref:System.Int32>|<span data-ttu-id="ada9e-561">中的字元數`value`包含在新的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-561">The number of characters in `value` to include in the new string.</span></span><br /><br /> <span data-ttu-id="ada9e-562">預設值： <xref:System.Array.Length%2A?displayProperty=nameWithType> </span><span class="sxs-lookup"><span data-stu-id="ada9e-562">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|  
|`count`|<xref:System.Int32>|<span data-ttu-id="ada9e-563">數目乘以字元`c`重複新的字串中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-563">The number of times the character `c` is repeated in the new string.</span></span> <span data-ttu-id="ada9e-564">如果`count`為零，新物件的值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-564">If `count` is zero, the value of the new object is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="ada9e-565">以下是所使用的參數的完整清單<xref:System.String>包含指標參數的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-565">Here is a complete list of parameters used by <xref:System.String> constructors that include a pointer parameter.</span></span> <span data-ttu-id="ada9e-566">每個多載所使用的參數，請參閱上述的多載語法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-566">For the parameters used by each overload, see the overload syntax above.</span></span>  
  
|<span data-ttu-id="ada9e-567">參數</span><span class="sxs-lookup"><span data-stu-id="ada9e-567">Parameter</span></span>|<span data-ttu-id="ada9e-568">類型</span><span class="sxs-lookup"><span data-stu-id="ada9e-568">Type</span></span>|<span data-ttu-id="ada9e-569">描述</span><span class="sxs-lookup"><span data-stu-id="ada9e-569">Description</span></span>|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> <span data-ttu-id="ada9e-570">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-570">-or-</span></span><br /><br /> <xref:System.SByte>\*|<span data-ttu-id="ada9e-571">以 null 結束的 Unicode 字元陣列或 8 位元帶正負號整數的陣列指標。</span><span class="sxs-lookup"><span data-stu-id="ada9e-571">A pointer to a null-terminated array of Unicode characters or an array of 8-bit signed integers.</span></span> <span data-ttu-id="ada9e-572">如果`value`已`null`或空陣列，新的字串值為<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-572">If `value` is `null` or an empty array, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="ada9e-573">定義新的字串中的第一個字元的陣列項目索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-573">The index of the array element that defines the first character in the new string.</span></span><br /><br /> <span data-ttu-id="ada9e-574">預設值：0</span><span class="sxs-lookup"><span data-stu-id="ada9e-574">Default value: 0</span></span>|  
|`length`|<xref:System.Int32>|<span data-ttu-id="ada9e-575">要用來建立新的字串的陣列元素數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-575">The number of array elements to use to create the new string.</span></span> <span data-ttu-id="ada9e-576">如果長度為零，建構函式會建立的字串，其值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-576">If length is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span><br /><br /> <span data-ttu-id="ada9e-577">預設值： <xref:System.Array.Length%2A?displayProperty=nameWithType> </span><span class="sxs-lookup"><span data-stu-id="ada9e-577">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|  
|`enc`|<xref:System.Text.Encoding>|<span data-ttu-id="ada9e-578">物件，指定如何`value`陣列進行編碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-578">An object that specifies how the `value` array is encoded.</span></span><br /><br /> <span data-ttu-id="ada9e-579">預設值： <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>，或系統的目前的 ANSI 字碼頁</span><span class="sxs-lookup"><span data-stu-id="ada9e-579">Default value: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, or the system's current ANSI code page</span></span>|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a><span data-ttu-id="ada9e-580">例外狀況</span><span class="sxs-lookup"><span data-stu-id="ada9e-580">Exceptions</span></span>  
 <span data-ttu-id="ada9e-581">以下是一份不包括指標參數的建構函式所擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ada9e-581">Here's a list of exceptions thrown by constructors that don't include pointer parameters.</span></span>  
  
|<span data-ttu-id="ada9e-582">例外</span><span class="sxs-lookup"><span data-stu-id="ada9e-582">Exception</span></span>|<span data-ttu-id="ada9e-583">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-583">Condition</span></span>|<span data-ttu-id="ada9e-584">藉由擲回</span><span class="sxs-lookup"><span data-stu-id="ada9e-584">Thrown by</span></span>|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|<span data-ttu-id="ada9e-585">`value` 為 `null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-585">`value` is `null`.</span></span>|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="ada9e-586">`startIndex``length`，或`count`小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-586">`startIndex`,`length`, or `count` is less than zero.</span></span><br /><br /> <span data-ttu-id="ada9e-587">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-587">-or-</span></span><br /><br /> <span data-ttu-id="ada9e-588">`startIndex` 和 `length` 的總和大於 `value` 中的項目數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-588">The sum of `startIndex` and `length` is greater than the number of elements in `value`.</span></span><br /><br /> <span data-ttu-id="ada9e-589">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-589">-or-</span></span><br /><br /> <span data-ttu-id="ada9e-590">`count` 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-590">`count` is less than zero.</span></span>|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 <span data-ttu-id="ada9e-591">以下是包含指標參數的建構函式所擲回例外狀況的清單。</span><span class="sxs-lookup"><span data-stu-id="ada9e-591">Here's a list of exceptions thrown by constructors that include pointer parameters.</span></span>  
  
|<span data-ttu-id="ada9e-592">例外</span><span class="sxs-lookup"><span data-stu-id="ada9e-592">Exception</span></span>|<span data-ttu-id="ada9e-593">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-593">Condition</span></span>|<span data-ttu-id="ada9e-594">藉由擲回</span><span class="sxs-lookup"><span data-stu-id="ada9e-594">Thrown by</span></span>|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|<span data-ttu-id="ada9e-595">`value` 指定包含無效的 Unicode 字元的陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-595">`value` specifies an array that contains an invalid Unicode character.</span></span><br /><br /> <span data-ttu-id="ada9e-596">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-596">-or-</span></span><br /><br /> <span data-ttu-id="ada9e-597">`value` 或是`value`  +  `startIndex`指定的位址小於 64k。</span><span class="sxs-lookup"><span data-stu-id="ada9e-597">`value` or `value` + `startIndex` specifies an address that is less than 64K.</span></span><br /><br /> <span data-ttu-id="ada9e-598">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-598">-or-</span></span><br /><br /> <span data-ttu-id="ada9e-599">新<xref:System.String>無法初始化執行個體，從`value`位元組陣列，因為`value`不會使用預設字碼頁編碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-599">A new <xref:System.String> instance could not be initialized from the `value` byte array because `value` does not use the default code page encoding.</span></span>|<span data-ttu-id="ada9e-600">具有指標的所有建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-600">All constructors with pointers.</span></span>|  
|<xref:System.ArgumentNullException>|<span data-ttu-id="ada9e-601">`value` 為 null。</span><span class="sxs-lookup"><span data-stu-id="ada9e-601">`value` is null.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="ada9e-602">目前的處理序沒有讀取所有定址字元的權限。</span><span class="sxs-lookup"><span data-stu-id="ada9e-602">The current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="ada9e-603">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-603">-or-</span></span><br /><br /> <span data-ttu-id="ada9e-604">`startIndex` 或 `length` 小於零、`value` + `startIndex` 導致指標溢位，或目前的處理序沒有所有定址字元的讀取權限。</span><span class="sxs-lookup"><span data-stu-id="ada9e-604">`startIndex` or `length` is less than zero, `value` + `startIndex` cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="ada9e-605">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-605">-or-</span></span><br /><br /> <span data-ttu-id="ada9e-606">新字串長度太大而無法配置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-606">The length of the new string is too large to allocate.</span></span>|<span data-ttu-id="ada9e-607">具有指標的所有建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-607">All constructors with pointers.</span></span>|  
|<xref:System.AccessViolationException>|<span data-ttu-id="ada9e-608">`value`或`value`  +  `startIndex`  +  `length` -1，指定了無效的位址。</span><span class="sxs-lookup"><span data-stu-id="ada9e-608">`value`, or `value` + `startIndex` + `length` - 1, specifies an invalid address.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a><span data-ttu-id="ada9e-609">我呼叫的方法？</span><span class="sxs-lookup"><span data-stu-id="ada9e-609">Which method do I call?</span></span>  
  
|<span data-ttu-id="ada9e-610">以</span><span class="sxs-lookup"><span data-stu-id="ada9e-610">To</span></span>|<span data-ttu-id="ada9e-611">呼叫或使用</span><span class="sxs-lookup"><span data-stu-id="ada9e-611">Call or use</span></span>|  
|--------|-----------------|  
|<span data-ttu-id="ada9e-612">建立字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-612">Create a string.</span></span>|<span data-ttu-id="ada9e-613">從字串常值或現有的字串指派 ([範例](#Ctor1_Example))</span><span class="sxs-lookup"><span data-stu-id="ada9e-613">Assignment from a string literal or an existing string ([example](#Ctor1_Example))</span></span>|  
|<span data-ttu-id="ada9e-614">從整個字元陣列建立字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-614">Create a string from an entire character array.</span></span>|<span data-ttu-id="ada9e-615"><xref:System.String.%23ctor%28System.Char%5B%5D%29> ([範例](#Ctor2_Example))</span><span class="sxs-lookup"><span data-stu-id="ada9e-615"><xref:System.String.%23ctor%28System.Char%5B%5D%29> ([example](#Ctor2_Example))</span></span>|  
|<span data-ttu-id="ada9e-616">從字元陣列的一部分建立的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-616">Create a string from a portion of a character array.</span></span>|<span data-ttu-id="ada9e-617"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([範例](#Ctor3_Example))</span><span class="sxs-lookup"><span data-stu-id="ada9e-617"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|  
|<span data-ttu-id="ada9e-618">建立重複多次的相同字元的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-618">Create a string that repeats the same character multiple times.</span></span>|<span data-ttu-id="ada9e-619"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([範例](#Ctor3_Example))</span><span class="sxs-lookup"><span data-stu-id="ada9e-619"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|  
|<span data-ttu-id="ada9e-620">從指標建立字串，以 Unicode 或寬字元陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-620">Create a string from a pointer to a Unicode or wide character array.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|<span data-ttu-id="ada9e-621">使用它的指標，從 Unicode 或寬字元陣列的一部分建立的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-621">Create a string from a portion of a Unicode or wide character array by using its pointer.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|<span data-ttu-id="ada9e-622">建立從字串C++`char`陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-622">Create a string from a C++ `char` array.</span></span>|<span data-ttu-id="ada9e-623"><xref:System.String.%23ctor%28System.SByte%2A%29>、 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span><span class="sxs-lookup"><span data-stu-id="ada9e-623"><xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span></span><br /><br /> <span data-ttu-id="ada9e-624">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-624">-or-</span></span><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<span data-ttu-id="ada9e-625">建立從 ASCII 字元的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-625">Create a string from ASCII characters.</span></span>|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a><span data-ttu-id="ada9e-626">建立字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-626">Creating strings</span></span>  
 <span data-ttu-id="ada9e-627">最常使用的技術以程式設計方式建立字串是簡單指派，如所示[本例](#Ctor1_Example)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-627">The most commonly used technique for creating strings programmatically is simple assignment, as illustrated in [this example](#Ctor1_Example).</span></span> <span data-ttu-id="ada9e-628"><xref:System.String>類別也包含四種類型的建構函式多載，可讓您從下列值建立字串：</span><span class="sxs-lookup"><span data-stu-id="ada9e-628">The <xref:System.String> class also includes four types of constructor overloads that let you create strings from the following values:</span></span>  
  
-   <span data-ttu-id="ada9e-629">從字元陣列 （UTF 16 編碼的字元陣列）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-629">From a character array (an array of UTF-16-encoded characters).</span></span> <span data-ttu-id="ada9e-630">您可以建立新<xref:System.String>物件中整個陣列或其中一部分的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-630">You can create a new <xref:System.String> object from the characters in the entire array or a portion of it.</span></span> <span data-ttu-id="ada9e-631"><xref:System.String.%23ctor%28System.Char%5B%5D%29>建構函式陣列中的所有字元都複製到新的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-631">The <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor copies all the characters in the array to the new string.</span></span> <span data-ttu-id="ada9e-632"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>建構函式會複製索引中的字元`startIndex`至索引`startIndex`  +  `length` -1，以新的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-632">The <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor copies the characters from index `startIndex` to index `startIndex` + `length` - 1 to the new string.</span></span> <span data-ttu-id="ada9e-633">如果`length`為零，新的字串值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-633">If `length` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
     <span data-ttu-id="ada9e-634">如果您的程式碼重複具現化具有相同值的字串，您可以使用替代方式來建立字串來改善應用程式的效能。</span><span class="sxs-lookup"><span data-stu-id="ada9e-634">If your code repeatedly instantiates strings that have the same value, you can improve application performance by using an alternate means of creating strings.</span></span> <span data-ttu-id="ada9e-635">如需詳細資訊，請參閱 <<c0> [ 處理重複的字串](#Repetitive)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-635">For more information, see [Handling repetitive strings](#Repetitive).</span></span>  
  
-   <span data-ttu-id="ada9e-636">從單一字元也就是重複的零，一個或一次，使用<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-636">From a single character that is duplicated zero, one, or more times, by using the <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="ada9e-637">如果`count`為零，新的字串值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-637">If `count` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="ada9e-638">以 null 結束的字元陣列指標，從使用<xref:System.String.%23ctor%28System.Char%2A%29>或<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-638">From a pointer to a null-terminated character array, by using the <xref:System.String.%23ctor%28System.Char%2A%29> or <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="ada9e-639">整個陣列或指定的範圍，都可以用來初始化的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-639">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="ada9e-640">建構函式會複製啟動從指定的指標，或從指定的指標加上的 Unicode 字元序列`startIndex`並且一直傳到結尾的陣列，或針對`length`字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-640">The constructor copies a sequence of Unicode characters starting from the specified pointer or from the specified pointer plus `startIndex` and continuing to the end of the array or for `length` characters.</span></span> <span data-ttu-id="ada9e-641">如果`value`為 null 指標或`length`為零，建構函式會建立的字串，其值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-641">If `value` is a null pointer or `length` is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-642">如果複製作業繼續進行陣列的結尾，而且陣列不是以 null 終止，建構函式的行為會與系統相關。</span><span class="sxs-lookup"><span data-stu-id="ada9e-642">If the copy operation proceeds to the end of the array and the array is not null-terminated, the constructor behavior is system-dependent.</span></span> <span data-ttu-id="ada9e-643">這種情況可能會造成存取違規。</span><span class="sxs-lookup"><span data-stu-id="ada9e-643">Such a condition might cause an access violation.</span></span>  
  
     <span data-ttu-id="ada9e-644">如果陣列包含任何內嵌的 null 字元 (U + 0000 或 '\0') 和<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>多載會呼叫後，會包含字串執行個體`length`字元，包括任何內嵌的 null。</span><span class="sxs-lookup"><span data-stu-id="ada9e-644">If the array contains any embedded null characters (U+0000 or '\0') and the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="ada9e-645">下列範例會顯示 10 個項目的陣列，其中包含兩個 null 字元的指標傳遞至時，會發生什麼事<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-645">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="ada9e-646">因為位址是陣列的開頭，而且可以加入至字串陣列中的所有項目，建構函式具現化具有 10 個字元，包括兩個內嵌的 null 的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-646">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="ada9e-647">另一方面，如果相同的陣列傳遞給<xref:System.String.%23ctor%28System.Char%2A%29>建構函式，結果是不含第一個 null 字元的四個字元字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-647">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.Char%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     <span data-ttu-id="ada9e-648">陣列必須包含 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-648">The array must contain Unicode characters.</span></span> <span data-ttu-id="ada9e-649">在C++，這個表示的字元陣列必須是定義為 managed <xref:System.Char>[] 型別或 unmanaged`wchar_t`[] 型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-649">In C++, this means that the character array must be defined either as the managed <xref:System.Char>[] type or the unmanaged`wchar_t`[] type.</span></span>  
  
     <span data-ttu-id="ada9e-650">如果<xref:System.String.%23ctor%28System.Char%2A%29>多載會呼叫和陣列不是以 null 終止，或如果<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>多載會呼叫並`startIndex`  +  `length`-1 包含範圍順序的字元，而外部記憶體配置建構函式的行為是系統而定，並可能會發生存取違規。</span><span class="sxs-lookup"><span data-stu-id="ada9e-650">If the <xref:System.String.%23ctor%28System.Char%2A%29> overload is called and the array is not null-terminated, or if the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called and `startIndex` + `length`-1 includes a range that it outside the memory allocated for the sequence of characters, the behavior of the constructor is system-dependent, and an access violation may occur.</span></span> <span data-ttu-id="ada9e-651">此外，Intel Itanium 處理器上，呼叫<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>建構函式可能會擲回<xref:System.DataMisalignedException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ada9e-651">In addition, on the Intel Itanium processor, calls to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor may throw a <xref:System.DataMisalignedException> exception.</span></span> <span data-ttu-id="ada9e-652">如果發生這種情況，呼叫<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>改。</span><span class="sxs-lookup"><span data-stu-id="ada9e-652">If this occurs, call the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> instead.</span></span>  
  
-   <span data-ttu-id="ada9e-653">從帶正負號的位元組陣列的指標。</span><span class="sxs-lookup"><span data-stu-id="ada9e-653">From a pointer to a signed byte array.</span></span> <span data-ttu-id="ada9e-654">整個陣列或指定的範圍，都可以用來初始化的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-654">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="ada9e-655">使用預設字碼頁編碼方式，可解譯的位元組序列，或可以指定建構函式呼叫中的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-655">The sequence of bytes can be interpreted by using the default code page encoding, or an encoding can be specified in the constructor call.</span></span> <span data-ttu-id="ada9e-656">如果建構函式嘗試具現化不是以 null 終止的是整個陣列的字串，或是如果從陣列的範圍`value`  +  `startIndex`要`value`  +  `startIndex`  +  `length` -1 會在配置給陣列的記憶體之外，這個建構函式的行為是系統而定，可能會發生存取違規。</span><span class="sxs-lookup"><span data-stu-id="ada9e-656">If the constructor tries to instantiate a string from an entire array that is not null-terminated, or if the range of the array from `value` + `startIndex` to `value` + `startIndex` + `length` -1 is outside of the memory allocated for the array, the behavior of this constructor is system-dependent, and an access violation may occur.</span></span>  
  
     <span data-ttu-id="ada9e-657">包含帶正負號的位元組陣列，做為參數的三個建構函式主要設計來轉換C++`char`陣列的字串，在此範例中所示：</span><span class="sxs-lookup"><span data-stu-id="ada9e-657">The three constructors that include a signed byte array as a parameter are designed primarily to convert a C++ `char` array to a string, as shown in this example:</span></span>  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     <span data-ttu-id="ada9e-658">如果陣列包含其值為 0 的任何 null 字元 ('\0') 或位元組，<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>多載呼叫，字串執行個體包含`length`字元，包括任何內嵌的 null。</span><span class="sxs-lookup"><span data-stu-id="ada9e-658">If the array contains any null characters ('\0') or bytes whose value is 0 and the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="ada9e-659">下列範例會顯示 10 個項目的陣列，其中包含兩個 null 字元的指標傳遞至時，會發生什麼事<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-659">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="ada9e-660">因為位址是陣列的開頭，而且可以加入至字串陣列中的所有項目，建構函式具現化具有 10 個字元，包括兩個內嵌的 null 的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-660">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="ada9e-661">另一方面，如果相同的陣列傳遞給<xref:System.String.%23ctor%28System.SByte%2A%29>建構函式，結果是不含第一個 null 字元的四個字元字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-661">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     <span data-ttu-id="ada9e-662">因為<xref:System.String.%23ctor%28System.SByte%2A%29>並<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>建構函式解譯`value`藉由使用的預設 ANSI 字碼頁，在呼叫這些建構函式具有相同的位元組陣列可能會建立在不同系統有不同的值的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-662">Because the <xref:System.String.%23ctor%28System.SByte%2A%29> and <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> constructors interpret `value` by using the default ANSI code page, calling these constructors with identical byte arrays may create strings that have different values on different systems.</span></span>  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a><span data-ttu-id="ada9e-663">處理重複的字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-663">Handling repetitive strings</span></span>  
 <span data-ttu-id="ada9e-664">應用程式的剖析，或將解碼之文字資料流時，通常會使用<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>建構函式或<xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法，以將字元序列轉換為字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-664">Apps that parse or decode streams of text often use the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor or the <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to convert sequences of characters into a string.</span></span> <span data-ttu-id="ada9e-665">重複使用相同的值，而不是建立及重複使用一個字串建立新字串，就會浪費記憶體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-665">Repeatedly creating new strings with the same value instead of creating and reusing one string wastes memory.</span></span> <span data-ttu-id="ada9e-666">如果您可能會重複建立相同的字串值，藉由呼叫<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>建構函式，即使您不知道在進入這些相同的字串值可能是，您可以改為使用查閱資料表。</span><span class="sxs-lookup"><span data-stu-id="ada9e-666">If you are likely to create the same string value repeatedly by calling the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor, even if you don't know in advance what those identical string values may be, you can use a lookup table instead.</span></span>  
  
 <span data-ttu-id="ada9e-667">例如，假設您讀取及剖析從包含 XML 標記和屬性檔案的字元資料流。</span><span class="sxs-lookup"><span data-stu-id="ada9e-667">For example, suppose you read and parse a stream of characters from a file that contains XML tags and attributes.</span></span> <span data-ttu-id="ada9e-668">當您剖析的資料流時，您重複遇到特定的權杖 （也就是有符號的意義的字元序列）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-668">When you parse the stream, you repeatedly encounter certain tokens (that is, sequences of characters that have a symbolic meaning).</span></span> <span data-ttu-id="ada9e-669">相當於"0"，"1"，"true"和"false"字串的語彙基元很可能經常發生在 XML 資料流中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-669">Tokens equivalent to the strings "0", "1", "true", and "false" are likely to occur frequently in an XML stream.</span></span>  
  
 <span data-ttu-id="ada9e-670">而不是將每個語彙基元轉換成新的字串，您可以建立<xref:System.Xml.NameTable?displayProperty=nameWithType>物件來保存經常出現的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-670">Instead of converting each token into a new string, you can create a <xref:System.Xml.NameTable?displayProperty=nameWithType> object to hold commonly occurring strings.</span></span> <span data-ttu-id="ada9e-671"><xref:System.Xml.NameTable>物件可改善效能，因為它會擷取儲存的字串，而不需配置暫時的記憶體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-671">The <xref:System.Xml.NameTable> object improves performance, because it retrieves stored strings without allocating temporary memory.</span></span> <span data-ttu-id="ada9e-672">當您遇到的語彙基元時，使用<xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法，以從資料表中擷取語彙基元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-672">When you encounter a token, use the <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to retrieve the token from the table.</span></span> <span data-ttu-id="ada9e-673">如果權杖存在，則方法會傳回對應的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-673">If the token exists, the method returns the corresponding string.</span></span> <span data-ttu-id="ada9e-674">如果權杖不存在，使用<xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法插入資料表中的權杖，並取得對應的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-674">If the token does not exist, use the <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to insert the token into the table and to get the corresponding string.</span></span>  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a><span data-ttu-id="ada9e-675">範例 1：使用字串指派</span><span class="sxs-lookup"><span data-stu-id="ada9e-675">Example 1: Using string assignment</span></span>  
 <span data-ttu-id="ada9e-676">下列範例會建立新的字串指派給字串常值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-676">The following example creates a new string by assigning it a string literal.</span></span> <span data-ttu-id="ada9e-677">它會建立第二個字串的第一個字串值，指派給它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-677">It creates a second string by assigning the value of the first string to it.</span></span> <span data-ttu-id="ada9e-678">這些是兩個最常用的方式來具現化新<xref:System.String>物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-678">These are the two most common ways to instantiate a new <xref:System.String> object.</span></span>  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a><span data-ttu-id="ada9e-679">範例 2：使用的字元陣列</span><span class="sxs-lookup"><span data-stu-id="ada9e-679">Example 2: Using a character array</span></span>  
 <span data-ttu-id="ada9e-680">下列範例示範如何建立新<xref:System.String>字元陣列中的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-680">The following example demonstrates how to create a new <xref:System.String> object from a character array.</span></span>  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a><span data-ttu-id="ada9e-681">範例 3：使用字元陣列中的部分，並重複單一字元</span><span class="sxs-lookup"><span data-stu-id="ada9e-681">Example 3: Using a portion of a character array and repeating a single character</span></span>  
 <span data-ttu-id="ada9e-682">下列範例示範如何建立新<xref:System.String>物件，從字元陣列，以及如何建立新的一部份<xref:System.String>物件，其中包含單一字元的多個項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-682">The following example demonstrates how to create a new <xref:System.String> object from a portion of a character array, and how to create a new <xref:System.String> object that contains multiple occurrences of a single character.</span></span>  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a><span data-ttu-id="ada9e-683">範例 4：使用字元陣列的指標</span><span class="sxs-lookup"><span data-stu-id="ada9e-683">Example 4: Using a pointer to a character array</span></span>  
 <span data-ttu-id="ada9e-684">下列範例示範如何建立新<xref:System.String>從指標到字元陣列中的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-684">The following example demonstrates how to create a new <xref:System.String> object from a pointer to an array of characters.</span></span> <span data-ttu-id="ada9e-685">必須編譯 C# 範例使用`/unsafe`編譯器參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-685">The C# example must be compiled by using the `/unsafe` compiler switch.</span></span>  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a><span data-ttu-id="ada9e-686">範例 5:具現化的字串指標和陣列的範圍</span><span class="sxs-lookup"><span data-stu-id="ada9e-686">Example 5: Instantiating a string from a pointer and a range of an array</span></span>  
 <span data-ttu-id="ada9e-687">下列範例會檢查期間或驚嘆號字元陣列的項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-687">The following example examines the elements of a character array for either a period or an exclamation point.</span></span> <span data-ttu-id="ada9e-688">如果有找到，它會具現化前面標點符號的字元陣列中的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-688">If one is found, it instantiates a string from the characters in the array that precede the punctuation symbol.</span></span> <span data-ttu-id="ada9e-689">如果沒有，它會具現化的字串陣列的整個內容。</span><span class="sxs-lookup"><span data-stu-id="ada9e-689">If not, it instantiates a string with the entire contents of the array.</span></span> <span data-ttu-id="ada9e-690">必須編譯 C# 範例，使用`/unsafe`編譯器參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-690">The C# example must be compiled using the `/unsafe` compiler switch.</span></span>  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a><span data-ttu-id="ada9e-691">範例 6:從指標到帶正負號的位元組陣列的字串具現化</span><span class="sxs-lookup"><span data-stu-id="ada9e-691">Example 6: Instantiating a string from a pointer to a signed byte array</span></span>  
 <span data-ttu-id="ada9e-692">下列範例示範如何建立執行個體<xref:System.String>類別搭配<xref:System.String.%23ctor%28System.SByte%2A%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-692">The following example demonstrates how you can create an instance of the <xref:System.String> class with the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor.</span></span>  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a><span data-ttu-id="ada9e-693">版本資訊</span><span class="sxs-lookup"><span data-stu-id="ada9e-693">Version information</span></span>  
 <span data-ttu-id="ada9e-694">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="ada9e-694">.NET Framework</span></span>  
 <span data-ttu-id="ada9e-695">所有多載支援：4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span><span class="sxs-lookup"><span data-stu-id="ada9e-695">All overloads are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span></span>  
  
 <span data-ttu-id="ada9e-696">.NET Framework Client Profile</span><span class="sxs-lookup"><span data-stu-id="ada9e-696">.NET Framework Client Profile</span></span>  
 <span data-ttu-id="ada9e-697">所有多載支援：4，3.5 SP1</span><span class="sxs-lookup"><span data-stu-id="ada9e-697">All overloads are supported in: 4, 3.5 SP1</span></span>  
  
 <span data-ttu-id="ada9e-698">可攜式類別庫</span><span class="sxs-lookup"><span data-stu-id="ada9e-698">Portable Class Library</span></span>  
 <span data-ttu-id="ada9e-699">而不需要的所有多載<xref:System.SByte>`*`參數支援</span><span class="sxs-lookup"><span data-stu-id="ada9e-699">All overloads without an <xref:System.SByte>`*` parameter are supported</span></span>  
  
 <span data-ttu-id="ada9e-700">適用於 Windows 市集應用程式的 .NET</span><span class="sxs-lookup"><span data-stu-id="ada9e-700">.NET for Windows Store apps</span></span>  
 <span data-ttu-id="ada9e-701">而不需要的所有多載<xref:System.SByte>`*`中支援參數：Windows 8</span><span class="sxs-lookup"><span data-stu-id="ada9e-701">All overloads without an <xref:System.SByte>`*` parameter are supported in: Windows 8</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-702">Unicode 字元之 Null 終端陣列的指標</span><span class="sxs-lookup"><span data-stu-id="ada9e-702">A pointer to a null-terminated array of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="ada9e-703">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 Unicode 字元陣列的指定指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-703">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-704">如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-704">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-705">目前的處理序沒有讀取所有定址字元的權限。</span><span class="sxs-lookup"><span data-stu-id="ada9e-705">The current process does not have read access to all the addressed characters.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-706"><paramref name="value" /> 指定包含無效 Unicode 字元的陣列，或 <paramref name="value" /> 指定小於 64000 的位址。</span><span class="sxs-lookup"><span data-stu-id="ada9e-706"><paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> specifies an address less than 64000.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ada9e-707">需要完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="ada9e-707">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ada9e-708">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-708">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-709">Unicode 字元陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-709">An array of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="ada9e-710">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 Unicode 字元陣列所指示的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-710">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-711">如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-711">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-712">以 null 結束之 8 位元帶正負號整數的陣列指標。</span><span class="sxs-lookup"><span data-stu-id="ada9e-712">A pointer to a null-terminated array of 8-bit signed integers.</span></span> <span data-ttu-id="ada9e-713">整數會使用目前的系統字碼頁編碼來解譯 (也就是由 <see cref="P:System.Text.Encoding.Default" /> 所指定的編碼)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-713">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span></span></param>
        <summary><span data-ttu-id="ada9e-714">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 8 位元帶正負號整數 (Signed Integer) 陣列的指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-714">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a pointer to an array of 8-bit signed integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-715">如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-715">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-716"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-716"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-717">無法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新執行個體，假設 <paramref name="value" /> 是 ANSI 編碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-717">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-718">要初始化的新字串長度，由 <paramref name="value" /> 之 null 結束字元所決定，該長度太長而無法配置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-718">The length of the new string to initialize, which is determined by the null termination character of <paramref name="value" />, is too large to allocate.</span></span></exception>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="ada9e-719"><paramref name="value" /> 指定了無效的位址。</span><span class="sxs-lookup"><span data-stu-id="ada9e-719"><paramref name="value" /> specifies an invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ada9e-720">需要完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="ada9e-720">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ada9e-721">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-721">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="ada9e-722">Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-722">A Unicode character.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-723"><paramref name="c" /> 發生的次數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-723">The number of times <paramref name="c" /> occurs.</span></span></param>
        <summary><span data-ttu-id="ada9e-724">將 <see cref="T:System.String" /> 類別的新執行個體初始化為由重複指定次數的指定 Unicode 字元所指示的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-724">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified Unicode character repeated a specified number of times.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-725">如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-725">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-726"><paramref name="count" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-726"><paramref name="count" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-727">Unicode 字元陣列的指標。</span><span class="sxs-lookup"><span data-stu-id="ada9e-727">A pointer to an array of Unicode characters.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-728">開始位置在 <paramref name="value" /> 內。</span><span class="sxs-lookup"><span data-stu-id="ada9e-728">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="ada9e-729"><paramref name="value" /> 內要使用的字元數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-729">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="ada9e-730">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 Unicode 字元陣列、在陣列內起始字元的位置以及長度等等的指定指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-730">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-731">如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-731">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-732"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零、<paramref name="value" /> + <paramref name="startIndex" /> 導致指標溢位，或目前的處理序沒有所有定址字元的讀取權限。</span><span class="sxs-lookup"><span data-stu-id="ada9e-732"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero, <paramref name="value" /> + <paramref name="startIndex" /> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-733"><paramref name="value" /> 指定包含無效 Unicode 字元的陣列，或 <paramref name="value" /> + <paramref name="startIndex" /> 指定小於 64000 的位址。</span><span class="sxs-lookup"><span data-stu-id="ada9e-733"><paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> + <paramref name="startIndex" /> specifies an address less than 64000.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ada9e-734">需要完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="ada9e-734">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ada9e-735">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-735">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-736">Unicode 字元陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-736">An array of Unicode characters.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-737">開始位置在 <paramref name="value" /> 內。</span><span class="sxs-lookup"><span data-stu-id="ada9e-737">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="ada9e-738"><paramref name="value" /> 內要使用的字元數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-738">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="ada9e-739">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 Unicode 字元陣列、在陣列內起始字元的位置和長度等等所指示的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-739">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-740">如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-740">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-741"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-741"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-742"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-742"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
<span data-ttu-id="ada9e-743">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-743">-or-</span></span> 
<span data-ttu-id="ada9e-744"><paramref name="startIndex" /> 和 <paramref name="length" /> 的總和大於 <paramref name="value" /> 中的項目數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-744">The sum of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the number of elements in <paramref name="value" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-745">8 位元帶正負號整數陣列的指標。</span><span class="sxs-lookup"><span data-stu-id="ada9e-745">A pointer to an array of 8-bit signed integers.</span></span> <span data-ttu-id="ada9e-746">整數會使用目前的系統字碼頁編碼來解譯 (也就是由 <see cref="P:System.Text.Encoding.Default" /> 所指定的編碼)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-746">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-747">開始位置在 <paramref name="value" /> 內。</span><span class="sxs-lookup"><span data-stu-id="ada9e-747">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="ada9e-748"><paramref name="value" /> 內要使用的字元數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-748">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="ada9e-749">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 8 位元帶正負號整數的陣列、在該陣列內開始位置和長度的指定指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-749">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-750">如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-750">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-751"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-751"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-752"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-752"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
<span data-ttu-id="ada9e-753">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-753">-or-</span></span> 
<span data-ttu-id="ada9e-754"><paramref name="value" /> + <paramref name="startIndex" /> 指定的位址對於目前的平台而言太大，也就是位址計算溢位。</span><span class="sxs-lookup"><span data-stu-id="ada9e-754">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span></span>  
  
<span data-ttu-id="ada9e-755">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-755">-or-</span></span> 
<span data-ttu-id="ada9e-756">要初始化的新字串長度太大而無法配置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-756">The length of the new string to initialize is too large to allocate.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-757"><paramref name="value" /> + <paramref name="startIndex" /> 指定的位址小於 64K。</span><span class="sxs-lookup"><span data-stu-id="ada9e-757">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span></span>  
  
<span data-ttu-id="ada9e-758">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-758">-or-</span></span> 
<span data-ttu-id="ada9e-759">無法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新執行個體，假設 <paramref name="value" /> 是 ANSI 編碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-759">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span></span></exception>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="ada9e-760"><paramref name="value" />、<paramref name="startIndex" /> 和 <paramref name="length" /> 共同指定了無效的位址。</span><span class="sxs-lookup"><span data-stu-id="ada9e-760"><paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ada9e-761">需要完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="ada9e-761">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ada9e-762">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-762">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-763">8 位元帶正負號整數陣列的指標。</span><span class="sxs-lookup"><span data-stu-id="ada9e-763">A pointer to an array of 8-bit signed integers.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-764">開始位置在 <paramref name="value" /> 內。</span><span class="sxs-lookup"><span data-stu-id="ada9e-764">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="ada9e-765"><paramref name="value" /> 內要使用的字元數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-765">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <param name="enc"><span data-ttu-id="ada9e-766">物件，指定以 <paramref name="value" /> 參考之陣列的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-766">An object that specifies how the array referenced by <paramref name="value" /> is encoded.</span></span> <span data-ttu-id="ada9e-767">如果 <paramref name="enc" /> 為 <see langword="null" />，則假設使用 ANSI 編碼方式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-767">If <paramref name="enc" /> is <see langword="null" />, ANSI encoding is assumed.</span></span></param>
        <summary><span data-ttu-id="ada9e-768">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 8 位元帶正負號整數的陣列、在該陣列內開始位置、長度和 <see cref="T:System.Text.Encoding" /> 物件的指定指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-768">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-769">如需範例和完整的使用方式資訊，這和其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>摘要的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-769">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-770"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-770"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-771"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-771"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
<span data-ttu-id="ada9e-772">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-772">-or-</span></span> 
<span data-ttu-id="ada9e-773"><paramref name="value" /> + <paramref name="startIndex" /> 指定的位址對於目前的平台而言太大，也就是位址計算溢位。</span><span class="sxs-lookup"><span data-stu-id="ada9e-773">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span></span>  
  
<span data-ttu-id="ada9e-774">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-774">-or-</span></span> 
<span data-ttu-id="ada9e-775">要初始化的新字串長度太大而無法配置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-775">The length of the new string to initialize is too large to allocate.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-776"><paramref name="value" /> + <paramref name="startIndex" /> 指定的位址小於 64K。</span><span class="sxs-lookup"><span data-stu-id="ada9e-776">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span></span>  
  
<span data-ttu-id="ada9e-777">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-777">-or-</span></span> 
<span data-ttu-id="ada9e-778">無法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新執行個體，假設 <paramref name="value" /> 是依照 <paramref name="enc" /> 的指定所編碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-778">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded as specified by <paramref name="enc" />.</span></span></exception>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="ada9e-779"><paramref name="value" />、<paramref name="startIndex" /> 和 <paramref name="length" /> 共同指定了無效的位址。</span><span class="sxs-lookup"><span data-stu-id="ada9e-779"><paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ada9e-780">需要完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="ada9e-780">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ada9e-781">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-781">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Index) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[Index] { char get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Index) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="ada9e-782">目前字串中的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-782">A position in the current string.</span></span></param>
        <summary><span data-ttu-id="ada9e-783">取得目前 <see cref="T:System.Char" /> 物件中指定位置的 <see cref="T:System.String" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-783">Gets the <see cref="T:System.Char" /> object at a specified position in the current <see cref="T:System.String" /> object.</span></span></summary>
        <value><span data-ttu-id="ada9e-784">在 <paramref name="index" /> 位置的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-784">The object at position <paramref name="index" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-785">`index`參數是以零為起始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-785">The `index` parameter is zero-based.</span></span>  
  
 <span data-ttu-id="ada9e-786">這個屬性會傳回<xref:System.Char>物件中所指定的位置`index`參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-786">This property returns the <xref:System.Char> object at the position specified by the `index` parameter.</span></span> <span data-ttu-id="ada9e-787">不過，您可能會將 Unicode 字元表示由多個<xref:System.Char>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-787">However, a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="ada9e-788">使用<xref:System.Globalization.StringInfo?displayProperty=nameWithType>類別來使用 Unicode 字元，而非<xref:System.Char>物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-788">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with Unicode characters instead of <xref:System.Char> objects.</span></span> <span data-ttu-id="ada9e-789">如需詳細資訊，請參閱中的 < Char 物件和 Unicode 字元 > 一節<xref:System.String>類別概觀。</span><span class="sxs-lookup"><span data-stu-id="ada9e-789">For more information, see the "Char Objects and Unicode Characters" section in the <xref:System.String> class overview.</span></span>  
  
 <span data-ttu-id="ada9e-790">在 C# 中，<xref:System.String.Chars%2A>屬性是索引子。</span><span class="sxs-lookup"><span data-stu-id="ada9e-790">In C#, the <xref:System.String.Chars%2A> property is an indexer.</span></span> <span data-ttu-id="ada9e-791">在 Visual Basic 中，它是預設屬性<xref:System.String>類別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-791">In Visual Basic, it is the default property of the <xref:System.String> class.</span></span> <span data-ttu-id="ada9e-792">每個<xref:System.Char>可以使用下列程式碼存取字串中的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-792">Each <xref:System.Char> object in the string can be accessed by using code such as the following.</span></span>  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-793">下列範例會示範如何使用這個索引子常式中驗證字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-793">The following example demonstrates how you can use this indexer in a routine to validate a string.</span></span>  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="ada9e-794"><paramref name="index" /> 大於或等於此物件的長度或小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-794"><paramref name="index" /> is greater than or equal to the length of this object or less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public string this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Chars(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(range As Range) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[Range] { System::String ^ get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Range) : string" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-795">傳回對 <see cref="T:System.String" /> 這個執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-795">Returns a reference to this instance of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-796"><see cref="T:System.String" /> 的這個執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-796">This instance of <see cref="T:System.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-797">傳回的值不是這個執行個體; 的獨立複本它是只是另一個檢視相同的資料。</span><span class="sxs-lookup"><span data-stu-id="ada9e-797">The return value is not an independent copy of this instance; it is simply another view of the same data.</span></span> <span data-ttu-id="ada9e-798">使用<xref:System.String.Copy%2A>或是<xref:System.String.CopyTo%2A>方法來建立個別<xref:System.String>物件具有相同的值與這個執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-798">Use the <xref:System.String.Copy%2A> or <xref:System.String.CopyTo%2A> method to create a separate <xref:System.String> object with the same value as this instance.</span></span>  
  
 <span data-ttu-id="ada9e-799">因為<xref:System.String.Clone%2A>方法只會傳回現有的字串執行個體，不太需要直接呼叫它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-799">Because the <xref:System.String.Clone%2A> method simply returns the existing string instance, there is little reason to call it directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-800">比較兩個指定的 <see cref="T:System.String" /> 物件，並傳回一個整數，指出它們在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-800">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-801"><xref:System.String.Compare%2A> 方法的所有多載會傳回 32 位元帶正負號整數，指出兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="ada9e-801">All overloads of the <xref:System.String.Compare%2A> method return a 32-bit signed integer indicating the lexical relationship between the two comparands.</span></span>  
  
|<span data-ttu-id="ada9e-802">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-802">Value</span></span>|<span data-ttu-id="ada9e-803">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-803">Condition</span></span>|  
|-----------|---------------|  
|<span data-ttu-id="ada9e-804">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-804">Less than zero</span></span>|<span data-ttu-id="ada9e-805">第一個子字串在排序次序中之前的第二個的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-805">The first substring precedes the second substring in the sort order.</span></span>|  
|<span data-ttu-id="ada9e-806">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-806">Zero</span></span>|<span data-ttu-id="ada9e-807">子字串出現在排序次序中的相同位置，或 `length` 為零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-807">The substrings occur in the same position in the sort order, or `length` is zero.</span></span>|  
|<span data-ttu-id="ada9e-808">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-808">Greater than zero</span></span>|<span data-ttu-id="ada9e-809">第一個子字串會遵循第二個的子字串在排序次序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-809">The first substring follows the second substring in the sort order.</span></span>|  
  
> [!WARNING]
>  <span data-ttu-id="ada9e-810">可能的話，您應該呼叫的多載<xref:System.String.Compare%2A>方法，其中包含<xref:System.StringComparison>參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-810">Whenever possible, you should call an overload of the <xref:System.String.Compare%2A> method that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="ada9e-811">如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-811">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7"><span data-ttu-id="ada9e-812">在 .NET Framework 中使用字串的最佳作法</span><span class="sxs-lookup"><span data-stu-id="ada9e-812">Best Practices for Using Strings in the .NET Framework</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ada9e-813">要比較的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-813">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ada9e-814">要比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-814">The second string to compare.</span></span></param>
        <summary><span data-ttu-id="ada9e-815">比較兩個指定的 <see cref="T:System.String" /> 物件，並傳回一個整數，指出它們在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-815">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ada9e-816">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="ada9e-816">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-817">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-817">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-818">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-818">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-819">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-819">Less than zero</span></span> 
 </term><description><span data-ttu-id="ada9e-820">在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-820"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-821">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-821">Zero</span></span> 
 </term><description><span data-ttu-id="ada9e-822"><paramref name="strA" /> 出現在排序次序中的位置和 <paramref name="strB" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-822"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-823">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-823">Greater than zero</span></span> 
 </term><description><span data-ttu-id="ada9e-824">在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="ada9e-824"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-825">比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-825">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ada9e-826">例如，某些字元的組合視為單一字元，或以特定的方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元，或跟隨它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-826">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ada9e-827">使用字組排序規則來進行比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-827">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ada9e-828">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-828">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ada9e-829">當比較字串，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，它會要求您明確指定此方法會使用的字串比較的型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-829">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="ada9e-830">如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-830">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ada9e-831">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-831">One or both comparands can be `null`.</span></span> <span data-ttu-id="ada9e-832">根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-832">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ada9e-833">當探索到的不等比較，或這兩個字串都比較之後，就會結束比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-833">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ada9e-834">不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，然後其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="ada9e-834">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ada9e-835">傳回的值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-835">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ada9e-836">比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-836">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ada9e-837">例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-837">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 <span data-ttu-id="ada9e-838">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-838">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ada9e-839">若要這樣做正確的程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="ada9e-839">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-840">下列範例會呼叫<xref:System.String.Compare%28System.String%2CSystem.String%29>方法來比較三個集合的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-840">The following example calls the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to compare three sets of strings.</span></span>  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 <span data-ttu-id="ada9e-841">在下列範例中，`ReverseStringComparer`類別會示範如何評估兩個字串<xref:System.String.Compare%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-841">In the following example, the `ReverseStringComparer` class demonstrates how you can evaluate two strings with the <xref:System.String.Compare%2A> method.</span></span>  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-842">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-842">Character sets include ignorable characters.</span></span> <span data-ttu-id="ada9e-843"><see cref="M:System.String.Compare(System.String,System.String)" />方法執行區分文化特性比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-843">The <see cref="M:System.String.Compare(System.String,System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-844">例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，區分文化特性的比較"animal"與"ani-惡意程式 」 （使用選擇性連字號或 U + 00AD） 表示兩個字串相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-844">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
<span data-ttu-id="ada9e-845">[!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]</span><span class="sxs-lookup"><span data-stu-id="ada9e-845">[!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]</span></span> 
<span data-ttu-id="ada9e-846">若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />方法，並提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或是<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如`comparisonType`參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-846">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ada9e-847">要比較的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-847">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ada9e-848">要比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-848">The second string to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ada9e-849"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-849"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-850">比較兩個指定的 <see cref="T:System.String" /> 物件，忽略或區分兩者的大小寫，並傳回一個整數，表示兩者在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-850">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ada9e-851">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="ada9e-851">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-852">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-852">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-853">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-853">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-854">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-854">Less than zero</span></span> 
 </term><description><span data-ttu-id="ada9e-855">在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-855"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-856">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-856">Zero</span></span> 
 </term><description><span data-ttu-id="ada9e-857"><paramref name="strA" /> 出現在排序次序中的位置和 <paramref name="strB" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-857"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-858">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-858">Greater than zero</span></span> 
 </term><description><span data-ttu-id="ada9e-859">在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="ada9e-859"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-860">比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-860">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ada9e-861">例如，某些字元的組合視為單一字元，或以特定的方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元，或跟隨它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-861">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ada9e-862">使用字組排序規則來進行比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-862">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ada9e-863">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-863">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ada9e-864">當比較字串，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，它會要求您明確指定此方法會使用的字串比較的型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-864">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="ada9e-865">如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-865">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ada9e-866">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-866">One or both comparands can be `null`.</span></span> <span data-ttu-id="ada9e-867">根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-867">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ada9e-868">當探索到的不等比較，或這兩個字串都比較之後，就會結束比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-868">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ada9e-869">不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，然後其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="ada9e-869">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ada9e-870">傳回的值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-870">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ada9e-871">比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-871">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ada9e-872">例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-872">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 <span data-ttu-id="ada9e-873">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-873">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ada9e-874">若要這樣做正確的程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="ada9e-874">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-875">下列範例示範<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29>方法就相當於使用<xref:System.String.ToUpper%2A>或<xref:System.String.ToLower%2A>比較字串時。</span><span class="sxs-lookup"><span data-stu-id="ada9e-875">The following example demonstrates that the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> method is equivalent to using <xref:System.String.ToUpper%2A> or <xref:System.String.ToLower%2A> when comparing strings.</span></span>  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-876">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-876">Character sets include ignorable characters.</span></span> <span data-ttu-id="ada9e-877"><see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" />方法執行區分文化特性比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-877">The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-878">例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，區分文化特性、 不區分大小寫的比較"animal"與"Ani-惡意程式 」 （使用選擇性連字號或 U + 00AD） 表示兩個字串相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-878">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive, case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
<span data-ttu-id="ada9e-879">[!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]</span><span class="sxs-lookup"><span data-stu-id="ada9e-879">[!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]</span></span> 
<span data-ttu-id="ada9e-880">若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />方法，並提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或是<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-880">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ada9e-881">要比較的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-881">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ada9e-882">要比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-882">The second string to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ada9e-883">其中一個列舉值，指定要用於比較的規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-883">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="ada9e-884">使用指定的規則比較兩個指定的 <see cref="T:System.String" /> 物件，並傳回一個整數，表示兩者在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-884">Compares two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ada9e-885">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="ada9e-885">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-886">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-886">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-887">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-887">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-888">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-888">Less than zero</span></span> 
 </term><description><span data-ttu-id="ada9e-889">在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-889"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-890">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-890">Zero</span></span> 
 </term><description><span data-ttu-id="ada9e-891"><paramref name="strA" /> 在排序次序中的位置和 <paramref name="strB" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-891"><paramref name="strA" /> is in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-892">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-892">Greater than zero</span></span> 
 </term><description><span data-ttu-id="ada9e-893">在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="ada9e-893"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-894">`comparisonType`參數會指出是否比較應該使用目前或而異的文化特性，接受或忽略大小寫的比較元，或使用 word （區分文化特性） 或序數 （不區分文化特性） 的排序規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-894">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>  
  
 <span data-ttu-id="ada9e-895">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-895">One or both comparands can be `null`.</span></span> <span data-ttu-id="ada9e-896">根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-896">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ada9e-897">當探索到的不等比較，或這兩個字串都比較之後，就會結束比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-897">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ada9e-898">不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="ada9e-898">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ada9e-899">傳回的值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-899">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ada9e-900">比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-900">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ada9e-901">例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-901">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 <span data-ttu-id="ada9e-902">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-902">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ada9e-903">若要這樣做正確的程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="ada9e-903">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-904">下列範例會比較三個版本的字母"I"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-904">The following example compares three versions of the letter "I".</span></span> <span data-ttu-id="ada9e-905">文化特性、 是否忽略大小寫，以及是否執行序數比較的選擇會影響結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-905">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-906"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-906"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ada9e-907">不支援 <see cref="T:System.StringComparison" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-907"><see cref="T:System.StringComparison" /> is not supported.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-908">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-908">Character sets include ignorable characters.</span></span> <span data-ttu-id="ada9e-909"><see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />方法執行區分文化特性比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-909">The <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-910">若要識別可忽略的字元在比較中，提供的值<see cref="F:System.StringComparison.Ordinal" />或是<see cref="F:System.StringComparison.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-910">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ada9e-911">要比較的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-911">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ada9e-912">要比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-912">The second string to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ada9e-913"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-913"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="ada9e-914">物件，提供文化特性相關的比較資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-914">An object that supplies culture-specific comparison information.</span></span></param>
        <summary><span data-ttu-id="ada9e-915">比較兩個指定的 <see cref="T:System.String" /> 物件，忽略或區分兩者的大小寫，並使用特定文化特性資訊來影響比較，然後傳回一個整數，表示兩者在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-915">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ada9e-916">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="ada9e-916">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-917">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-917">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-918">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-918">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-919">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-919">Less than zero</span></span> 
 </term><description><span data-ttu-id="ada9e-920">在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-920"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-921">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-921">Zero</span></span> 
 </term><description><span data-ttu-id="ada9e-922"><paramref name="strA" /> 出現在排序次序中的位置和 <paramref name="strB" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-922"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-923">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-923">Greater than zero</span></span> 
 </term><description><span data-ttu-id="ada9e-924">在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="ada9e-924"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-925">比較使用`culture`參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-925">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ada9e-926">例如，某些字元的組合視為單一字元，或以特定的方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元，或跟隨它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-926">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ada9e-927">使用字組排序規則來進行比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-927">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ada9e-928">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-928">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ada9e-929">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-929">One or both comparands can be `null`.</span></span> <span data-ttu-id="ada9e-930">根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-930">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ada9e-931">當探索到的不等比較，或這兩個字串都比較之後，就會結束比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-931">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ada9e-932">不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，然後其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="ada9e-932">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ada9e-933">傳回的值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-933">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ada9e-934">比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-934">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ada9e-935">例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-935">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 <span data-ttu-id="ada9e-936">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-936">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ada9e-937">若要這樣做正確的程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="ada9e-937">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-938">下列範例示範文化特性如何影響比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-938">The following example demonstrates how culture can affect a comparison.</span></span> <span data-ttu-id="ada9e-939">捷克文-捷克共和國文化特性，在 「 ch"會是單一字元，超過"d"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-939">In Czech - Czech Republic culture, "ch" is a single character that is greater than "d".</span></span> <span data-ttu-id="ada9e-940">不過，在英文-美國文化特性，"ch"所組成兩個字元，而且"c"小於"d"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-940">However, in English - United States culture, "ch" consists of two characters, and "c" is less than "d".</span></span>  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-941"><paramref name="culture" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-941"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-942">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-942">Character sets include ignorable characters.</span></span> <span data-ttu-id="ada9e-943"><see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />方法執行區分文化特性比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-943">The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-944">例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，"animal"與"Ani-惡意程式 」 （使用選擇性連字號或 U + 00AD） 的不區分大小寫比較使用不區分文化特性會指出兩個字串相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-944">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) using the invariant culture indicates that the two strings are equivalent.</span></span>  
  
<span data-ttu-id="ada9e-945">[!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]</span><span class="sxs-lookup"><span data-stu-id="ada9e-945">[!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]</span></span> 
<span data-ttu-id="ada9e-946">若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法，並提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或是<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="options" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-946">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ada9e-947">要比較的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-947">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ada9e-948">要比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-948">The second string to compare.</span></span></param>
        <param name="culture"><span data-ttu-id="ada9e-949">提供特定文化特性之比較資訊的文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-949">The culture that supplies culture-specific comparison information.</span></span></param>
        <param name="options"><span data-ttu-id="ada9e-950">執行比較時要使用的選項 (例如忽略大小寫或符號)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-950">Options to use when performing the comparison (such as ignoring case or symbols).</span></span></param>
        <summary><span data-ttu-id="ada9e-951">比較兩個指定的 <see cref="T:System.String" /> 物件，使用指定的比較選項及特定文化特性資訊影響比較，然後傳回整數，這個整數表示這兩個字串在排序次序中彼此的關聯性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-951">Compares two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ada9e-952">32 位元帶正負號的整數，這個整數表示 <paramref name="strA" /> 和 <paramref name="strB" /> 之間的語彙關係，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-952">A 32-bit signed integer that indicates the lexical relationship between <paramref name="strA" /> and <paramref name="strB" />, as shown in the following table</span></span> 
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-953">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-953">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-954">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-954">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-955">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-955">Less than zero</span></span> 
 </term><description><span data-ttu-id="ada9e-956">在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-956"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-957">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-957">Zero</span></span> 
 </term><description><span data-ttu-id="ada9e-958"><paramref name="strA" /> 出現在排序次序中的位置和 <paramref name="strB" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-958"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-959">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-959">Greater than zero</span></span> 
 </term><description><span data-ttu-id="ada9e-960">在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="ada9e-960"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-961">比較使用`culture`參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-961">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="ada9e-962">例如，某些字元的組合，視為單一字元、 大寫和小寫字元要比較以特定的方式，可以指定特定文化特性或字元的排序次序取決於字元，與其前面或後面。</span><span class="sxs-lookup"><span data-stu-id="ada9e-962">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ada9e-963"><xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>方法主要針對用於排序或依字母順序排列的作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-963">The <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="ada9e-964">此外，它不應該使用時呼叫方法的主要目的是要判斷兩個字串是否相等 （也就是當方法呼叫的目的是要測試傳回的值為零）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-964">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="ada9e-965">若要判斷兩個字串是否相等，請呼叫<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-965">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="ada9e-966">比較可以進一步指定`options`參數，其中包含一個或多個成員<xref:System.Globalization.CompareOptions>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-966">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions> enumeration.</span></span> <span data-ttu-id="ada9e-967">不過，這個方法的目的是要進行區分文化特性字串比較，因為<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>和<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>值沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="ada9e-967">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>  
  
 <span data-ttu-id="ada9e-968">可以是任一個或兩個比較元`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-968">Either or both comparands can be `null`.</span></span> <span data-ttu-id="ada9e-969">根據定義，任何字串，其中包括<xref:System.String.Empty?displayProperty=nameWithType>，彼此相等比較大於 null 參考，且兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-969">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ada9e-970">當探索到的不等比較，或這兩個字串都比較之後，就會結束比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-970">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="ada9e-971">不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="ada9e-971">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-972">下列範例會比較兩個字串中有三種： 使用 EN-US 文化特性; 的語言比較會使用 EN-US 文化特性; 語言區分大小寫的比較並使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-972">The following example compares two strings in three different ways: using linguistic comparison for the en-US culture; using linguistic case-sensitive comparison for the en-US culture; and using an ordinal comparison.</span></span> <span data-ttu-id="ada9e-973">它會說明如何比較的三種方法會產生三個不同的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-973">It illustrates how the three methods of comparison produce three different results.</span></span>  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-974"><paramref name="options" /> 不是 <see cref="T:System.Globalization.CompareOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-974"><paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-975"><paramref name="culture" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-975"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-976">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="ada9e-976">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-977"><see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法執行區分文化特性比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-977">The <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-978">若要識別可忽略的字元在比較中，提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或是<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="options" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-978">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ada9e-979">要用於比較中的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-979">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ada9e-980"><paramref name="strA" /> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-980">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="ada9e-981">要用於比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-981">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ada9e-982"><paramref name="strB" /> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-982">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="ada9e-983">要比較之子字串的字元數上限。</span><span class="sxs-lookup"><span data-stu-id="ada9e-983">The maximum number of characters in the substrings to compare.</span></span></param>
        <summary><span data-ttu-id="ada9e-984">比較兩個指定的 <see cref="T:System.String" /> 物件子字串，並傳回一個整數，指出它們在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-984">Compares substrings of two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ada9e-985">32 位元帶正負號整數，指出兩比較元的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="ada9e-985">A 32-bit signed integer indicating the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-986">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-986">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-987">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-987">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-988">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-988">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-989"><paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-989">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-990">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-990">Zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-991">子字串出現在排序次序中的相同位置，或 <paramref name="length" /> 為零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-991">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-992">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-992">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-993"><paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。</span><span class="sxs-lookup"><span data-stu-id="ada9e-993">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-994">要比較之子字串開始`strA`位於`indexA`然後在`strB`在`indexB`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-994">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="ada9e-995">兩者`indexA`並`indexB`之以零起始的是，也就是中的第一個字元`strA`和`strB`位在位置零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-995">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="ada9e-996">第一個子字串的長度等於長度`strA`減`indexA`再加 1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-996">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="ada9e-997">第二個的子字串長度會等於長度`strB`減`indexB`再加 1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-997">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="ada9e-998">要比較的字元數是較小的兩個子字串，長度和`length`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-998">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ada9e-999">`indexA`， `indexB`，和`length`參數不可為負值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-999">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ada9e-1000">比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1000">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ada9e-1001">例如，某些字元的組合視為單一字元，或以特定的方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元，或跟隨它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1001">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ada9e-1002">使用字組排序規則來進行比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1002">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ada9e-1003">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1003">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ada9e-1004">當比較字串，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>方法，它會要求您明確指定此方法會使用的字串比較的型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1004">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="ada9e-1005">如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1005">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ada9e-1006">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1006">One or both comparands can be `null`.</span></span> <span data-ttu-id="ada9e-1007">根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1007">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ada9e-1008">當探索到的不等比較，或兩個子字串都比較之後，將會結束比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1008">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ada9e-1009">不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，然後其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1009">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ada9e-1010">傳回的值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1010">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ada9e-1011">比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1011">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ada9e-1012">例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1012">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 <span data-ttu-id="ada9e-1013">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1013">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ada9e-1014">若要這樣做正確的程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1014">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1015">下列範例會比較這兩個子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1015">The following example compares two substrings.</span></span>  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-1016"><paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1016"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ada9e-1017">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1017">-or-</span></span> 
 <span data-ttu-id="ada9e-1018"><paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1018"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ada9e-1019">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1019">-or-</span></span> 
 <span data-ttu-id="ada9e-1020"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1020"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-1021">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1021">-or-</span></span> 
<span data-ttu-id="ada9e-1022"><paramref name="indexA" /> 或 <paramref name="indexB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1022">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-1023">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1023">Character sets include ignorable characters.</span></span> <span data-ttu-id="ada9e-1024"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />方法執行語言或文化特性的比較時不會考慮這些字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1024">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-1025">若要識別可忽略的字元在比較中，呼叫<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />方法，並提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1025">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ada9e-1026">要用於比較中的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1026">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ada9e-1027"><paramref name="strA" /> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1027">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="ada9e-1028">要用於比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1028">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ada9e-1029"><paramref name="strB" /> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1029">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="ada9e-1030">要比較之子字串的字元數上限。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1030">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ada9e-1031"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1031"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-1032">比較兩個指定之 <see cref="T:System.String" /> 物件的子字串，忽略或區分兩者的大小寫，並傳回一個整數，表示兩者在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1032">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1033">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1033">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-1034">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-1034">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-1035">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-1035">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-1036">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1036">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1037"><paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1037">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1038">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1038">Zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1039">子字串出現在排序次序中的相同位置，或 <paramref name="length" /> 為零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1039">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1040">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1040">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1041"><paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1041">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1042">要比較之子字串開始`strA`位於`indexA`，然後在`strB`在`indexB`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1042">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="ada9e-1043">兩者`indexA`並`indexB`之以零起始的是，也就是中的第一個字元`strA`和`strB`位在位置零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1043">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="ada9e-1044">第一個子字串的長度等於長度`strA`減`indexA`再加 1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1044">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="ada9e-1045">第二個的子字串長度會等於長度`strB`減`indexB`再加 1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1045">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="ada9e-1046">要比較的字元數是較小的兩個子字串，長度和`length`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1046">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ada9e-1047">`indexA`， `indexB`，和`length`參數不可為負值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1047">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ada9e-1048">比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1048">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ada9e-1049">例如，某些字元的組合視為單一字元，或以特定的方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元，或跟隨它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1049">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ada9e-1050">使用字組排序規則來進行比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1050">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ada9e-1051">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1051">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ada9e-1052">當比較字串，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>方法，它會要求您明確指定此方法會使用的字串比較的型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1052">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="ada9e-1053">如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1053">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="ada9e-1054">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1054">One or both comparands can be `null`.</span></span> <span data-ttu-id="ada9e-1055">根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1055">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ada9e-1056">當探索到的不等比較，或兩個子字串都比較之後，將會結束比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1056">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ada9e-1057">不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，然後其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1057">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ada9e-1058">傳回的值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1058">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ada9e-1059">比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1059">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ada9e-1060">例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1060">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 <span data-ttu-id="ada9e-1061">路徑名稱必須以不變的方式進行比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1061">The path name needs to be compared in an invariant manner.</span></span> <span data-ttu-id="ada9e-1062">若要這樣做正確的程式碼如下所示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1062">The correct code to do this is as follows.</span></span>  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1063">下列範例會在案例中的兩個比較的兩個只有不同的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1063">The following example performs two comparisons of two substrings that only differ in case.</span></span> <span data-ttu-id="ada9e-1064">第一個比較會忽略大小寫，第二個比較會考慮大小寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1064">The first comparison ignores case and the second comparison considers case.</span></span>  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-1065"><paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1065"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ada9e-1066">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1066">-or-</span></span> 
 <span data-ttu-id="ada9e-1067"><paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1067"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ada9e-1068">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1068">-or-</span></span> 
 <span data-ttu-id="ada9e-1069"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1069"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-1070">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1070">-or-</span></span> 
<span data-ttu-id="ada9e-1071"><paramref name="indexA" /> 或 <paramref name="indexB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1071">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-1072">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1072">Character sets include ignorable characters.</span></span> <span data-ttu-id="ada9e-1073"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />方法執行語言或文化特性的比較時不會考慮這些字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1073">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-1074">若要識別可忽略的字元在比較中，呼叫<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />方法，並提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1074">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ada9e-1075">要用於比較中的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1075">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ada9e-1076"><paramref name="strA" /> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1076">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="ada9e-1077">要用於比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1077">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ada9e-1078"><paramref name="strB" /> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1078">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="ada9e-1079">要比較之子字串的字元數上限。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1079">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ada9e-1080">其中一個列舉值，指定要用於比較的規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1080">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="ada9e-1081">使用指定的規則比較兩個指定之 <see cref="T:System.String" /> 物件的子字串，並傳回一個整數，表示兩者在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1081">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1082">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1082">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-1083">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-1083">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-1084">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-1084">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-1085">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1085">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1086"><paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1086">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1087">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1087">Zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1088">相同排序次序中相同位置出現的子字串，或 <paramref name="length" /> 參數為零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1088">The substrings occur in the same position in the sort order, or the <paramref name="length" /> parameter is zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1089">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1089">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1090"><paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1090">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1091">要比較之子字串開始`strA`位於`indexA`然後在`strB`在`indexB`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1091">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="ada9e-1092">兩者`indexA`並`indexB`是以零為起始，也就是中的第一個字元`strA`和`strB`是在位置零、 放在其中一個。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1092">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="ada9e-1093">第一個子字串的長度等於長度`strA`減`indexA`再加 1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1093">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="ada9e-1094">第二個的子字串長度會等於長度`strB`減`indexB`再加 1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1094">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="ada9e-1095">要比較的字元數是較小的兩個子字串，長度和`length`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1095">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ada9e-1096">`indexA`， `indexB`，和`length`參數不可為負值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1096">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ada9e-1097">`comparisonType`參數會指出是否比較應該使用目前或而異的文化特性，接受或忽略大小寫的比較元，或使用 word （區分文化特性） 或序數 （不區分文化特性） 的排序規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1097">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>  
  
 <span data-ttu-id="ada9e-1098">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1098">One or both comparands can be `null`.</span></span> <span data-ttu-id="ada9e-1099">根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1099">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ada9e-1100">當探索到的不等比較，或兩個子字串都比較之後，將會結束比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1100">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ada9e-1101">不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1101">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ada9e-1102">傳回的值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1102">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ada9e-1103">比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1103">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ada9e-1104">例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1104">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 <span data-ttu-id="ada9e-1105">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1105">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ada9e-1106">若要這樣做正確的程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1106">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1107">下列範例會比較這兩個子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1107">The following example compares two substrings.</span></span>  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-1108"><paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1108"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ada9e-1109">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1109">-or-</span></span> 
 <span data-ttu-id="ada9e-1110"><paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1110"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ada9e-1111">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1111">-or-</span></span> 
 <span data-ttu-id="ada9e-1112"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1112"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-1113">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1113">-or-</span></span> 
<span data-ttu-id="ada9e-1114"><paramref name="indexA" /> 或 <paramref name="indexB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1114">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-1115"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1115"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-1116">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1116">Character sets include ignorable characters.</span></span> <span data-ttu-id="ada9e-1117"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />方法執行語言或文化特性的比較時不會考慮這些字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1117">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-1118">若要識別可忽略的字元在比較中，提供的值<see cref="F:System.StringComparison.Ordinal" />或是<see cref="F:System.StringComparison.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1118">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ada9e-1119">要用於比較中的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1119">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ada9e-1120"><paramref name="strA" /> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1120">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="ada9e-1121">要用於比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1121">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ada9e-1122"><paramref name="strB" /> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1122">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="ada9e-1123">要比較之子字串的字元數上限。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1123">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ada9e-1124"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1124"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="ada9e-1125">物件，提供文化特性相關的比較資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1125">An object that supplies culture-specific comparison information.</span></span></param>
        <summary><span data-ttu-id="ada9e-1126">比較兩個指定之 <see cref="T:System.String" /> 物件的子字串，忽略或區分兩者的大小寫，並使用文化特性資訊來影響比較，然後傳回一個整數，表示兩者在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1126">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1127">整數，表示兩個比較元 (Comparand) 之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1127">An integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-1128">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-1128">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-1129">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-1129">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-1130">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1130">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1131"><paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1131">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1132">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1132">Zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1133">子字串出現在排序次序中的相同位置，或 <paramref name="length" /> 為零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1133">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1134">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1134">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1135"><paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1135">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1136">要比較之子字串開始`strA`位於`indexA`，然後在`strB`在`indexB`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1136">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="ada9e-1137">兩者`indexA`並`indexB`是以零為起始，也就是中的第一個字元`strA`和`strB`是在位置零、 放在其中一個。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1137">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="ada9e-1138">第一個子字串的長度等於長度`strA`減`indexA`再加 1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1138">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="ada9e-1139">第二個的子字串長度會等於長度`strB`減`indexB`再加 1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1139">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="ada9e-1140">要比較的字元數是較小的兩個子字串，長度和`length`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1140">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ada9e-1141">`indexA`， `indexB`，和`length`參數不可為負值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1141">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ada9e-1142">比較使用`culture`參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1142">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="ada9e-1143">例如，某些字元的組合視為單一字元，或以特定的方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元，或跟隨它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1143">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="ada9e-1144">使用字組排序規則來進行比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1144">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="ada9e-1145">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1145">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ada9e-1146">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1146">One or both comparands can be `null`.</span></span> <span data-ttu-id="ada9e-1147">根據定義，任何字串，包括空字串 ("")，為 null 的參考; 大於的比較並比較彼此相等的兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1147">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ada9e-1148">當探索到的不等比較，或兩個子字串都比較之後，將會結束比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1148">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ada9e-1149">不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，然後其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1149">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="ada9e-1150">傳回的值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1150">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="ada9e-1151">比較會受到特定文化特性的大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1151">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="ada9e-1152">例如，在土耳其文，下列範例會產生錯誤的結果因為土耳其文中的檔案系統不會使用語言大小寫規則，以找到字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1152">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 <span data-ttu-id="ada9e-1153">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1153">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="ada9e-1154">若要這樣做正確的程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1154">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1155">下列範例會比較這兩個子字串使用不同的文化特性並忽略大小寫的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1155">The following example compares two substrings using different cultures and ignoring the case of the substrings.</span></span> <span data-ttu-id="ada9e-1156">文化特性的選擇會影響如何字母"I"是比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1156">The choice of culture affects how the letter "I" is compared.</span></span>  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-1157"><paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1157"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ada9e-1158">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1158">-or-</span></span> 
 <span data-ttu-id="ada9e-1159"><paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1159"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ada9e-1160">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1160">-or-</span></span> 
 <span data-ttu-id="ada9e-1161"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1161"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-1162">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1162">-or-</span></span> 
<span data-ttu-id="ada9e-1163"><paramref name="strA" /> 或 <paramref name="strB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1163">Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1164"><paramref name="culture" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1164"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-1165">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1165">Character sets include ignorable characters.</span></span> <span data-ttu-id="ada9e-1166"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />方法執行語言或文化特性的比較時不會考慮這些字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1166">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-1167">若要識別可忽略的字元在比較中，呼叫<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法，並提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="options" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1167">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ada9e-1168">要用於比較中的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1168">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ada9e-1169"><paramref name="strA" /> 中子字串的開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1169">The starting position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="ada9e-1170">要用於比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1170">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ada9e-1171"><paramref name="strB" /> 中子字串的開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1171">The starting position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="ada9e-1172">要比較之子字串的字元數上限。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1172">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="culture"><span data-ttu-id="ada9e-1173">物件，提供文化特性相關的比較資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1173">An object that supplies culture-specific comparison information.</span></span></param>
        <param name="options"><span data-ttu-id="ada9e-1174">執行比較時要使用的選項 (例如忽略大小寫或符號)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1174">Options to use when performing the comparison (such as ignoring case or symbols).</span></span></param>
        <summary><span data-ttu-id="ada9e-1175">比較兩個指定的 <see cref="T:System.String" /> 物件的子字串，使用指定的比較選項及特定文化特性資訊影響比較，然後傳回整數，這個整數表示這兩個子字串在排序次序中彼此的關聯性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1175">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1176">整數，這個整數表示兩個子字串之間的語彙關係，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1176">An integer that indicates the lexical relationship between the two substrings, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-1177">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-1177">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-1178">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-1178">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-1179">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1179">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1180"><paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1180">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1181">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1181">Zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1182">子字串出現在排序次序中的相同位置，或 <paramref name="length" /> 為零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1182">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1183">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1183">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1184"><paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1184">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1185">要比較之子字串開始`strA`位置處`indexA`然後在`strB`位置`indexB`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1185">The substrings to compare start in `strA` at position `indexA` and in `strB` at position `indexB`.</span></span> <span data-ttu-id="ada9e-1186">第一個子字串的長度是長度`strA`減`indexA`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1186">The length of the first substring is the length of `strA` minus `indexA`.</span></span> <span data-ttu-id="ada9e-1187">第二個的子字串的長度是長度`strB`減`indexB`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1187">The length of the second substring is the length of `strB` minus `indexB`.</span></span>  
  
 <span data-ttu-id="ada9e-1188">要比較的字元數是較小的兩個子字串，長度和`length`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1188">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="ada9e-1189">`indexA`， `indexB`，和`length`參數不可為負值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1189">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ada9e-1190">比較使用`culture`參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1190">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="ada9e-1191">例如，某些字元的組合，視為單一字元、 大寫和小寫字元要比較以特定的方式，可以指定特定文化特性或字元的排序次序取決於字元，與其前面或後面。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1191">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ada9e-1192"><xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>方法主要針對用於排序或依字母順序排列的作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1192">The <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="ada9e-1193">此外，它不應該使用時呼叫方法的主要目的是要判斷這兩個子字串是否相等 （也就是當方法呼叫的目的是要測試傳回的值為零）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1193">It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="ada9e-1194">若要判斷兩個字串是否相等，請呼叫<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1194">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="ada9e-1195">其中一個或多個`strA`並`strB`可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1195">One or both of `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="ada9e-1196">根據定義，任何字串，其中包括<xref:System.String.Empty?displayProperty=nameWithType>，彼此相等比較大於 null 參考，且兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1196">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="ada9e-1197">比較可以進一步指定`options`參數，其中包含一個或多個成員<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1197">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="ada9e-1198">不過，這個方法的目的是要進行區分文化特性字串比較，因為<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>和<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>值沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1198">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>  
  
 <span data-ttu-id="ada9e-1199">當探索到的不等比較，或兩個子字串都比較之後，將會結束比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1199">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="ada9e-1200">不過，如果兩個字串比較等於一個字串的結尾，而另一個字串有多餘的字元，其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1200">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span> <span data-ttu-id="ada9e-1201">傳回的值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1201">The return value is the result of the last comparison performed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1202">下列範例會使用<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>方法來比較兩個人員的姓氏。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1202">The following example uses the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method to compare the last names of two people.</span></span> <span data-ttu-id="ada9e-1203">然後它會列出它們依字母順序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1203">It then lists them in alphabetical order.</span></span>  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-1204"><paramref name="options" /> 不是 <see cref="T:System.Globalization.CompareOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1204"><paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-1205"><paramref name="indexA" /> 大於 <paramref name="strA" /><see langword=".Length" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1205"><paramref name="indexA" /> is greater than <paramref name="strA" /><see langword=".Length" />.</span></span>  
  
<span data-ttu-id="ada9e-1206">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1206">-or-</span></span> 
 <span data-ttu-id="ada9e-1207"><paramref name="indexB" /> 大於 <paramref name="strB" /><see langword=".Length" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1207"><paramref name="indexB" /> is greater than <paramref name="strB" /><see langword=".Length" />.</span></span>  
  
<span data-ttu-id="ada9e-1208">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1208">-or-</span></span> 
 <span data-ttu-id="ada9e-1209"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1209"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-1210">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1210">-or-</span></span> 
<span data-ttu-id="ada9e-1211"><paramref name="strA" /> 或 <paramref name="strB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1211">Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1212"><paramref name="culture" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1212"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-1213">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1213">Character sets include ignorable characters.</span></span> <span data-ttu-id="ada9e-1214"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法執行語言或文化特性的比較時不會考慮這些字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1214">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-1215">若要識別可忽略的字元在比較中，提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或是<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="options" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1215">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-1216">藉由評估每個字串中對應的 <see cref="T:System.String" /> 物件之數字值，比較兩個 <see cref="T:System.Char" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1216">Compares two <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ada9e-1217">要比較的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1217">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="ada9e-1218">要比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1218">The second string to compare.</span></span></param>
        <summary><span data-ttu-id="ada9e-1219">藉由評估每個字串中對應的 <see cref="T:System.String" /> 物件之數字值，比較兩個指定 <see cref="T:System.Char" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1219">Compares two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1220">整數，表示兩個比較元 (Comparand) 之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1220">An integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-1221">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-1221">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-1222">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-1222">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-1223">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1223">Less than zero</span></span> 
 </term><description><span data-ttu-id="ada9e-1224"><paramref name="strA" /> 小於 <paramref name="strB" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1224"><paramref name="strA" /> is less than <paramref name="strB" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1225">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1225">Zero</span></span> 
 </term><description><span data-ttu-id="ada9e-1226"><paramref name="strA" /> 和 <paramref name="strB" /> 相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1226"><paramref name="strA" /> and <paramref name="strB" /> are equal.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1227">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1227">Greater than zero</span></span> 
 </term><description><span data-ttu-id="ada9e-1228"><paramref name="strA" /> 大於 <paramref name="strB" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1228"><paramref name="strA" /> is greater than <paramref name="strB" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1229">這個方法會執行區分大小寫比較，使用序數排序規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1229">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="ada9e-1230">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1230">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-1231">若要執行不區分大小寫比較，使用序數排序規則，請呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法`comparisonType`引數設定為<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1231">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ada9e-1232">因為<xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>是一種靜態方法，`strA`並`strB`可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1232">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="ada9e-1233">如果這兩個值都是`null`，方法會傳回 0 （零），表示`strA`和`strB`相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1233">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="ada9e-1234">如果只有其中一個值為`null`，此方法會考慮較大的非 null 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1234">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1235">下列範例會執行與序數比較兩個字串只有大小寫不同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1235">The following example performs and ordinal comparison of two strings that only differ in case.</span></span>  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="ada9e-1236">要用於比較中的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1236">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="ada9e-1237"><paramref name="strA" /> 中子字串的起始索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1237">The starting index of the substring in <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="ada9e-1238">要用於比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1238">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="ada9e-1239"><paramref name="strB" /> 中子字串的起始索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1239">The starting index of the substring in <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="ada9e-1240">要比較之子字串的字元數上限。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1240">The maximum number of characters in the substrings to compare.</span></span></param>
        <summary><span data-ttu-id="ada9e-1241">藉由評估每個子字串中對應的 <see cref="T:System.String" /> 物件之數字值，比較兩個指定的 <see cref="T:System.Char" /> 物件之子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1241">Compares substrings of two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each substring.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1242">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1242">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-1243">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-1243">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-1244">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-1244">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-1245">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1245">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1246"><paramref name="strA" /> 中的子字串小於 <paramref name="strB" /> 中的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1246">The substring in <paramref name="strA" /> is less than the substring in <paramref name="strB" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1247">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1247">Zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1248">子字串相等，或者 <paramref name="length" /> 為零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1248">The substrings are equal, or <paramref name="length" /> is zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1249">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1249">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1250"><paramref name="strA" /> 中的子字串大於 <paramref name="strB" /> 中的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1250">The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1251">`indexA`， `indexB`，和`length`參數不可為負值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1251">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="ada9e-1252">相較的字元數是較小的長度`strA`少`indexA`，長度`strB`較少`indexB`，和`length`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1252">The number of characters compared is the lesser of the length of `strA` less `indexA`, the length of `strB` less `indexB`, and `length`.</span></span>  
  
 <span data-ttu-id="ada9e-1253">這個方法會執行區分大小寫比較，使用序數排序規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1253">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="ada9e-1254">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1254">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-1255">若要執行不區分大小寫比較，使用序數排序規則，請呼叫<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>方法`comparisonType`引數設定為<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1255">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ada9e-1256">因為<xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>是一種靜態方法，`strA`並`strB`可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1256">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="ada9e-1257">如果這兩個值都是`null`，方法會傳回 0 （零），表示`strA`和`strB`相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1257">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="ada9e-1258">如果只有其中一個值為`null`，此方法會考慮較大的非 null 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1258">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1259">下列範例示範<xref:System.String.CompareOrdinal%2A>和<xref:System.String.Compare%2A>使用不同的排序次序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1259">This following example demonstrates that <xref:System.String.CompareOrdinal%2A> and <xref:System.String.Compare%2A> use different sort orders.</span></span>  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-1260"><paramref name="strA" /> 不是 <see langword="null" /> 且 <paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1260"><paramref name="strA" /> is not <see langword="null" /> and <paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ada9e-1261">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1261">-or-</span></span> 
 <span data-ttu-id="ada9e-1262"><paramref name="strB" /> 不是 <see langword="null" /> 且 <paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1262"><paramref name="strB" /> is not <see langword="null" /> and <paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
<span data-ttu-id="ada9e-1263">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1263">-or-</span></span> 
 <span data-ttu-id="ada9e-1264"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1264"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span></exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-1265">比較這個執行個體與指定的物件或 <see cref="T:System.String" />，並傳回一個整數，指出這個執行個體在排序次序中，位於指定物件或 <see cref="T:System.String" /> 之前、之後或相同位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1265">Compares this instance with a specified object or <see cref="T:System.String" /> and returns an integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified object or <see cref="T:System.String" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1266">這兩個多載<xref:System.String.CompareTo%2A>方法執行區分文化特性和區分大小寫的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1266">Both overloads of the <xref:System.String.CompareTo%2A> method perform culture-sensitive and case-sensitive comparison.</span></span> <span data-ttu-id="ada9e-1267">您無法使用這個方法來執行不區分文化特性或序數比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1267">You cannot use this method to perform culture-insensitive or ordinal comparisons.</span></span> <span data-ttu-id="ada9e-1268">為了讓程式碼，我們建議您避免<xref:System.String.CompareTo%2A>方法，並呼叫<xref:System.String.Compare%2A>方法改為。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1268">For code clarity, we recommend that you avoid the <xref:System.String.CompareTo%2A> method and call the <xref:System.String.Compare%2A> method instead.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-1269">評估為 <see cref="T:System.String" /> 的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1269">An object that evaluates to a <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-1270">比較這個執行個體與指定的 <see cref="T:System.Object" />，並且指出這個執行個體在排序次序中，位於所指定 <see cref="T:System.Object" /> 之前、之後或相同位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1270">Compares this instance with a specified <see cref="T:System.Object" /> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1271">32 位元帶正負號的整數，指出這個執行個體在排序次序中，位於 <paramref name="value" /> 參數之前、之後或相同位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1271">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="value" /> parameter.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-1272">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-1272">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-1273">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-1273">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-1274">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1274">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1275">這個執行個體位於 <paramref name="value" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1275">This instance precedes <paramref name="value" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1276">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1276">Zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1277">這個執行個體在排序次序中的位置與 <paramref name="value" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1277">This instance has the same position in the sort order as <paramref name="value" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1278">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1278">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1279">這個執行個體位於 <paramref name="value" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1279">This instance follows <paramref name="value" />.</span></span>  
  
<span data-ttu-id="ada9e-1280">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1280">-or-</span></span> 
 <span data-ttu-id="ada9e-1281"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1281"><paramref name="value" /> is <see langword="null" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1282">`value` 必須是<xref:System.String>物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1282">`value` must be a <xref:System.String> object.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ada9e-1283"><xref:System.String.CompareTo%2A>方法依設計主要是用於排序或依字母順序排列的作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1283">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="ada9e-1284">此外，它不應該使用時呼叫方法的主要目的是要判斷兩個字串是否相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1284">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="ada9e-1285">若要判斷兩個字串是否相等，請呼叫<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1285">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="ada9e-1286">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1286">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="ada9e-1287">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1287">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ada9e-1288">這個方法的行為的相關詳細資訊，請參閱 < 備註 > 一節<xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1288">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1289">下列範例會使用<xref:System.String.CompareTo%2A>方法使用<xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1289">The following example uses the <xref:System.String.CompareTo%2A> method with an <xref:System.Object>.</span></span> <span data-ttu-id="ada9e-1290">因為它會嘗試比較<xref:System.String>執行個體`TestClass`物件，方法會擲回<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1290">Because it attempts to compare a <xref:System.String> instance to a `TestClass` object, the method throws an <xref:System.ArgumentException>.</span></span>  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-1291"><paramref name="value" /> 不是 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1291"><paramref name="value" /> is not a <see cref="T:System.String" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-1292">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1292">Character sets include ignorable characters.</span></span> <span data-ttu-id="ada9e-1293"><see cref="M:System.String.CompareTo(System.Object)" />方法執行區分文化特性比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1293">The <see cref="M:System.String.CompareTo(System.Object)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-1294">例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，"animal"與"ani-惡意程式 」 （使用選擇性連字號或 U + 00AD） 的比較，指出兩個字串相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1294">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
<span data-ttu-id="ada9e-1295">[!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="ada9e-1295">[!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]</span></span> 
<span data-ttu-id="ada9e-1296">若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.CompareOrdinal(System.String,System.String)" />方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1296">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</span></span></para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB"><span data-ttu-id="ada9e-1297">要和這個執行個體比較的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1297">The string to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="ada9e-1298">比較這個執行個體與指定的 <see cref="T:System.String" /> 物件，並且表示這個執行個體在排序次序中，位於所指定字串之前、之後或相同位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1298">Compares this instance with a specified <see cref="T:System.String" /> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1299">32 位元帶正負號的整數，指出這個執行個體在排序次序中，位於 <paramref name="strB" /> 參數之前、之後或相同位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1299">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="strB" /> parameter.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ada9e-1300">值</span><span class="sxs-lookup"><span data-stu-id="ada9e-1300">Value</span></span> 
 </term><description> <span data-ttu-id="ada9e-1301">條件</span><span class="sxs-lookup"><span data-stu-id="ada9e-1301">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ada9e-1302">小於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1302">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1303">這個執行個體位於 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1303">This instance precedes <paramref name="strB" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1304">零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1304">Zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1305">這個執行個體在排序次序中的位置與 <paramref name="strB" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1305">This instance has the same position in the sort order as <paramref name="strB" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ada9e-1306">大於零</span><span class="sxs-lookup"><span data-stu-id="ada9e-1306">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ada9e-1307">這個執行個體位於 <paramref name="strB" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1307">This instance follows <paramref name="strB" />.</span></span>  
  
<span data-ttu-id="ada9e-1308">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1308">-or-</span></span> 
 <span data-ttu-id="ada9e-1309"><paramref name="strB" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1309"><paramref name="strB" /> is <see langword="null" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1310">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1310">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="ada9e-1311">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1311">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ada9e-1312"><xref:System.String.CompareTo%2A>方法依設計主要是用於排序或依字母順序排列的作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1312">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="ada9e-1313">此外，它不應該使用時呼叫方法的主要目的是要判斷兩個字串是否相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1313">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="ada9e-1314">若要判斷兩個字串是否相等，請呼叫<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1314">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="ada9e-1315">這個方法的行為的相關詳細資訊，請參閱 < 備註 > 一節<xref:System.String.Compare%28System.String%2CSystem.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1315">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29> method.</span></span>  
  
 <span data-ttu-id="ada9e-1316">這個方法會實作<xref:System.IComparable%601?displayProperty=nameWithType>介面並執行稍微優於<xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType>方法，因為它不能以判斷是否`strB`引數是可變動的實值型別，必須要經過 boxing 處理，而且不需要轉型其從參數<xref:System.Object>至<xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1316">This method implements the <xref:System.IComparable%601?displayProperty=nameWithType> interface and performs slightly better than the <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> method, because it does not have to determine whether the `strB` argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <xref:System.Object> to a <xref:System.String>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1317">下列範例會使用<xref:System.String.CompareTo%2A>方法來比較目前的字串執行個體，以另一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1317">The following example uses the <xref:System.String.CompareTo%2A> method to compare the current string instance with another string.</span></span>  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 <span data-ttu-id="ada9e-1318">下列範例示範數個值和參考類型的 CompareTo 方法的泛型和非泛型版本。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1318">The following example demonstrates generic and non-generic versions of the CompareTo method for several value and reference types.</span></span>  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-1319">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1319">Character sets include ignorable characters.</span></span> <span data-ttu-id="ada9e-1320"><see cref="M:System.String.CompareTo(System.String)" />方法執行區分文化特性比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1320">The <see cref="M:System.String.CompareTo(System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-1321">例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，"animal"與"ani-惡意程式 」 （使用選擇性連字號或 U + 00AD） 的比較，指出兩個字串相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1321">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
<span data-ttu-id="ada9e-1322">[!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="ada9e-1322">[!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]</span></span> 
<span data-ttu-id="ada9e-1323">若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.CompareOrdinal(System.String,System.String)" />方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1323">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</span></span></para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-1324">串連一或多個 <see cref="T:System.String" /> 執行個體，或者一或多個 <see cref="T:System.String" /> 執行個體值的 <see cref="T:System.Object" /> 表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1324">Concatenates one or more instances of <see cref="T:System.String" />, or the <see cref="T:System.String" /> representations of the values of one or more instances of <see cref="T:System.Object" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values"><span data-ttu-id="ada9e-1325">集合物件，這個物件實作 <see cref="T:System.Collections.Generic.IEnumerable`1" />，且其泛型類型引數為 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1325">A collection object that implements <see cref="T:System.Collections.Generic.IEnumerable`1" /> and whose generic type argument is <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-1326">串連類型 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 之已建構的 <see cref="T:System.String" /> 集合的成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1326">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1327"><paramref name="values" /> 中的串連字串，或如果 <paramref name="values" /> 是空白的 <see langword="IEnumerable(Of String)" />則為 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1327">The concatenated strings in <paramref name="values" />, or <see cref="F:System.String.Empty" /> if <paramref name="values" /> is an empty <see langword="IEnumerable(Of String)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1328">方法會串連每個物件在`values`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1328">The method concatenates each object in `values`; it does not add any delimiters.</span></span> <span data-ttu-id="ada9e-1329">若要指定每個成員之間的分隔符號`values`，呼叫<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1329">To specify a delimiter between each member of `values`, call the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 <span data-ttu-id="ada9e-1330"><xref:System.String.Empty>替代任何 null 的項目中使用字串`values`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1330">An <xref:System.String.Empty> string is used in place of any null element in `values`.</span></span>  
  
 <span data-ttu-id="ada9e-1331">如果`values`為空`IEnumerable(Of String)`，則方法會傳回<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1331">If `values` is an empty `IEnumerable(Of String)`, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-1332">如果`values`已`null`，方法會擲回<xref:System.ArgumentNullException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1332">If `values` is `null`, the method throws an <xref:System.ArgumentNullException> exception.</span></span>  
  
 <span data-ttu-id="ada9e-1333"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 是一種便利方法，可讓您串連每個項目`IEnumerable(Of String)`集合，而不先將項目轉換成字串陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1333"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="ada9e-1334">它特別適合使用 Language-Integrated Query (LINQ) 查詢運算式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1334">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="ada9e-1335">下列範例會傳遞`List(Of String)`物件，包含 lambda 運算式會選取等於或大於特定字母 （即，在範例中，"M"） 的字母英文字母大寫或小寫字母。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1335">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="ada9e-1336">`IEnumerable(Of String)`所傳回的集合<xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>方法會傳遞至<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法來顯示結果，以單一字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1336">The `IEnumerable(Of String)` collection that is returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1337">下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1337">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="ada9e-1338">它會將結果指派<xref:System.Collections.Generic.List%601>類型的物件<xref:System.String>，這會接著傳遞給<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1338">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1339"><paramref name="values" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1339"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="ada9e-1340">要表示的物件，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1340">The object to represent, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-1341">建立指定之物件的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1341">Creates the string  representation of a specified object.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1342"><paramref name="arg0" /> 值的字串表示；如果 <see cref="F:System.String.Empty" /> 為 <paramref name="arg0" />，則為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1342">The string representation of the value of <paramref name="arg0" />, or <see cref="F:System.String.Empty" /> if <paramref name="arg0" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1343"><xref:System.String.Concat%28System.Object%29>方法代表`arg0`做為字串，藉由呼叫其無參數`ToString`方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1343">The <xref:System.String.Concat%28System.Object%29> method represents `arg0` as a string by calling its parameterless `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1344">下列範例示範<xref:System.String.Concat%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1344">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="ada9e-1345">包含要串連之項目的物件陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1345">An object array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="ada9e-1346">串連指定之 <see cref="T:System.Object" /> 陣列中項目的字串表示法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1346">Concatenates the string representations of the elements in a specified <see cref="T:System.Object" /> array.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1347"><paramref name="args" /> 中之項目值的串連字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1347">The concatenated string representations of the values of the elements in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1348">方法會串連每個物件在`args`藉由呼叫無參數`ToString`方法，該物件; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1348">The method concatenates each object in `args` by calling the parameterless `ToString` method of that object; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ada9e-1349"><xref:System.String.Empty?displayProperty=nameWithType> 用來在陣列中的任何 null 物件取代。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1349"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1350">下列範例示範如何使用<xref:System.String.Concat%2A>方法使用<xref:System.Object>陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1350">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with an <xref:System.Object> array.</span></span>  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1351"><paramref name="args" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1351"><paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="ada9e-1352">記憶體不足。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1352">Out of memory.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-1353">這個方法不由呼叫C++程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1353">This method is not called by C++ code.</span></span> <span data-ttu-id="ada9e-1354">C++編譯器解析呼叫<see cref="Overload:System.String.Concat" />具有四個或多個物件參數與呼叫<see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1354">The C++ compiler resolves calls to <see cref="Overload:System.String.Concat" /> that have four or more object parameters as a call to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</span></span></para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values"><span data-ttu-id="ada9e-1355">字串執行個體的陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1355">An array of string instances.</span></span></param>
        <summary><span data-ttu-id="ada9e-1356">串連指定 <see cref="T:System.String" /> 陣列中的項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1356">Concatenates the elements of a specified <see cref="T:System.String" /> array.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1357"><paramref name="values" /> 的串連項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1357">The concatenated elements of <paramref name="values" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1358">方法會串連每個物件在`values`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1358">The method concatenates each object in `values`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ada9e-1359"><xref:System.String.Empty>字串來取代陣列中的任何 null 物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1359">An <xref:System.String.Empty> string is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1360">下列範例示範如何使用<xref:System.String.Concat%2A>方法使用<xref:System.String>陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1360">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with a <xref:System.String> array.</span></span>  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1361"><paramref name="values" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1361"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="ada9e-1362">記憶體不足。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1362">Out of memory.</span></span></exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="ada9e-1363">要串連的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1363">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="ada9e-1364">要串連的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1364">The second object to concatenate.</span></span></param>
        <summary><span data-ttu-id="ada9e-1365">串連兩個指定之物件的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1365">Concatenates the string representations of two specified objects.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1366"><paramref name="arg0" /> 和 <paramref name="arg1" /> 之值的串連字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1366">The concatenated string representations of the values of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1367">方法會串連`arg0`並`arg1`藉由呼叫無參數`ToString`方法`arg0`和`arg1`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1367">The method concatenates `arg0` and `arg1` by calling the parameterless `ToString` method of `arg0` and `arg1`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ada9e-1368"><xref:System.String.Empty?displayProperty=nameWithType> 用來取代任何 null 引數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1368"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
 <span data-ttu-id="ada9e-1369">如果是引數的陣列參考，此方法會串連字串，表示該陣列，而不是其成員 (例如，"System.String[]")。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1369">If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1370">下列範例示範<xref:System.String.Concat%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1370">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="ada9e-1371">要串連的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1371">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="ada9e-1372">要串連的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1372">The second string to concatenate.</span></span></param>
        <summary><span data-ttu-id="ada9e-1373">串連 <see cref="T:System.String" /> 的兩個指定執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1373">Concatenates two specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1374"><paramref name="str0" /> 和 <paramref name="str1" /> 的串連。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1374">The concatenation of <paramref name="str0" /> and <paramref name="str1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1375">方法會串連`str0`和`str1`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1375">The method concatenates `str0` and `str1`; it does not add any delimiters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-1376">您可以也使用您語言的字串串連運算子，例如`+`在 C# 中，或是`&`和`+`在 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-1376">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)</span></span>  
>   
>  <span data-ttu-id="ada9e-1377">來串連字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1377">, to concatenate strings.</span></span>  
  
 <span data-ttu-id="ada9e-1378"><xref:System.String.Empty>字串來取代任何 null 引數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1378">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1379">下列範例會串連個人的名字、 中間名和姓氏的名稱。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1379">The following example concatenates a person's first, middle, and last name.</span></span>  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="ada9e-1380">要串連的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1380">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="ada9e-1381">要串連的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1381">The second object to concatenate.</span></span></param>
        <param name="arg2"><span data-ttu-id="ada9e-1382">要串連的第三個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1382">The third object to concatenate.</span></span></param>
        <summary><span data-ttu-id="ada9e-1383">串連三個指定之物件的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1383">Concatenates the string representations of three specified objects.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1384"><paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 之值的串連字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1384">The concatenated string representations of the values of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1385">方法會串連`arg0`， `arg1`，並`arg2`藉由呼叫無參數`ToString`方法的每個物件; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1385">The method concatenates `arg0`, `arg1`, and `arg2` by calling the parameterless `ToString` method of each object; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ada9e-1386"><xref:System.String.Empty?displayProperty=nameWithType> 用來取代任何 null 引數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1386"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1387">下列範例示範<xref:System.String.Concat%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1387">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <param name="str2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="ada9e-1388">要串連的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1388">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="ada9e-1389">要串連的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1389">The second string to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="ada9e-1390">要串連的第三個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1390">The third string to concatenate.</span></span></param>
        <summary><span data-ttu-id="ada9e-1391">串連 <see cref="T:System.String" /> 的三個指定執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1391">Concatenates three specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1392"><paramref name="str0" />、<paramref name="str1" /> 和 <paramref name="str2" /> 的串連。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1392">The concatenation of <paramref name="str0" />, <paramref name="str1" />, and <paramref name="str2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1393">方法會串連`str0`， `str1`，和`str2`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1393">The method concatenates `str0`, `str1`, and `str2`; it does not add any delimiters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-1394">您可以也使用您語言的字串串連運算子，例如`+`在 C# 中，或是`&`和`+`在 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-1394">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)</span></span>  
>   
>  <span data-ttu-id="ada9e-1395">來串連字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1395">, to concatenate strings.</span></span>  
  
 <span data-ttu-id="ada9e-1396"><xref:System.String.Empty>字串來取代任何 null 引數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1396">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1397">下列範例會使用<xref:System.String.Concat%2A>方法來串連三個字串，並顯示結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1397">The following example uses the <xref:System.String.Concat%2A> method to concatenate three strings and displays the result.</span></span>  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="ada9e-1398">要串連的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1398">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="ada9e-1399">要串連的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1399">The second object to concatenate.</span></span></param>
        <param name="arg2"><span data-ttu-id="ada9e-1400">要串連的第三個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1400">The third object to concatenate.</span></span></param>
        <param name="arg3"><span data-ttu-id="ada9e-1401">要串連的第四個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1401">The fourth object to concatenate.</span></span></param>
        <summary><span data-ttu-id="ada9e-1402">串連四個指定的物件之字串表示和選擇性變數長度參數清單中所指定的任何物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1402">Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1403">參數清單中每個值的已串連字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1403">The concatenated string representation of each value in the parameter list.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-1404">此應用程式開發介面不符合 CLS 標準。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1404">This API is not CLS-compliant.</span></span> <span data-ttu-id="ada9e-1405">符合 CLS 標準的替代項目為 <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1405">The CLS-compliant alternative is <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-1406">C# 和 Visual Basic 編譯器會自動解決呼叫這個方法與呼叫<xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1406">The C# and Visual Basic compilers automatically resolve a call to this method as a call to <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ada9e-1407">方法會在參數清單中的每個物件串連藉由呼叫其無參數`ToString`方法; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1407">The method concatenates each object in the parameter list by calling its parameterless `ToString` method; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ada9e-1408"><xref:System.String.Empty?displayProperty=nameWithType> 用來取代任何 null 引數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1408"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-1409">最後一個參數<xref:System.String.Concat%2A>方法是一或多個串連的其他物件的選擇性逗號分隔清單。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1409">The last parameter of the  <xref:System.String.Concat%2A> method is an optional comma-delimited list of one or more additional objects to concatenate.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1410">下列範例示範如何將<xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法來串連變數參數清單。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1410">The following example illustrates the use of the <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to concatenate a list of variable parameters.</span></span> <span data-ttu-id="ada9e-1411">在此情況下，方法被呼叫九個參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1411">In this case, the method is called with nine parameters.</span></span>  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-1412">這個方法標記著<see langword="vararg" />關鍵字，這表示它支援不同數量的參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1412">This method is marked with the <see langword="vararg" /> keyword, which means that it supports a variable number of parameters.</span></span> <span data-ttu-id="ada9e-1413">可以呼叫方法，從 視覺效果C++，但不能從呼叫C#或 Visual Basic 程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1413">The method can be called from Visual C++, but it cannot be called from C# or Visual Basic code.</span></span> <span data-ttu-id="ada9e-1414">C# 和 Visual Basic 編譯器呼叫解析為<see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />做為呼叫<see cref="M:System.String.Concat(System.Object[])" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1414">The C# and Visual Basic compilers resolve calls to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> as calls to <see cref="M:System.String.Concat(System.Object[])" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <param name="str2">To be added.</param>
        <param name="str3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="ada9e-1415">要串連的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1415">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="ada9e-1416">要串連的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1416">The second string to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="ada9e-1417">要串連的第三個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1417">The third string to concatenate.</span></span></param>
        <param name="str3"><span data-ttu-id="ada9e-1418">要串連的第四個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1418">The fourth string to concatenate.</span></span></param>
        <summary><span data-ttu-id="ada9e-1419">串連 <see cref="T:System.String" /> 的四個指定執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1419">Concatenates four specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1420"><paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" /> 和 <paramref name="str3" /> 的串連。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1420">The concatenation of <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />, and <paramref name="str3" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1421">方法會串連`str0`， `str1`， `str2`，和`str3`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1421">The method concatenates `str0`, `str1`, `str2`, and `str3`; it does not add any delimiters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-1422">您可以也使用您語言的字串串連運算子，例如`+`在 C# 中，或是`&`和`+`在 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-1422">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)</span></span>  
>   
>  <span data-ttu-id="ada9e-1423">來串連字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1423">, to concatenate strings.</span></span>  
  
 <span data-ttu-id="ada9e-1424"><xref:System.String.Empty>字串來取代陣列中的任何 null 物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1424">An <xref:System.String.Empty> string is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1425">下列範例定義四個字母構成的單字的陣列，並將其個別的字母字串陣列來儲存才能弄亂它們。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1425">The following example defines an array of four-letter words and stores their individual letters to a string array in order to scramble them.</span></span> <span data-ttu-id="ada9e-1426">然後它會呼叫<xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29>早先變碼的字組的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1426">It then calls the <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> method to reassemble the scrambled words.</span></span>  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="ada9e-1427"><paramref name="values" /> 之成員的類型。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1427">The type of the members of <paramref name="values" />.</span></span></typeparam>
        <param name="values"><span data-ttu-id="ada9e-1428">集合物件，這個物件實作 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 介面。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1428">A collection object that implements the <see cref="T:System.Collections.Generic.IEnumerable`1" /> interface.</span></span></param>
        <summary><span data-ttu-id="ada9e-1429">串連 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 實作的成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1429">Concatenates the members of an <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementation.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1430"><paramref name="values" /> 中的串連成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1430">The concatenated members in <paramref name="values" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1431">方法會串連每個物件在`values`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1431">The method concatenates each object in `values`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="ada9e-1432"><xref:System.String.Empty>字串來取代任何 null 引數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1432">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
 <span data-ttu-id="ada9e-1433"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 是一種便利方法，可讓您串連每個項目<xref:System.Collections.Generic.IEnumerable%601>而不先將項目轉換成字串的集合。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1433"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each element in an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting the elements to strings.</span></span> <span data-ttu-id="ada9e-1434">如範例所示，它是使用 Language-Integrated Query (LINQ) 查詢運算式，特別有用。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1434">It is particularly useful with Language-Integrated Query (LINQ) query expressions, as the example illustrates.</span></span> <span data-ttu-id="ada9e-1435">在每個物件的字串表示<xref:System.Collections.Generic.IEnumerable%601>集合藉由呼叫該物件衍生`ToString`方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1435">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1436">下列範例會定義一個非常簡單`Animal`類別，其中包含針對 animal 和其所屬的順序的名稱。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1436">The following example defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="ada9e-1437">然後它會定義<xref:System.Collections.Generic.List%601>物件包含的數字`Animal`物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1437">It then defines a <xref:System.Collections.Generic.List%601> object to contain a number of `Animal` objects.</span></span> <span data-ttu-id="ada9e-1438"><xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>會呼叫擴充方法來擷取`Animal`物件，而其`Order`屬性等於"齧齒動物 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1438">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="ada9e-1439">結果會傳遞至<xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法和顯示到主控台。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1439">The result is passed to the <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> method and displayed to the console.</span></span>  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1440"><paramref name="values" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1440"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-1441">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1441">The string to seek.</span></span></param>
        <summary><span data-ttu-id="ada9e-1442">傳回值，這個值表示指定的子字串是否會出現在這個字串內。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1442">Returns a value indicating whether a specified substring occurs within this string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1443">如果 <see langword="true" /> 參數出現在這個字串內，或是 <paramref name="value" /> 為空字串 ("")，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1443"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string, or if <paramref name="value" /> is the empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1444">這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1444">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span> <span data-ttu-id="ada9e-1445">搜尋這個字串的第一個字元位置開始，然後繼續進行到最後一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1445">The search begins at the first character position of this string and continues through the last character position.</span></span>  
  
 <span data-ttu-id="ada9e-1446">若要判斷字串是否包含指定的子字串使用序數比較 （例如，區分文化特性的比較或不區分大小寫的序數比較） 以外的項目，您可以建立自訂的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1446">To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method.</span></span> <span data-ttu-id="ada9e-1447">下列範例說明這類方法之一。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1447">The following example illustrates one such approach.</span></span> <span data-ttu-id="ada9e-1448">它會定義<xref:System.String>擴充方法，其中包含<xref:System.StringComparison>參數，並指出字串是否包含子字串，使用指定的格式的字串比較時。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1448">It defines a <xref:System.String> extension method  that includes a <xref:System.StringComparison> parameter and indicates whether a string contains a substring when using the specified form of string comparison.</span></span>  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 <span data-ttu-id="ada9e-1449">下列範例會接著呼叫`Contains`延伸模組方法，以判斷子字串是否要使用序數比較和區分大小寫的序數比較時的字串中找到。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1449">The following example then calls the `Contains` extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 <span data-ttu-id="ada9e-1450">如果您有興趣的子字串的位置`value`在目前的執行個體，您可以呼叫<xref:System.String.IndexOf%2A>可以呼叫方法來取得其第一個項目，或您的開始位置<xref:System.String.LastIndexOf%2A>方法來取得的起始位置及其上一次。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1450">If you are interested in the position of the substring `value` in the current instance, you can call the <xref:System.String.IndexOf%2A> method to get the starting position of its first occurrence, or you can call the <xref:System.String.LastIndexOf%2A> method to get the starting position of its last occurrence.</span></span> <span data-ttu-id="ada9e-1451">此範例包括呼叫<xref:System.String.IndexOf%28System.String%29>方法如果在字串執行個體中找到的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1451">The example includes a call to the <xref:System.String.IndexOf%28System.String%29> method if a substring is found in a string instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1452">下列範例會判斷熟悉引號的子字串是否包含"fox"的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1452">The following example determines whether the string "fox" is a substring of a familiar quotation.</span></span> <span data-ttu-id="ada9e-1453">如果字串中找到"fox"，它也會顯示其起始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1453">If "fox" is found in the string, it also displays its starting position.</span></span>  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1454"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1454"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="ada9e-1455">要複製的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1455">The string to copy.</span></span></param>
        <summary><span data-ttu-id="ada9e-1456">使用與指定的 <see cref="T:System.String" /> 相同的值，建立 <see cref="T:System.String" /> 的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1456">Creates a new instance of <see cref="T:System.String" /> with the same value as a specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1457">具有與 <paramref name="str" /> 相同值的新字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1457">A new string with the same value as <paramref name="str" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1458"><xref:System.String.Copy%2A>方法會傳回<xref:System.String>原始字串值相同，但代表不同的物件參考的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1458">The <xref:System.String.Copy%2A> method returns a <xref:System.String> object that has the same value as the original string but represents a different object reference.</span></span> <span data-ttu-id="ada9e-1459">不同於指派運算，會將現有的字串參考其他物件變數指派。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1459">It differs from an assignment operation, which assigns an existing string reference to an additional object variable.</span></span> <span data-ttu-id="ada9e-1460">此範例說明的差異。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1460">The example illustrates the difference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1461">下列範例會建立兩個字串物件，使用不同的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1461">The following example creates two string objects with different values.</span></span> <span data-ttu-id="ada9e-1462">當呼叫<xref:System.String.Copy%2A>方法來將第一個值指派給第二個字串，所以輸出指出雖然其值現在是相等的字串，代表不同的物件參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1462">When it calls the <xref:System.String.Copy%2A> method to assign the first value to the second string, the output indicates that the strings represent different object references although their values are now equal.</span></span> <span data-ttu-id="ada9e-1463">相反地，當第一個字串指派給第二個字串時，兩個字串具有相同的值，因為它們代表相同的物件參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1463">On the other hand, when the first string is assigned to the second string, the two strings have identical values because they represent the same object reference.</span></span>  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1464"><paramref name="str" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1464"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex"><span data-ttu-id="ada9e-1465">這個要複製的執行個體中第一個字元的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1465">The index of the first character in this instance to copy.</span></span></param>
        <param name="destination"><span data-ttu-id="ada9e-1466">複製這個執行個體之字元的目標 Unicode 字元陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1466">An array of Unicode characters to which characters in this instance are copied.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="ada9e-1467">在 <paramref name="destination" /> 中開始複製作業的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1467">The index in <paramref name="destination" /> at which the copy operation begins.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-1468">這個執行個體中要複製到 <paramref name="destination" /> 的字元數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1468">The number of characters in this instance to copy to <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-1469">將字元的指定數目從這個執行個體的指定位置，複製到 Unicode 字元陣列的指定位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1469">Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1470">這個方法會複製`count`字元`sourceIndex`位置，這個執行個體`destinationIndex`位置`destination`字元陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1470">This method copies `count` characters from the `sourceIndex` position of this instance to the `destinationIndex` position of `destination` character array.</span></span> <span data-ttu-id="ada9e-1471">這個方法不會不會調整大小`destination`字元陣列; 它必須有足夠數目的項目，以容納複製的字元，或方法會擲回<xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1471">This method does not resize the `destination` character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="ada9e-1472">`sourceIndex` 和`destinationIndex`是以零起始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1472">`sourceIndex` and `destinationIndex` are zero-based.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1473">下列範例示範<xref:System.String.CopyTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1473">The following example demonstrates the <xref:System.String.CopyTo%2A> method.</span></span>  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1474"><paramref name="destination" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1474"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-1475"><paramref name="sourceIndex" />、<paramref name="destinationIndex" /> 或 <paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1475"><paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" /> is negative</span></span> 
<span data-ttu-id="ada9e-1476">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1476">-or-</span></span> 
 <span data-ttu-id="ada9e-1477"><paramref name="sourceIndex" /> 未識別目前執行個體中的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1477"><paramref name="sourceIndex" /> does not identify a position in the current instance.</span></span>  
  
<span data-ttu-id="ada9e-1478">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1478">-or-</span></span> 
 <span data-ttu-id="ada9e-1479"><paramref name="destinationIndex" /> 未識別 <paramref name="destination" /> 陣列中的有效索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1479"><paramref name="destinationIndex" /> does not identify a valid index in the <paramref name="destination" /> array.</span></span>  
  
<span data-ttu-id="ada9e-1480">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1480">-or-</span></span> 
 <span data-ttu-id="ada9e-1481"><paramref name="count" /> 大於從 <paramref name="sourceIndex" /> 到這個執行個體結尾的子字串長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1481"><paramref name="count" /> is greater than the length of the substring from <paramref name="sourceIndex" /> to the end of this instance</span></span> 
<span data-ttu-id="ada9e-1482">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1482">-or-</span></span> 
 <span data-ttu-id="ada9e-1483"><paramref name="count" /> 大於從 <paramref name="destinationIndex" /> 到 <paramref name="destination" /> 陣列結尾的子陣列長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1483"><paramref name="count" /> is greater than the length of the subarray from <paramref name="destinationIndex" /> to the end of the <paramref name="destination" /> array.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ada9e-1484">表示空字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1484">Represents the empty string.</span></span> <span data-ttu-id="ada9e-1485">此欄位為唯讀。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1485">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1486">這個欄位的值是零長度字串，""。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1486">The value of this field is the zero-length string, "".</span></span>  
  
 <span data-ttu-id="ada9e-1487">在應用程式程式碼，這個欄位是最常用於指派中初始化為空字串的字串變數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1487">In application code, this field is most commonly used in assignments to initialize a string variable to an empty string.</span></span> <span data-ttu-id="ada9e-1488">若要測試是否為字串的值是`null`或是<xref:System.String.Empty?displayProperty=nameWithType>，使用<xref:System.String.IsNullOrEmpty%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1488">To test whether the value of a string is either `null` or <xref:System.String.Empty?displayProperty=nameWithType>, use the <xref:System.String.IsNullOrEmpty%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-1489">判斷這個字串執行個體的結尾是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1489">Determines whether the end of this string instance matches a specified string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-1490">要在這個執行個體結束時，與子字串比較的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1490">The string to compare to the substring at the end of this instance.</span></span></param>
        <summary><span data-ttu-id="ada9e-1491">判斷這個字串執行個體的結尾是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1491">Determines whether the end of this string instance matches the specified string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1492">如果 <see langword="true" /> 符合這個執行個體的結尾，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1492"><see langword="true" /> if <paramref name="value" /> matches the end of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1493">這個方法會比較`value`結尾的這個執行個體的長度相同的子字串`value`，並傳回指示它們是否相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1493">This method compares `value` to the substring at the end of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="ada9e-1494">為相等，`value`必須是這個相同的執行個體的參考，或比對這個執行個體的結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1494">To be equal, `value` must be a reference to this same instance or match the end of this instance.</span></span>  
  
 <span data-ttu-id="ada9e-1495">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1495">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1496">下列範例指出陣列中的每個字串是否以句號結尾 ("。")。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1496">The following example indicates whether each string in an array ends with a period (".").</span></span>  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 <span data-ttu-id="ada9e-1497">下列範例會定義`StripEndTags`方法，以使用<xref:System.String.EndsWith%28System.String%29>方法來移除行尾的 HTML 結尾標記。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1497">The following example defines a `StripEndTags` method that uses the <xref:System.String.EndsWith%28System.String%29> method to remove HTML end tags from the end of a line.</span></span> <span data-ttu-id="ada9e-1498">請注意，`StripEndTags`呼叫方法以遞迴方式來確認已移除行結尾的多個 HTML 結尾標記。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1498">Note that the  `StripEndTags` method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.</span></span>  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1499"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1499"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-1500">中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1500">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ada9e-1501">若要判斷字串是否以結束特定的子字串使用目前文化特性的字串比較規則，請呼叫<see cref="M:System.String.EndsWith(System.String,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1501">To determine whether a string ends with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-1502">要在這個執行個體結束時，與子字串比較的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1502">The string to compare to the substring at the end of this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ada9e-1503">列舉值之一，指定這個字串和 <paramref name="value" /> 的比較方式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1503">One of the enumeration values that determines how this string and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="ada9e-1504">判斷當使用指定的比較選項進行比較時，這個字串執行個體的結尾是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1504">Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1505">如果 <see langword="true" /> 參數符合這個字串的結尾，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1505"><see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1506"><xref:System.String.EndsWith%2A>方法會比較`value`在這個字串的結尾的子字串的參數和傳回值，這個值，指出它們是否相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1506">The <xref:System.String.EndsWith%2A> method compares the `value` parameter to the substring at the end of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="ada9e-1507">為相等，`value`必須為這個相同字串的參考，必須是空字串 ("")，或必須符合這個字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1507">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the end of this string.</span></span> <span data-ttu-id="ada9e-1508">所執行的比較的型別<xref:System.String.EndsWith%2A>方法而定的值`comparisonType`參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1508">The type of comparison performed by the <xref:System.String.EndsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1509">下列範例會判斷字串是否以特定的子字串結束。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1509">The following example determines whether a string ends with a particular substring.</span></span> <span data-ttu-id="ada9e-1510">文化特性、 是否忽略大小寫，以及是否執行序數比較的選擇會影響結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1510">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1511"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1511"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-1512"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1512"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-1513">要在這個執行個體結束時，與子字串比較的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1513">The string to compare to the substring at the end of this instance.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ada9e-1514"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1514"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="ada9e-1515">判斷如何比較此執行個體和 <paramref name="value" /> 的文化特性資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1515">Cultural information that determines how this instance and <paramref name="value" /> are compared.</span></span> <span data-ttu-id="ada9e-1516">如果 <paramref name="culture" /> 是 <see langword="null" />，則會使用目前的文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1516">If <paramref name="culture" /> is <see langword="null" />, the current culture is used.</span></span></param>
        <summary><span data-ttu-id="ada9e-1517">判斷當使用指定之文化特性進行比較時，這個字串執行個體的結尾是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1517">Determines whether the end of this string instance matches the specified string when compared using the specified culture.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1518">如果 <see langword="true" /> 參數符合這個字串的結尾，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1518"><see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1519">這個方法會比較`value`參數的長度相同，這個字串結尾的子字串`value`，並傳回值，指出它們是否相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1519">This method compares the `value` parameter to the substring at the end of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="ada9e-1520">為相等，`value`必須是這個相同的執行個體的參考，或符合這個字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1520">To be equal, `value` must be a reference to this same instance or match the end of this string.</span></span>  
  
 <span data-ttu-id="ada9e-1521">這個方法會執行使用指定的大小寫和文化特性的字 （區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1521">This method performs a word (culture-sensitive) comparison using the specified casing and culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1522">下列範例會判斷字串是否發生在另一個字串結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1522">The following example determines whether a string occurs at the end of another string.</span></span> <span data-ttu-id="ada9e-1523"><xref:System.String.EndsWith%2A>方法呼叫數次使用區分大小寫、 不區分大小寫和不同的文化特性會影響搜尋的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1523">The <xref:System.String.EndsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1524"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1524"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-1525">判斷兩個 <see cref="T:System.String" /> 物件是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1525">Determines whether two <see cref="T:System.String" /> objects have the same value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ada9e-1526">要與這個執行個體比較的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1526">The string to compare to this instance.</span></span></param>
        <summary><span data-ttu-id="ada9e-1527">判斷這個執行個體和指定的物件 (同時還必須是 <see cref="T:System.String" /> 物件) 是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1527">Determines whether this instance and a specified object, which must also be a <see cref="T:System.String" /> object, have the same value.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1528">如果 <see langword="true" /> 是 <paramref name="obj" />，且其值與這個執行個體相同，則為 <see cref="T:System.String" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1528"><see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.String" /> and its value is the same as this instance; otherwise, <see langword="false" />.</span></span>  <span data-ttu-id="ada9e-1529">如果 <paramref name="obj" /> 是 <see langword="null" />，則方法會傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1529">If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1530">這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1530">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1531">下列範例示範<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1531">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-1532">要與這個執行個體比較的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1532">The string to compare to this instance.</span></span></param>
        <summary><span data-ttu-id="ada9e-1533">判斷這個執行個體和另一個指定的 <see cref="T:System.String" /> 物件是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1533">Determines whether this instance and another specified <see cref="T:System.String" /> object have the same value.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1534">如果 <see langword="true" /> 參數的值與這個執行個體的值相同，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1534"><see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as the value of this instance; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="ada9e-1535">如果 <paramref name="value" /> 是 <see langword="null" />，則方法會傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1535">If <paramref name="value" /> is <see langword="null" />, the method returns <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1536">這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1536">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1537">下列範例示範<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1537">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span> <span data-ttu-id="ada9e-1538">它會比較標題式大小寫字組"File"對等的 word、 其小寫的對等項目、 其大寫對等項目，和包含 LATIN 小型字母無點 I 字 (U + 0131) 而非拉丁文小型字母 I (u+0069)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1538">It compares the title-cased word "File" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I (U+0131) instead of LATIN SMALL LETTER I (U+0069).</span></span> <span data-ttu-id="ada9e-1539">因為<xref:System.String.Equals%28System.String%29>方法會執行序數比較，傳回相同的字組比較`true`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1539">Because the <xref:System.String.Equals%28System.String%29> method performs an ordinal comparison, only the comparison with an identical word returns `true`.</span></span>  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="ada9e-1540">要比較的第一個字串，或是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1540">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="ada9e-1541">要比較的第二個字串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1541">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-1542">判斷兩個指定的 <see cref="T:System.String" /> 物件是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1542">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1543">如果 <see langword="true" /> 的值與 <paramref name="a" /> 的值相同，則為 <paramref name="b" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1543"><see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="ada9e-1544">如果 <paramref name="a" /> 和 <paramref name="b" /> 都是 <see langword="null" />，則這個方法會傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1544">If both <paramref name="a" /> and <paramref name="b" /> are <see langword="null" />, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1545">這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1545">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1546">下列範例示範<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1546">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-1547">要與這個執行個體比較的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1547">The string to compare to this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ada9e-1548">其中一個列舉值，指定字串的比較方式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1548">One of the enumeration values that specifies how the strings will be compared.</span></span></param>
        <summary><span data-ttu-id="ada9e-1549">判斷這個字串和指定的 <see cref="T:System.String" /> 物件是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1549">Determines whether this string and a specified <see cref="T:System.String" /> object have the same value.</span></span> <span data-ttu-id="ada9e-1550">參數可指定用於比較的文化特性、大小寫及排序規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1550">A parameter specifies the culture, case, and sort rules used in the comparison.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1551">如果 <see langword="true" /> 參數的值與這個字串相同，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1551"><see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1552">`comparisonType`參數會指出是否比較應該使用目前或而異的文化特性，接受或忽略大小寫的兩個字串進行比較，或使用 word 或序數排序規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1552">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1553">下列範例會建立包含以大寫"I"、"i"，以小寫及無點的"ı"的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1553">The following example creates a string array that consists of an uppercase "I", a lowercase "i", and a dotless "ı".</span></span> <span data-ttu-id="ada9e-1554">然後它會呼叫<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>方法來比較它們使用每一個可能的<xref:System.StringComparison>列舉值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1554">It then calls the <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method to compare them by using each possible <xref:System.StringComparison> enumeration value.</span></span>  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 <span data-ttu-id="ada9e-1555">下列範例會比較四字組所使用的每個成員<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1555">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="ada9e-1556">比較使用英文 （美國） 和沙米文 （上方瑞典） 文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1556">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="ada9e-1557">請注意，字串"encyclopædia"和"百科全書"會被視為對等項目在 EN-US 文化特性，但不是在沙米文 （北瑞典） 文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1557">Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-1558"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1558"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="ada9e-1559">要比較的第一個字串，或是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1559">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="ada9e-1560">要比較的第二個字串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1560">The second string to compare, or <see langword="null" />.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ada9e-1561">其中一個列舉值，指定比較的規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1561">One of the enumeration values that specifies the rules for the comparison.</span></span></param>
        <summary><span data-ttu-id="ada9e-1562">判斷兩個指定的 <see cref="T:System.String" /> 物件是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1562">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span></span> <span data-ttu-id="ada9e-1563">參數可指定用於比較的文化特性、大小寫及排序規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1563">A parameter specifies the culture, case, and sort rules used in the comparison.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1564">如果 <see langword="true" /> 參數的值等於 <paramref name="a" /> 參數的值，則為 <paramref name="b" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1564"><see langword="true" /> if the value of the <paramref name="a" /> parameter is equal to the value of the <paramref name="b" /> parameter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1565">`comparisonType`參數會指出是否比較應該使用目前或而異的文化特性，接受或忽略大小寫的兩個字串進行比較，或使用 word 或序數排序規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1565">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1566">下列範例會比較四字組所使用的每個成員<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1566">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="ada9e-1567">比較使用英文 （美國） 和沙米文 （上方瑞典） 文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1567">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="ada9e-1568">請注意，字串"encyclopædia"和"百科全書"會被視為對等項目在 EN-US 文化特性，但不是在沙米文 （北瑞典） 文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1568">Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-1569"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1569"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-1570">根據指定的格式將物件的值轉換為字串，並將它們插入到另一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1570">Converts the value of objects to strings based on the formats specified and inserts them into another string.</span></span>  
  
<span data-ttu-id="ada9e-1571">如果您不熟悉 `String.Format` 方法，請參閱 [String.Format 方法入門](#Starting)一節以取得快速概觀。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1571">If you are new to the `String.Format` method, see the [Get started with the String.Format method](#Starting) section for a quick overview.</span></span>  
  
<span data-ttu-id="ada9e-1572">如需 `String.Format` 方法的一般文件，請參閱[備註](#remarks-top)一節。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1572">See the [Remarks](#remarks-top) section for general documentation for the `String.Format` method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 <span data-ttu-id="ada9e-1573">本節內容：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1573">In this section:</span></span>  
  
 <span data-ttu-id="ada9e-1574">[String.Format 方法入門](#Starting) </span><span class="sxs-lookup"><span data-stu-id="ada9e-1574">[Get started with the String.Format method](#Starting) </span></span>  
 <span data-ttu-id="ada9e-1575">[我呼叫的方法？](#FTaskList) </span><span class="sxs-lookup"><span data-stu-id="ada9e-1575">[Which method do I call?](#FTaskList) </span></span>  
 <span data-ttu-id="ada9e-1576">[Format 方法簡介](#Format_Brief) </span><span class="sxs-lookup"><span data-stu-id="ada9e-1576">[The Format method in brief](#Format_Brief) </span></span>  
 <span data-ttu-id="ada9e-1577">[格式項目](#FormatItem) </span><span class="sxs-lookup"><span data-stu-id="ada9e-1577">[The Format item](#FormatItem) </span></span>  
 <span data-ttu-id="ada9e-1578">[引數格式化的方式](#HowFormatted) </span><span class="sxs-lookup"><span data-stu-id="ada9e-1578">[How arguments are formatted](#HowFormatted) </span></span>  
 <span data-ttu-id="ada9e-1579">[具有相同索引的格式項目](#SameIndex) </span><span class="sxs-lookup"><span data-stu-id="ada9e-1579">[Format items that have the same index](#SameIndex) </span></span>  
 <span data-ttu-id="ada9e-1580">[格式設定和文化特性](#Format_Culture) </span><span class="sxs-lookup"><span data-stu-id="ada9e-1580">[Formatting and culture](#Format_Culture) </span></span>  
 <span data-ttu-id="ada9e-1581">[自訂格式化作業](#Format_Custom) </span><span class="sxs-lookup"><span data-stu-id="ada9e-1581">[Custom formatting operations](#Format_Custom) </span></span>  
 [<span data-ttu-id="ada9e-1582">String.Format Q & A</span><span class="sxs-lookup"><span data-stu-id="ada9e-1582">String.Format Q & A</span></span>](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a><span data-ttu-id="ada9e-1583">String.Format 方法入門</span><span class="sxs-lookup"><span data-stu-id="ada9e-1583">Get started with the String.Format method</span></span>  
 <span data-ttu-id="ada9e-1584">使用<xref:System.String.Format%2A?displayProperty=nameWithType>如果您需要將物件、 變數或運算式的值插入至另一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1584">Use <xref:System.String.Format%2A?displayProperty=nameWithType> if you need to insert the value of an object, variable, or expression into another string.</span></span> <span data-ttu-id="ada9e-1585">例如，您可以在其中插入的值<xref:System.Decimal>為字串，以顯示給使用者以單一字串值：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1585">For example, you can insert the value of a <xref:System.Decimal> value into a string to display it to the user as a single string:</span></span>  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 <span data-ttu-id="ada9e-1586">您可以控制該值格式：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1586">And you can control that value's formatting:</span></span>  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 <span data-ttu-id="ada9e-1587">除了格式設定，您也可以控制對齊及間距。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1587">Besides formatting, you can also control alignment and spacing.</span></span>  
  
 ### <a name="inserting-a-string"></a><span data-ttu-id="ada9e-1588">插入字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1588">Inserting a string</span></span>  

 <span data-ttu-id="ada9e-1589"><xref:System.String.Format%2A?displayProperty=nameWithType> 開始使用的格式字串，後面接著一個或多個物件會轉換為字串，並插入格式字串中的指定位置的運算式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1589"><xref:System.String.Format%2A?displayProperty=nameWithType> starts with a format string, followed by one or more objects or expressions that will be converted to strings and inserted at a specified place in the format string.</span></span> <span data-ttu-id="ada9e-1590">例如：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1590">For example:</span></span>  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 <span data-ttu-id="ada9e-1591">`{0}`格式字串是一個格式項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1591">The `{0}` in the format string is a format item.</span></span> <span data-ttu-id="ada9e-1592">`0` 為其字串值會在該位置插入物件的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1592">`0` is the index of the object whose string value will be inserted at that position.</span></span> <span data-ttu-id="ada9e-1593">（索引從 0 開始。）如果要插入的物件不是字串，其`ToString`呼叫方法，將它轉換成其中一個，再將其插入結果字串中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1593">(Indexes start at 0.) If the object to be inserted is not a string, its `ToString` method is called to convert it to one before inserting it in the result string.</span></span>  
  
 <span data-ttu-id="ada9e-1594">在 [物件] 清單中會使用兩個格式項目和兩個物件的另一個範例如下︰</span><span class="sxs-lookup"><span data-stu-id="ada9e-1594">Here's another example that uses two format items and two objects in the object list:</span></span>  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 <span data-ttu-id="ada9e-1595">您可以有多個格式項目，並想與您的 [物件] 清單中的多個物件，只要每個格式項目的索引物件清單中有相符的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1595">You can have as many format items and as many objects in the object list as you want, as long as the index of every format item has a matching object in the object list.</span></span> <span data-ttu-id="ada9e-1596">您也不需要擔心有關哪個多載您呼叫;編譯器會選取適合您。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1596">You also don't have to worry about which overload you call; the compiler will select the appropriate one for you.</span></span>  
  
 ### <a name="controlling-formatting"></a><span data-ttu-id="ada9e-1597">控制格式</span><span class="sxs-lookup"><span data-stu-id="ada9e-1597">Controlling formatting</span></span>  
 <span data-ttu-id="ada9e-1598">您可以遵循以格式字串來控制如何格式化物件的格式項目中的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1598">You can follow the index in a format item with a format string to control how an object is formatted.</span></span> <span data-ttu-id="ada9e-1599">比方說， `{0:d}` "d"格式字串套用至物件清單中的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1599">For example, `{0:d}` applies the "d" format string to the first object in the object list.</span></span> <span data-ttu-id="ada9e-1600">以下是具有單一物件的範例，以及兩個格式項目：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1600">Here is an example with a single object and two format items:</span></span>  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 <span data-ttu-id="ada9e-1601">幾個型別支援的格式字串，包括所有數字類型 (兩者[標準](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂](~/docs/standard/base-types/custom-numeric-format-strings.md)格式字串)，所有日期和時間 (同時[標準](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自訂](~/docs/standard/base-types/custom-date-and-time-format-strings.md)格式字串) 和時間間隔 (同時[標準](~/docs/standard/base-types/standard-timespan-format-strings.md)並[自訂](~/docs/standard/base-types/custom-timespan-format-strings.md)格式字串)，所有的列舉型別[列舉型別](~/docs/standard/base-types/enumeration-format-strings.md)，並[Guid](https://msdn.microsoft.com/library/97af8hh4.aspx)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1601">A number of types support format strings, including all numeric types (both [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) and [custom](~/docs/standard/base-types/custom-numeric-format-strings.md) format strings), all dates and times (both [standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [custom](~/docs/standard/base-types/custom-date-and-time-format-strings.md) format strings) and time intervals (both [standard](~/docs/standard/base-types/standard-timespan-format-strings.md) and [custom](~/docs/standard/base-types/custom-timespan-format-strings.md) format strings), all enumeration types [enumeration types](~/docs/standard/base-types/enumeration-format-strings.md), and [GUIDs](https://msdn.microsoft.com/library/97af8hh4.aspx).</span></span> <span data-ttu-id="ada9e-1602">您也可以將格式字串的支援加入自己的型別中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1602">You can also add support for format strings to your own types.</span></span>  
  
 ### <a name="controlling-spacing"></a><span data-ttu-id="ada9e-1603">控制間距</span><span class="sxs-lookup"><span data-stu-id="ada9e-1603">Controlling spacing</span></span>  
 <span data-ttu-id="ada9e-1604">您可以定義使用下列語法會插入至結果字串的字串寬度`{0,12}`，其插入 12 個字元的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1604">You can define the width of the string that is inserted into the result string by using syntax such as `{0,12}`, which inserts a 12-character string.</span></span> <span data-ttu-id="ada9e-1605">在此情況下，第一個物件的字串表示是靠右對齊在 12 個字元的欄位。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1605">In this case, the string representation of the first object is right-aligned in the 12-character field.</span></span>  <span data-ttu-id="ada9e-1606">（如果第一個物件的字串表示的長度超過 12 個字元，不過，慣用的欄位寬度會被忽略，和整個字串插入至結果字串。）</span><span class="sxs-lookup"><span data-stu-id="ada9e-1606">(If the string representation of the first object is more than 12 characters in length, though, the preferred field width is ignored, and the entire string is inserted into the result string.)</span></span>  
  
 <span data-ttu-id="ada9e-1607">下列範例定義了 6 個字元的欄位來容納字串 「 年 」 和部份年的字串，以及 15 個字元的欄位來容納字串 「 母體擴展 」 以及一些人口資料。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1607">The following example defines a 6-character field to hold the string "Year" and some year strings, as well as an 15-character field to hold the string "Population" and some population data.</span></span> <span data-ttu-id="ada9e-1608">請注意，字元會靠右對齊欄位中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1608">Note that the characters are right-aligned in the field.</span></span>  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a><span data-ttu-id="ada9e-1609">控制對齊方式</span><span class="sxs-lookup"><span data-stu-id="ada9e-1609">Controlling alignment</span></span>  
 <span data-ttu-id="ada9e-1610">根據預設，字串會靠右對齊其欄位內如果您指定欄位寬度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1610">By default, strings are right-aligned within their field if you specify a field width.</span></span> <span data-ttu-id="ada9e-1611">若要靠左對齊欄位中的字串，您前加上負號，將欄位寬度這類`{0,-12}`定義 12 個字元，靠左對齊的欄位。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1611">To left-align strings in a field, you preface the field width with a negative sign, such as `{0,-12}` to define a 12-character left-aligned field.</span></span>  
  
 <span data-ttu-id="ada9e-1612">下列範例是類似於上一個，不同之處在於它靠左對齊的標籤和資料。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1612">The following example is similar to the previous one, except that it left-aligns both labels and data.</span></span>  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <span data-ttu-id="ada9e-1613"><xref:System.String.Format%2A?displayProperty=nameWithType> 利用複合格式功能。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1613"><xref:System.String.Format%2A?displayProperty=nameWithType> makes use of the composite formatting feature.</span></span> <span data-ttu-id="ada9e-1614">如需詳細資訊，請參閱[複合格式設定](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1614">For more information, see [Composite Formatting](~/docs/standard/base-types/composite-formatting.md).</span></span>  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a><span data-ttu-id="ada9e-1615">我呼叫的方法？</span><span class="sxs-lookup"><span data-stu-id="ada9e-1615">Which method do I call?</span></span>  
  
|<span data-ttu-id="ada9e-1616">以</span><span class="sxs-lookup"><span data-stu-id="ada9e-1616">To</span></span>|<span data-ttu-id="ada9e-1617">Call</span><span class="sxs-lookup"><span data-stu-id="ada9e-1617">Call</span></span>|  
|--------|----------|  
|<span data-ttu-id="ada9e-1618">使用目前的文化特性的慣例格式化一個或多個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1618">Format one or more objects by using the conventions of the current culture.</span></span>|<span data-ttu-id="ada9e-1619">除了包含的多載`provider`參數，其餘<xref:System.String.Format%2A>多載包含<xref:System.String>參數後面接著一或多個物件的參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1619">Except for the overloads that include a `provider` parameter, the remaining <xref:System.String.Format%2A> overloads include a <xref:System.String> parameter followed by one or more object parameters.</span></span> <span data-ttu-id="ada9e-1620">基於這個原因，您不需要判斷哪些<xref:System.String.Format%2A>您想要呼叫的多載。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1620">Because of this, you don't have to determine which <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="ada9e-1621">您的語言編譯器會選取從沒有多載中的適當多載`provider`參數，根據您的引數清單。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1621">Your language compiler selects the appropriate overload from among the overloads that don't have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="ada9e-1622">例如，如果您的引數清單有五個引數，編譯器會呼叫<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1622">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>|  
|<span data-ttu-id="ada9e-1623">使用特定文化特性的慣例格式化一個或多個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1623">Format one or more objects by using the conventions of a specific culture.</span></span>|<span data-ttu-id="ada9e-1624">每個<xref:System.String.Format%2A>開頭的多載`provider`後面接著參數<xref:System.String>參數和一個或多個物件的參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1624">Each <xref:System.String.Format%2A> overload that begins with a `provider` parameter is followed by a <xref:System.String> parameter and one or more object parameters.</span></span> <span data-ttu-id="ada9e-1625">基於這個原因，您不需要判斷哪一項特定<xref:System.String.Format%2A>您想要呼叫的多載。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1625">Because of this, you don't have to determine which specific <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="ada9e-1626">您的語言編譯器會選取具有多載，從適當的多載`provider`參數，根據您的引數清單。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1626">Your language compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="ada9e-1627">例如，如果您的引數清單有五個引數，編譯器會呼叫<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1627">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method.</span></span>|  
|<span data-ttu-id="ada9e-1628">不論是透過執行自訂的格式設定操作<xref:System.ICustomFormatter>實作或<xref:System.IFormattable>實作。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1628">Perform a custom formatting operation either with an <xref:System.ICustomFormatter> implementation or an <xref:System.IFormattable> implementation.</span></span>|<span data-ttu-id="ada9e-1629">任何具有四個多載`provider`參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1629">Any of the four overloads with a `provider` parameter.</span></span> <span data-ttu-id="ada9e-1630">編譯器會選擇適當的多載，從多載`provider`參數，根據您的引數清單。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1630">The compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span>|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a><span data-ttu-id="ada9e-1631">Format 方法簡介</span><span class="sxs-lookup"><span data-stu-id="ada9e-1631">The Format method in brief</span></span> 

 <span data-ttu-id="ada9e-1632">每個多載<xref:System.String.Format%2A>方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)若要包含以零為起始的索引的位置，呼叫*項目的格式*，複合格式字串中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1632">Each overload of the <xref:System.String.Format%2A> method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to include zero-based indexed placeholders, called *format items*, in a composite format string.</span></span> <span data-ttu-id="ada9e-1633">在執行階段，每個格式項目會取代對應的引數在參數清單的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1633">At run time, each format item is replaced with the string representation of the corresponding argument in a parameter list.</span></span> <span data-ttu-id="ada9e-1634">引數的值是否`null`，將格式項目會取代<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1634">If the value of the argument is `null`, the format item is replaced with <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-1635">例如，下列呼叫來<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法包含三個格式項目 中，格式字串{0}， {1}，和{2}，和包含三個項目的引數清單。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1635">For example, the following call to the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method includes a format string with three format items, {0}, {1}, and {2}, and an argument list with three items.</span></span>  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a><span data-ttu-id="ada9e-1636">格式項目</span><span class="sxs-lookup"><span data-stu-id="ada9e-1636">The format item</span></span>  
 <span data-ttu-id="ada9e-1637">格式項目具有此語法：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1637">A format item has this syntax:</span></span>  
  
```  
{index[,alignment][:formatString]}  
```  
 
 <span data-ttu-id="ada9e-1638">方括號表示選擇性的項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1638">Brackets denote optional elements.</span></span> <span data-ttu-id="ada9e-1639">左和右大括號是必要。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1639">The opening and closing braces are required.</span></span> <span data-ttu-id="ada9e-1640">(包含常值的開頭或結尾大括號在格式字串中，請參閱[逸出大括號](~/docs/standard/base-types/composite-formatting.md#escaping-braces)一節[複合格式化](~/docs/standard/base-types/composite-formatting.md)文章。)</span><span class="sxs-lookup"><span data-stu-id="ada9e-1640">(To include a literal opening or closing brace in the format string, see the [Escaping Braces](~/docs/standard/base-types/composite-formatting.md#escaping-braces) section in the [Composite Formatting](~/docs/standard/base-types/composite-formatting.md) article.)</span></span>  
  
 <span data-ttu-id="ada9e-1641">比方說，若要格式化為貨幣值的格式項目可能如下所示：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1641">For example, a format item to format a currency value might appear like this:</span></span>  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 <span data-ttu-id="ada9e-1642">格式項目具有下列項目：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1642">A format item has the following elements:</span></span>  
  
 <span data-ttu-id="ada9e-1643">*index*</span><span class="sxs-lookup"><span data-stu-id="ada9e-1643">*index*</span></span>  
 <span data-ttu-id="ada9e-1644">起始的索引，要為其字串表示的引數包含在字串中的這個位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1644">The zero-based index of the argument whose string representation is to be included at this position in the string.</span></span> <span data-ttu-id="ada9e-1645">如果這個引數是`null`，空字串會包含在字串中的這個位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1645">If this argument is `null`, an empty string will be included at this position in the string.</span></span>  
  
 <span data-ttu-id="ada9e-1646">*alignment*</span><span class="sxs-lookup"><span data-stu-id="ada9e-1646">*alignment*</span></span>  
 <span data-ttu-id="ada9e-1647">選擇性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1647">Optional.</span></span> <span data-ttu-id="ada9e-1648">帶正負號的整數，指出欄位的總長度的引數會插入和它會靠右對齊 （正整數），或靠左對齊 （負整數）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1648">A signed integer that indicates the total length of the field into which the argument is inserted and whether it is right-aligned (a positive integer) or left-aligned (a negative integer).</span></span> <span data-ttu-id="ada9e-1649">如果您省略*對齊*，不含前置或尾端空格的欄位會插入對應的引數的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1649">If you omit *alignment*, the string representation of the corresponding argument is inserted in a field with no leading or trailing spaces.</span></span>  
  
 <span data-ttu-id="ada9e-1650">如果的值*對齊*是要插入的引數的長度小於*對齊*會被忽略，並用引數的字串表示的長度當做欄位寬度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1650">If the value of *alignment* is less than the length of the argument to be inserted, *alignment* is ignored and the length of the string representation of the argument is used as the field width.</span></span>  
  
 <span data-ttu-id="ada9e-1651">*formatString*</span><span class="sxs-lookup"><span data-stu-id="ada9e-1651">*formatString*</span></span>  
 <span data-ttu-id="ada9e-1652">選擇性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1652">Optional.</span></span> <span data-ttu-id="ada9e-1653">字串，指定對應的引數的結果字串的格式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1653">A string that specifies the format of the corresponding argument's result string.</span></span> <span data-ttu-id="ada9e-1654">如果您省略*formatString*，對應的引數的無參數`ToString`呼叫方法來產生它的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1654">If you omit *formatString*, the corresponding argument's parameterless `ToString` method is called to produce its string representation.</span></span> <span data-ttu-id="ada9e-1655">如果您指定*formatString*，將格式項目所參考的引數必須實作<xref:System.IFormattable>介面。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1655">If you specify *formatString*, the argument referenced by the format item must implement the <xref:System.IFormattable> interface.</span></span> <span data-ttu-id="ada9e-1656">支援格式字串的類型包括：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1656">Types that support format strings include:</span></span>  
  
-   <span data-ttu-id="ada9e-1657">所有的整數和浮點數型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1657">All integral and floating-point types.</span></span> <span data-ttu-id="ada9e-1658">(請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。)</span><span class="sxs-lookup"><span data-stu-id="ada9e-1658">(See [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="ada9e-1659"><xref:System.DateTime> 和 <xref:System.DateTimeOffset>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1659"><xref:System.DateTime> and <xref:System.DateTimeOffset>.</span></span> <span data-ttu-id="ada9e-1660">(請參閱[標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。)</span><span class="sxs-lookup"><span data-stu-id="ada9e-1660">(See [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="ada9e-1661">所有列舉類型。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1661">All enumeration types.</span></span> <span data-ttu-id="ada9e-1662">(請參閱[列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。)</span><span class="sxs-lookup"><span data-stu-id="ada9e-1662">(See [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="ada9e-1663"><xref:System.TimeSpan> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1663"><xref:System.TimeSpan> values.</span></span> <span data-ttu-id="ada9e-1664">(請參閱[標準 TimeSpan 格式字串](~/docs/standard/base-types/standard-timespan-format-strings.md)並[自訂 TimeSpan 格式字串](~/docs/standard/base-types/custom-timespan-format-strings.md)。)</span><span class="sxs-lookup"><span data-stu-id="ada9e-1664">(See [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) and [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="ada9e-1665">GUID。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1665">GUIDs.</span></span> <span data-ttu-id="ada9e-1666">(請參閱<xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>方法。)</span><span class="sxs-lookup"><span data-stu-id="ada9e-1666">(See the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> method.)</span></span>  
  
 <span data-ttu-id="ada9e-1667">不過，請注意，可以實作任何自訂的型別<xref:System.IFormattable>擴充現有的類型或<xref:System.IFormattable>實作。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1667">However, note that any custom type can implement <xref:System.IFormattable> or extend an existing type's <xref:System.IFormattable> implementation.</span></span>  
  
 <span data-ttu-id="ada9e-1668">下列範例會使用`alignment`和`formatString`来產生格式化的輸出引數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1668">The following example uses the `alignment` and `formatString` arguments to produce formatted output.</span></span>  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a><span data-ttu-id="ada9e-1669">引數格式化的方式</span><span class="sxs-lookup"><span data-stu-id="ada9e-1669">How arguments are formatted</span></span>  
 <span data-ttu-id="ada9e-1670">格式項目會依序處理，從字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1670">Format items are processed sequentially from the beginning of the string.</span></span> <span data-ttu-id="ada9e-1671">每個格式項目有對應至方法的引數清單中之物件的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1671">Each format item has an index that corresponds to an object in the method's argument list.</span></span> <span data-ttu-id="ada9e-1672"><xref:System.String.Format%2A>方法會擷取引數，並衍生其字串表示，如下所示：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1672">The <xref:System.String.Format%2A> method retrieves the argument and derives its string representation as follows:</span></span>  
  
-   <span data-ttu-id="ada9e-1673">如果引數`null`，此方法會插入<xref:System.String.Empty?displayProperty=nameWithType>至結果字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1673">If the argument is `null`, the method inserts <xref:System.String.Empty?displayProperty=nameWithType> into the result string.</span></span> <span data-ttu-id="ada9e-1674">您不必擔心處理<xref:System.NullReferenceException>null 引數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1674">You don't have to be concerned with handling a <xref:System.NullReferenceException> for null arguments.</span></span> 
  
-   <span data-ttu-id="ada9e-1675">如果您呼叫<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>多載，而`provider`物件的<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>實作會傳回非 null<xref:System.ICustomFormatter>實作中，引數傳遞至其<xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1675">If you call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> overload and the `provider` object's <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementation returns a non-null <xref:System.ICustomFormatter> implementation, the argument is passed to its <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ada9e-1676">如果格式項目包含*formatString*傳遞引數，它是做為第一個引數的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1676">If the format item includes a *formatString* argument, it is passed as the first argument to the method.</span></span> <span data-ttu-id="ada9e-1677">如果<xref:System.ICustomFormatter>實作可用，而且會產生一個非 null 字串，會傳回字串作為引數的字串表示; 否則下一個步驟執行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1677">If the <xref:System.ICustomFormatter> implementation is available and produces a non-null string, that string is returned as the string representation of the argument; otherwise, the next step executes.</span></span>  
  
-   <span data-ttu-id="ada9e-1678">如果引數會實作<xref:System.IFormattable>介面，其<xref:System.IFormattable.ToString%2A?displayProperty=nameWithType>實作稱為。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1678">If the argument implements the <xref:System.IFormattable> interface, its <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation is called.</span></span>  
  
-   <span data-ttu-id="ada9e-1679">引數的無參數`ToString`方法，它會覆寫或繼承自基底類別實作，會呼叫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1679">The argument's parameterless `ToString` method, which either overrides or inherits from a base class implementation, is called.</span></span>  
  
 <span data-ttu-id="ada9e-1680">如需範例，會呼叫攔截<xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>方法，並可讓您查看哪些資訊<xref:System.String.Format%2A>方法傳遞至格式的方法，以便在複合格式字串中，每個格式項目請參閱[範例：截距，提供者和羅馬字母數字格式子](#Format7_Example)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1680">For an example that intercepts calls to the <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> method and allows you to see what information the <xref:System.String.Format%2A> method passes to a formatting method for each format item in a composite format string, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>  

 <span data-ttu-id="ada9e-1681">如需詳細資訊，請參閱 <<c0> [ 處理順序](~/docs/standard/base-types/composite-formatting.md##processing-order)一節[複合格式化](~/docs/standard/base-types/composite-formatting.md)文章。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1681">For more information, see the [Processing Order](~/docs/standard/base-types/composite-formatting.md##processing-order) section in the [Composite Formatting](~/docs/standard/base-types/composite-formatting.md) article.</span></span>  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a><span data-ttu-id="ada9e-1682">具有相同索引的格式項目</span><span class="sxs-lookup"><span data-stu-id="ada9e-1682">Format items that have the same index</span></span>  
 <span data-ttu-id="ada9e-1683"><xref:System.String.Format%2A>方法會擲回<xref:System.FormatException>索引的索引項目是否大於或等於引數清單中的引數的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1683">The <xref:System.String.Format%2A> method throws a <xref:System.FormatException> exception if the index of an index item is greater than or equal to the number of arguments in the argument list.</span></span> <span data-ttu-id="ada9e-1684">不過，`format`可以包含有引數，超過的格式項目，為多個格式項目具有相同的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1684">However, `format` can include more format items than there are arguments, as long as multiple format items have the same index.</span></span> <span data-ttu-id="ada9e-1685">在呼叫<xref:System.String.Format%28System.String%2CSystem.Object%29>在下列範例中，引數清單的方法有單一引數，但在格式字串包含兩個格式項目： 一個會顯示數字的十進位值與另一個則顯示其十六進位值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1685">In the call to the <xref:System.String.Format%28System.String%2CSystem.Object%29> method in following example, the argument list has a single argument, but the format string includes two format items: one displays the decimal value of a number, and the other displays its hexadecimal value.</span></span>  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a><span data-ttu-id="ada9e-1686">格式設定和文化特性</span><span class="sxs-lookup"><span data-stu-id="ada9e-1686">Formatting and culture</span></span>  
 <span data-ttu-id="ada9e-1687">一般而言，引數清單中的物件會轉換成其字串表示法傳回使用目前的文化特性的慣例<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1687">Generally, objects in the argument list are converted to their string representations by using the conventions of the current culture, which is returned by the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ada9e-1688">您可以控制此行為，藉由呼叫其中一個多載<xref:System.String.Format%2A>，其中包含`provider`參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1688">You can control this behavior by calling one of the overloads of <xref:System.String.Format%2A> that includes a `provider` parameter.</span></span> <span data-ttu-id="ada9e-1689">`provider`參數是<xref:System.IFormatProvider>實作，提供自訂和特定文化特性格式資訊用來調節格式處理。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1689">The `provider` parameter is an <xref:System.IFormatProvider> implementation that supplies custom and culture-specific formatting information that is used to moderate the formatting process.</span></span>  
  
 <span data-ttu-id="ada9e-1690"><xref:System.IFormatProvider>介面具有單一成員， <xref:System.IFormatProvider.GetFormat%2A>，它會負責傳回提供格式設定資訊的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1690">The <xref:System.IFormatProvider> interface has a single member, <xref:System.IFormatProvider.GetFormat%2A>, which is responsible for returning the object that provides formatting information.</span></span> <span data-ttu-id="ada9e-1691">.NET 有三個<xref:System.IFormatProvider>實作，以提供特定文化特性：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1691">.NET has three <xref:System.IFormatProvider> implementations that provide culture-specific formatting:</span></span>  
  
-   <span data-ttu-id="ada9e-1692"><xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="ada9e-1692"><xref:System.Globalization.CultureInfo>.</span></span> <span data-ttu-id="ada9e-1693">其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法會傳回特定文化特性<xref:System.Globalization.NumberFormatInfo>格式化數值和特定文化特性的物件<xref:System.Globalization.DateTimeFormatInfo>格式化日期和時間值的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1693">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns a culture-specific <xref:System.Globalization.NumberFormatInfo> object for formatting numeric values and a culture-specific <xref:System.Globalization.DateTimeFormatInfo> object for formatting date and time values.</span></span>  
  
-   <span data-ttu-id="ada9e-1694"><xref:System.Globalization.DateTimeFormatInfo>它用於文化特性專屬格式的日期和時間值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1694"><xref:System.Globalization.DateTimeFormatInfo>, which is used for culture-specific formatting of date and time values.</span></span> <span data-ttu-id="ada9e-1695">其<xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A>方法會傳回本身。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1695">Its <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> method returns itself.</span></span>  
  
-   <span data-ttu-id="ada9e-1696"><xref:System.Globalization.NumberFormatInfo>用於特定文化特性的數值格式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1696"><xref:System.Globalization.NumberFormatInfo>, which is used for culture-specific formatting of numeric values.</span></span> <span data-ttu-id="ada9e-1697">其<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>屬性會傳回本身。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1697">Its <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> property returns itself.</span></span> 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a><span data-ttu-id="ada9e-1698">自訂格式化作業</span><span class="sxs-lookup"><span data-stu-id="ada9e-1698">Custom formatting operations</span></span>  
 <span data-ttu-id="ada9e-1699">您也可以呼叫任何多載<xref:System.String.Format%2A>方法具有`provider`型別的參數<xref:System.IFormatProvider>執行自訂的格式設定作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1699">You can also call the any of the overloads of the <xref:System.String.Format%2A> method that have a `provider` parameter of type <xref:System.IFormatProvider> to perform custom formatting operations.</span></span> <span data-ttu-id="ada9e-1700">比方說，您可以格式化整數作為身分證號碼或電話號碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1700">For example, you could format an integer as an identification number or as a telephone number.</span></span> <span data-ttu-id="ada9e-1701">若要執行自訂的格式，您`provider`引數必須同時實作<xref:System.IFormatProvider>和<xref:System.ICustomFormatter>介面。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1701">To perform custom formatting, your `provider` argument must implement both the <xref:System.IFormatProvider> and <xref:System.ICustomFormatter> interfaces.</span></span> <span data-ttu-id="ada9e-1702">時<xref:System.String.Format%2A>傳遞給方法<xref:System.ICustomFormatter>做為實作`provider`引數，<xref:System.String.Format%2A>方法呼叫其<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>實作，並要求型別的物件<xref:System.ICustomFormatter>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1702">When the <xref:System.String.Format%2A> method is passed an <xref:System.ICustomFormatter> implementation as the `provider` argument, the <xref:System.String.Format%2A> method calls its   <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementation and requests an object of type <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="ada9e-1703">然後它會呼叫傳回<xref:System.ICustomFormatter>物件的<xref:System.ICustomFormatter.Format%2A>方法來格式化複合字串中的每個格式項目傳遞給它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1703">It then calls the returned <xref:System.ICustomFormatter> object's <xref:System.ICustomFormatter.Format%2A> method to format each format item in the composite string passed to it.</span></span>  
  
 <span data-ttu-id="ada9e-1704">如需有關如何提供自訂格式解決方案的詳細資訊，請參閱[How to:定義和使用自訂數值格式提供者](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)和<xref:System.ICustomFormatter>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1704">For more information about providing custom formatting solutions, see [How to: Define and Use Custom Numeric Format Providers](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) and <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="ada9e-1705">如需將整數轉換為格式化的自訂數字的範例，請參閱[範例：自訂的格式設定操作](#Format6_Example)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1705">For an example that converts integers to formatted custom numbers, see [Example: A custom formatting operation](#Format6_Example).</span></span> <span data-ttu-id="ada9e-1706">如需將不帶正負號的位元組轉換成羅馬數字的範例，請參閱[範例：截距，提供者和羅馬字母數字格式子](#Format7_Example)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1706">For an example that converts unsigned bytes to Roman numerals, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>  
  
<a name="Format6_Example"></a>   
### <a name="example-a-custom-formatting-operation"></a><span data-ttu-id="ada9e-1707">範例：自訂格式化作業</span><span class="sxs-lookup"><span data-stu-id="ada9e-1707">Example: A custom formatting operation</span></span>  
 <span data-ttu-id="ada9e-1708">這個範例會定義為以表單為 x-xxxxx-xx 的客戶帳戶編號格式的整數值的格式提供者。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1708">This example defines a format provider that formats an integer value as a customer account number in the form x-xxxxx-xx.</span></span>  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a><span data-ttu-id="ada9e-1709">範例：截距，提供者和羅馬數字格式器</span><span class="sxs-lookup"><span data-stu-id="ada9e-1709">Example: An intercept provider and Roman numeral formatter</span></span>  
 <span data-ttu-id="ada9e-1710">這個範例會定義自訂的格式提供者可實作<xref:System.ICustomFormatter>和<xref:System.IFormatProvider>介面做兩件事：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1710">This example defines a custom format provider that implements the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces to do two things:</span></span>  
  
-   <span data-ttu-id="ada9e-1711">它會顯示參數傳遞至其<xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>實作。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1711">It displays the parameters passed to its <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementation.</span></span> <span data-ttu-id="ada9e-1712">這可讓我們看到哪些參數<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法將傳遞給每個物件，它會嘗試格式化自訂的格式化實作。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1712">This enables us to see what parameters the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is passing to the custom formatting implementation for each object that it tries to format.</span></span> <span data-ttu-id="ada9e-1713">當您偵錯您的應用程式，這非常有用。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1713">This can be useful when you're debugging your application.</span></span>  
  
-   <span data-ttu-id="ada9e-1714">要格式化的物件是否為使用"R"標準格式字串格式化的不帶正負號的位元組值，將自訂格式器會格式化為羅馬字母數字的數字的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1714">If the object to be formatted is an unsigned byte value that is to be formatted by using the "R" standard format string, the custom formatter formats the numeric value as a Roman numeral.</span></span>  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a><span data-ttu-id="ada9e-1715">String.Format 問與答</span><span class="sxs-lookup"><span data-stu-id="ada9e-1715">String.Format Q & A</span></span>  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a><span data-ttu-id="ada9e-1716">為什麼建議字串內插補點透過呼叫`String.Format`方法？</span><span class="sxs-lookup"><span data-stu-id="ada9e-1716">Why do you recommend string interpolation over calls to the `String.Format` method?</span></span>

<span data-ttu-id="ada9e-1717">字串插補是：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1717">String interpolation is:</span></span>

- <span data-ttu-id="ada9e-1718">更有彈性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1718">More flexible.</span></span> <span data-ttu-id="ada9e-1719">它可以是任何字串中不需要使用支援複合格式方法的呼叫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1719">It can be used in any string without requiring a call to a method that supports composite formatting.</span></span> <span data-ttu-id="ada9e-1720">否則，您必須呼叫<xref:System.String.Format%2A>方法或另一個方法，支援複合格式設定，例如<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1720">Otherwise, you have to call the <xref:System.String.Format%2A> method or another method that supports composite formatting, such as <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>.</span></span> 

- <span data-ttu-id="ada9e-1721">更容易閱讀。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1721">More readable.</span></span> <span data-ttu-id="ada9e-1722">因為要插入至字串的運算式會出現在插入運算式中，而不是引數清單中，字串插值是最容易的程式碼和讀取。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1722">Because the expression to insert into a string appears in the interpolated expression rather than in a argument list, interpolated strings are far easier to code and to read.</span></span> <span data-ttu-id="ada9e-1723">因為其更高的可讀性，字串插值可以取代不只呼叫複合格式方法，但它們也可用在字串串連作業以產生更簡潔、 更清楚的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1723">Because of their greater readability, interpolated strings can replace not only calls to composite format methods, but they can also be used in string concatenation operations to produce more concise, clearer code.</span></span> 

<span data-ttu-id="ada9e-1724">下列兩個程式碼範例的比較會說明字串插值的優勢，透過字串串連 」 和 「 複合格式化方法的呼叫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1724">A comparison of the following two code examples illustrates the superiority of interpolated strings over string concatenation and calls to composite formatting methods.</span></span> <span data-ttu-id="ada9e-1725">在下列範例中的多個字串串連作業將會產生詳細資訊] 及 [硬讀取的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1725">The use of multiple string concatenation operations in the following example produces verbose and hard-to-read code.</span></span>

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

<span data-ttu-id="ada9e-1726">相較之下，使用插入字串，在下列範例會產生比字串串連陳述式和呼叫要清楚得多、 更簡潔的程式碼<xref:System.String.Format%2A>在上述範例中的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1726">In contrast, the use of interpolated strings in the following example produce much clearer, more concise code than the string concatenation statement and the call to the <xref:System.String.Format%2A> method in the previous example.</span></span>

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a><span data-ttu-id="ada9e-1727">哪裡可以找到預先定義的格式字串可以搭配格式項目清單？</span><span class="sxs-lookup"><span data-stu-id="ada9e-1727">Where can I find a list of the predefined format strings that can be used with format items?</span></span>  
  
-   <span data-ttu-id="ada9e-1728">對於所有的整數和浮點數類型，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1728">For all integral and floating-point types, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ada9e-1729">日期和時間值，請參閱[標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1729">For date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ada9e-1730">列舉值，請參閱[列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1730">For enumeration values, see [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ada9e-1731">針對<xref:System.TimeSpan>值，請參閱[標準 TimeSpan 格式字串](~/docs/standard/base-types/standard-timespan-format-strings.md)並[自訂 TimeSpan 格式字串](~/docs/standard/base-types/custom-timespan-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1731">For <xref:System.TimeSpan> values, see  [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) and [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ada9e-1732">針對<xref:System.Guid>值，請參閱 < 備註 > 一節<xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>參考頁面。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1732">For <xref:System.Guid> values, see the Remarks section of the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> reference page.</span></span>  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a><span data-ttu-id="ada9e-1733">如何控制結果字串時，將格式項目的對齊方式？</span><span class="sxs-lookup"><span data-stu-id="ada9e-1733">How do I control the alignment of the result strings that replace format items?</span></span>  
 <span data-ttu-id="ada9e-1734">格式項目的一般語法如下：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1734">The general syntax of a format item is:</span></span>  
  
```  
{index[,alignment][: formatString]}  
```  
  
 <span data-ttu-id="ada9e-1735">何處*對齊*是帶正負號的整數，定義欄位寬度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1735">where *alignment* is a signed integer that defines the field width.</span></span> <span data-ttu-id="ada9e-1736">如果此值為負數，欄位中的文字會靠左對齊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1736">If this value is negative, text in the field is left-aligned.</span></span> <span data-ttu-id="ada9e-1737">如果它是正數，則文字會靠右對齊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1737">If it is positive, text is right-aligned.</span></span>  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a><span data-ttu-id="ada9e-1738">如何控制小數分隔符號後的數字數目？</span><span class="sxs-lookup"><span data-stu-id="ada9e-1738">How do I control the number of digits after the decimal separator?</span></span>  
 <span data-ttu-id="ada9e-1739">所有[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)除外 （這會只顯示整數） 的"D"、"G"、"R"和"X"允許的有效位數規範定義結果字串中的小數位數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1739">All [standard numeric format strings](~/docs/standard/base-types/standard-numeric-format-strings.md) except "D" (which is used with integers only), "G", "R", and "X" allow a precision specifier that defines the number of decimal digits in the result string.</span></span> <span data-ttu-id="ada9e-1740">下列範例會使用標準數值格式字串來控制結果字串中的小數位數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1740">The following example uses standard numeric format strings to control the number of decimal digits in the result string.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 <span data-ttu-id="ada9e-1741">如果您使用[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)，使用"0"的格式規範來控制在結果字串中，如下列範例所示的小數位數數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1741">If you're using a [custom numeric format string](~/docs/standard/base-types/custom-numeric-format-strings.md), use the "0" format specifier to control the number of decimal digits in the result string, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a><span data-ttu-id="ada9e-1742">如何控制整數位數數的字？</span><span class="sxs-lookup"><span data-stu-id="ada9e-1742">How do I control the number of integral digits?</span></span>  
 <span data-ttu-id="ada9e-1743">根據預設，格式化作業只會顯示非零的整數位數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1743">By default, formatting operations only display non-zero integral digits.</span></span> <span data-ttu-id="ada9e-1744">如果您要格式化的整數，您可以使用精確度規範"D"和"X"標準格式字串來控制的位數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1744">If you are formatting integers, you can use a precision specifier with the "D" and "X" standard format strings to control the number of digits.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 <span data-ttu-id="ada9e-1745">您可以填補整數或浮點數，加上前置零來使用 「 0 」 產生的結果字串會以指定的數字的整數位數[自訂數值格式規範](~/docs/standard/base-types/custom-numeric-format-strings.md)，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1745">You can pad an integer or floating-point number with leading zeros to produce a result string with a specified number of integral digits by using the "0" [custom numeric format specifier](~/docs/standard/base-types/custom-numeric-format-strings.md), as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a><span data-ttu-id="ada9e-1746">是否可以在 [格式] 清單中包含多少個項目？</span><span class="sxs-lookup"><span data-stu-id="ada9e-1746">How many items can I include in the format list?</span></span>  
 <span data-ttu-id="ada9e-1747">沒有任何實際的限制。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1747">There is no practical limit.</span></span> <span data-ttu-id="ada9e-1748">第二個參數<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法會標記為<xref:System.ParamArrayAttribute>屬性，可讓您包含分隔的清單或物件陣列做為您的格式清單。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1748">The second parameter of the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is tagged with the <xref:System.ParamArrayAttribute> attribute, which allows you to include either a delimited list or an object array as your format list.</span></span>  
  
<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a><span data-ttu-id="ada9e-1749">我該如何包含常值大括號 ("{"和"}") 結果字串中？</span><span class="sxs-lookup"><span data-stu-id="ada9e-1749">How do I include literal braces ("{" and "}") in the result string?</span></span>  
 <span data-ttu-id="ada9e-1750">比方說，如何執行您避免下列方法呼叫擲回<xref:System.FormatException>例外狀況？</span><span class="sxs-lookup"><span data-stu-id="ada9e-1750">For example, how do you prevent the following method call from throwing a <xref:System.FormatException> exception?</span></span>  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 <span data-ttu-id="ada9e-1751">單一的左或右大括號一律會解譯為開頭或結尾的格式項目中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1751">A single opening or closing brace is always interpreted as the beginning or end of a format item.</span></span> <span data-ttu-id="ada9e-1752">若要解譯為常值，則必須逸出。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1752">To be interpreted literally, it must be escaped.</span></span> <span data-ttu-id="ada9e-1753">您新增另一個大括號逸出大括號 ("{{"和"}} 」 而不是"{"和"}")，如下列方法呼叫：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1753">You escape a brace by adding another brace ("{{" and "}}" instead of "{" and "}"), as in the following method call:</span></span>  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 <span data-ttu-id="ada9e-1754">不過，即使逸出大括號會輕易地譯。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1754">However, even escaped braces are easily misinterpreted.</span></span> <span data-ttu-id="ada9e-1755">我們建議您在 [格式] 清單中包含大括號，並使用將其插入在結果字串中，如下列範例所示的格式項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1755">We recommend that you include braces in the format list and use format items to insert them in the result string, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a><span data-ttu-id="ada9e-1756">為什麼我呼叫 String.Format 方法擲回 FormatException？</span><span class="sxs-lookup"><span data-stu-id="ada9e-1756">Why does my call to the String.Format method throw a FormatException?</span></span>  
 <span data-ttu-id="ada9e-1757">最常見的例外狀況的原因是格式項目的索引未對應至 [格式] 清單中的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1757">The most common cause of the exception is that the index of a format item doesn't correspond to an object in the format list.</span></span> <span data-ttu-id="ada9e-1758">通常這表示您已 misnumbered 格式項目的索引，或是您忘記在 [格式] 清單中包含的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1758">Usually this indicates that you've misnumbered the indexes of format items or you've forgotten to include an object in the format list.</span></span> <span data-ttu-id="ada9e-1759">嘗試將包含未逸出的左或右括弧字元也會擲回<xref:System.FormatException>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1759">Attempting to include an unescaped left or right brace character also throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="ada9e-1760">有時候，例外狀況是打錯字; 的結果例如，典型的錯誤是打錯"["（左括號） 而不是"{"（左括號）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1760">Occasionally, the exception is the result of a typo; for example, a typical mistake is to mistype "[" (the left bracket) instead of "{" (the left brace).</span></span>  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a><span data-ttu-id="ada9e-1761">如果 Format(System.IFormatProvider,System.String,System.Object[]) 方法支援參數陣列，為何沒有我的程式碼時擲回例外狀況使用陣列嗎？</span><span class="sxs-lookup"><span data-stu-id="ada9e-1761">If the Format(System.IFormatProvider,System.String,System.Object[]) method supports parameter arrays, why does my code throw an exception when I use an array?</span></span>  
 <span data-ttu-id="ada9e-1762">例如，下列程式碼會擲回<xref:System.FormatException>例外狀況：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1762">For example, the following code throws a <xref:System.FormatException> exception:</span></span>  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 <span data-ttu-id="ada9e-1763">這是編譯器多載解析的問題。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1763">This is a problem of compiler overload resolution.</span></span> <span data-ttu-id="ada9e-1764">因為編譯器無法將整數的陣列轉換成物件陣列，它會將整數陣列視為單一引數，因此它會呼叫<xref:System.String.Format%28System.String%2CSystem.Object%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1764">Because the compiler cannot convert an array of integers to an object array, it treats the integer array as a single argument, so it calls the <xref:System.String.Format%28System.String%2CSystem.Object%29> method.</span></span> <span data-ttu-id="ada9e-1765">因為有四個格式項目，但單一項目格式 清單中的，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1765">The exception is thrown because there are four format items but only a single item in the format list.</span></span>  
  
 <span data-ttu-id="ada9e-1766">由於 Visual Basic 和 C# 都不可以轉換成物件陣列的整數陣列，您必須自行執行轉換，然後再呼叫<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1766">Because neither Visual Basic nor C# can convert an integer array to an object array, you have to perform the conversion yourself before calling the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span> <span data-ttu-id="ada9e-1767">下列範例提供一個實作。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1767">The following example provides one implementation.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

<span data-ttu-id="ada9e-1768">呼叫的數個範例<xref:System.String.Format%2A>方法透過相互穿插[備註](#remarks)一節。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1768">Numerous examples that call the <xref:System.String.Format%2A> method are interspersed through the [Remarks](#remarks) section of this article.</span></span>  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

<span data-ttu-id="ada9e-1769">您也可以下載一組完整的`String.Format`範例中，也就是包含[適用於 C# 的.NET Core 2.0 專案](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip)並[適用於 Visual Basic.NET Core 2.0 專案](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip)，從[dotnet /範例 GitHub 儲存機制](https://github.com/dotnet/samples)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1769">You can also download a complete set of `String.Format` examples, which are included a [.NET Core 2.0 project for C#](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) and a [.NET Core 2.0 project for Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), from the [dotnet/samples GitHub repository](https://github.com/dotnet/samples).</span></span>

<span data-ttu-id="ada9e-1770">以下是一些文章中隨附的範例：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1770">The following are some of the examples included in the article:</span></span>

### <a name="create-a-format-string"></a><span data-ttu-id="ada9e-1771">建立格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1771">Create a format string</span></span>

[<span data-ttu-id="ada9e-1772">插入字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1772">Inserting a string</span></span>](#inserting-a-string)  
[<span data-ttu-id="ada9e-1773">格式項目</span><span class="sxs-lookup"><span data-stu-id="ada9e-1773">The format item</span></span>](#the-format-item)  
[<span data-ttu-id="ada9e-1774">具有相同索引的格式項目</span><span class="sxs-lookup"><span data-stu-id="ada9e-1774">Format items that have the same index</span></span>](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a><span data-ttu-id="ada9e-1775">控制格式化的輸出</span><span class="sxs-lookup"><span data-stu-id="ada9e-1775">Control formatted output</span></span>

[<span data-ttu-id="ada9e-1776">控制格式</span><span class="sxs-lookup"><span data-stu-id="ada9e-1776">Controlling formatting</span></span>](#controlling-formatting)  
[<span data-ttu-id="ada9e-1777">控制間距</span><span class="sxs-lookup"><span data-stu-id="ada9e-1777">Controlling spacing</span></span>](#controlling-spacing)  
[<span data-ttu-id="ada9e-1778">控制對齊方式</span><span class="sxs-lookup"><span data-stu-id="ada9e-1778">Controlling alignment</span></span>](#controlling-alignment)  
[<span data-ttu-id="ada9e-1779">控制數目的整數位數</span><span class="sxs-lookup"><span data-stu-id="ada9e-1779">Controlling the number of integral digits</span></span>](#how-do-i-control-the-number-of-integral-digits)  
[<span data-ttu-id="ada9e-1780">控制的位數，小數分隔符號之後的</span><span class="sxs-lookup"><span data-stu-id="ada9e-1780">Controlling the number of digits after the decimal separator</span></span>](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[<span data-ttu-id="ada9e-1781">在結果字串中包括常值大括號</span><span class="sxs-lookup"><span data-stu-id="ada9e-1781">Including literal braces in a result string</span></span>](#braces)  

### <a name="make-format-strings-culture-sensitive"></a><span data-ttu-id="ada9e-1782">進行區分文化特性的格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1782">Make format strings culture-sensitive</span></span>

[<span data-ttu-id="ada9e-1783">區分文化特性格式</span><span class="sxs-lookup"><span data-stu-id="ada9e-1783">Culture-sensitive formatting</span></span>](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a><span data-ttu-id="ada9e-1784">自訂格式化作業</span><span class="sxs-lookup"><span data-stu-id="ada9e-1784">Customize the formatting operation</span></span>

[<span data-ttu-id="ada9e-1785">自訂格式化作業</span><span class="sxs-lookup"><span data-stu-id="ada9e-1785">A custom formatting operation</span></span>](#example-a-custom-formatting-operation)  
[<span data-ttu-id="ada9e-1786">截距，提供者和羅馬數字格式器</span><span class="sxs-lookup"><span data-stu-id="ada9e-1786">An intercept provider and Roman numeral formatter</span></span>](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ada9e-1787">在 .NET 中將類型格式化</span><span class="sxs-lookup"><span data-stu-id="ada9e-1787">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="ada9e-1788">複合格式</span><span class="sxs-lookup"><span data-stu-id="ada9e-1788">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="ada9e-1789">標準日期和時間格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1789">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="ada9e-1790">自訂日期和時間格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1790">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="ada9e-1791">標準數值格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1791">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="ada9e-1792">自訂數值格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1792">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="ada9e-1793">標準 TimeSpan 格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1793">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="ada9e-1794">自訂 TimeSpan 格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1794">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="ada9e-1795">列舉格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1795">Enumeration Format Strings</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ada9e-1796">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1796">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ada9e-1797">要格式化的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1797">The object to format.</span></span></param>
        <summary><span data-ttu-id="ada9e-1798">以指定物件的字串表示，取代字串中的一或多個格式項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1798">Replaces one or more format items in a string with the string representation of a specified object.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1799"><paramref name="format" /> 的複本，其中的所有格式項目已由 <paramref name="arg0" /> 的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1799">A copy of <paramref name="format" /> in which any format items are replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ada9e-1800">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將運算式的值轉換為其字串表示，並在字串中內嵌該表示法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1800">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a><span data-ttu-id="ada9e-1801">範例：格式化的單一引數</span><span class="sxs-lookup"><span data-stu-id="ada9e-1801">Example: Formatting a single argument</span></span>  
 
 <span data-ttu-id="ada9e-1802">下列範例會使用<xref:System.String.Format%28System.String%2CSystem.Object%29>內嵌在字串當中的個人的年齡的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1802">The following example uses the <xref:System.String.Format%28System.String%2CSystem.Object%29> method to embed an individual's age in the middle of a string.</span></span>  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1803"><paramref name="format" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1803"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-1804"><paramref name="format" /> 中的格式項目無效。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1804">The format item in <paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ada9e-1805">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1805">-or-</span></span> 
<span data-ttu-id="ada9e-1806">格式項目的索引不是零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1806">The index of a format item is not zero.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ada9e-1807">在 .NET 中將類型格式化</span><span class="sxs-lookup"><span data-stu-id="ada9e-1807">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="ada9e-1808">複合格式</span><span class="sxs-lookup"><span data-stu-id="ada9e-1808">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="ada9e-1809">標準日期和時間格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1809">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="ada9e-1810">自訂日期和時間格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1810">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="ada9e-1811">標準數值格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1811">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="ada9e-1812">自訂數值格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1812">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="ada9e-1813">標準 TimeSpan 格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1813">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="ada9e-1814">自訂 TimeSpan 格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1814">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="ada9e-1815">列舉格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1815">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ada9e-1816">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1816">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="args"><span data-ttu-id="ada9e-1817">物件陣列，包含零或多個要格式化的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1817">An object array that contains zero or more objects to format.</span></span></param>
        <summary><span data-ttu-id="ada9e-1818">以指定陣列中對應物件的字串表示，取代指定之字串中的格式項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1818">Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1819"><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="args" /> 中對應物件的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1819">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ada9e-1820">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)四個或多個運算式的值轉換成其字串表示法，並內嵌在字串中的那些表示法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1820">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="ada9e-1821">由於`args`參數會標示<xref:System.ParamArrayAttribute?displayProperty=nameWithType>屬性，您可以將物件傳遞至方法做為個別引數，或為<xref:System.Object>陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1821">Since the `args` parameter is marked with the <xref:System.ParamArrayAttribute?displayProperty=nameWithType> attribute, you can pass the objects to the method as individual arguments or as an <xref:System.Object> array.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a><span data-ttu-id="ada9e-1822">範例：設定格式化的三個以上的引數</span><span class="sxs-lookup"><span data-stu-id="ada9e-1822">Example: Formatting more than three arguments</span></span>  
 
 <span data-ttu-id="ada9e-1823">這個範例會建立包含在特定日期的高低溫度資料的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1823">This example creates a string that contains data on the high and low temperature on a particular date.</span></span> <span data-ttu-id="ada9e-1824">複合格式字串有五個格式項目，在 C# 範例和六個 in Visual Basic 範例。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1824">The composite format string has five format items in the C# example and six in the Visual Basic example.</span></span> <span data-ttu-id="ada9e-1825">兩個格式項目定義及其對應值的字串表示法，寬度，而且第一個格式項目，也包含的標準日期和時間格式字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1825">Two of the format items define the width of their corresponding value's string representation, and the first format item also includes a standard date and time format string.</span></span>  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 <span data-ttu-id="ada9e-1826">您也可以傳遞要格式化為陣列，而不是做為引數清單的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1826">You can also pass the objects to be formatted as an array rather than as an argument list.</span></span>  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1827"><paramref name="format" /> 或 <paramref name="args" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1827"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-1828"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1828"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ada9e-1829">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1829">-or-</span></span> 
<span data-ttu-id="ada9e-1830">格式項目的索引小於零，或大於等於 <paramref name="args" /> 陣列的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1830">The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ada9e-1831">在 .NET 中將類型格式化</span><span class="sxs-lookup"><span data-stu-id="ada9e-1831">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="ada9e-1832">複合格式</span><span class="sxs-lookup"><span data-stu-id="ada9e-1832">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="ada9e-1833">標準日期和時間格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1833">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="ada9e-1834">自訂日期和時間格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1834">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="ada9e-1835">標準數值格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1835">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="ada9e-1836">自訂數值格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1836">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="ada9e-1837">標準 TimeSpan 格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1837">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="ada9e-1838">自訂 TimeSpan 格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1838">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="ada9e-1839">列舉格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1839">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-1840">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1840">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="ada9e-1841">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1841">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ada9e-1842">要格式化的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1842">The object to format.</span></span></param>
        <summary><span data-ttu-id="ada9e-1843">以對應物件的字串表示，取代指定之字串中的一或多個格式項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1843">Replaces the format item or items in a specified string with the string representation of the corresponding object.</span></span> <span data-ttu-id="ada9e-1844">參數提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1844">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1845"><paramref name="format" /> 的複本，其中的一或多個格式項目已由 <paramref name="arg0" /> 的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1845">A copy of <paramref name="format" /> in which the format item or items have been replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ada9e-1846">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將運算式的值轉換為其字串表示，並在字串中內嵌該表示法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1846">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span> <span data-ttu-id="ada9e-1847">在執行轉換，該方法會使用區分文化特性格式，或自訂格式器。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1847">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="ada9e-1848">方法會將轉換`arg0`為其字串表示，藉由呼叫其**ToString(IFormatProvider)** 方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其**ToString (String，IFormatProvider）** 方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1848">The method converts `arg0` to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="ada9e-1849">如果這些方法不存在，則會呼叫物件的無參數**ToString**方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1849">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1850"><paramref name="format" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1850"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-1851"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1851"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ada9e-1852">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1852">-or-</span></span> 
<span data-ttu-id="ada9e-1853">格式項目的索引不是零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1853">The index of a format item is not zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-1854">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1854">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="ada9e-1855">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1855">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="args"><span data-ttu-id="ada9e-1856">物件陣列，包含零或多個要格式化的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1856">An object array that contains zero or more objects to format.</span></span></param>
        <summary><span data-ttu-id="ada9e-1857">以指定陣列中對應物件的字串表示，取代字串中的格式項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1857">Replaces the format items in a string with the string representations of corresponding objects in a specified array.</span></span> <span data-ttu-id="ada9e-1858">參數提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1858">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1859"><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="args" /> 中對應物件的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1859">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ada9e-1860">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將四個或多個運算式轉換成其字串表示法，並內嵌在字串中的那些表示法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1860">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="ada9e-1861">在執行轉換，該方法會使用區分文化特性格式，或自訂格式器。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1861">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="ada9e-1862">方法會將每個<xref:System.Object>引數為其字串表示，藉由呼叫其**ToString(IFormatProvider)** 方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其**ToString(String,IFormatProvider)** 方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1862">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="ada9e-1863">如果這些方法不存在，則會呼叫物件的無參數**ToString**方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1863">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a><span data-ttu-id="ada9e-1864">範例：區分文化特性格式</span><span class="sxs-lookup"><span data-stu-id="ada9e-1864">Example: Culture-sensitive formatting</span></span>  
 <span data-ttu-id="ada9e-1865">這個範例會使用<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法，以使用數個不同的文化特性顯示一些日期和時間值和數字值的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1865">This example uses the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method to display the string representation of some date and time values and numeric values by using several different cultures.</span></span>  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1866"><paramref name="format" /> 或 <paramref name="args" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1866"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-1867"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1867"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ada9e-1868">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1868">-or-</span></span> 
<span data-ttu-id="ada9e-1869">格式項目的索引小於零，或大於等於 <paramref name="args" /> 陣列的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1869">The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ada9e-1870">在 .NET 中將類型格式化</span><span class="sxs-lookup"><span data-stu-id="ada9e-1870">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="ada9e-1871">複合格式</span><span class="sxs-lookup"><span data-stu-id="ada9e-1871">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="ada9e-1872">標準日期和時間格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1872">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="ada9e-1873">自訂日期和時間格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1873">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="ada9e-1874">標準數值格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1874">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="ada9e-1875">自訂數值格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1875">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="ada9e-1876">標準 TimeSpan 格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1876">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="ada9e-1877">自訂 TimeSpan 格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1877">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="ada9e-1878">列舉格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1878">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ada9e-1879">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1879">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ada9e-1880">要格式化的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1880">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="ada9e-1881">要格式化的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1881">The second object to format.</span></span></param>
        <summary><span data-ttu-id="ada9e-1882">以兩個指定物件的字串表示，取代字串中的格式項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1882">Replaces the format items in a string with the string representation of two specified objects.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1883"><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="arg0" /> 和 <paramref name="arg1" /> 的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1883">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ada9e-1884">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將兩個運算式的值轉換成其字串表示法，並內嵌在字串中的那些表示法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1884">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of two expressions to their string representations and to embed those representations in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a><span data-ttu-id="ada9e-1885">範例：格式化的兩個引數</span><span class="sxs-lookup"><span data-stu-id="ada9e-1885">Example: Formatting two arguments</span></span>  
 
 <span data-ttu-id="ada9e-1886">這個範例會使用<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29>方法，以顯示儲存在一般時間和溫度資料<xref:System.Collections.Generic.Dictionary%602>物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1886">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> method to display time and temperature data stored in a generic <xref:System.Collections.Generic.Dictionary%602> object.</span></span> <span data-ttu-id="ada9e-1887">請注意，格式字串會有三個格式項目，雖然只有兩個要格式化的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1887">Note that the format string has three format items, although there are only two objects to format.</span></span> <span data-ttu-id="ada9e-1888">這是因為在清單中 （日期和時間值） 的第一個物件由兩個格式項目：第一個格式項目會顯示第二個情況下，就會顯示日期。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1888">This is because the first object in the list (a date and time value) is used by two format items: The first format item displays the time, and the second displays the date.</span></span>  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1889"><paramref name="format" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1889"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-1890"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1890"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ada9e-1891">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1891">-or-</span></span> 
<span data-ttu-id="ada9e-1892">格式項目的索引不是零或一。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1892">The index of a format item is not zero or one.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ada9e-1893">在 .NET 中將類型格式化</span><span class="sxs-lookup"><span data-stu-id="ada9e-1893">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="ada9e-1894">複合格式</span><span class="sxs-lookup"><span data-stu-id="ada9e-1894">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="ada9e-1895">標準日期和時間格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1895">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="ada9e-1896">自訂日期和時間格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1896">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="ada9e-1897">標準數值格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1897">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="ada9e-1898">自訂數值格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1898">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="ada9e-1899">標準 TimeSpan 格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1899">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="ada9e-1900">自訂 TimeSpan 格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1900">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="ada9e-1901">列舉格式字串</span><span class="sxs-lookup"><span data-stu-id="ada9e-1901">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-1902">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1902">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="ada9e-1903">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1903">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ada9e-1904">要格式化的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1904">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="ada9e-1905">要格式化的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1905">The second object to format.</span></span></param>
        <summary><span data-ttu-id="ada9e-1906">以兩個指定物件的字串表示，取代字串中的格式項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1906">Replaces the format items in a string with the string representation of two specified objects.</span></span> <span data-ttu-id="ada9e-1907">參數提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1907">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1908"><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="arg0" /> 和 <paramref name="arg1" /> 的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1908">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ada9e-1909">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將兩個運算式轉換成其字串表示法，並內嵌在字串中的那些表示法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1909">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert two expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="ada9e-1910">在執行轉換，該方法會使用區分文化特性格式，或自訂格式器。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1910">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="ada9e-1911">方法會將每個<xref:System.Object>引數為其字串表示，藉由呼叫其**ToString(IFormatProvider)** 方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其**ToString(String,IFormatProvider)** 方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1911">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="ada9e-1912">如果這些方法不存在，則會呼叫物件的無參數**ToString**方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1912">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1913"><paramref name="format" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1913"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-1914"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1914"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ada9e-1915">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1915">-or-</span></span> 
<span data-ttu-id="ada9e-1916">格式項目的索引不是零或一。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1916">The index of a format item is not zero or one.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ada9e-1917">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1917">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ada9e-1918">要格式化的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1918">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="ada9e-1919">要格式化的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1919">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="ada9e-1920">要格式化的第三個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1920">The third object to format.</span></span></param>
        <summary><span data-ttu-id="ada9e-1921">以三個指定物件的字串表示，取代字串中的格式項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1921">Replaces the format items in a string with the string representation of three specified objects.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1922"><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1922">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ada9e-1923">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)三個運算式的值轉換成其字串表示法，並內嵌在字串中的那些表示法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1923">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of three expressions to their string representations and to embed those representations in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a><span data-ttu-id="ada9e-1924">範例：格式的三個引數</span><span class="sxs-lookup"><span data-stu-id="ada9e-1924">Example: Formatting three arguments</span></span>  
 
 <span data-ttu-id="ada9e-1925">這個範例會使用<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法來建立說明的布林值結果字串`And`與兩個整數值的作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1925">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to create a string that illustrates the result of a Boolean `And` operation with two integer values.</span></span> <span data-ttu-id="ada9e-1926">請注意，格式字串包含六個格式項目，但方法具有三個項目在其參數清單中，因為每個項目兩種不同方式格式化。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1926">Note that the format string includes six format items, but the method has only three items in its parameter list, because each item is formatted in two different ways.</span></span>  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1927"><paramref name="format" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1927"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-1928"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1928"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ada9e-1929">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1929">-or-</span></span> 
<span data-ttu-id="ada9e-1930">格式項目的索引小於零或大於二。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1930">The index of a format item is less than zero, or greater than two.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="ada9e-1931">在 .NET 中將類型格式化</span><span class="sxs-lookup"><span data-stu-id="ada9e-1931">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="ada9e-1932">複合格式</span><span class="sxs-lookup"><span data-stu-id="ada9e-1932">Composite Formatting</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-1933">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1933">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="ada9e-1934">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1934">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="ada9e-1935">要格式化的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1935">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="ada9e-1936">要格式化的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1936">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="ada9e-1937">要格式化的第三個物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1937">The third object to format.</span></span></param>
        <summary><span data-ttu-id="ada9e-1938">以三個指定物件的字串表示，取代字串中的格式項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1938">Replaces the format items in a string with the string representation of three specified objects.</span></span> <span data-ttu-id="ada9e-1939">參數提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1939">An parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1940"><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1940">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="ada9e-1941">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將三個運算式轉換成其字串表示法，並內嵌在字串中的那些表示法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1941">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert three expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="ada9e-1942">在執行轉換，該方法會使用區分文化特性格式，或自訂格式器。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1942">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="ada9e-1943">方法會將每個<xref:System.Object>引數為其字串表示，藉由呼叫其**ToString(IFormatProvider)** 方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其**ToString(String,IFormatProvider)** 方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1943">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="ada9e-1944">如果這些方法不存在，則會呼叫物件的無參數**ToString**方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1944">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-1945"><paramref name="format" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1945"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-1946"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1946"><paramref name="format" /> is invalid.</span></span>  
  
<span data-ttu-id="ada9e-1947">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-1947">-or-</span></span> 
<span data-ttu-id="ada9e-1948">格式項目的索引小於零或大於二。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1948">The index of a format item is less than zero, or greater than two.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-1949">擷取可以逐一查看這個字串中個別字元的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1949">Retrieves an object that can iterate through the individual characters in this string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1950">列舉程式物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1950">An enumerator object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> <span data-ttu-id="ada9e-1951">而不是呼叫<xref:System.String.GetEnumerator%2A>方法來擷取<xref:System.CharEnumerator>物件，然後使用列舉字串，您應該改為使用您語言的反覆項目建構 (在C#中C++/CLR，並在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1951">Rather than calling the <xref:System.String.GetEnumerator%2A> method to retrieve a <xref:System.CharEnumerator> object that you then use to enumerate a string, you should instead use your language's iteration construct (in C#, in C++/CLR, and in Visual Basic).</span></span> <span data-ttu-id="ada9e-1952">[foreach](~/docs/csharp/language-reference/keywords/foreach-in.md)在 C# 中，[每個](/cpp/dotnet/for-each-in)C + /cli CLR，和[每個](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1952">[foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in C#, [for each](/cpp/dotnet/for-each-in) in C++/CLR, and [For Each](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) in Visual Basic).</span></span>
  
 <span data-ttu-id="ada9e-1953">這個方法可讓您逐一查看字串中的個別字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1953">This method enables you to iterate the individual characters in a string.</span></span> <span data-ttu-id="ada9e-1954">例如，Visual Basic`For Each`和 C#`foreach`陳述式會叫用此方法以傳回<xref:System.CharEnumerator>可唯讀存取這個字串執行個體中的字元的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1954">For example, the Visual Basic `For Each` and C# `foreach` statements invoke this method to return a <xref:System.CharEnumerator> object that can provide read-only access to the characters in this string instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1955">下列範例會逐一查看數個字串中的字元，並顯示其個別字元的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1955">The following example iterates the characters in several strings and displays information about their individual characters.</span></span> <span data-ttu-id="ada9e-1956">它會使用語言的反覆項目建構，而不是呼叫<xref:System.String.GetEnumerator%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1956">It uses the language iteration construct rather than a call to the <xref:System.String.GetEnumerator%2A> method.</span></span>  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-1957">傳回這個字串的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1957">Returns the hash code for this string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1958">32 位元帶正負號的整數雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1958">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-1959">行為<xref:System.String.GetHashCode%2A>取決於它的實作，可能會變更到另一個版本的 common language runtime。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1959">The behavior of <xref:System.String.GetHashCode%2A> is dependent on its implementation, which might change from one version of the common language runtime to another.</span></span> <span data-ttu-id="ada9e-1960">這種情形的原因是要提升的效能<xref:System.String.GetHashCode%2A>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1960">A reason why this might happen is to improve the performance of <xref:System.String.GetHashCode%2A>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ada9e-1961">如果兩個字串物件是否相等，<xref:System.String.GetHashCode%2A>方法會傳回相同的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1961">If two string objects are equal, the <xref:System.String.GetHashCode%2A> method returns identical values.</span></span> <span data-ttu-id="ada9e-1962">不過，沒有每個唯一的字串值的唯一雜湊程式碼值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1962">However, there is not a unique hash code value for each unique string value.</span></span> <span data-ttu-id="ada9e-1963">不同的字串可能會傳回相同的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1963">Different strings can return the same hash code.</span></span>  
>   
>  <span data-ttu-id="ada9e-1964">不保證雜湊程式碼本身是穩定的。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1964">The hash code itself is not guaranteed to be stable.</span></span> <span data-ttu-id="ada9e-1965">跨.NET 實作、 跨.NET 版本和跨.NET 平台 （例如 32 位元和 64 位元） 的單一.NET 版本，可以不同於相同字串的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1965">Hash codes for identical strings can differ across .NET implementations, across .NET versions, and across .NET platforms (such as 32-bit and 64-bit) for a single version of .NET.</span></span> <span data-ttu-id="ada9e-1966">在某些情況下，它們甚至可以與應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1966">In some cases, they can even differ by application domain.</span></span> <span data-ttu-id="ada9e-1967">這表示兩個後續執行相同的程式可能會傳回不同的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1967">This implies that two subsequent runs of the same program may return different hash codes.</span></span>  
>   
>  <span data-ttu-id="ada9e-1968">如此一來，雜湊程式碼應該永遠不會使用外部應用程式定義域中他們所建立，它們應該永遠不會當做索引鍵的欄位，在集合中，使用，以及它們應該永遠不會保存。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1968">As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.</span></span>  
>   
>  <span data-ttu-id="ada9e-1969">最後，不使用的雜湊程式碼而不是在您需要強式密碼編譯雜湊時密碼編譯雜湊函式所傳回的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1969">Finally, don't use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="ada9e-1970">密碼編譯雜湊，使用一個衍生自類別<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>或<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>類別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1970">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
>   
>  <span data-ttu-id="ada9e-1971">如需有關雜湊碼的詳細資訊，請參閱<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1971">For more information about hash codes, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ada9e-1972">在桌面應用程式，您可以使用[ \<UseRandomizedStringHashAlgorithm > 項目](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)來產生唯一的雜湊程式碼在每個應用程式定義域為基準。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1972">In desktop apps, you can use the [\<UseRandomizedStringHashAlgorithm> element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) to generate unique hash codes on a per application domain basis.</span></span> <span data-ttu-id="ada9e-1973">這可減少衝突的數目，並改善整體效能的插入和使用雜湊表的查詢。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1973">This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</span></span> <span data-ttu-id="ada9e-1974">下列範例示範如何使用[ \<UseRandomizedStringHashAlgorithm > 項目](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1974">The following example shows how to use the [\<UseRandomizedStringHashAlgorithm> element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span> <span data-ttu-id="ada9e-1975">它會定義`DisplayString`類別，其中包含私用的字串常數， `s`，其值為"This is 字串"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1975">It defines a `DisplayString` class that includes a private string constant, `s`, whose value is "This is a string."</span></span> <span data-ttu-id="ada9e-1976">它也包含 `ShowStringHashCode` 方法，這個方法會將字串值及其雜湊碼與方法執行所在之應用程式定義域的名稱一起顯示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1976">It also includes a `ShowStringHashCode` method that displays the string value and its hash code along with the name of the application domain in which the method is executing.</span></span>
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 <span data-ttu-id="ada9e-1977">當您在沒有提供組態檔的情況下執行此範例，它會顯示類似下列的輸出。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1977">When you run the example without supplying a configuration file, it displays output similar to the following.</span></span> <span data-ttu-id="ada9e-1978">請注意，字串的雜湊碼在兩個應用程式定義域中相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1978">Note that the hash codes for the string are identical in the two application domains.</span></span>  
  
```
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC
```  
  
 <span data-ttu-id="ada9e-1979">不過，如果您將下列組態檔加入至範例的目錄，然後執行這個範例，相同字串的雜湊碼將會因為應用程式定義域不同而有所不同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1979">However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.</span></span>  
  
```xml
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>
```  
  
 <span data-ttu-id="ada9e-1980">當組態檔存在時，這個範例會顯示下列輸出：</span><span class="sxs-lookup"><span data-stu-id="ada9e-1980">When the configuration file is present, the example displays the following output:</span></span>  
  
```  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D
String 'This is a string.' in domain 'NewDomain': 75CC8236
```  
  
> [!IMPORTANT]
>  <span data-ttu-id="ada9e-1981">雜湊程式碼用來插入並有效率地擷取雜湊資料表的索引鍵的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1981">Hash codes are used to insert and retrieve keyed objects from hash tables efficiently.</span></span> <span data-ttu-id="ada9e-1982">不過，雜湊程式碼沒有可唯一識別字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1982">However, hash codes don't uniquely identify strings.</span></span> <span data-ttu-id="ada9e-1983">相同的字串具有相同的雜湊碼，但 common language runtime 也可以將相同的雜湊程式碼指派給不同的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1983">Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings.</span></span> <span data-ttu-id="ada9e-1984">此外，雜湊程式碼可能會不同的.NET 版本、 平台內的單一版本，和應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1984">In addition, hash codes can vary by version of .NET, by platform within a single version, and by application domain.</span></span> <span data-ttu-id="ada9e-1985">基於這個原因，您不應該序列化，或保存雜湊程式碼的值，也不應該使用它們做為索引鍵的雜湊表或字典中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1985">Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.</span></span>  
  
 <span data-ttu-id="ada9e-1986">如需使用雜湊碼的其他資訊和`GetHashCode`方法，請參閱<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1986">For additional information about the use of hash codes and the `GetHashCode` method, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-1987">下列範例示範<xref:System.String.GetHashCode%2A>使用不同的方法輸入字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1987">The following example demonstrates the <xref:System.String.GetHashCode%2A> method using various input strings.</span></span>  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-1988">所傳回的值<see cref="M:System.String.GetHashCode" />平台而異。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1988">The value returned by <see cref="M:System.String.GetHashCode" /> is platform-dependent.</span></span> <span data-ttu-id="ada9e-1989">不同於 32 位元和 64 位元版本的.NET Framework。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1989">It differs on the 32-bit and 64-bit versions of the .NET Framework.</span></span> <span data-ttu-id="ada9e-1990">它也可以與不同版本的.NET Framework 和.NET Core 之間。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1990">It also can differ between versions of the .NET Framework and .NET Core.</span></span></para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630"><span data-ttu-id="ada9e-1991">&lt;UseRandomizedStringHashAlgorithm&gt;項目</span><span class="sxs-lookup"><span data-stu-id="ada9e-1991">&lt;UseRandomizedStringHashAlgorithm&gt; Element</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-1992">傳回類別 <see cref="T:System.TypeCode" /> 的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1992">Returns the <see cref="T:System.TypeCode" /> for class <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1993">列舉常數 <see cref="F:System.TypeCode.String" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1993">The enumerated constant, <see cref="F:System.TypeCode.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ada9e-1994">下列範例會顯示<xref:System.TypeCode>列舉的常數，<xref:System.String>型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1994">The following example displays the <xref:System.TypeCode> enumerated constant for the <xref:System.String> type.</span></span>  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-1995">報告這個執行個體中指定之 Unicode 字元或字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1995">Reports the zero-based index of the first occurrence of a specified Unicode character or string within this instance.</span></span> <span data-ttu-id="ada9e-1996">如果在此執行個體中找不到該字元或字串，此方法會傳回 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1996">The method returns -1 if the character or string is not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-1997">要搜尋的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1997">A Unicode character to seek.</span></span></param>
        <summary><span data-ttu-id="ada9e-1998">報告這個字串中指定之 Unicode 字元第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1998">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-1999">如果找到該字元，則為 <paramref name="value" /> 以零為起始的索引位置，如果找不到為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-1999">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2000">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2000">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ada9e-2001">這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2001">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ada9e-2002">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2002">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2003">下列範例示範如何搜尋<xref:System.String>字元，使用<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2003">The following example demonstrates how you can search a <xref:System.String> for a character using the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2004">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2004">The string to seek.</span></span></param>
        <summary><span data-ttu-id="ada9e-2005">回報這個執行個體中指定之字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2005">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2006">如果找到該字串，則為 <paramref name="value" /> 以零為起始的索引位置，如未找到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2006">The zero-based index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ada9e-2007">如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 0。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2007">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2008">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2008">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ada9e-2009">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2009">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="ada9e-2010">搜尋這個執行個體的第一個字元位置開始，並接著直到最後一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2010">The search begins at the first character position of this instance and continues until the last character position.</span></span>  
  
 <span data-ttu-id="ada9e-2011">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2011">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2012">執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2012">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ada9e-2013">如果`value`只包含一個或多個可忽略的字元，<xref:System.String.IndexOf%28System.String%29>方法一律會傳回 0 （零），以指出找到相符項目時，會在目前的執行個體的開頭。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2013">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%29> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</span></span> <span data-ttu-id="ada9e-2014">在下列範例中，<xref:System.String.IndexOf%28System.String%29>方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)，後面接著"n"，選擇性連字號和選擇性的連字號後面接著"m"）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2014">In the following example, the <xref:System.String.IndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="ada9e-2015">只有其中一個字串包含選擇性連字號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2015">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="ada9e-2016">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在每個案例中，因為選擇性連字號是可忽略的字元，如果結果為相同因為選擇性連字號不包含在`value`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2016">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="ada9e-2017">搜尋的軟連字號只能時，則方法會傳回 0 （零），指出它已在字串的開頭找到相符項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2017">When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.</span></span>  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2018">下列範例會搜尋"n"在"animal"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2018">The following example searches for the "n" in "animal".</span></span> <span data-ttu-id="ada9e-2019">由於字串索引從零，而不是一個開始<xref:System.String.IndexOf%28System.String%29>方法指出"n"是在位置 1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2019">Because string indexes begin at zero rather than one, the <xref:System.String.IndexOf%28System.String%29> method indicates that the "n" is at position 1.</span></span>  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 <span data-ttu-id="ada9e-2020">下列範例會使用<xref:System.String.IndexOf%2A>方法，以判斷動物的名稱在句子中的開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2020">The following example uses the <xref:System.String.IndexOf%2A> method to determine the starting position of an animal name in a sentence.</span></span> <span data-ttu-id="ada9e-2021">然後會使用這個位置插入句子描述動物形容詞。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2021">It then uses this position to insert an adjective that describes the animal into the sentence.</span></span>  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2022"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2022"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2023">中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2023">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ada9e-2024">若要尋找的字串執行個體中子字串的第一個索引，使用目前文化特性的比較規則，呼叫<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其`comparisonType`參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2024">To find the first index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2025">要搜尋的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2025">A Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2026">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2026">The search starting position.</span></span></param>
        <summary><span data-ttu-id="ada9e-2027">報告這個字串中指定之 Unicode 字元第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2027">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span> <span data-ttu-id="ada9e-2028">搜尋從指定的字元位置開始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2028">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2029">如果找到該字元，則為從字串起始處之 <paramref name="value" /> 的以零為起始索引位置，如果找不到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2029">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2030">索引編號從 0 開始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2030">Index numbering starts from 0.</span></span> <span data-ttu-id="ada9e-2031">`startIndex` 參數的範圍可以從 0 到字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2031">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="ada9e-2032">如果`startIndex`等於字串執行個體的長度，則方法會傳回-1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2032">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="ada9e-2033">搜尋範圍是從`startIndex`到字串結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2033">The search ranges from `startIndex` to the end of the string.</span></span>  
  
 <span data-ttu-id="ada9e-2034">這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2034">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ada9e-2035">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2035">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2036">下列範例示範<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2036">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2037"><paramref name="startIndex" /> 小於 0 (零) 或大於字串的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2037"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of the string.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2038">要搜尋的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2038">The character to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ada9e-2039">列舉值，其指定搜尋規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2039">An enumeration value that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ada9e-2040">報告這個字串中指定之 Unicode 字元第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2040">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span> <span data-ttu-id="ada9e-2041">參數會指定要用於指定字元的搜尋類型。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2041">A parameter specifies the type of search to use for the specified character.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2042">如果找到該字元，則為 <paramref name="value" /> 以零為起始的索引；如果找不到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2042">The zero-based index of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="ada9e-2043">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2043">Index numbering starts from zero.</span></span>  
  
<span data-ttu-id="ada9e-2044">`comparisonType`參數是<xref:System.StringComparison>列舉的成員，指定是否搜尋`value`引數會使用目前或而異的文化特性，區分大小寫或區分大小寫，或使用 word 或序數比較規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2044">The `comparisonType` parameter is a <xref:System.StringComparison> enumeration member that specifies whether the search for the `value` argument uses the current or invariant culture, is case-sensitive or case-insensitive, or uses word or ordinal comparison rules.</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-2045"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2045"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2046">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2046">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2047">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2047">The search starting position.</span></span></param>
        <summary><span data-ttu-id="ada9e-2048">回報這個執行個體中指定之字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2048">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span> <span data-ttu-id="ada9e-2049">搜尋從指定的字元位置開始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2049">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2050">如果找到該字串，則為從目前執行個體起始處之 <paramref name="value" /> 的以零為起始索引位置；如果找不到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2050">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ada9e-2051">如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2051">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2052">索引編號從 0 開始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2052">Index numbering starts from 0.</span></span> <span data-ttu-id="ada9e-2053">`startIndex` 參數的範圍可以從 0 到字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2053">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="ada9e-2054">如果`startIndex`等於字串執行個體的長度，則方法會傳回-1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2054">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="ada9e-2055">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2055">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="ada9e-2056">搜尋開始`startIndex`字元位置，這個執行個體，並接著直到最後一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2056">The search begins at the `startIndex` character position of this instance and continues until the last character position.</span></span>  
  
 <span data-ttu-id="ada9e-2057">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2057">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2058">執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2058">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ada9e-2059">如果`value`只包含一個或多個可忽略的字元，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>方法一律會傳回`startIndex`，這是搜尋開始處的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2059">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="ada9e-2060">在下列範例中，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>方法用來尋找後面接著"m"兩個字串中選擇性連字號 (U + 00AD) 的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2060">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings.</span></span> <span data-ttu-id="ada9e-2061">只有其中一個字串包含必要的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2061">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ada9e-2062">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2062">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string.</span></span> <span data-ttu-id="ada9e-2063">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2063">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2064">下列範例會搜尋指定的字串，在目標字串內的所有項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2064">The following example searches for all occurrences of a specified string within a target string.</span></span>  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2065"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2065"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2066"><paramref name="startIndex" /> 小於 0 (零) 或大於這個字串的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2066"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2067">中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2067">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ada9e-2068">若要尋找特定的字元位置之後，就會發生子字串的第一個索引，使用目前文化特性的比較規則，請呼叫<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其`comparisonType`參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2068">To find the first index of a substring that occurs after a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2069">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2069">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ada9e-2070">其中一個列舉值，指定搜尋規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2070">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ada9e-2071">報告目前 <see cref="T:System.String" /> 物件中指定之字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2071">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ada9e-2072">參數會指定要用於指定字串的搜尋類型。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2072">A parameter specifies the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2073">如果找到該字串，則為 <paramref name="value" /> 的索引位置，如果沒有找到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2073">The index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ada9e-2074">如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 0。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2074">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2075">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2075">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ada9e-2076">`comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用 word 或序數比較規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2076">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2077">下列範例示範三個多載<xref:System.String.IndexOf%2A>找出第一個字串在字串中使用的不同值的另一個字串的方法<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2077">The following example demonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2078"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2078"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-2079"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2079"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2080">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2080">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2081">執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2081">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ada9e-2082">如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />方法一律會傳回 0 （零），以指出找到相符項目時，會在目前的執行個體的開頭。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2082">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</span></span>  
  
<span data-ttu-id="ada9e-2083">在下列範例中，<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)，後面接著"n"，選擇性連字號和選擇性的連字號後面接著"m"）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2083">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="ada9e-2084">只有其中一個字串包含選擇性連字號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2084">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="ada9e-2085">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，因為選擇性連字號是可忽略的字元，區分文化特性的搜尋會傳回相同的值，它會傳回選擇性連字號所不包含搜尋字串中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2085">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</span></span> <span data-ttu-id="ada9e-2086">序數搜尋，不過，成功於一個字串中找到選擇性連字號，並報告它不存在從第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2086">An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</span></span>  
  
<span data-ttu-id="ada9e-2087">[!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</span><span class="sxs-lookup"><span data-stu-id="ada9e-2087">[!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2088">要搜尋的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2088">A Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2089">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2089">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-2090">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2090">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ada9e-2091">報告這個執行個體中指定之字元第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2091">Reports the zero-based index of the first occurrence of the specified character in this instance.</span></span> <span data-ttu-id="ada9e-2092">搜尋從指定的字元位置開始，並檢視指定數目的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2092">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2093">如果找到該字元，則為從字串起始處之 <paramref name="value" /> 的以零為起始索引位置，如果找不到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2093">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2094">搜尋開始於`startIndex`，並持續`startIndex`  +  `count` -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2094">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="ada9e-2095">在字元`startIndex`  +  `count`不會包含在搜尋中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2095">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="ada9e-2096">編號從 0 （零） 的開始索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2096">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="ada9e-2097">`startIndex` 參數的範圍可以從 0 到字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2097">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="ada9e-2098">這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2098">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ada9e-2099">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2099">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2100">下列範例示範<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2100">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2101"><paramref name="count" /> 或 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2101"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-2102">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2102">-or-</span></span> 
 <span data-ttu-id="ada9e-2103"><paramref name="startIndex" /> 大於這個字串的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2103"><paramref name="startIndex" /> is greater than the length of this string.</span></span>  
  
<span data-ttu-id="ada9e-2104">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2104">-or-</span></span> 
 <span data-ttu-id="ada9e-2105"><paramref name="count" /> 大於這個字串減 <paramref name="startIndex" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2105"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2106">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2106">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2107">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2107">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-2108">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2108">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ada9e-2109">回報這個執行個體中指定之字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2109">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span> <span data-ttu-id="ada9e-2110">搜尋從指定的字元位置開始，並檢視指定數目的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2110">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2111">如果找到該字串，則為從目前執行個體起始處之 <paramref name="value" /> 的以零為起始索引位置；如果找不到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2111">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ada9e-2112">如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2112">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2113">編號從 0 （零） 的開始索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2113">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="ada9e-2114">`startIndex` 參數的範圍可以從 0 到字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2114">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="ada9e-2115">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2115">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="ada9e-2116">搜尋開始於`startIndex`，並持續`startIndex`  +  `count` -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2116">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="ada9e-2117">在字元`startIndex`  +  `count`不會包含在搜尋中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2117">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="ada9e-2118">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2118">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2119">執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2119">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ada9e-2120">如果`value`只包含一個或多個可忽略的字元，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法一律會傳回`startIndex`，這是搜尋開始處的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2120">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="ada9e-2121">在下列範例中，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法用來尋找選擇性連字號 (U + 00AD) 後面接著"m"中的第三個透過兩個字串中的第六個字元位置開始的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2121">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</span></span> <span data-ttu-id="ada9e-2122">只有其中一個字串包含必要的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2122">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ada9e-2123">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2123">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2124">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2124">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2125">下列範例會尋找所有出現字串的索引"he"另一個字串的子字串內。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2125">The following example finds the index of all occurrences of the string "he" within a substring of another string.</span></span> <span data-ttu-id="ada9e-2126">請注意要搜尋的字元數，必須重新計算針對每個搜尋反覆項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2126">Note that the number of characters to be searched must be recalculated for each search iteration.</span></span>  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2127"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2127"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2128"><paramref name="count" /> 或 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2128"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-2129">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2129">-or-</span></span> 
 <span data-ttu-id="ada9e-2130"><paramref name="startIndex" /> 大於這個字串的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2130"><paramref name="startIndex" /> is greater than the length of this string.</span></span>  
  
<span data-ttu-id="ada9e-2131">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2131">-or-</span></span> 
 <span data-ttu-id="ada9e-2132"><paramref name="count" /> 大於這個字串減 <paramref name="startIndex" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2132"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2133">中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2133">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ada9e-2134">若要使用目前文化特性的比較規則，執行這項作業，呼叫<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其`comparisonType`參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2134">To use the comparison rules of the current culture to perform this operation, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2135">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2135">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2136">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2136">The search starting position.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ada9e-2137">其中一個列舉值，指定搜尋規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2137">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ada9e-2138">報告目前 <see cref="T:System.String" /> 物件中指定之字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2138">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ada9e-2139">參數會指定目前字串中的開始搜尋位置和要用於指定字串的搜尋類型。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2139">Parameters specify the starting search position in the current string and the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2140">如果找到該字串，則為從目前執行個體起始處之 <paramref name="value" /> 參數的以零為起始索引位置；如果找不到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2140">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ada9e-2141">如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2141">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2142">索引編號從 0 開始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2142">Index numbering starts from 0.</span></span> <span data-ttu-id="ada9e-2143">`startIndex` 參數的範圍可以從 0 到字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2143">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="ada9e-2144">如果`startIndex`等於字串執行個體的長度，則方法會傳回-1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2144">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="ada9e-2145">`comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用 word 或序數比較規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2145">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2146">下列範例示範三個多載<xref:System.String.IndexOf%2A>找出第一個字串在字串中使用的不同值的另一個字串的方法<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2146">The following example demonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2147"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2147"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2148"><paramref name="startIndex" /> 小於 0 (零) 或大於這個字串的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2148"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-2149"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2149"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2150">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2150">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2151">執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2151">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ada9e-2152">如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />方法一律會傳回<paramref name="startIndex" />，這是搜尋開始處的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2152">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
<span data-ttu-id="ada9e-2153">在下列範例中，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />方法用來尋找選擇性連字號 (U + 00AD) 後面接著"m"從兩個字串中的第三個字元位置開始的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2153">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting with the third character position in two strings.</span></span> <span data-ttu-id="ada9e-2154">只有其中一個字串包含必要的子字串。如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2154">Only one of the strings contains the required substring.If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2155">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2155">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span> <span data-ttu-id="ada9e-2156">只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2156">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
<span data-ttu-id="ada9e-2157">[!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</span><span class="sxs-lookup"><span data-stu-id="ada9e-2157">[!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2158">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2158">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2159">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2159">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-2160">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2160">The number of character positions to examine.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ada9e-2161">其中一個列舉值，指定搜尋規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2161">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ada9e-2162">報告目前 <see cref="T:System.String" /> 物件中指定之字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2162">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ada9e-2163">參數會指定目前字串中的開始搜尋位置、目前字串中要搜尋的字元數目，以及要用於指定字串的搜尋類型。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2163">Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2164">如果找到該字串，則為從目前執行個體起始處之 <paramref name="value" /> 參數的以零為起始索引位置；如果找不到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2164">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ada9e-2165">如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2165">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2166">編號從 0 （零） 的開始索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2166">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="ada9e-2167">`startIndex` 參數的範圍可以從 0 到字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2167">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="ada9e-2168">搜尋開始於`startIndex`，並持續`startIndex`  +  `count` -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2168">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="ada9e-2169">在字元`startIndex`  +  `count`不會包含在搜尋中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2169">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="ada9e-2170">`comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用 word 或序數比較規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2170">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2171">下列範例示範三個多載<xref:System.String.IndexOf%2A>找出第一個字串在字串中使用的不同值的另一個字串的方法<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2171">The following example demonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2172"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2172"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2173"><paramref name="count" /> 或 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2173"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-2174">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2174">-or-</span></span> 
 <span data-ttu-id="ada9e-2175"><paramref name="startIndex" /> 大於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2175"><paramref name="startIndex" /> is greater than the length of this instance.</span></span>  
  
<span data-ttu-id="ada9e-2176">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2176">-or-</span></span> 
 <span data-ttu-id="ada9e-2177"><paramref name="count" /> 大於這個字串減 <paramref name="startIndex" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2177"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-2178"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2178"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2179">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2179">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2180">執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2180">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ada9e-2181">如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法一律會傳回<paramref name="startIndex" />，這是搜尋開始處的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2181">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
<span data-ttu-id="ada9e-2182">在下列範例中，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法用來尋找選擇性連字號 (U + 00AD) 後面接著"m"中的第三個透過兩個字串中的第六個字元位置開始的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2182">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</span></span> <span data-ttu-id="ada9e-2183">只有其中一個字串包含必要的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2183">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ada9e-2184">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2184">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2185">當它執行序數比較時，不過，它會尋找子字串只在第一個字串中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2185">When it performs an ordinal comparison, however, it finds the substring only in the first string.</span></span> <span data-ttu-id="ada9e-2186">請注意，第一個字串，其中包含選擇性的連字號後面接著"m"，如果方法無法傳回選擇性連字號的索引，但改為傳回"m"的索引，當它執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2186">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2187">只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2187">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
<span data-ttu-id="ada9e-2188">[!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</span><span class="sxs-lookup"><span data-stu-id="ada9e-2188">[!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-2189">報告指定 Unicode 字元陣列中的任何字元於這個執行個體中第一個符合項目的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2189">Reports the index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="ada9e-2190">如果在此執行個體中找不到陣列中的字元，此方法會傳回 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2190">The method returns -1 if the characters in the array are not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ada9e-2191">Unicode 字元陣列，含有一或多個要搜尋的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2191">A Unicode character array containing one or more characters to seek.</span></span></param>
        <summary><span data-ttu-id="ada9e-2192">報告指定的 Unicode 字元陣列中，任何字元在這個執行個體中第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2192">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2193">在此執行個體中，<paramref name="anyOf" /> 中的任何字元第一次出現的所在索引位置 (以零為起始)，如果找不到 <paramref name="anyOf" /> 中的字元，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2193">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2194">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2194">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ada9e-2195">搜尋`anyOf`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2195">The search for `anyOf` is case-sensitive.</span></span> <span data-ttu-id="ada9e-2196">如果`anyOf`是空的陣列，字串的開頭比對方法找到 （亦即，索引位置為零）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2196">If `anyOf` is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).</span></span>  
  
 <span data-ttu-id="ada9e-2197">這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2197">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ada9e-2198">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2198">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2199">下列範例會尋找字串中的第一個母音。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2199">The following example finds the first vowel in a string.</span></span>  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2200"><paramref name="anyOf" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2200"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ada9e-2201">Unicode 字元陣列，含有一或多個要搜尋的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2201">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2202">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2202">The search starting position.</span></span></param>
        <summary><span data-ttu-id="ada9e-2203">報告指定的 Unicode 字元陣列中，任何字元在這個執行個體中第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2203">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="ada9e-2204">搜尋從指定的字元位置開始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2204">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2205">在此執行個體中，<paramref name="anyOf" /> 中的任何字元第一次出現的所在索引位置 (以零為起始)，如果找不到 <paramref name="anyOf" /> 中的字元，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2205">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2206">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2206">Index numbering starts from zero.</span></span> <span data-ttu-id="ada9e-2207">`startIndex`參數的範圍可以從 0 到小於字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2207">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>  
  
 <span data-ttu-id="ada9e-2208">搜尋範圍是從`startIndex`到字串結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2208">The search ranges from `startIndex` to the end of the string.</span></span>  
  
 <span data-ttu-id="ada9e-2209">搜尋`anyOf`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2209">The search for `anyOf` is case-sensitive.</span></span>  
  
 <span data-ttu-id="ada9e-2210">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有當其 Unicode 純量值都是相同字元即視為相當於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2210">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="ada9e-2211">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2211">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2212">下列範例會尋找相符項目的任何字元字串的索引"is"另一個字串的子字串內。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2212">The following example finds the index of the occurrence of any character of the string "is" within a substring of another string.</span></span>  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2213"><paramref name="anyOf" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2213"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2214"><paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2214"><paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-2215">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2215">-or-</span></span> 
 <span data-ttu-id="ada9e-2216"><paramref name="startIndex" /> 大於這個執行個體的字元數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2216"><paramref name="startIndex" /> is greater than the number of characters in this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ada9e-2217">Unicode 字元陣列，含有一或多個要搜尋的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2217">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2218">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2218">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-2219">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2219">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ada9e-2220">報告指定的 Unicode 字元陣列中，任何字元在這個執行個體中第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2220">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="ada9e-2221">搜尋從指定的字元位置開始，並檢視指定數目的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2221">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2222">在此執行個體中，<paramref name="anyOf" /> 中的任何字元第一次出現的所在索引位置 (以零為起始)，如果找不到 <paramref name="anyOf" /> 中的字元，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2222">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2223">搜尋開始於`startIndex`，並持續`startIndex`  +  `count` -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2223">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="ada9e-2224">在字元`startIndex`  +  `count`不會包含在搜尋中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2224">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="ada9e-2225">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2225">Index numbering starts from zero.</span></span> <span data-ttu-id="ada9e-2226">`startIndex`參數的範圍可以從 0 到小於字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2226">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>  
  
 <span data-ttu-id="ada9e-2227">搜尋`anyOf`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2227">The search for `anyOf` is case-sensitive.</span></span>  
  
 <span data-ttu-id="ada9e-2228">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有當其 Unicode 純量值都是相同字元即視為相當於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2228">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="ada9e-2229">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2229">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2230">下列範例會尋找另一個字串的子字串內的任何字元的字串"aid"的相符項目索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2230">The following example finds the index of the occurrence of any character of the string "aid" within a substring of another string.</span></span>  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2231"><paramref name="anyOf" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2231"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2232"><paramref name="count" /> 或 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2232"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-2233">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2233">-or-</span></span> 
 <span data-ttu-id="ada9e-2234"><paramref name="count" /> + <paramref name="startIndex" /> 大於這個執行個體的字元數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2234"><paramref name="count" /> + <paramref name="startIndex" /> is greater than the number of characters in this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ada9e-2235">插入的索引位置 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2235">The zero-based index position of the insertion.</span></span></param>
        <param name="value"><span data-ttu-id="ada9e-2236">要插入的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2236">The string to insert.</span></span></param>
        <summary><span data-ttu-id="ada9e-2237">傳回新字串，其中已在這個執行個體中指定的索引位置插入指定的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2237">Returns a new string in which a specified string is inserted at a specified index position in this instance.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2238">與這個執行個體相等的新字串，但是在 <paramref name="value" /> 位置插入了 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2238">A new string that is equivalent to this instance, but with <paramref name="value" /> inserted at position <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2239">如果`startIndex`等於這個執行個體，長度`value`附加至這個執行個體的結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2239">If `startIndex` is equal to the length of this instance, `value` is appended to the end of this instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-2240">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2240">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-2241">相反地，它會傳回新字串，其中`value`插入至目前的執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2241">Instead, it returns a new string in which `value` is inserted into the current instance.</span></span>  
  
 <span data-ttu-id="ada9e-2242">例如，傳回值的`"abc".Insert(2, "XYZ")`是 「 abXYZc"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2242">For example, the return value of `"abc".Insert(2, "XYZ")` is "abXYZc".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2243">下列範例會插入空格字元在字串的第四個字元位置 （位於索引 3 的字元）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2243">The following example inserts a space character in the fourth character position (the character at index 3) of a string.</span></span>  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 <span data-ttu-id="ada9e-2244">下列主控台應用程式會提示使用者輸入來描述兩個動物的一或多個形容詞。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2244">The following console application prompts the users to enter one or more adjectives to describe two animals.</span></span> <span data-ttu-id="ada9e-2245">然後它會呼叫<xref:System.String.Insert%2A>方法以將使用者輸入字串的文字。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2245">It then calls the <xref:System.String.Insert%2A> method to insert the text entered by the user into a string.</span></span>  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2246"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2246"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2247"><paramref name="startIndex" /> 是負值或大於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2247"><paramref name="startIndex" /> is negative or greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="ada9e-2248">要在保留集區中搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2248">A string to search for in the intern pool.</span></span></param>
        <summary><span data-ttu-id="ada9e-2249">擷取指定的 <see cref="T:System.String" /> 的系統參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2249">Retrieves the system's reference to the specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2250">如果已經保留，則為系統的 <paramref name="str" /> 參考，否則為具有 <paramref name="str" /> 值之字串的新參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2250">The system's reference to <paramref name="str" />, if it is interned; otherwise, a new reference to a string with the value of <paramref name="str" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2251">通用語言執行平台讓維護稱為保留集區，包含每個唯一的常值字串，宣告或以程式設計方式建立您的程式中的單一參考的資料表，以節省字串儲存體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2251">The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program.</span></span> <span data-ttu-id="ada9e-2252">因此，含有特定值的常值字串的執行個體只存在於一次在系統中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2252">Consequently, an instance of a literal string with a particular value only exists once in the system.</span></span>  
  
 <span data-ttu-id="ada9e-2253">比方說，如果您將相同的常值字串指派給數個變數時，執行階段擷取的常值字串來保留集區從相同的參考，並將它指派給每個變數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2253">For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.</span></span>  
  
 <span data-ttu-id="ada9e-2254"><xref:System.String.Intern%2A>方法會保留集區使用的值相等的字串搜尋`str`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2254">The <xref:System.String.Intern%2A> method uses the intern pool to search for a string equal to the value of `str`.</span></span> <span data-ttu-id="ada9e-2255">如果這類字串已存在，則會傳回其在保留集區的參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2255">If such a string exists, its reference in the intern pool is returned.</span></span> <span data-ttu-id="ada9e-2256">如果字串不存在，參考`str`保留集區，則會傳回該參考加入。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2256">If the string does not exist, a reference to `str` is added to the intern pool, then that reference is returned.</span></span>  
  
 <span data-ttu-id="ada9e-2257">在下列範例中，字串 s1，其 「 MyTest"的值，是已經被保留，因為它是在程式中的常值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2257">In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program.</span></span> <span data-ttu-id="ada9e-2258"><xref:System.Text.StringBuilder?displayProperty=nameWithType>類別會產生新的字串物件，其與 s1 相同的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2258">The <xref:System.Text.StringBuilder?displayProperty=nameWithType> class generates a new string object that has the same value as s1.</span></span> <span data-ttu-id="ada9e-2259">該字串的參考，則指派給 s2。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2259">A reference to that string is assigned to s2.</span></span> <span data-ttu-id="ada9e-2260"><xref:System.String.Intern%2A>方法搜尋字串具有相同的值為 s2。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2260">The <xref:System.String.Intern%2A> method searches for a string that has the same value as s2.</span></span> <span data-ttu-id="ada9e-2261">因為有這樣的字串，這個方法會傳回相同的參考指派至 s1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2261">Because such a string exists, the method returns the same reference that is assigned to s1.</span></span> <span data-ttu-id="ada9e-2262">接著，該參考會指派給 s3。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2262">That reference is then assigned to s3.</span></span> <span data-ttu-id="ada9e-2263">參考 s1 和 s2 比較相等因為它們參考不同的物件;參考 s1 與 s3 比較相等，因為它們參考相同的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2263">References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.</span></span>  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 <span data-ttu-id="ada9e-2264">比較這個方法，以<xref:System.String.IsInterned%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2264">Compare this method to the <xref:System.String.IsInterned%2A> method.</span></span>  
  
## <a name="version-considerations"></a><span data-ttu-id="ada9e-2265">版本的考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-2265">Version Considerations</span></span>  
 <span data-ttu-id="ada9e-2266">在  [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]，則<xref:System.String.Intern%2A>方法還原成其行為在.NET Framework 1.0 和 1.1 方面暫留空字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2266">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], the <xref:System.String.Intern%2A> method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string.</span></span> <span data-ttu-id="ada9e-2267">在下列範例中，變數`str1`參考會指派給<xref:System.String.Empty>，和變數`str2`指派參考<xref:System.String.Empty>藉由呼叫傳回<xref:System.String.Intern%2A>方法之後轉換<xref:System.Text.StringBuilder>物件，其值為<xref:System.String.Empty>為字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2267">In the following example, the variable `str1` is assigned a reference to <xref:System.String.Empty>, and the variable `str2` is assigned the reference to <xref:System.String.Empty> that is returned by calling the <xref:System.String.Intern%2A> method after converting a <xref:System.Text.StringBuilder> object whose value is <xref:System.String.Empty> to a string.</span></span> <span data-ttu-id="ada9e-2268">然後參考包含在`str1`和`str2`會比較是否相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2268">Then the references contained in `str1` and `str2` are compared for equality.</span></span>  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 <span data-ttu-id="ada9e-2269">在  [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]， [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]，並[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]，`str1`和`str2`相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2269">In the [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], and [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` and `str2` are equal.</span></span> <span data-ttu-id="ada9e-2270">在 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]並[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]，`str1`和`str2`是否不相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2270">In the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] and [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` and `str2` are not equal.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="ada9e-2271">效能考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-2271">Performance Considerations</span></span>  
 <span data-ttu-id="ada9e-2272">如果您嘗試降低記憶體總數量會配置您的應用程式，請記住，暫留 」 字串有兩個不必要的副作用。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2272">If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects.</span></span> <span data-ttu-id="ada9e-2273">首先，記憶體配置的暫留<xref:System.String>物件可能不會發行到 common language runtime (CLR) 結束為止。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2273">First, the memory allocated for interned <xref:System.String> objects is not likely to be released until the common language runtime (CLR) terminates.</span></span> <span data-ttu-id="ada9e-2274">原因是保留的 CLR 參考<xref:System.String>物件可以保存您的應用程式或甚至是您的應用程式定義域之後，會終止。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2274">The reason is that the CLR's reference to the interned <xref:System.String> object can persist after your application, or even your application domain, terminates.</span></span> <span data-ttu-id="ada9e-2275">其次，若 intern 字串，您必須先建立字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2275">Second, to intern a string, you must first create the string.</span></span> <span data-ttu-id="ada9e-2276">所使用的記憶體<xref:System.String>物件必須仍配置，即使記憶體最終將會回收。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2276">The memory used by the <xref:System.String> object must still be allocated, even though the memory will eventually be garbage collected.</span></span>  
  
 <span data-ttu-id="ada9e-2277">.NET Framework 2.0 版導入了<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType>列舉成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2277">The .NET Framework version 2.0 introduces the <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> enumeration member.</span></span> <span data-ttu-id="ada9e-2278"><xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>成員標示為不需要字串常值暫留 」 組件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2278">The <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> member marks an assembly as not requiring string-literal interning.</span></span> <span data-ttu-id="ada9e-2279">您可以套用<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>使用的組件<xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2279">You can apply <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> to an assembly using the <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> attribute.</span></span> <span data-ttu-id="ada9e-2280">此外，當您使用[Ngen.exe （原生映像產生器）](~/docs/framework/tools/ngen-exe-native-image-generator.md)編譯組件之前 執行階段，字串不暫留在模組。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2280">Also, when you use the [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) to compile an assembly in advance of run time, strings are not interned across modules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2281">下列範例使用三個相等值，以判斷是否為新建立的字串中的字串，並保留的字串相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2281">The following example uses three strings that are equal in value to determine whether a newly created string and an interned string are equal.</span></span>  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2282"><paramref name="str" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2282"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="ada9e-2283">要在保留集區中搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2283">The string to search for in the intern pool.</span></span></param>
        <summary><span data-ttu-id="ada9e-2284">擷取對指定 <see cref="T:System.String" /> 的參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2284">Retrieves a reference to a specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2285">如果是在 Common Language Runtime 保留集區中，則為 <paramref name="str" /> 的參考，否則為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2285">A reference to <paramref name="str" /> if it is in the common language runtime intern pool; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2286">Common language runtime 會自動維護的資料表，稱為保留集區，其中包含宣告的程式，以及任何唯一的執行個體的每個唯一的常值字串常數的單一執行個體<xref:System.String>藉由呼叫以程式設計方式新增<xref:System.String.Intern%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2286">The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <xref:System.String> you add programmatically by calling the <xref:System.String.Intern%2A> method.</span></span>  
  
 <span data-ttu-id="ada9e-2287">保留集區可節省的字串存放區。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2287">The intern pool conserves string storage.</span></span> <span data-ttu-id="ada9e-2288">如果您將常值的字串常數指派給數個變數時，每個變數會設定為參考相同的常數在保留集區，而不是參考的數個不同的執行個體<xref:System.String>有相同的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2288">If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <xref:System.String> that have identical values.</span></span>  
  
 <span data-ttu-id="ada9e-2289">這個方法會查詢`str`在保留集區。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2289">This method looks up `str` in the intern pool.</span></span> <span data-ttu-id="ada9e-2290">如果`str`已經過暫留，該執行個體的參考會傳回; 否則即為`null`會傳回。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2290">If `str` has already been interned, a reference to that instance is returned; otherwise, `null` is returned.</span></span>  
  
 <span data-ttu-id="ada9e-2291">比較這個方法，以<xref:System.String.Intern%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2291">Compare this method to the <xref:System.String.Intern%2A> method.</span></span>  
  
 <span data-ttu-id="ada9e-2292">這個方法不會傳回布林值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2292">This method does not return a Boolean value.</span></span> <span data-ttu-id="ada9e-2293">如果您呼叫方法，因為您想要的布林值，指出是否要暫留的特定字串，您可以使用如下所示的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2293">If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.</span></span>  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-2294">從.NET Framework 2.0 版開始，您可以覆寫保留集區使用當您使用[Ngen.exe （原生映像產生器）](~/docs/framework/tools/ngen-exe-native-image-generator.md)組件安裝至本機電腦的原生映像快取。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2294">Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) to install an assembly to the native image cache on a local computer.</span></span> <span data-ttu-id="ada9e-2295">如需詳細資訊，請參閱 < 備註 > 一節中的效能考量<xref:System.String.Intern%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2295">For more information, see Performance Considerations in the Remarks section for the <xref:System.String.Intern%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2296">下列範例會示範，常值字串暫留會自動由編譯器。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2296">The following example demonstrates that literal strings are interned automatically by the compiler.</span></span>  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2297"><paramref name="str" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2297"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-2298">指出這個字串是否為特定的 Unicode 正規化格式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2298">Indicates whether this string is in a particular Unicode normalization form.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-2299">指出這個字串是否為 Unicode 正規化格式 C。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2299">Indicates whether this string is in Unicode normalization form C.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2300">如果這個字串為正規化格式 C，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2300"><see langword="true" /> if this string is in normalization form C; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2301">某些 Unicode 字元有多個對等的二進位表示，其中包含結合的集合及/或複合的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2301">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="ada9e-2302">搜尋、 排序、 比對，以及其他作業，則存在單一字元的多種表示法變得非常複雜。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2302">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="ada9e-2303">Unicode 標準會定義稱為傳回一個二進位表示法指定任何對等的二進位表示的字元時的正規化程序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2303">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="ada9e-2304">可使用數種演算法，稱為正規化表單，可遵循不同的規則執行正規化。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2304">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="ada9e-2305">.NET 目前支援的正規化表單 C、 D、 KC 和 KD。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2305">.NET currently supports normalization forms C, D, KC, and KD.</span></span>  
  
 <span data-ttu-id="ada9e-2306">如需支援的 Unicode 正規化格式的說明，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2306">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2307">下列範例會判斷字串是否成功正規化各種的正規化形式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2307">The following example determines whether a string is successfully normalized to various normalization forms.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-2308">目前的執行個體包含無效的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2308">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2309"><see cref="Overload:System.String.IsNormalized" />方法會傳回<see langword="false" />當它遇到第一個非標準化字元在字串中的。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2309">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="ada9e-2310">因此，如果字串包含非標準化的字元，後面接著無效的 Unicode 字元<see cref="Overload:System.String.Normalize" />方法會擲回<see cref="T:System.ArgumentException" />雖然<see cref="Overload:System.String.IsNormalized" />傳回<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2310">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm"><span data-ttu-id="ada9e-2311">Unicode 正規化格式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2311">A Unicode normalization form.</span></span></param>
        <summary><span data-ttu-id="ada9e-2312">指出這個字串是否為指定的 Unicode 正規化格式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2312">Indicates whether this string is in the specified Unicode normalization form.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2313">如果這個字串為 <see langword="true" /> 參數指定的正規化格式，則為 <paramref name="normalizationForm" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2313"><see langword="true" /> if this string is in the normalization form specified by the <paramref name="normalizationForm" /> parameter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2314">某些 Unicode 字元有多個對等的二進位表示，其中包含結合的集合及/或複合的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2314">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="ada9e-2315">搜尋、 排序、 比對，以及其他作業，則存在單一字元的多種表示法變得非常複雜。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2315">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="ada9e-2316">Unicode 標準會定義稱為傳回一個二進位表示法指定任何對等的二進位表示的字元時的正規化程序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2316">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="ada9e-2317">可使用數種演算法，稱為正規化表單，可遵循不同的規則執行正規化。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2317">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="ada9e-2318">.NET 目前支援的正規化表單 C、 D、 KC 和 KD。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2318">.NET currently supports normalization forms C, D, KC, and KD.</span></span>  
  
 <span data-ttu-id="ada9e-2319">如需支援的 Unicode 正規化格式的說明，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2319">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2320">下列範例示範<xref:System.String.IsNormalized%2A>和<xref:System.String.Normalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2320">The following example demonstrates the <xref:System.String.IsNormalized%2A> and <xref:System.String.Normalize%2A> methods.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-2321">目前的執行個體包含無效的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2321">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2322"><see cref="Overload:System.String.IsNormalized" />方法會傳回<see langword="false" />當它遇到第一個非標準化字元在字串中的。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2322">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="ada9e-2323">因此，如果字串包含非標準化的字元，後面接著無效的 Unicode 字元<see cref="Overload:System.String.Normalize" />方法會擲回<see cref="T:System.ArgumentException" />雖然<see cref="Overload:System.String.IsNormalized" />傳回<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2323">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2324">要測試的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2324">The string to test.</span></span></param>
        <summary><span data-ttu-id="ada9e-2325">表示指定的字串是否為 <see langword="null" /> 或空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2325">Indicates whether the specified string is <see langword="null" /> or an empty string ("").</span></span></summary>
        <returns><span data-ttu-id="ada9e-2326">如果 <see langword="true" /> 參數為 <paramref name="value" /> 或空字串 ("")，則為 <see langword="null" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2326"><see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or an empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2327"><xref:System.String.IsNullOrEmpty%2A> 是一種便利方法，可讓您以同時測試是否<xref:System.String>已`null`或其值為<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2327"><xref:System.String.IsNullOrEmpty%2A> is a convenience method that enables you to simultaneously test whether a <xref:System.String> is `null` or its value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-2328">相當於下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="ada9e-2328">It is equivalent to the following code:</span></span>  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 <span data-ttu-id="ada9e-2329">您可以使用<xref:System.String.IsNullOrWhiteSpace%2A>方法來測試字串是否`null`，其值是<xref:System.String.Empty?displayProperty=nameWithType>，或它只包含泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2329">You can use the <xref:System.String.IsNullOrWhiteSpace%2A> method to test whether a string is `null`, its value is <xref:System.String.Empty?displayProperty=nameWithType>,  or it consists only of white-space characters.</span></span>  
  
## <a name="what-is-a-null-string"></a><span data-ttu-id="ada9e-2330">什麼是 null 字串？</span><span class="sxs-lookup"><span data-stu-id="ada9e-2330">What is a null string?</span></span>

<span data-ttu-id="ada9e-2331">字串是`null`如果它尚未指派值 (在C++和 Visual Basic) 或如果已明確地被指派的值`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2331">A string is `null` if it has not been assigned a value (in C++ and Visual Basic) or if it has explicitly been assigned a value of `null`.</span></span> <span data-ttu-id="ada9e-2332">雖然[複合格式](~/docs/standard/base-types/composite-formatting.md)功能可以正常處理 null 的字串，如下列範例所示，嘗試呼叫其中一個，如果其成員擲回<xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2332">Although the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <xref:System.NullReferenceException>.</span></span>  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a><span data-ttu-id="ada9e-2333">什麼是空字串？</span><span class="sxs-lookup"><span data-stu-id="ada9e-2333">What is an empty string?</span></span>  

<span data-ttu-id="ada9e-2334">字串是空明確指派為空字串 ("") 或<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2334">A string is empty if it  is explicitly assigned an empty string ("") or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-2335">空的字串具有<xref:System.String.Length%2A>為 0。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2335">An empty string has a <xref:System.String.Length%2A> of 0.</span></span>  <span data-ttu-id="ada9e-2336">下列範例會建立空的字串，並顯示它的值，它的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2336">The following example creates an empty string and displays its value and its length.</span></span>  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 <span data-ttu-id="ada9e-2337">下列範例會檢查三個字串，並判斷每個字串的值、 為空字串，或為`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2337">The following example examines three strings and determines whether each string has a value, is an empty string, or is `null`.</span></span>  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2338">要測試的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2338">The string to test.</span></span></param>
        <summary><span data-ttu-id="ada9e-2339">表示指定的字串是否為 <see langword="null" />、空白，或只由空白字元組成的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2339">Indicates whether a specified string is <see langword="null" />, empty, or consists only of white-space characters.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2340">如果 <see langword="true" /> 參數是 <paramref name="value" /> 或 <see langword="null" />，或者 <see cref="F:System.String.Empty" /> 完全由空白字元組成，則為 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2340"><see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" />, or if <paramref name="value" /> consists exclusively of white-space characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2341"><xref:System.String.IsNullOrWhiteSpace%2A> 是很便利的方法大致如下列程式碼中，不同之處在於它提供更優異的效能：</span><span class="sxs-lookup"><span data-stu-id="ada9e-2341"><xref:System.String.IsNullOrWhiteSpace%2A> is a convenience method that is similar to the following  code, except that it offers superior performance:</span></span>  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 <span data-ttu-id="ada9e-2342">泛空白字元是由 Unicode 標準定義。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2342">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="ada9e-2343"><xref:System.String.IsNullOrWhiteSpace%2A>方法會傳回值的任何字元將解譯`true`則會傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>為空格字元的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2343">The <xref:System.String.IsNullOrWhiteSpace%2A> method interprets any character that returns a value of `true` when it is passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method as a white-space character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2344">下列範例會建立字串陣列，並接著將傳遞至陣列的每個項目<xref:System.String.IsNullOrWhiteSpace%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2344">The following example creates a string array, and then passes each element of the array to the <xref:System.String.IsNullOrWhiteSpace%2A> method.</span></span>  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-2345">串連指定之陣列的項目或集合的成員，並在每個項目或成員之間使用指定的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2345">Concatenates the elements of a specified array or the members of a collection, using the specified separator between each element or member.</span></span></summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ada9e-2346">要當作分隔符號的字串。<paramref name="separator" /></span><span class="sxs-lookup"><span data-stu-id="ada9e-2346">The string to use as a separator.<paramref name="separator" /></span></span> <span data-ttu-id="ada9e-2347">只有在 <paramref name="values" /> 有一個以上的項目時，才會包含在傳回的字串中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2347">is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="ada9e-2348">包含要串連之字串的集合。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2348">A collection that contains the strings to concatenate.</span></span></param>
        <summary><span data-ttu-id="ada9e-2349">串連類型 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 之已建構的 <see cref="T:System.String" /> 集合的成員，並在每個成員之間使用指定的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2349">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2350">字串，由 <paramref name="values" /> 中的成員組成，且每個成員之間都會以 <paramref name="separator" /> 字串分隔。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2350">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="ada9e-2351">如果 <paramref name="values" /> 沒有成員，方法會傳回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2351">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2352">如果`separator`已`null`、 空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 會改為使用。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2352">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ada9e-2353">如果任何屬於`values`是`null`，改為使用空字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2353">If any member of `values` is `null`, an empty string is used instead.</span></span>  
  
 <span data-ttu-id="ada9e-2354"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 是一種便利方法，可讓您串連每個項目`IEnumerable(Of String)`集合，而不先將項目轉換成字串陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2354"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="ada9e-2355">它特別適合使用 Language-Integrated Query (LINQ) 查詢運算式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2355">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="ada9e-2356">下列範例會傳遞`List(Of String)`物件，包含 lambda 運算式會選取等於或大於特定字母 （即，在範例中，"M"） 的字母英文字母大寫或小寫字母。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2356">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="ada9e-2357">`IEnumerable(Of String)`所傳回的集合<xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>方法會傳遞至<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法來顯示結果，以單一字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2357">The `IEnumerable(Of String)` collection returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2358">下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2358">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="ada9e-2359">它會將結果指派<xref:System.Collections.Generic.List%601>類型的物件<xref:System.String>，這會接著傳遞給<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2359">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2360"><paramref name="values" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2360"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ada9e-2361">要當做分隔符號的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2361">The string to use as a separator.</span></span> <span data-ttu-id="ada9e-2362">只有在 <paramref name="values" /> 的元素有一個以上時，<paramref name="separator" /> 才會包含在傳回的字串中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2362"><paramref name="separator" /> is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="ada9e-2363">含有要串連之項目的陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2363">An array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="ada9e-2364">串連物件陣列的項目，並在每個項目之間使用指定的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2364">Concatenates the elements of an object array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2365">字串，由 <paramref name="values" /> 的項目組成，且每個項目之間都會以 <paramref name="separator" /> 字串分隔。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2365">A string that consists of the elements of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="ada9e-2366">如果 <paramref name="values" /> 為空陣列，則方法會傳回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2366">If <paramref name="values" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2367">如果`separator`是`null`或任何項目`values`以外的第一個元素不`null`，空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 會改為使用。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2367">If `separator` is `null` or if any element of `values` other than the first element is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ada9e-2368">請參閱呼叫端一節的資訊，如果第一個項目`values`是`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2368">See the Notes for Callers section if the first element of `values` is `null`.</span></span>  
  
 <span data-ttu-id="ada9e-2369"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> 是一種便利方法，可讓您串連物件陣列中的每個項目，而不需要明確地將其項目轉換為字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2369"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings.</span></span> <span data-ttu-id="ada9e-2370">藉由呼叫該物件的陣列中的每個物件的字串表示衍生`ToString`方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2370">The string representation of each object in the array is derived by calling that object's `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2371">下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2371">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="ada9e-2372">它會將結果指派到的整數陣列，然後將傳遞給<xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2372">It assigns the result to a integer array, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2373"><paramref name="values" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2373"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2374">如果第一個項目<paramref name="values" />是<see langword="null" />，則<see cref="M:System.String.Join(System.String,System.Object[])" />方法不會串連中的項目<paramref name="values" />而是傳回<see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2374">If the first element of <paramref name="values" /> is <see langword="null" />, the <see cref="M:System.String.Join(System.String,System.Object[])" /> method does not concatenate the elements in <paramref name="values" /> but instead returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ada9e-2375">提供此問題的因應措施的數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2375">A number of workarounds for this issue are available.</span></span> <span data-ttu-id="ada9e-2376">若要指派的值的最簡單的方法是<see cref="F:System.String.Empty" />陣列的第一個元素，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2376">The easiest is to assign a value of <see cref="F:System.String.Empty" /> to the first element of the array, as the following example shows.</span></span>  
  
<span data-ttu-id="ada9e-2377">[!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</span><span class="sxs-lookup"><span data-stu-id="ada9e-2377">[!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</span></span></para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ada9e-2378">要當做分隔符號的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2378">The string to use as a separator.</span></span> <span data-ttu-id="ada9e-2379">只有在 <paramref name="value" /> 的元素有一個以上時，<paramref name="separator" /> 才會包含在傳回的字串中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2379"><paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="ada9e-2380">含有要串連之項目的陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2380">An array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="ada9e-2381">串連字串陣列的所有項目，並在每個項目之間使用指定的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2381">Concatenates all the elements of a string array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2382">字串，由 <paramref name="value" /> 中的項目組成，且每個項目之間都會以 <paramref name="separator" /> 字串分隔。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2382">A string that consists of the elements in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="ada9e-2383">如果 <paramref name="value" /> 為空陣列，則方法會傳回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2383">If <paramref name="value" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2384">比方說，如果`separator`是"，"的項目和`value`是"apple"、 「 橙色 」、 「 grape 處理 」 和 「 西洋梨"`Join(separator, value)`傳回 「 apple、 orange、 grape 處理、 西洋梨"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2384">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value)` returns "apple, orange, grape, pear".</span></span>  
  
 <span data-ttu-id="ada9e-2385">如果`separator`已`null`、 空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 會改為使用。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2385">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ada9e-2386">如果在任何項目`value`是`null`，改為使用空字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2386">If any element in `value` is `null`, an empty string is used instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2387">下列範例示範<xref:System.String.Join%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2387">The following example demonstrates the <xref:System.String.Join%2A> method.</span></span>  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2388"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2388"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ada9e-2389">要當做分隔符號的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2389">The string to use as a separator.</span></span> <span data-ttu-id="ada9e-2390">只有在 <paramref name="value" /> 的元素有一個以上時，<paramref name="separator" /> 才會包含在傳回的字串中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2390"><paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="ada9e-2391">含有要串連之項目的陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2391">An array that contains the elements to concatenate.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2392"><paramref name="value" /> 中要使用的第一個項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2392">The first element in <paramref name="value" /> to use.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-2393">要使用的 <paramref name="value" /> 項目數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2393">The number of elements of <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="ada9e-2394">串連字串陣列的指定項目，並在每個項目之間使用指定的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2394">Concatenates the specified elements of a string array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2395">由 <paramref name="value" /> 中之字串組成的字串，每個字串之間都以 <paramref name="separator" /> 字串隔開。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2395">A string that consists of the strings in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span></span>  
  
<span data-ttu-id="ada9e-2396">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2396">-or-</span></span> 
 <span data-ttu-id="ada9e-2397">如果 <see cref="F:System.String.Empty" /> 為零、<paramref name="count" /> 沒有任何項目，或 <paramref name="value" /> 和 <paramref name="separator" /> 的所有項目都是 <paramref name="value" />，則為 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2397"><see cref="F:System.String.Empty" /> if <paramref name="count" /> is zero, <paramref name="value" /> has no elements, or <paramref name="separator" /> and all the elements of <paramref name="value" /> are <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2398">比方說，如果`separator`是"，"的項目和`value`是"apple"、 「 橙色 」、 「 grape 處理 」 和 「 西洋梨"`Join(separator, value, 1, 2)`傳回 「 橙色，grape 處理 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2398">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value, 1, 2)` returns "orange, grape".</span></span>  
  
 <span data-ttu-id="ada9e-2399">如果`separator`已`null`、 空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 會改為使用。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2399">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ada9e-2400">如果在任何項目`value`是`null`，改為使用空字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2400">If any element in `value` is `null`, an empty string is used instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2401">下列範例會串連兩個項目從水果名稱陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2401">The following example concatenates two elements from an array of names of fruit.</span></span>  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2402"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2402"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2403"><paramref name="startIndex" /> 或 <paramref name="count" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2403"><paramref name="startIndex" /> or <paramref name="count" /> is less than 0.</span></span>  
  
<span data-ttu-id="ada9e-2404">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2404">-or-</span></span> 
 <span data-ttu-id="ada9e-2405"><paramref name="startIndex" /> 加上 <paramref name="count" /> 大於 <paramref name="value" /> 中的項目數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2405"><paramref name="startIndex" /> plus <paramref name="count" /> is greater than the number of elements in <paramref name="value" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="ada9e-2406">記憶體不足。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2406">Out of memory.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="ada9e-2407"><paramref name="values" /> 之成員的類型。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2407">The type of the members of <paramref name="values" />.</span></span></typeparam>
        <param name="separator"><span data-ttu-id="ada9e-2408">要當作分隔符號的字串。<paramref name="separator" /></span><span class="sxs-lookup"><span data-stu-id="ada9e-2408">The string to use as a separator.<paramref name="separator" /></span></span> <span data-ttu-id="ada9e-2409">只有在 <paramref name="values" /> 有一個以上的項目時，才會包含在傳回的字串中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2409">is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="ada9e-2410">包含要串連之物件的集合。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2410">A collection that contains the objects to concatenate.</span></span></param>
        <summary><span data-ttu-id="ada9e-2411">串連集合的成員，並在每個成員之間使用指定的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2411">Concatenates the members of a collection, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2412">字串，由 <paramref name="values" /> 中的成員組成，且每個成員之間都會以 <paramref name="separator" /> 字串分隔。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2412">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="ada9e-2413">如果 <paramref name="values" /> 沒有成員，方法會傳回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2413">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2414">如果`separator`已`null`、 空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 會改為使用。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2414">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="ada9e-2415">如果任何屬於`values`是`null`，改為使用空字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2415">If any member of `values` is `null`, an empty string is used instead.</span></span>  
  
 <span data-ttu-id="ada9e-2416"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 是一種便利方法，可讓您串連的每個成員<xref:System.Collections.Generic.IEnumerable%601>而不先將它們轉換成字串的集合。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2416"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each member of an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting them to strings.</span></span> <span data-ttu-id="ada9e-2417">在每個物件的字串表示<xref:System.Collections.Generic.IEnumerable%601>集合藉由呼叫該物件衍生`ToString`方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2417">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>  
  
 <span data-ttu-id="ada9e-2418">這個方法是在特定使用 Language-Integrated Query (LINQ) 查詢運算式很有用。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2418">This method is particular useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="ada9e-2419">例如，下列程式碼定義非常簡單`Animal`類別，其中包含針對 animal 和其所屬的順序的名稱。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2419">For example, the following code defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="ada9e-2420">然後它會定義<xref:System.Collections.Generic.List%601>物件，其中包含許多`Animal`物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2420">It then defines a <xref:System.Collections.Generic.List%601> object that contains a number of `Animal` objects.</span></span> <span data-ttu-id="ada9e-2421"><xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>會呼叫擴充方法來擷取`Animal`物件，而其`Order`屬性等於"齧齒動物 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2421">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="ada9e-2422">結果會傳遞至<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2422">The result is passed to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2423">下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2423">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="ada9e-2424">它會將結果指派<xref:System.Collections.Generic.List%601>物件的整數類型，這會接著傳遞給<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2424">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type integer, which it then passes to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2425"><paramref name="values" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2425"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-2426">報告這個執行個體中指定之 Unicode 字元或字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2426">Reports the zero-based index position of the last occurrence of a specified Unicode character or string within this instance.</span></span> <span data-ttu-id="ada9e-2427">如果在此執行個體中找不到該字元或字串，此方法會傳回 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2427">The method returns -1 if the character or string is not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2428">要搜尋的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2428">The Unicode character to seek.</span></span></param>
        <summary><span data-ttu-id="ada9e-2429">報告這個執行個體中指定之 Unicode 字元最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2429">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2430">如果找到該字元，則為 <paramref name="value" /> 以零為起始的索引位置，如果找不到為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2430">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2431">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2431">Index numbering starts from zero.</span></span> <span data-ttu-id="ada9e-2432">也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2432">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ada9e-2433">這個方法會在這個執行個體的最後一個字元位置開始搜尋，然後反向朝直到開始`value`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2433">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="ada9e-2434">搜尋會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2434">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ada9e-2435">這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2435">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ada9e-2436">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2436">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2437">下列範例會定義`ExtractFilename`方法，以使用<xref:System.String.LastIndexOf%28System.Char%29>方法來尋找字串中的最後一個目錄分隔符號字元，並擷取字串的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2437">The following example defines an `ExtractFilename` method that uses the <xref:System.String.LastIndexOf%28System.Char%29> method to find the last directory separator character in a string and to extract the string's file name.</span></span> <span data-ttu-id="ada9e-2438">如果檔案存在，則方法會傳回不包含其路徑的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2438">If the file exists, the method returns the file name without its path.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2439">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2439">The string to seek.</span></span></param>
        <summary><span data-ttu-id="ada9e-2440">回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2440">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2441">如果找到該字串，則為 <paramref name="value" /> 以零為起始的起始索引位置，如未找到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2441">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ada9e-2442">如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值為這個執行個體中的最後一個索引位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2442">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2443">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2443">Index numbering starts from zero.</span></span> <span data-ttu-id="ada9e-2444">也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2444">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ada9e-2445">搜尋這個執行個體的最後一個字元位置開始，然後反向朝直到開始`value`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2445">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>  
  
 <span data-ttu-id="ada9e-2446">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2446">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="ada9e-2447">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2447">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2448">執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2448">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ada9e-2449">如果`value`只包含一個或多個可忽略的字元，<xref:System.String.LastIndexOf%28System.String%29>方法一律會傳回<xref:System.String.Length%2A?displayProperty=nameWithType>-1，表示目前執行個體之最後索引位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2449">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%29> method always returns <xref:System.String.Length%2A?displayProperty=nameWithType> - 1, which represents the last index position in the current instance.</span></span> <span data-ttu-id="ada9e-2450">在下列範例中，<xref:System.String.LastIndexOf%28System.String%29>方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)，後面接著"n"，選擇性連字號和選擇性的連字號後面接著"m"）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2450">In the following example, the <xref:System.String.LastIndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="ada9e-2451">只有其中一個字串包含選擇性連字號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2451">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="ada9e-2452">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在每個案例中，因為選擇性連字號是可忽略的字元，如果結果為相同因為選擇性連字號不包含在`value`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2452">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="ada9e-2453">搜尋的軟連字號只能時，這個方法會傳回 6 和 5。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2453">When searching for a soft hyphen only, the method returns 6 and 5.</span></span> <span data-ttu-id="ada9e-2454">這些值會對應至兩個字串中的最後一個字元索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2454">These values correspond to the index of the last character in the two strings.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2455">下列範例會移除開頭和結尾的字串，如果標記開始與結束字串的 HTML 標記。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2455">The following example removes opening and closing HTML tags from a string if the tags begin and end the string.</span></span> <span data-ttu-id="ada9e-2456">如果字串的結尾的右括弧字元 (">")，此範例會使用<xref:System.String.LastIndexOf%2A>方法來找出的結束標記開頭。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2456">If a string ends with a closing bracket character (">"), the example uses the <xref:System.String.LastIndexOf%2A> method to locate the start of the end tag.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2457"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2457"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2458">中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2458">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ada9e-2459">若要尋找的字串執行個體中子字串的最後一個索引，使用目前文化特性的比較規則，呼叫<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2459">To find the last index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2460">要搜尋的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2460">The Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2461">搜尋的開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2461">The starting position of the search.</span></span> <span data-ttu-id="ada9e-2462">搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2462">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="ada9e-2463">報告這個執行個體中指定之 Unicode 字元最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2463">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span></span> <span data-ttu-id="ada9e-2464">搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2464">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2465">如果找到該字元，則為 <paramref name="value" /> 的以零為起始索引位置，如果找不到該字元或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2465">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2466">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2466">Index numbering starts from zero.</span></span> <span data-ttu-id="ada9e-2467">也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1.此方法會在開始搜尋`startIndex`字元位置，這個執行個體與繼續回溯直到目前的執行個體開頭`value`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2467">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning of the current instance until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="ada9e-2468">例如，如果`startIndex`是<xref:System.String.Length%2A>-1，該方法會搜尋字串中要開始從最後一個字元的每個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2468">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span> <span data-ttu-id="ada9e-2469">搜尋會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2469">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ada9e-2470">這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2470">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ada9e-2471">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2471">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2472">下列範例會尋找所有出現的字元索引，在字串中，使用從字串的結尾字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2472">The following example finds the index of all occurrences of a character in a string, working from the end of the string to the start of the string.</span></span>  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2473">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於零，或者大於或等於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2473">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2474">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2474">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2475">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2475">The search starting position.</span></span> <span data-ttu-id="ada9e-2476">搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2476">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="ada9e-2477">回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2477">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="ada9e-2478">搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2478">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2479">如果找到該字串，則為 <paramref name="value" /> 的以零為起始索引位置，如果找不到該字串或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2479">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ada9e-2480">如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" /> 或這個執行個體之最後索引位置，取兩者中較小者。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2480">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2481">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2481">Index numbering starts from zero.</span></span> <span data-ttu-id="ada9e-2482">也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2482">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ada9e-2483">搜尋開始於`startIndex`字元位置，這個執行個體與繼續回溯直到開始朝向`value`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2483">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="ada9e-2484">例如，如果`startIndex`是<xref:System.String.Length%2A>-1，該方法會搜尋字串中要開始從最後一個字元的每個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2484">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>  
  
 <span data-ttu-id="ada9e-2485">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2485">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="ada9e-2486">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2486">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2487">執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2487">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ada9e-2488">如果`value`只包含一個或多個可忽略的字元，<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>方法一律會傳回`startIndex`，這是搜尋開始處的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2488">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="ada9e-2489">在下列範例中，<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>方法用來尋找子字串，其中包含選擇性連字號 (U + 00AD)，以及之前或在字串中加入的最後一個的"m"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2489">In the following example, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string.</span></span> <span data-ttu-id="ada9e-2490">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，搜尋字串中的選擇性連字號會被忽略，因為呼叫方法來尋找子字串，包含選擇性連字號和"m"會傳回"m"的位置在字串中，而呼叫它來尋找 substring 包含選擇性連字號和"n"會傳回"n"的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2490">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n".</span></span> <span data-ttu-id="ada9e-2491">當搜尋字串不包含只選擇性連字號時，方法會傳回"m"，其代表的值索引`startIndex`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2491">When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of `startIndex`.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2492">下列範例會尋找所有出現的字串的索引，在目標字串中，從目標字串的結尾努力的目標字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2492">The following example finds the index of all occurrences of a string in target string, working from the end of the target string to the start of the target string.</span></span>  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2493"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2493"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2494">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於零或大於目前執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2494">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span></span>  
  
<span data-ttu-id="ada9e-2495">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2495">-or-</span></span> 
<span data-ttu-id="ada9e-2496">目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於 -1 或大於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2496">The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2497">中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2497">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ada9e-2498">若要尋找特定的字元位置之前使用目前文化特性的比較規則的子字串的索引，請呼叫<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2498">To find the index of a substring that precedes a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2499">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2499">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ada9e-2500">其中一個列舉值，指定搜尋規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2500">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ada9e-2501">報告目前 <see cref="T:System.String" /> 物件中指定之字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2501">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ada9e-2502">參數會指定要用於指定字串的搜尋類型。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2502">A parameter specifies the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2503">如果找到該字串，則為 <paramref name="value" /> 參數的以零為起始的起始索引位置，否則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2503">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="ada9e-2504">如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值為這個執行個體中的最後一個索引位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2504">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2505">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2505">Index numbering starts from zero.</span></span> <span data-ttu-id="ada9e-2506">也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2506">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ada9e-2507">`comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用 word 或序數比較規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2507">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
 <span data-ttu-id="ada9e-2508">搜尋這個執行個體的最後一個字元位置開始，然後反向朝直到開始`value`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2508">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2509">下列範例示範三個多載<xref:System.String.LastIndexOf%2A>尋找使用的不同值的另一個字串內的字串中的最後一次出現的方法<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2509">The following example demonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2510"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2510"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-2511"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2511"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2512">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2512">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2513">執行區分文化特性的搜尋 (也就是說，如果 <paramref name="options" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2513">In a culture-sensitive search (that is, if <paramref name="options" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ada9e-2514">如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />方法一律會傳回<see cref="P:System.String.Length" />-1，表示目前執行個體之最後索引位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2514">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method always returns <see cref="P:System.String.Length" /> - 1, which represents the last index position in the current instance.</span></span>  
  
<span data-ttu-id="ada9e-2515">在下列範例中，<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)，後面接著"n"，選擇性連字號和選擇性的連字號後面接著"m"）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2515">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="ada9e-2516">只有其中一個字串包含選擇性連字號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2516">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="ada9e-2517">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，因為選擇性連字號是可忽略的字元，區分文化特性的搜尋會傳回相同的值，它會傳回選擇性連字號所不包含搜尋字串中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2517">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</span></span> <span data-ttu-id="ada9e-2518">序數搜尋，不過，成功於一個字串中找到選擇性連字號，並報告它不存在從第二個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2518">An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</span></span>  
  
<span data-ttu-id="ada9e-2519">[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</span><span class="sxs-lookup"><span data-stu-id="ada9e-2519">[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2520">要搜尋的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2520">The Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2521">搜尋的開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2521">The starting position of the search.</span></span> <span data-ttu-id="ada9e-2522">搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2522">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-2523">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2523">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ada9e-2524">報告這個執行個體的子字串中，指定的 Unicode 字元最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2524">Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance.</span></span> <span data-ttu-id="ada9e-2525">搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2525">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2526">如果找到該字元，則為 <paramref name="value" /> 的以零為起始索引位置，如果找不到該字元或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2526">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2527">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2527">Index numbering starts from zero.</span></span> <span data-ttu-id="ada9e-2528">也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2528">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ada9e-2529">這個方法會在開始搜尋`startIndex`字元的位置和進行回溯朝這個執行個體的開頭，直到`value`找到或`count`已檢查的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2529">This method begins searching at the `startIndex` character position and proceeds backward toward the beginning of this instance until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="ada9e-2530">例如，如果`startIndex`是<xref:System.String.Length%2A>-1，此方法會向後搜尋`count`從字串中的最後一個字元的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2530">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span> <span data-ttu-id="ada9e-2531">搜尋會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2531">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ada9e-2532">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有當其 Unicode 純量值都是相同字元即視為相當於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2532">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="ada9e-2533">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2533">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2534">下列範例會尋找所有出現的字元的索引中的子字串中，然後再從子字串的結尾努力的子字串起點。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2534">The following example finds the index of all occurrences of a character in a substring, working from the end of the substring to the start of the substring.</span></span>  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2535">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於零，或者大於或等於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2535">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span></span>  
  
<span data-ttu-id="ada9e-2536">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2536">-or-</span></span> 
<span data-ttu-id="ada9e-2537">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> - <paramref name="count" /> + 1 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2537">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" /> + 1 is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2538">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2538">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2539">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2539">The search starting position.</span></span> <span data-ttu-id="ada9e-2540">搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2540">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-2541">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2541">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ada9e-2542">回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2542">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="ada9e-2543">搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2543">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2544">如果找到該字串，則為 <paramref name="value" /> 的以零為起始索引位置，如果找不到該字串或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2544">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ada9e-2545">如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" /> 或這個執行個體之最後索引位置，取兩者中較小者。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2545">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2546">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2546">Index numbering starts from zero.</span></span> <span data-ttu-id="ada9e-2547">也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2547">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ada9e-2548">搜尋開始於`startIndex`字元位置，這個執行個體與繼續回溯直到開始朝向`value`找到或`count`已檢查的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2548">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="ada9e-2549">例如，如果`startIndex`是<xref:System.String.Length%2A>-1，此方法會向後搜尋`count`從字串中的最後一個字元的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2549">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>  
  
 <span data-ttu-id="ada9e-2550">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2550">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="ada9e-2551">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2551">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2552">執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2552">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ada9e-2553">如果`value`只包含一個或多個可忽略的字元，<xref:System.String.LastIndexOf%2A>方法一律會傳回`startIndex`，這是搜尋開始處的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2553">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%2A> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="ada9e-2554">在下列範例中，<xref:System.String.LastIndexOf%2A>方法用來尋找在前面兩個字串的最後一個"m"的兩個字元的選擇性連字號 (U + 00AD) 的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2554">In the following example, the <xref:System.String.LastIndexOf%2A> method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings.</span></span> <span data-ttu-id="ada9e-2555">只有其中一個字串包含必要的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2555">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ada9e-2556">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2556">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2557">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2557">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2558">下列範例會尋找所有出現的字串的索引中的子字串，從子字串的結尾努力的子字串起點。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2558">The following example finds the index of all occurrences of a string in substring, working from the end of the substring to the start of the substring.</span></span>  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2559"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2559"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2560"><paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2560"><paramref name="count" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-2561">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2561">-or-</span></span> 
<span data-ttu-id="ada9e-2562">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2562">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-2563">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2563">-or-</span></span> 
<span data-ttu-id="ada9e-2564">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 大於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2564">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span></span>  
  
<span data-ttu-id="ada9e-2565">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2565">-or-</span></span> 
<span data-ttu-id="ada9e-2566">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> - <paramref name="count" />+ 1 指定的位置不在此執行個體之內。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2566">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" />+ 1 specifies a position that is not within this instance.</span></span>  
  
<span data-ttu-id="ada9e-2567">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2567">-or-</span></span> 
<span data-ttu-id="ada9e-2568">目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="start" /> 小於 -1 或大於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2568">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span></span>  
  
<span data-ttu-id="ada9e-2569">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2569">-or-</span></span> 
<span data-ttu-id="ada9e-2570">目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="count" /> 大於 1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2570">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2571">中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2571">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ada9e-2572">若要使用目前文化特性的比較規則，以執行這項作業，請呼叫<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2572">To perform this operation by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2573">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2573">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2574">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2574">The search starting position.</span></span> <span data-ttu-id="ada9e-2575">搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2575">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ada9e-2576">其中一個列舉值，指定搜尋規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2576">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ada9e-2577">報告目前 <see cref="T:System.String" /> 物件中指定之字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2577">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="ada9e-2578">搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2578">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span> <span data-ttu-id="ada9e-2579">參數會指定搜尋指定字串時要執行的比較類型。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2579">A parameter specifies the type of comparison to perform when searching for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2580">如果找到該字串，則為 <paramref name="value" /> 參數以零為起始的索引位置，如果找不到該字串或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2580">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ada9e-2581">如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" /> 或這個執行個體之最後索引位置，取兩者中較小者。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2581">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2582">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2582">Index numbering starts from zero.</span></span> <span data-ttu-id="ada9e-2583">也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2583">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ada9e-2584">搜尋開始於`startIndex`字元位置與繼續回溯直到`value`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2584">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="ada9e-2585">例如，如果`startIndex`是<xref:System.String.Length%2A>-1，該方法會搜尋字串中要開始從最後一個字元的每個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2585">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>  
  
 <span data-ttu-id="ada9e-2586">`comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用 word 或序數比較規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2586">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2587">下列範例示範三個多載<xref:System.String.LastIndexOf%2A>尋找使用的不同值的另一個字串內的字串中的最後一次出現的方法<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2587">The following example demonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2588"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2588"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2589">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於零或大於目前執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2589">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span></span>  
  
<span data-ttu-id="ada9e-2590">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2590">-or-</span></span> 
<span data-ttu-id="ada9e-2591">目前的執行個體等於 <see cref="F:System.String.Empty" /> 且 <paramref name="startIndex" /> 小於 -1 或大於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2591">The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-2592"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2592"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2593">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2593">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2594">執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2594">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ada9e-2595">如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />方法一律會傳回<paramref name="startIndex" />，這是搜尋開始處的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2595">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
<span data-ttu-id="ada9e-2596">在下列範例中，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />方法用來尋找後面接著"m"，開頭為兩個字串中的"m"最後一個選擇性連字號 (U + 00AD) 的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2596">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m", starting with the final "m" in two strings.</span></span> <span data-ttu-id="ada9e-2597">只有其中一個字串包含必要的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2597">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ada9e-2598">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2598">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2599">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2599">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span> <span data-ttu-id="ada9e-2600">只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2600">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
<span data-ttu-id="ada9e-2601">[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</span><span class="sxs-lookup"><span data-stu-id="ada9e-2601">[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-2602">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2602">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2603">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2603">The search starting position.</span></span> <span data-ttu-id="ada9e-2604">搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2604">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-2605">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2605">The number of character positions to examine.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ada9e-2606">其中一個列舉值，指定搜尋規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2606">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="ada9e-2607">回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2607">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="ada9e-2608">搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2608">The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions.</span></span> <span data-ttu-id="ada9e-2609">參數會指定搜尋指定字串時要執行的比較類型。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2609">A parameter specifies the type of comparison to perform when searching for the specified string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2610">如果找到該字串，則為 <paramref name="value" /> 參數以零為起始的索引位置，如果找不到該字串或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2610">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="ada9e-2611">如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" /> 或這個執行個體之最後索引位置，取兩者中較小者。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2611">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2612">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2612">Index numbering starts from zero.</span></span> <span data-ttu-id="ada9e-2613">也就是在字串中的第一個字元索引位置為零且最後一個在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2613">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="ada9e-2614">搜尋開始於`startIndex`字元位置與繼續回溯直到`value`找到或`count`已檢查的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2614">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="ada9e-2615">例如，如果`startIndex`是<xref:System.String.Length%2A>-1，此方法會向後搜尋`count`從字串中的最後一個字元的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2615">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>  
  
 <span data-ttu-id="ada9e-2616">`comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用 word 或序數比較規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2616">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2617">下列範例示範三個多載<xref:System.String.LastIndexOf%2A>尋找使用的不同值的另一個字串內的字串中的最後一次出現的方法<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2617">The following example demonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2618"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2618"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2619"><paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2619"><paramref name="count" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-2620">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2620">-or-</span></span> 
<span data-ttu-id="ada9e-2621">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2621">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-2622">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2622">-or-</span></span> 
<span data-ttu-id="ada9e-2623">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 大於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2623">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span></span>  
  
<span data-ttu-id="ada9e-2624">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2624">-or-</span></span> 
<span data-ttu-id="ada9e-2625">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> + 1 - <paramref name="count" /> 指定的位置不在此執行個體之內。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2625">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> + 1 - <paramref name="count" /> specifies a position that is not within this instance.</span></span>  
  
<span data-ttu-id="ada9e-2626">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2626">-or-</span></span> 
<span data-ttu-id="ada9e-2627">目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="start" /> 小於 -1 或大於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2627">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span></span>  
  
<span data-ttu-id="ada9e-2628">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2628">-or-</span></span> 
<span data-ttu-id="ada9e-2629">目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="count" /> 大於 1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2629">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-2630"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2630"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2631">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2631">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2632">執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2632">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="ada9e-2633">如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法一律會傳回<paramref name="startIndex" />，這是搜尋開始處的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2633">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
<span data-ttu-id="ada9e-2634">在下列範例中，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法用來在兩個字串中尋找的選擇性連字號 (U + 00AD) 後面接著"m"中所有的位置，但第一個字元位置之前的最終"m"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2634">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in all but the first character position before the final "m" in two strings.</span></span> <span data-ttu-id="ada9e-2635">只有其中一個字串包含必要的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2635">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="ada9e-2636">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2636">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2637">當它執行序數比較時，不過，它會尋找子字串只在第一個字串中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2637">When it performs an ordinal comparison, however, it finds the substring only in the first string.</span></span> <span data-ttu-id="ada9e-2638">請注意，第一個字串，其中包含選擇性的連字號後面接著"m"，如果方法無法傳回選擇性連字號的索引，但改為傳回"m"的索引，當它執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2638">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="ada9e-2639">只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2639">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
<span data-ttu-id="ada9e-2640">[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</span><span class="sxs-lookup"><span data-stu-id="ada9e-2640">[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-2641">報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2641">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="ada9e-2642">如果在此執行個體中找不到陣列中的字元，此方法會傳回 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2642">The method returns -1 if the characters in the array are not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ada9e-2643">Unicode 字元陣列，含有一或多個要搜尋的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2643">A Unicode character array containing one or more characters to seek.</span></span></param>
        <summary><span data-ttu-id="ada9e-2644">報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2644">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2645">這個執行個體中最後項目的索引位置，其中找到了 <paramref name="anyOf" /> 中的任何字元，如果 <paramref name="anyOf" /> 中沒有找到任何字元，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2645">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2646">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2646">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ada9e-2647">這個方法會在這個執行個體的最後一個字元位置開始搜尋，然後反向朝中任一個字元之前開頭`anyOf`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2647">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="ada9e-2648">搜尋會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2648">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ada9e-2649">這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2649">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ada9e-2650">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2650">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2651">下列範例會尋找索引的任何字元字串中最後一次出現 「 是 」 在另一個字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2651">The following example finds the index of the last occurrence of any character in the string "is" within another string.</span></span>  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2652"><paramref name="anyOf" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2652"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ada9e-2653">Unicode 字元陣列，含有一或多個要搜尋的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2653">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2654">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2654">The search starting position.</span></span> <span data-ttu-id="ada9e-2655">搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2655">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="ada9e-2656">報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2656">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="ada9e-2657">搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2657">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2658">所找到之 <paramref name="anyOf" /> 的任何字元，在這個執行個體中最後一次出現的索引位置；如果找不到 <paramref name="anyOf" /> 中的字元，或目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2658">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2659">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2659">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ada9e-2660">這個方法會在開始搜尋`startIndex`字元位置，這個執行個體與回溯到中的任一個字元之前開頭繼續`anyOf`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2660">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="ada9e-2661">搜尋會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2661">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ada9e-2662">這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2662">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ada9e-2663">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2663">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2664">下列範例會尋找任何字元字串中最後一個出現的索引"is"另一個字串的子字串內。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2664">The following example finds the index of the last occurrence of any character in the string "is" within a substring of another string.</span></span>  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2665"><paramref name="anyOf" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2665"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2666">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 指定的位置不在這個執行個體之內。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2666">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> specifies a position that is not within this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="ada9e-2667">Unicode 字元陣列，含有一或多個要搜尋的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2667">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="ada9e-2668">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2668">The search starting position.</span></span> <span data-ttu-id="ada9e-2669">搜尋會從 <paramref name="startIndex" /> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2669">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-2670">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2670">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="ada9e-2671">報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2671">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="ada9e-2672">搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2672">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2673">所找到之 <paramref name="anyOf" /> 的任何字元，在這個執行個體中最後一次出現的索引位置；如果找不到 <paramref name="anyOf" /> 中的字元，或目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2673">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2674">編號從零開始編製索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2674">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="ada9e-2675">這個方法會在開始搜尋`startIndex`字元位置，這個執行個體與繼續回溯直到中任一個的字元開頭`anyOf`找到或`count`已檢查的字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2675">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="ada9e-2676">搜尋會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2676">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="ada9e-2677">這個方法會執行序數 （不區分文化特性） 搜尋，其中字元視為相當於另一個字元才 Unicode 純量值都相同。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2677">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="ada9e-2678">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值，表示為預先的字元，例如連音符號"Æ 」 (U + 00 C 6)，可能會被視為字元的元件中的任何項目請更正順序，例如"AE"(u+0041，U + 0045)，這取決於文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2678">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2679">下列範例會尋找另一個字串的子字串內最後一個相符的字串"輔助工具 」 中的任何字元的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2679">The following example finds the index of the last occurrence of any character in the string "aid" within a substring of another string.</span></span>  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2680"><paramref name="anyOf" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2680"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2681">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="count" /> 或 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2681">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
<span data-ttu-id="ada9e-2682">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2682">-or-</span></span> 
<span data-ttu-id="ada9e-2683">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> - <paramref name="count" /> + 1 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2683">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> minus <paramref name="count" /> + 1 is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ada9e-2684">取得目前 <see cref="T:System.String" /> 物件中字元的數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2684">Gets the number of characters in the current <see cref="T:System.String" /> object.</span></span></summary>
        <value><span data-ttu-id="ada9e-2685">目前字串中的字元數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2685">The number of characters in the current string.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2686"><xref:System.String.Length%2A>屬性傳回的數目<xref:System.Char>這個執行個體中的物件，不是 Unicode 字元的數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2686">The <xref:System.String.Length%2A> property returns the number of <xref:System.Char> objects in this instance, not the number of Unicode characters.</span></span> <span data-ttu-id="ada9e-2687">原因是 Unicode 字元可能會表示由多個<xref:System.Char>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2687">The reason is that a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="ada9e-2688">使用<xref:System.Globalization.StringInfo?displayProperty=nameWithType>類別來使用每個 Unicode 字元，而不是每個<xref:System.Char>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2688">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with each Unicode character instead of each <xref:System.Char>.</span></span>  
  
 <span data-ttu-id="ada9e-2689">在某些語言，例如 C 和C++，null 字元表示字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2689">In some languages, such as C and C++, a null character indicates the end of a string.</span></span> <span data-ttu-id="ada9e-2690">在.NET 中，可以在字串中內嵌的 null 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2690">In .NET, a null character can be embedded in a string.</span></span> <span data-ttu-id="ada9e-2691">當字串包含一或多個 null 字元時，它們會包含在總字串的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2691">When a string includes one or more null characters, they are included in the length of the total string.</span></span> <span data-ttu-id="ada9e-2692">例如，在下列字串"abc"和"def"會以 null 字元分隔的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2692">For example, in the following string, the substrings "abc" and "def" are separated by a null character.</span></span> <span data-ttu-id="ada9e-2693"><xref:System.String.Length%2A>屬性會傳回 7，這表示它包含六個字母的字元，以及 null 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2693">The <xref:System.String.Length%2A> property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.</span></span>  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2694">下列範例示範<xref:System.String.Length%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2694">The following example demonstrates the <xref:System.String.Length%2A> property.</span></span>  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-2695">傳回新的字串，其二進位表示為特定的 Unicode 正規化格式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2695">Returns a new string whose binary representation is in a particular Unicode normalization form.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-2696">傳回新的字串，其文字值與這個字串相同，但是其二進位表示為 Unicode 正規化格式 C。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2696">Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2697">新的正規化字串，其文字值與這個字串相同，但是其二進位表示為正規化格式 C。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2697">A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2698">某些 Unicode 字元有多個對等的二進位表示，其中包含結合的集合及/或複合的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2698">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="ada9e-2699">例如，任何下列的字碼指標可以代表字母"ắ 」:</span><span class="sxs-lookup"><span data-stu-id="ada9e-2699">For example, any of the following code points can represent the letter "ắ":</span></span>  
  
-   <span data-ttu-id="ada9e-2700">U+1EAF</span><span class="sxs-lookup"><span data-stu-id="ada9e-2700">U+1EAF</span></span>  
  
-   <span data-ttu-id="ada9e-2701">U+0103 U+0301</span><span class="sxs-lookup"><span data-stu-id="ada9e-2701">U+0103 U+0301</span></span>  
  
-   <span data-ttu-id="ada9e-2702">U+0061 U+0306 U+0301</span><span class="sxs-lookup"><span data-stu-id="ada9e-2702">U+0061 U+0306 U+0301</span></span>  
  
 <span data-ttu-id="ada9e-2703">搜尋、 排序、 比對，以及其他作業，則存在單一字元的多種表示法變得非常複雜。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2703">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="ada9e-2704">Unicode 標準會定義稱為傳回一個二進位表示法指定任何對等的二進位表示的字元時的正規化程序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2704">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="ada9e-2705">可使用數種演算法，稱為正規化表單，可遵循不同的規則執行正規化。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2705">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="ada9e-2706">.NET 支援的四個正規化表單 （C、 D、 KC 和 KD） 由 Unicode 標準所定義。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2706">.NET supports the four normalization forms (C, D, KC, and KD) that are defined by the Unicode standard.</span></span> <span data-ttu-id="ada9e-2707">當兩個字串會以相同的正規化形式表示時，他們可以使用序數比較來比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2707">When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="ada9e-2708">若要正常化，並比較兩個字串，執行下列作業：</span><span class="sxs-lookup"><span data-stu-id="ada9e-2708">To normalize and compare two strings, do the following:</span></span>  
  
1.  <span data-ttu-id="ada9e-2709">取得可用來從輸入來源，例如檔案或使用者的輸入的裝置要比較的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2709">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>  
  
2.  <span data-ttu-id="ada9e-2710">呼叫<xref:System.String.Normalize>方法，以將字串標準化為正規化格式 c。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2710">Call the <xref:System.String.Normalize> method to normalize the strings to normalization form C.</span></span>  
  
3.  <span data-ttu-id="ada9e-2711">若要比較兩個字串，呼叫的方法，支援的序數字串比較，例如<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，並提供的值<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>做為<xref:System.StringComparison>引數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2711">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="ada9e-2712">若要排序的正規化字串陣列，請傳遞`comparer`的值<xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType>或<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType>的適當多載來<xref:System.Array.Sort%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2712">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>  
  
4.  <span data-ttu-id="ada9e-2713">發出根據上一個步驟所指示的順序排序的輸出中的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2713">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>  
  
 <span data-ttu-id="ada9e-2714">如需支援的 Unicode 正規化格式的說明，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2714">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2715">下列範例會將字串標準化為每個四種的正規化形式，、 確認字串已標準化為指定的正規化表單，然後列出的正規化字串中的字碼指標。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2715">The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-2716">目前的執行個體包含無效的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2716">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2717"><see cref="Overload:System.String.IsNormalized" />方法會傳回<see langword="false" />當它遇到第一個非標準化字元在字串中的。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2717">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="ada9e-2718">因此，如果字串包含非標準化的字元，後面接著無效的 Unicode 字元<see cref="Overload:System.String.Normalize" />方法會擲回<see cref="T:System.ArgumentException" />雖然<see cref="Overload:System.String.IsNormalized" />傳回<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2718">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm"><span data-ttu-id="ada9e-2719">Unicode 正規化格式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2719">A Unicode normalization form.</span></span></param>
        <summary><span data-ttu-id="ada9e-2720">傳回新的字串，其文字值與這個字串相同，但是其二進位表示為特定的 Unicode 正規化格式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2720">Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2721">新的字串，其文字值與這個字串相同，但是其二進位表示為 <paramref name="normalizationForm" /> 參數指定的正規化格式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2721">A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <paramref name="normalizationForm" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2722">某些 Unicode 字元有多個對等的二進位表示，其中包含結合的集合及/或複合的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2722">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="ada9e-2723">搜尋、 排序、 比對，以及其他作業，則存在單一字元的多種表示法變得非常複雜。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2723">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="ada9e-2724">Unicode 標準會定義稱為傳回一個二進位表示法指定任何對等的二進位表示的字元時的正規化程序。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2724">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="ada9e-2725">可使用數種演算法，稱為正規化表單，可遵循不同的規則執行正規化。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2725">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="ada9e-2726">.NET 支援的四個正規化表單 （C、 D、 KC 和 KD） 由 Unicode 標準所定義。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2726">.NET supports the four normalization forms (C, D, KC, and KD) that are defined by the Unicode standard.</span></span> <span data-ttu-id="ada9e-2727">當兩個字串會以相同的正規化形式表示時，他們可以使用序數比較來比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2727">When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="ada9e-2728">若要正常化，並比較兩個字串，執行下列作業：</span><span class="sxs-lookup"><span data-stu-id="ada9e-2728">To normalize and compare two strings, do the following:</span></span>  
  
1.  <span data-ttu-id="ada9e-2729">取得可用來從輸入來源，例如檔案或使用者的輸入的裝置要比較的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2729">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>  
  
2.  <span data-ttu-id="ada9e-2730">呼叫<xref:System.String.Normalize%28System.Text.NormalizationForm%29>方法，以將字串標準化為指定的正規化格式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2730">Call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29> method to normalize the strings to a specified normalization form.</span></span>  
  
3.  <span data-ttu-id="ada9e-2731">若要比較兩個字串，呼叫的方法，支援的序數字串比較，例如<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，並提供的值<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>做為<xref:System.StringComparison>引數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2731">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="ada9e-2732">若要排序的正規化字串陣列，請傳遞`comparer`的值<xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType>或<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType>的適當多載來<xref:System.Array.Sort%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2732">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>  
  
4.  <span data-ttu-id="ada9e-2733">發出根據上一個步驟所指示的順序排序的輸出中的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2733">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>  
  
 <span data-ttu-id="ada9e-2734">如需支援的 Unicode 正規化格式的說明，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2734">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2735">下列範例會將字串標準化為每個四種的正規化形式，、 確認字串已標準化為指定的正規化表單，然後列出的正規化字串中的字碼指標。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2735">The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-2736">目前的執行個體包含無效的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2736">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2737"><see cref="Overload:System.String.IsNormalized" />方法會傳回<see langword="false" />當它遇到第一個非標準化字元在字串中的。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2737">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="ada9e-2738">因此，如果字串包含非標準化的字元，後面接著無效的 Unicode 字元<see cref="Overload:System.String.Normalize" />方法可能會擲回<see cref="T:System.ArgumentException" />雖然<see cref="Overload:System.String.IsNormalized" />傳回<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2738">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method may throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="ada9e-2739">要比較的第一個字串，或是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2739">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="ada9e-2740">要比較的第二個字串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2740">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-2741">判斷兩個指定的字串是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2741">Determines whether two specified strings have the same value.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2742">如果 <see langword="true" /> 的值與 <paramref name="a" /> 的值相同，則為 <paramref name="b" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2742"><see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2743"><xref:System.String.op_Equality%2A>方法來定義等號比較運算子的營運<xref:System.String>類別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2743">The <xref:System.String.op_Equality%2A> method defines the operation of the equality operator for the <xref:System.String> class.</span></span> <span data-ttu-id="ada9e-2744">它可讓程式碼，例如，範例 > 一節所示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2744">It enables code such as that shown in the Example section.</span></span> <span data-ttu-id="ada9e-2745">運算子，再轉而呼叫靜態<xref:System.String.Equals%28System.String%2CSystem.String%29>方法，這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2745">The operator, in turn, calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-2746">Visual Basic 編譯器不會解析為對進行呼叫的等號比較運算子<xref:System.String.op_Equality%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2746">The Visual Basic compiler does not resolve the equality operator as a call to the <xref:System.String.op_Equality%2A> method.</span></span> <span data-ttu-id="ada9e-2747">相反地，等號比較運算子會包裝對呼叫<xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2747">Instead, the equality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2748">下列範例示範等號比較運算子。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2748">The following example demonstrates the equality operator.</span></span>  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="ada9e-2749">要比較的第一個字串，或是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2749">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="ada9e-2750">要比較的第二個字串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2750">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-2751">判斷兩個指定的字串是否具有不同的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2751">Determines whether two specified strings have different values.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2752">如果 <see langword="true" /> 的值與 <paramref name="a" /> 的值不同，則為 <paramref name="b" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2752"><see langword="true" /> if the value of <paramref name="a" /> is different from the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2753"><xref:System.String.op_Inequality%2A>方法定義的不等比較運算子的營運<xref:System.String>類別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2753">The <xref:System.String.op_Inequality%2A> method defines the operation of the inequality operator for the <xref:System.String> class.</span></span>   <span data-ttu-id="ada9e-2754">它可讓程式碼，例如，範例 > 一節所示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2754">It enables code such as that shown in the Examples section.</span></span>  
  
 <span data-ttu-id="ada9e-2755"><xref:System.String.op_Inequality%2A>運算子會接著呼叫靜態<xref:System.String.Equals%28System.String%2CSystem.String%29>方法，這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2755">The <xref:System.String.op_Inequality%2A> operator in turn calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-2756">Visual Basic 編譯器不會解析為對進行呼叫的不等比較運算子<xref:System.String.op_Inequality%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2756">The Visual Basic compiler does not resolve the inequality operator as a call to the <xref:System.String.op_Inequality%2A> method.</span></span> <span data-ttu-id="ada9e-2757">相反地，不等比較運算子會包裝對呼叫<xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2757">Instead, the inequality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2758">下列範例示範不等比較運算子。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2758">The following example demonstrates the inequality operator.</span></span>  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-2759">傳回指定之長度的新字串，其中目前字串的開頭將以空白和或指定的 Unicode 字元填補。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2759">Returns a new string of a specified length in which the beginning of the current string is padded with spaces or with a specified Unicode character.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="ada9e-2760">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2760">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <summary><span data-ttu-id="ada9e-2761">傳回新字串，此字串會以空格填補左側至指定的總長度，靠右對齊這個執行個體中的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2761">Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2762">與這個執行個體相等的新字串，但為靠右對齊，並在左側視需要填補若干空間來建立 <paramref name="totalWidth" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2762">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="ada9e-2763">但是，如果 <paramref name="totalWidth" /> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2763">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="ada9e-2764">如果 <paramref name="totalWidth" /> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2764">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2765">Unicode 空間會定義為十六進位 0x0020。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2765">A Unicode space is defined as hexadecimal 0x0020.</span></span>  
  
 <span data-ttu-id="ada9e-2766"><xref:System.String.PadLeft%28System.Int32%29>方法會傳回字串的開頭來填補。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2766">The <xref:System.String.PadLeft%28System.Int32%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="ada9e-2767">這表示，用於由右至左的語言，它會填補字串的右邊部分。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2767">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-2768">如果<xref:System.String.PadLeft%2A>方法填補空格字元，目前的執行個體，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2768">If the <xref:System.String.PadLeft%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-2769">相反地，它會傳回新字串，使其總長度前置空白字元填補`totalWidth`字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2769">Instead, it returns a new string that is padded with leading white space so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2770">下列範例示範<xref:System.String.PadLeft%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2770">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2771"><paramref name="totalWidth" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2771"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="ada9e-2772">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2772">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <param name="paddingChar"><span data-ttu-id="ada9e-2773">Unicode 填補字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2773">A Unicode padding character.</span></span></param>
        <summary><span data-ttu-id="ada9e-2774">傳回新字串，此字串會以指定的 Unicode 字元填補左側至指定的總長度，靠右對齊這個執行個體中的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2774">Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2775">與這個執行個體相等的新字串，但為靠右對齊，並在左側視需要填補若干 <paramref name="paddingChar" /> 字元來建立 <paramref name="totalWidth" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2775">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="ada9e-2776">但是，如果 <paramref name="totalWidth" /> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2776">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="ada9e-2777">如果 <paramref name="totalWidth" /> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2777">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2778"><xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29>方法會傳回字串的開頭來填補。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2778">The <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="ada9e-2779">這表示，用於由右至左的語言，它會填補字串的右邊部分。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2779">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-2780">如果<xref:System.String.PadLeft%2A>方法填補空格字元，目前的執行個體，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2780">If the <xref:System.String.PadLeft%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-2781">相反地，它會傳回新字串，會使用前置填補`paddingChar`個字元，使其總長度`totalWidth`字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2781">Instead, it returns a new string that is padded with leading `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2782">下列範例示範<xref:System.String.PadLeft%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2782">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2783"><paramref name="totalWidth" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2783"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-2784">傳回指定之長度的新字串，其中目前字串的結尾將以空白和或指定的 Unicode 字元填補。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2784">Returns a new string of a specified length in which the end of the current string is padded with spaces or with a specified Unicode character.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="ada9e-2785">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2785">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <summary><span data-ttu-id="ada9e-2786">傳回新字串，此字串會以空格填補右側至指定的總長度，靠左對齊這個字串中的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2786">Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2787">與這個執行個體相等的新字串，但為靠左對齊，並在右側視需要填補若干空間來建立 <paramref name="totalWidth" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2787">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="ada9e-2788">但是，如果 <paramref name="totalWidth" /> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2788">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="ada9e-2789">如果 <paramref name="totalWidth" /> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2789">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2790">Unicode 空間會定義為十六進位 0x0020。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2790">A Unicode space is defined as hexadecimal 0x0020.</span></span>  
  
 <span data-ttu-id="ada9e-2791"><xref:System.String.PadRight%28System.Int32%29>方法會傳回字串的結尾來填補。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2791">The <xref:System.String.PadRight%28System.Int32%29> method pads the end of the returned string.</span></span> <span data-ttu-id="ada9e-2792">這表示，用於由右至左的語言，它會填補字串的左側的部分。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2792">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-2793">如果<xref:System.String.PadRight%2A>方法填補空格字元，目前的執行個體，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2793">If the <xref:System.String.PadRight%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-2794">相反地，它會傳回新字串，使其總長度，以尾端的空白字元會填補`totalWidth`字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2794">Instead, it returns a new string that is padded with trailing white space so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2795">下列範例示範<xref:System.String.PadRight%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2795">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2796"><paramref name="totalWidth" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2796"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="ada9e-2797">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2797">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <param name="paddingChar"><span data-ttu-id="ada9e-2798">Unicode 填補字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2798">A Unicode padding character.</span></span></param>
        <summary><span data-ttu-id="ada9e-2799">傳回新字串，此字串會以指定的 Unicode 字元填補右側至指定的總長度，靠左對齊這個字串中的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2799">Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2800">與這個執行個體相等的新字串，但為靠左對齊，並在右側視需要填補若干 <paramref name="paddingChar" /> 字元來建立 <paramref name="totalWidth" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2800">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="ada9e-2801">但是，如果 <paramref name="totalWidth" /> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2801">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="ada9e-2802">如果 <paramref name="totalWidth" /> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2802">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2803"><xref:System.String.PadRight%28System.Int32%2CSystem.Char%29>方法會傳回字串的結尾來填補。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2803">The <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> method pads the end of the returned string.</span></span> <span data-ttu-id="ada9e-2804">這表示，用於由右至左的語言，它會填補字串的左側的部分。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2804">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-2805">如果<xref:System.String.PadRight%2A>方法填補空格字元，目前的執行個體，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2805">If the <xref:System.String.PadRight%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-2806">相反地，它會傳回新字串，會以尾端填補`paddingChar`個字元，使其總長度`totalWidth`字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2806">Instead, it returns a new string that is padded with trailing `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2807">下列範例示範<xref:System.String.PadRight%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2807">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2808"><paramref name="totalWidth" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2808"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-2809">傳回新字串，其中刪除了目前字串中指定的字元數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2809">Returns a new string in which a specified number of characters from the current string are deleted.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ada9e-2810">要開始刪除字元之以零為起始的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2810">The zero-based position to begin deleting characters.</span></span></param>
        <summary><span data-ttu-id="ada9e-2811">傳回新字串，其中已刪除目前執行個體中的所有字元 (從指定位置開始到最後一個位置為止)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2811">Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2812">新字串，除了已移除的字元以外，其餘部分都與這個字串相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2812">A new string that is equivalent to this string except for the removed characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2813">在  [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]，字串是以零為起始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2813">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="ada9e-2814">值`startIndex`參數的範圍可以介於零到字串執行個體的長度大於或等於。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2814">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-2815">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2815">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-2816">相反地，它會傳回新的字串中的所有字元位置`startIndex`原始字串的結尾已移除。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2816">Instead, it returns a new string in which all characters from position `startIndex` to the end of the original string have been removed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2817">下列範例示範<xref:System.String.Remove%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2817">The following example demonstrates the <xref:System.String.Remove%2A> method.</span></span> <span data-ttu-id="ada9e-2818">下一步 倒數第二個案例中，會移除從指定的索引，到字串結尾的所有文字。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2818">The next-to-last case removes all text starting from the specified index through the end of the string.</span></span> <span data-ttu-id="ada9e-2819">最後這個情況下會移除從指定的索引開始的三個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2819">The last case removes three characters starting from the specified index.</span></span>  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2820"><paramref name="startIndex" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2820"><paramref name="startIndex" /> is less than zero.</span></span>  
  
<span data-ttu-id="ada9e-2821">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2821">-or-</span></span> 
 <span data-ttu-id="ada9e-2822"><paramref name="startIndex" /> 指定不在此字串內的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2822"><paramref name="startIndex" /> specifies a position that is not within this string.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ada9e-2823">要開始刪除字元之以零為起始的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2823">The zero-based position to begin deleting characters.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-2824">要刪除的字元數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2824">The number of characters to delete.</span></span></param>
        <summary><span data-ttu-id="ada9e-2825">傳回新字串，其中已刪除在目前執行個體中指定位置開始之指定數目的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2825">Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2826">新字串，除了已移除的字元以外，其餘部分都與這個執行個體相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2826">A new string that is equivalent to this instance except for the removed characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2827">在  [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]，字串是以零為起始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2827">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="ada9e-2828">值`startIndex`參數的範圍可以介於零到字串執行個體的長度大於或等於。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2828">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-2829">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2829">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-2830">相反地，它會傳回新字串的字元數所指定`count`已移除參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2830">Instead, it returns a new string in which the number of characters specified by the `count` parameter have been removed.</span></span> <span data-ttu-id="ada9e-2831">字元會在所指定的位置移除`startIndex`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2831">The characters are removed at the position specified by `startIndex`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2832">下列範例會示範如何移除中間名的完整名稱。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2832">The following example demonstrates how you can remove the middle name from a complete name.</span></span>  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-2833"><paramref name="startIndex" /> 或 <paramref name="count" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2833">Either <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="ada9e-2834">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-2834">-or-</span></span> 
 <span data-ttu-id="ada9e-2835"><paramref name="startIndex" /> 加上 <paramref name="count" /> 指定的位置超出此執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2835"><paramref name="startIndex" /> plus <paramref name="count" /> specify a position outside this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-2836">傳回新字串，其中目前字串中指定之 Unicode 字元或 <see cref="T:System.String" /> 的所有項目，全都會被取代成另一個指定的 Unicode 字元或 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2836">Returns a new string in which all occurrences of a specified Unicode character or <see cref="T:System.String" /> in the current string are replaced with another specified Unicode character or <see cref="T:System.String" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar"><span data-ttu-id="ada9e-2837">要被取代的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2837">The Unicode character to be replaced.</span></span></param>
        <param name="newChar"><span data-ttu-id="ada9e-2838">要用來取代所有出現之 <paramref name="oldChar" /> 的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2838">The Unicode character to replace all occurrences of <paramref name="oldChar" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-2839">傳回新字串，其中這個執行個體中所有出現的指定 Unicode 字元都取代成其他指定的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2839">Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2840">相當於這個執行個體的字串，只是 <paramref name="oldChar" /> 的所有執行個體都會取代成 <paramref name="newChar" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2840">A string that is equivalent to this instance except that all instances of <paramref name="oldChar" /> are replaced with <paramref name="newChar" />.</span></span> <span data-ttu-id="ada9e-2841">如果在目前的執行個體中找不到 <paramref name="oldChar" />，則方法傳回未變更的目前執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2841">If <paramref name="oldChar" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2842">這個方法會執行序數 （區分大小寫且區分文化特性） 搜尋來尋找`oldChar`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2842">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldChar`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-2843">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2843">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-2844">相反地，它會傳回新的字串中的所有項目`oldChar`會取代`newChar`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2844">Instead, it returns a new string in which all occurrences of `oldChar` are replaced by `newChar`.</span></span>  
  
 <span data-ttu-id="ada9e-2845">因為這個方法會傳回已修改的字串，您可以鏈結在一起後續呼叫<xref:System.String.Replace%2A>方法，以在原始字串上執行多個替代項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2845">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="ada9e-2846">方法呼叫從左到右執行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2846">Method calls are executed from left to right.</span></span> <span data-ttu-id="ada9e-2847">下列範例提供一個實例。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2847">The following example provides an illustration.</span></span>  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2848">下列範例會建立以逗號分隔值清單所得到的一系列數字之間的空白。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2848">The following example creates a comma separated value list by substituting commas for the blanks between a series of numbers.</span></span>  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="ada9e-2849">要被取代的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2849">The string to be replaced.</span></span></param>
        <param name="newValue"><span data-ttu-id="ada9e-2850">用來取代所有出現之 <paramref name="oldValue" /> 的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2850">The string to replace all occurrences of <paramref name="oldValue" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-2851">傳回新字串，其中目前執行個體中所有出現的指定字串，都取代成其他指定的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2851">Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2852">相當於目前字串的字串，只是 <paramref name="oldValue" /> 的所有執行個體都會取代成 <paramref name="newValue" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2852">A string that is equivalent to the current string except that all instances of <paramref name="oldValue" /> are replaced with <paramref name="newValue" />.</span></span> <span data-ttu-id="ada9e-2853">如果在目前的執行個體中找不到 <paramref name="oldValue" />，則方法傳回未變更的目前執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2853">If <paramref name="oldValue" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2854">如果`newValue`已`null`，所有出現的`oldValue`會移除。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2854">If `newValue` is `null`, all occurrences of `oldValue` are removed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-2855">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2855">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-2856">相反地，它會傳回新的字串中的所有項目`oldValue`會取代`newValue`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2856">Instead, it returns a new string in which all occurrences of `oldValue` are replaced by `newValue`.</span></span>  
  
 <span data-ttu-id="ada9e-2857">這個方法會執行序數 （區分大小寫且區分文化特性） 搜尋來尋找`oldValue`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2857">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldValue`.</span></span>  
  
 <span data-ttu-id="ada9e-2858">因為這個方法會傳回已修改的字串，您可以鏈結在一起後續呼叫<xref:System.String.Replace%2A>方法，以在原始字串上執行多個替代項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2858">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="ada9e-2859">方法呼叫從左到右執行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2859">Method calls are executed from left to right.</span></span> <span data-ttu-id="ada9e-2860">下列範例提供一個實例。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2860">The following example provides an illustration.</span></span>  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-2861">下列範例示範如何使用<xref:System.String.Replace%2A>更正拼字錯誤的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2861">The following example demonstrates how you can use the <xref:System.String.Replace%2A> method to correct a spelling error.</span></span>  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-2862"><paramref name="oldValue" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2862"><paramref name="oldValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-2863"><paramref name="oldValue" /> 為空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2863"><paramref name="oldValue" /> is the empty string ("").</span></span></exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-2864">傳回字串陣列，這個陣列包含這個執行個體中，由指定的字串或 Unicode 字元陣列之項目所分隔的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2864">Returns a string array that contains the substrings in this instance that are delimited by elements of a specified string or Unicode character array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2865"><xref:System.String.Split%2A> 用來 break 分隔的字串成子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2865"><xref:System.String.Split%2A> is used to break a delimited string into substrings.</span></span> <span data-ttu-id="ada9e-2866">您可用來指定零個、 一個或多個分隔字元的字元陣列 (<xref:System.String.Split%28System.Char%5B%5D%29>方法)，或者您可以使用的字元陣列，指定零個、 一個或多個分隔的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2866">You can use either a character array to specify zero, one, or multiple delimiting characters (the <xref:System.String.Split%28System.Char%5B%5D%29> method), or you can use a character array to specify zero, one, or multiple delimiting strings.</span></span> <span data-ttu-id="ada9e-2867">多載<xref:System.String.Split%2A>方法可讓您限制的方法所傳回的子字串數目 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29>方法)，以判斷傳回的子字串中是否包含空字串 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29>和<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>方法，或以這兩種 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>和<xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>方法)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2867">Overloads of the <xref:System.String.Split%2A> method allow you to limit the number of substrings returned by the method (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> method), to determine whether empty strings are included in the returned substrings (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> methods, or to do both (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> methods).</span></span>  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a><span data-ttu-id="ada9e-2868">String.Split 的替代方案</span><span class="sxs-lookup"><span data-stu-id="ada9e-2868">Alternatives to String.Split</span></span>

 <span data-ttu-id="ada9e-2869"><xref:System.String.Split%2A>方法永遠不是將分隔的字串成子字串的最佳方式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2869">The <xref:System.String.Split%2A> method is not always the best way to break a delimited string into substrings.</span></span> <span data-ttu-id="ada9e-2870">如果您不想要擷取所有的子字串分隔的字串，或如果您想要剖析字串，而不是一組分隔符號字元的模式為基礎，請考慮下列的替代方案。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2870">If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</span></span>  
  
### <a name="regular-expressions"></a><span data-ttu-id="ada9e-2871">規則運算式</span><span class="sxs-lookup"><span data-stu-id="ada9e-2871">Regular expressions</span></span>  
 <span data-ttu-id="ada9e-2872">如果您的字串符合固定的模式，您可以使用規則運算式以擷取並處理其項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2872">If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</span></span> <span data-ttu-id="ada9e-2873">比方說，如果字串的形式 」*數字**運算元**數目*「 您可以使用[規則運算式](~/docs/standard/base-types/regular-expressions.md)擷取及處理字串的項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2873">For example, if strings take the form "*number* *operand* *number*" you can use a [regular expression](~/docs/standard/base-types/regular-expressions.md) to extract and handle the string's elements.</span></span> <span data-ttu-id="ada9e-2874">以下為範例：</span><span class="sxs-lookup"><span data-stu-id="ada9e-2874">Here's an example:</span></span>  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 <span data-ttu-id="ada9e-2875">規則運算式模式`(\d+)\s+([-+*/])\s+(\d+)`定義如下：</span><span class="sxs-lookup"><span data-stu-id="ada9e-2875">The regular expression pattern `(\d+)\s+([-+*/])\s+(\d+)` is defined like this:</span></span>  
  
|<span data-ttu-id="ada9e-2876">模式</span><span class="sxs-lookup"><span data-stu-id="ada9e-2876">Pattern</span></span>|<span data-ttu-id="ada9e-2877">描述</span><span class="sxs-lookup"><span data-stu-id="ada9e-2877">Description</span></span>|  
|-------------|-----------------|  
|`(\d+)`|<span data-ttu-id="ada9e-2878">比對一個或多個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2878">Match one or more decimal digits.</span></span> <span data-ttu-id="ada9e-2879">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2879">This is the first capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="ada9e-2880">比對一或多個空格字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2880">Match one or more white-space characters.</span></span>|  
|`([-+*/])`|<span data-ttu-id="ada9e-2881">比對的算術運算子號 (+、-、 \*，或 /)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2881">Match an arithmetic operator sign (+, -, \*, or /).</span></span> <span data-ttu-id="ada9e-2882">這是第二個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2882">This is the second capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="ada9e-2883">比對一或多個空格字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2883">Match one or more white-space characters.</span></span>|  
|`(\d+)`|<span data-ttu-id="ada9e-2884">比對一個或多個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2884">Match one or more decimal digits.</span></span> <span data-ttu-id="ada9e-2885">這是第三個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2885">This is the third capturing group.</span></span>|  
  
 <span data-ttu-id="ada9e-2886">您也可以使用規則運算式來擷取基礎模式，而不是一組固定的字元字串的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2886">You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</span></span> <span data-ttu-id="ada9e-2887">當任一條件發生時，這是常見的案例：</span><span class="sxs-lookup"><span data-stu-id="ada9e-2887">This is a common scenario when either of these conditions occurs:</span></span>  
  
-   <span data-ttu-id="ada9e-2888">一或多個分隔符號字元不一定服務做為分隔符號，以在<xref:System.String>執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2888">One or more of the delimiter characters does not always serve as a delimiter in the <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="ada9e-2889">順序及分隔符號字元數目為變數或未知。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2889">The sequence and number of delimiter characters is variable or unknown.</span></span>  
  
 <span data-ttu-id="ada9e-2890">例如，<xref:System.String.Split%2A>方法不能將下列字串中，因為數目`\n`（在 C# 中) 或`vbCrLf`（在 Visual Basic) 字元是變數，而且它們不一定會做為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2890">For example, the <xref:System.String.Split%2A> method cannot be used to split the following string, because the number of `\n` (in C#) or `vbCrLf` (in Visual Basic) characters is variable, and they don't always serve as delimiters.</span></span>  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 <span data-ttu-id="ada9e-2891">規則運算式可以輕鬆地，如下列範例所示分割此字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2891">A regular expression can split this string easily, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 <span data-ttu-id="ada9e-2892">規則運算式模式`\[([^\[\]]+)\]`定義如下：</span><span class="sxs-lookup"><span data-stu-id="ada9e-2892">The regular expression pattern `\[([^\[\]]+)\]` is defined like this:</span></span>  
  
|<span data-ttu-id="ada9e-2893">模式</span><span class="sxs-lookup"><span data-stu-id="ada9e-2893">Pattern</span></span>|<span data-ttu-id="ada9e-2894">描述</span><span class="sxs-lookup"><span data-stu-id="ada9e-2894">Description</span></span>|  
|-------------|-----------------|  
|`\[`|<span data-ttu-id="ada9e-2895">比對左括號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2895">Match an opening bracket.</span></span>|  
|`([^\[\]]+)`|<span data-ttu-id="ada9e-2896">比對任何不是左或右括號一次以上的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2896">Match any character that is not an opening or a closing bracket one or more times.</span></span> <span data-ttu-id="ada9e-2897">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2897">This is the first capturing group.</span></span>|  
|`\]`|<span data-ttu-id="ada9e-2898">比對右括號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2898">Match a closing bracket.</span></span>|  
  
 <span data-ttu-id="ada9e-2899"><xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方式幾乎完全相同<xref:System.String.Split%2A?displayProperty=nameWithType>，只不過它會根據規則運算式模式，而不是固定的字元集的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2899">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method is almost identical to <xref:System.String.Split%2A?displayProperty=nameWithType>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</span></span> <span data-ttu-id="ada9e-2900">例如，下列範例會使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法，將包含各種組合的連字號和其他字元來分隔的子字串的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2900">For example, the following example uses the <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 <span data-ttu-id="ada9e-2901">規則運算式模式`\s-\s?[+*]?\s?-\s`定義如下：</span><span class="sxs-lookup"><span data-stu-id="ada9e-2901">The regular expression pattern `\s-\s?[+*]?\s?-\s` is defined like this:</span></span>  
  
|<span data-ttu-id="ada9e-2902">模式</span><span class="sxs-lookup"><span data-stu-id="ada9e-2902">Pattern</span></span>|<span data-ttu-id="ada9e-2903">描述</span><span class="sxs-lookup"><span data-stu-id="ada9e-2903">Description</span></span>|  
|-------------|-----------------|  
|`\s-`|<span data-ttu-id="ada9e-2904">比對空白字元後面接著連字號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2904">Match a white-space character followed by a hyphen.</span></span>|  
|`\s?`|<span data-ttu-id="ada9e-2905">比對零個或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2905">Match zero or one white-space character.</span></span>|  
|`[+*]?`|<span data-ttu-id="ada9e-2906">比對零個或一個出現的 + 或 \* 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2906">Match zero or one occurrence of either the + or \* character.</span></span>|  
|`\s?`|<span data-ttu-id="ada9e-2907">比對零個或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2907">Match zero or one white-space character.</span></span>|  
|`-\s`|<span data-ttu-id="ada9e-2908">比對連字號後面接著空格字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2908">Match a hyphen followed by a white-space character.</span></span>|  
  
### <a name="search-methods-and-the-substring-method"></a><span data-ttu-id="ada9e-2909">搜尋方法和 Substring 方法</span><span class="sxs-lookup"><span data-stu-id="ada9e-2909">Search methods and the Substring method</span></span>  
 <span data-ttu-id="ada9e-2910">如果您不想要在字串中子字串的所有項目，您可能想要使用其中一個傳回相符項目開始處的索引的字串比較方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2910">If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</span></span> <span data-ttu-id="ada9e-2911">您可以接著呼叫<xref:System.String.Substring%2A>方法來擷取您想要的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2911">You can then call the <xref:System.String.Substring%2A> method to extract the substring that you want.</span></span> <span data-ttu-id="ada9e-2912">字串比較方法包括：</span><span class="sxs-lookup"><span data-stu-id="ada9e-2912">The string comparison methods include:</span></span>  
  
-   <span data-ttu-id="ada9e-2913"><xref:System.String.IndexOf%2A>傳回字元或字串第一次出現的以零起始的索引中的字串執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2913"><xref:System.String.IndexOf%2A>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="ada9e-2914"><xref:System.String.IndexOfAny%2A>它會以零為起始的索引傳回在目前的字元陣列中的任何字元第一次出現的字串執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2914"><xref:System.String.IndexOfAny%2A>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</span></span>  
  
-   <span data-ttu-id="ada9e-2915"><xref:System.String.LastIndexOf%2A>其中的字串執行個體傳回的字元或字串最後一次出現的以零起始的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2915"><xref:System.String.LastIndexOf%2A>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="ada9e-2916"><xref:System.String.LastIndexOfAny%2A>它會以零為起始的索引傳回在目前的最後一個出現的字元陣列中的任何字元的字串執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2916"><xref:System.String.LastIndexOfAny%2A>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</span></span>  
  
 <span data-ttu-id="ada9e-2917">下列範例會使用<xref:System.String.IndexOf%2A>方法來尋找字串中的句點。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2917">The following example uses the <xref:System.String.IndexOf%2A> method to find the periods in a string.</span></span> <span data-ttu-id="ada9e-2918">然後它會使用<xref:System.String.Substring%2A>方法，以傳回完整的句子。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2918">It then uses the <xref:System.String.Substring%2A> method to return full sentences.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ada9e-2919">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2919">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-2920">根據陣列中的字元分割字串成子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2920">Splits a string into substrings that are based on the characters in an array.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2921">陣列，其項目中包含了這個執行個體中的子字串，由 <paramref name="separator" /> 內的一或多個字元分隔。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2921">An array whose elements contain the substrings from this instance that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="ada9e-2922">如需詳細資訊，請參閱＜備註＞一節。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2922">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2923">當已知的一組字元所分隔的字串時，您可以使用<xref:System.String.Split%28System.Char%5B%5D%29>分隔成子字串的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2923">When a string is delimited by a known set of characters, you can use the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate it into substrings.</span></span>   
  
### <a name="return-value-details"></a><span data-ttu-id="ada9e-2924">傳回值的詳細資料</span><span class="sxs-lookup"><span data-stu-id="ada9e-2924">Return value details</span></span>  
 <span data-ttu-id="ada9e-2925">在傳回陣列中的項目不包含分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2925">Delimiter characters are not included in the elements of the returned array.</span></span> <span data-ttu-id="ada9e-2926">例如，如果分隔符號的陣列包含字元"-"和目前的字串執行個體的值是"aa-bb-cc"，方法會傳回陣列，其中包含三個項目:"aa"、"bb"和"cc"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2926">For example, if the separator array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="ada9e-2927">如果這個執行個體不包含任何字元在`separator`，傳回的陣列是由單一元素，其中包含這個執行個體所組成。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2927">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="ada9e-2928">每個項目的`separator`定義不同的分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2928">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="ada9e-2929">如果兩個分隔符號是相鄰的或分隔符號位於開頭或結尾的這個執行個體，傳回的陣列中對應的項目包含<xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2929">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <xref:System.String.Empty>.</span></span> <span data-ttu-id="ada9e-2930">以下是一些範例：</span><span class="sxs-lookup"><span data-stu-id="ada9e-2930">Here are some examples:</span></span>  
  
|<span data-ttu-id="ada9e-2931">字串值</span><span class="sxs-lookup"><span data-stu-id="ada9e-2931">String value</span></span>|<span data-ttu-id="ada9e-2932">Separator</span><span class="sxs-lookup"><span data-stu-id="ada9e-2932">Separator</span></span>|<span data-ttu-id="ada9e-2933">傳回的陣列</span><span class="sxs-lookup"><span data-stu-id="ada9e-2933">Returned array</span></span>|  
|------------------|---------------|--------------------|  
|<span data-ttu-id="ada9e-2934">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="ada9e-2934">"42, 12, 19"</span></span>|<span data-ttu-id="ada9e-2935">new Char[] {',', ' '} (C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2935">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="ada9e-2936">Char() = {","c, " "c}) (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2936">Char() = {","c, " "c}) (Visual Basic)</span></span>|<span data-ttu-id="ada9e-2937">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="ada9e-2937">{"42", "", "12", "", "19"}</span></span>|  
|<span data-ttu-id="ada9e-2938">"42..12..19"</span><span class="sxs-lookup"><span data-stu-id="ada9e-2938">"42..12..19"</span></span>|<span data-ttu-id="ada9e-2939">新 Char [] {'。 '}</span><span class="sxs-lookup"><span data-stu-id="ada9e-2939">new Char[] {'.'}</span></span> <span data-ttu-id="ada9e-2940">(C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2940">(C#)</span></span><br /><br /> <span data-ttu-id="ada9e-2941">Char （) = {"。"c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2941">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="ada9e-2942">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="ada9e-2942">{"42", "", "12", "", "19"}</span></span>|  
|<span data-ttu-id="ada9e-2943">"Banana"</span><span class="sxs-lookup"><span data-stu-id="ada9e-2943">"Banana"</span></span>|<span data-ttu-id="ada9e-2944">新 Char [] {'。 '}</span><span class="sxs-lookup"><span data-stu-id="ada9e-2944">new Char[] {'.'}</span></span> <span data-ttu-id="ada9e-2945">(C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2945">(C#)</span></span><br /><br /> <span data-ttu-id="ada9e-2946">Char （) = {"。"c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2946">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="ada9e-2947">{"Banana"}</span><span class="sxs-lookup"><span data-stu-id="ada9e-2947">{"Banana"}</span></span>|  
|<span data-ttu-id="ada9e-2948">「 Darb\nSmarba"(C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2948">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ada9e-2949">「 Darb"vbLf &"Smarba 」 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2949">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ada9e-2950">新 Char [] {} (C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2950">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="ada9e-2951">Char （) = {} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2951">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="ada9e-2952">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="ada9e-2952">{"Darb", "Smarba"}</span></span>|  
|<span data-ttu-id="ada9e-2953">「 Darb\nSmarba"(C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2953">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ada9e-2954">「 Darb"vbLf &"Smarba 」 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2954">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ada9e-2955">null (C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2955">null (C#)</span></span><br /><br /> <span data-ttu-id="ada9e-2956">Nothing (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-2956">Nothing (Visual Basic)</span></span>|<span data-ttu-id="ada9e-2957">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="ada9e-2957">{"Darb", "Smarba"}</span></span>|  
  
### <a name="the-separator-array"></a><span data-ttu-id="ada9e-2958">分隔符號的陣列</span><span class="sxs-lookup"><span data-stu-id="ada9e-2958">The separator array</span></span>  
 <span data-ttu-id="ada9e-2959">每個項目分隔符號的定義不同的分隔符號所組成的單一字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2959">Each element of separator defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="ada9e-2960">如果`separator`引數是`null`或不包含任何字元，方法會將空白字元視為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2960">If the `separator` argument is `null` or contains no characters, the method treats white-space characters as the delimiters.</span></span> <span data-ttu-id="ada9e-2961">泛空白字元是由 Unicode 標準; 定義它們會傳回`true`如果將它們傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2961">White-space characters are defined by the Unicode standard; they return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a><span data-ttu-id="ada9e-2962">String.Split(Char[]) 和編譯器多載解析</span><span class="sxs-lookup"><span data-stu-id="ada9e-2962">String.Split(Char[]) and compiler overload resolution</span></span>  
 <span data-ttu-id="ada9e-2963">雖然這個多載的單一參數<xref:System.String.Split%2A?displayProperty=nameWithType>是字元陣列中，您可以使用單一字元中, 呼叫它，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2963">Although the single parameter for this overload of <xref:System.String.Split%2A?displayProperty=nameWithType> is a character array, you can call it with a single character, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 <span data-ttu-id="ada9e-2964">因為`separator`參數以裝飾<xref:System.ParamArrayAttribute>屬性，編譯器會解譯為單一元素字元陣列的單一字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2964">Because the `separator` parameter is decorated  with the <xref:System.ParamArrayAttribute> attribute, compilers will interpret a single character as a single-element character array.</span></span> <span data-ttu-id="ada9e-2965">這不是適用於其他案例<xref:System.String.Split%2A?displayProperty=nameWithType>包含的多載`separator`參數，您必須明確傳遞這些多載的字元陣列，做為`separator`引數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2965">This is not the case for other <xref:System.String.Split%2A?displayProperty=nameWithType> overloads that include a `separator` parameter; you must explicitly pass these overloads a character array as the `separator` argument.</span></span>  
  
### <a name="comparison-details"></a><span data-ttu-id="ada9e-2966">比較詳細資料</span><span class="sxs-lookup"><span data-stu-id="ada9e-2966">Comparison details</span></span>  
 <span data-ttu-id="ada9e-2967"><xref:System.String.Split%28System.Char%5B%5D%29>方法會擷取這個字串中，由一或多個中的字元所分隔的子字串`separator`陣列，並傳回這些子字串，做為陣列的項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2967">The <xref:System.String.Split%28System.Char%5B%5D%29> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` array, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="ada9e-2968"><xref:System.String.Split%28System.Char%5B%5D%29>方法會尋找分隔符號執行使用區分大小寫的序數排序規則比較的方式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2968">The <xref:System.String.Split%28System.Char%5B%5D%29> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="ada9e-2969">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2969">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
### <a name="performance-considerations"></a><span data-ttu-id="ada9e-2970">效能考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-2970">Performance Considerations</span></span>  
 <span data-ttu-id="ada9e-2971"><xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2971">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ada9e-2972">如果您的應用程式需要最佳效能，或管理記憶體配置很重要，在您的應用程式，請考慮使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2972">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method.</span></span> <span data-ttu-id="ada9e-2973">您也可以選擇使用<xref:System.String.Compare%2A>方法來找出字串內子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2973">You also have the option of using the <xref:System.String.Compare%2A> method to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ada9e-2974">若要分割的分隔字元字串，請使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法在字串中尋找是分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2974">To split a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ada9e-2975">若要分割的分隔符號字串的字串，請使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出的分隔符號字串的第一個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2975">To split a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ada9e-2976">然後使用<xref:System.String.Compare%2A>方法，以判斷該第一個字元之後的字元是否相等的分隔符號字串的其餘字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2976">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ada9e-2977">此外，如果相同設定的字元用來分隔在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2977">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ada9e-2978">這會大幅降低每個方法呼叫的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2978">This significantly reduces the additional overhead of each method call.</span></span>  
  
## Examples  
 <span data-ttu-id="ada9e-2979">下列範例示範如何擷取文字區塊中的個別單字，藉由將做為分隔符號的泛空白字元和標點符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2979">The following example demonstrates how to extract individual words from a block of text by treating white space and punctuation marks as delimiters.</span></span> <span data-ttu-id="ada9e-2980">字元陣列傳遞給`separator`參數<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法包含空格字元和定位字元，以及一些常見的標點符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2980">The character array passed to the `separator` parameter of the <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> method consists of a space character and a tab character, together with some common punctuation symbols.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-2981">在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法會傳遞<paramref name="separator" />也就是<see langword="null" />或不包含任何字元，該方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2981">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ada9e-2982">從.NET Framework 4 開始，這兩種方法會使用一組完全相同的泛空白字元的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2982">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ada9e-2983">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2983">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-2984">要傳回的子字串之最大數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2984">The maximum number of substrings to return.</span></span></param>
        <summary><span data-ttu-id="ada9e-2985">根據陣列中的字元分割字串成最大數目的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2985">Splits a string into a maximum number of substrings based on the characters in an array.</span></span> <span data-ttu-id="ada9e-2986">您也要指定傳回的子字串之最大數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2986">You also specify the maximum number of substrings to return.</span></span></summary>
        <returns><span data-ttu-id="ada9e-2987">陣列，其項目中包含了這個執行個體中的子字串，由 <paramref name="separator" /> 內的一或多個字元分隔。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2987">An array whose elements contain the substrings in this instance that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="ada9e-2988">如需詳細資訊，請參閱＜備註＞一節。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2988">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-2989">在傳回陣列中的項目不包含分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2989">Delimiter characters are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="ada9e-2990">如果這個執行個體不包含任何字元在`separator`，傳回的陣列是由單一元素，其中包含這個執行個體所組成。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2990">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="ada9e-2991">如果`count`為零，則傳回空的陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2991">If `count` is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="ada9e-2992">如果`separator`參數是`null`不包含任何字元，或空格字元，會假設為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2992">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ada9e-2993">泛空白字元由 Unicode 標準並返回`true`如果將它們傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2993">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ada9e-2994">每個項目的`separator`定義不同的分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2994">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="ada9e-2995">如果兩個分隔符號是相鄰的或分隔符號位於開頭或結尾的這個執行個體，對應的陣列元素包含<xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2995">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ada9e-2996">如果有多個`count`在這種情況的子字串第一`count`減 1 的子字串會傳回在第一個`count`減 1 的傳回值，以及剩餘的字元，這個執行個體中的項目會傳回在過去傳回值的項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2996">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="ada9e-2997">如果`count`數目大於可用的子字串會傳回子字串，並擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2997">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
 <span data-ttu-id="ada9e-2998">下表提供範例。</span><span class="sxs-lookup"><span data-stu-id="ada9e-2998">The following table provides examples.</span></span>  
  
|<span data-ttu-id="ada9e-2999">字串值</span><span class="sxs-lookup"><span data-stu-id="ada9e-2999">String value</span></span>|<span data-ttu-id="ada9e-3000">Separator</span><span class="sxs-lookup"><span data-stu-id="ada9e-3000">Separator</span></span>|<span data-ttu-id="ada9e-3001">計數</span><span class="sxs-lookup"><span data-stu-id="ada9e-3001">Count</span></span>|<span data-ttu-id="ada9e-3002">傳回的陣列</span><span class="sxs-lookup"><span data-stu-id="ada9e-3002">Returned array</span></span>|  
|------------------|---------------|-----------|--------------------|  
|<span data-ttu-id="ada9e-3003">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="ada9e-3003">"42, 12, 19"</span></span>|<span data-ttu-id="ada9e-3004">new Char[] {',', ' '} (C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3004">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="ada9e-3005">Char() = {","c, " "c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3005">Char() = {","c, " "c} (Visual Basic)</span></span>|<span data-ttu-id="ada9e-3006">2</span><span class="sxs-lookup"><span data-stu-id="ada9e-3006">2</span></span>|<span data-ttu-id="ada9e-3007">{"42", " 12, 19"}</span><span class="sxs-lookup"><span data-stu-id="ada9e-3007">{"42", " 12, 19"}</span></span>|  
|<span data-ttu-id="ada9e-3008">"42..12..19"</span><span class="sxs-lookup"><span data-stu-id="ada9e-3008">"42..12..19"</span></span>|<span data-ttu-id="ada9e-3009">新 Char [] {'。 '}</span><span class="sxs-lookup"><span data-stu-id="ada9e-3009">new Char[] {'.'}</span></span> <span data-ttu-id="ada9e-3010">(C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3010">(C#)</span></span><br /><br /> <span data-ttu-id="ada9e-3011">Char （) = {"。"c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3011">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="ada9e-3012">4</span><span class="sxs-lookup"><span data-stu-id="ada9e-3012">4</span></span>|<span data-ttu-id="ada9e-3013">{"42", "", "12", ".19"}</span><span class="sxs-lookup"><span data-stu-id="ada9e-3013">{"42", "", "12", ".19"}</span></span>|  
|<span data-ttu-id="ada9e-3014">"Banana"</span><span class="sxs-lookup"><span data-stu-id="ada9e-3014">"Banana"</span></span>|<span data-ttu-id="ada9e-3015">新 Char [] {'。 '}</span><span class="sxs-lookup"><span data-stu-id="ada9e-3015">new Char[] {'.'}</span></span> <span data-ttu-id="ada9e-3016">(C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3016">(C#)</span></span><br /><br /> <span data-ttu-id="ada9e-3017">Char （) = {"。"c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3017">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="ada9e-3018">2</span><span class="sxs-lookup"><span data-stu-id="ada9e-3018">2</span></span>|<span data-ttu-id="ada9e-3019">{"Banana"}</span><span class="sxs-lookup"><span data-stu-id="ada9e-3019">{"Banana"}</span></span>|  
|<span data-ttu-id="ada9e-3020">「 Darb\nSmarba"(C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3020">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ada9e-3021">「 Darb"vbLf &"Smarba 」 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3021">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ada9e-3022">新 Char [] {} (C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3022">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="ada9e-3023">Char （) = {} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3023">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="ada9e-3024">1</span><span class="sxs-lookup"><span data-stu-id="ada9e-3024">1</span></span>|<span data-ttu-id="ada9e-3025">{"Darb\nSmarba"} (C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3025">{"Darb\nSmarba"} (C#)</span></span><br /><br /> <span data-ttu-id="ada9e-3026">「 Darb"vbLf &"Smarba 」 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3026">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|  
|<span data-ttu-id="ada9e-3027">「 Darb\nSmarba"(C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3027">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ada9e-3028">「 Darb"vbLf &"Smarba 」 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3028">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ada9e-3029">新 Char [] null (C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3029">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="ada9e-3030">Char() = Nothing</span><span class="sxs-lookup"><span data-stu-id="ada9e-3030">Char() = Nothing</span></span>|<span data-ttu-id="ada9e-3031">2</span><span class="sxs-lookup"><span data-stu-id="ada9e-3031">2</span></span>|<span data-ttu-id="ada9e-3032">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="ada9e-3032">{"Darb", "Smarba"}</span></span>|  
|<span data-ttu-id="ada9e-3033">「 Darb\nSmarba"(C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3033">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="ada9e-3034">「 Darb"vbLf &"Smarba 」 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3034">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="ada9e-3035">新 Char [] null (C#)</span><span class="sxs-lookup"><span data-stu-id="ada9e-3035">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="ada9e-3036">Char() = Nothing</span><span class="sxs-lookup"><span data-stu-id="ada9e-3036">Char() = Nothing</span></span>|<span data-ttu-id="ada9e-3037">100</span><span class="sxs-lookup"><span data-stu-id="ada9e-3037">100</span></span>|<span data-ttu-id="ada9e-3038">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="ada9e-3038">{"Darb", "Smarba"}</span></span>|  
  
### <a name="performance-considerations"></a><span data-ttu-id="ada9e-3039">效能考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-3039">Performance Considerations</span></span>  
 <span data-ttu-id="ada9e-3040"><xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3040">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ada9e-3041">如果您的應用程式需要最佳效能，或管理記憶體配置很重要，在您的應用程式，請考慮使用<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出字串內子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3041">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ada9e-3042">如果您要分割的分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法在字串中尋找是分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3042">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ada9e-3043">如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出的分隔符號字串的第一個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3043">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ada9e-3044">然後使用<xref:System.String.Compare%2A>方法，以判斷該第一個字元之後的字元是否相等的分隔符號字串的其餘字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3044">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ada9e-3045">此外，如果相同設定的字元用來分隔在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3045">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ada9e-3046">這會大幅降低每個方法呼叫的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3046">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3047">下列範例示範如何`count`會影響所傳回的字串數目<xref:System.String.Split%2A>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3047">The following example demonstrates how `count` affects the number of strings returned by <xref:System.String.Split%2A>.</span></span>  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-3048"><paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3048"><paramref name="count" /> is negative.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-3049">在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法會傳遞<paramref name="separator" />也就是<see langword="null" />或不包含任何字元，該方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3049">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ada9e-3050">從.NET Framework 4 開始，這兩種方法會使用一組完全相同的泛空白字元的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3050">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ada9e-3051">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3051">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="options"><span data-ttu-id="ada9e-3052"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> 表示要省略傳回陣列中的空陣列項目，否則 <see cref="F:System.StringSplitOptions.None" /> 表示要包含傳回陣列中的空陣列項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3052"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="ada9e-3053">根據陣列中的字元分割字串成子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3053">Splits a string into substrings based on the characters in an array.</span></span> <span data-ttu-id="ada9e-3054">您可以指定子字串是否包含空的陣列元素。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3054">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3055">陣列，其項目包含了這個字串中由 <paramref name="separator" /> 內的一或多個字元所分隔的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3055">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="ada9e-3056">如需詳細資訊，請參閱＜備註＞一節。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3056">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a><span data-ttu-id="ada9e-3057">傳回值的詳細資料</span><span class="sxs-lookup"><span data-stu-id="ada9e-3057">Return value details</span></span>  
 <span data-ttu-id="ada9e-3058">分隔符號字元 (字元`separator`陣列) 不包含在傳回陣列中的項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3058">Delimiter characters (the characters in the `separator` array) are not included in the elements of the returned array.</span></span> <span data-ttu-id="ada9e-3059">例如，如果`separator`陣列包含字元"-"和目前的字串執行個體的值是"aa-bb-cc"，方法會傳回陣列，其中包含三個項目:"aa"、"bb"和"cc"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3059">For example, if the `separator` array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="ada9e-3060">如果這個執行個體不包含任何字元在`separator`，傳回的陣列是由單一元素，其中包含這個執行個體所組成。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3060">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="ada9e-3061">如果`options`參數是<xref:System.StringSplitOptions.RemoveEmptyEntries>和這個執行個體的長度為零，方法會傳回空陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3061">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>  
  
 <span data-ttu-id="ada9e-3062">每個項目的`separator`定義不同的分隔符號所組成的單一字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3062">Each element of `separator` defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="ada9e-3063">如果`options`引數<xref:System.StringSplitOptions.None>，和是相鄰的兩個分隔符號或分隔符號位於開頭或結尾的這個執行個體，對應的陣列項目包含<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3063">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-3064">比方說，如果`separator`包含兩個元素，"-"和"\_"，字串執行個體的值是"-\_aa 位\_"，和值`options`引數是<xref:System.StringSplitOptions.None>，方法會傳回的字串陣列下列五個項目：</span><span class="sxs-lookup"><span data-stu-id="ada9e-3064">For example, if `separator` includes  two elements, "-" and "\_", the value of the string instance is "-\_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a string array with the following five elements:</span></span>  
  
1.  <span data-ttu-id="ada9e-3065"><xref:System.String.Empty?displayProperty=nameWithType>表示空字串"-"字元位於索引 0。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3065"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" character at index 0.</span></span>  
  
2.  <span data-ttu-id="ada9e-3066"><xref:System.String.Empty?displayProperty=nameWithType>表示之間的空白字串"-"字元在索引 0 和 1 的索引處的"_"字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3066"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</span></span>  
  
3.  <span data-ttu-id="ada9e-3067">"aa"，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3067">"aa",</span></span>  
  
4.  <span data-ttu-id="ada9e-3068"><xref:System.String.Empty?displayProperty=nameWithType>表示遵循索引 4 的"_"字元的空字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3068"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" character at index 4.</span></span>  
  
5.  <span data-ttu-id="ada9e-3069"><xref:System.String.Empty?displayProperty=nameWithType>用來表示空字串，會遵循 「-」 中 5 的索引處的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3069"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" character at index 5.</span></span>  
  
### <a name="the-separator-array"></a><span data-ttu-id="ada9e-3070">分隔符號的陣列</span><span class="sxs-lookup"><span data-stu-id="ada9e-3070">The separator array</span></span>  
 <span data-ttu-id="ada9e-3071">如果`separator`參數是`null`不包含任何字元，或空格字元，會假設為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3071">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ada9e-3072">泛空白字元由 Unicode 標準並返回`true`如果將它們傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3072">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ada9e-3073">如果`separator`這個方法多載的呼叫中的參數是`null`，編譯器多載解析失敗。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3073">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="ada9e-3074">若要明確地識別所呼叫的方法，您的程式碼必須指出的型別`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3074">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="ada9e-3075">下列範例示範數種方式可明確地識別這個多載。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3075">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a><span data-ttu-id="ada9e-3076">比較詳細資料</span><span class="sxs-lookup"><span data-stu-id="ada9e-3076">Comparison details</span></span>  
 <span data-ttu-id="ada9e-3077"><xref:System.String.Split%2A>方法會擷取這個字串中，由一或多個中的字元所分隔的子字串`separator`參數，並傳回這些子字串，做為陣列的項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3077">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="ada9e-3078"><xref:System.String.Split%2A>方法會尋找分隔符號執行使用區分大小寫的序數排序規則比較的方式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3078">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="ada9e-3079">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3079">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
### <a name="performance-considerations"></a><span data-ttu-id="ada9e-3080">效能考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-3080">Performance Considerations</span></span>  
 <span data-ttu-id="ada9e-3081"><xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3081">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ada9e-3082">如果您的應用程式需要最佳效能，或管理記憶體配置很重要，在您的應用程式，請考慮使用<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出字串內子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3082">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ada9e-3083">如果您要分割的分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法在字串中尋找是分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3083">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ada9e-3084">如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出的分隔符號字串的第一個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3084">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ada9e-3085">然後使用<xref:System.String.Compare%2A>方法，以判斷該第一個字元之後的字元是否相等的分隔符號字串的其餘字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3085">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ada9e-3086">此外，如果相同設定的字元用來分隔在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3086">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ada9e-3087">這會大幅降低每個方法呼叫的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3087">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3088">下列範例會使用<xref:System.StringSplitOptions>列舉型別，要包含或排除所產生的子字串<xref:System.String.Split%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3088">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-3089"><paramref name="options" /> 不是其中一個 <see cref="T:System.StringSplitOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3089"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-3090">在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法會傳遞<paramref name="separator" />也就是<see langword="null" />或不包含任何字元，該方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3090">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ada9e-3091">從.NET Framework 4 開始，這兩種方法會使用一組完全相同的泛空白字元的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3091">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ada9e-3092">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3092">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="options"><span data-ttu-id="ada9e-3093"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> 表示要省略傳回陣列中的空陣列項目，否則 <see cref="F:System.StringSplitOptions.None" /> 表示要包含傳回陣列中的空陣列項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3093"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="ada9e-3094">根據陣列中的字串分割字串成子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3094">Splits a string into substrings based on the strings in an array.</span></span> <span data-ttu-id="ada9e-3095">您可以指定子字串是否包含空的陣列元素。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3095">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3096">陣列，其項目包含了這個字串中由 <paramref name="separator" /> 內的一或多個字串所分隔的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3096">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span></span> <span data-ttu-id="ada9e-3097">如需詳細資訊，請參閱＜備註＞一節。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3097">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3098">當一組已知的字串所分隔的字串時，您可以使用<xref:System.String.Split%2A>分隔成子字串的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3098">When a string is delimited by a known set of strings, you can use the <xref:System.String.Split%2A> method to separate it into substrings.</span></span>  
  
### <a name="return-value-details"></a><span data-ttu-id="ada9e-3099">傳回值的詳細資料</span><span class="sxs-lookup"><span data-stu-id="ada9e-3099">Return value details</span></span>  
 <span data-ttu-id="ada9e-3100">在傳回陣列中的項目不包含分隔符號的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3100">Delimiter strings are not included in the elements of the returned array.</span></span> <span data-ttu-id="ada9e-3101">例如，如果`separator`陣列包含字串"-"和目前的字串執行個體的值為"aa-bb cc 」，方法會傳回陣列，其中包含三個項目:"aa"、"bb"和"cc"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3101">For example, if the `separator` array includes the string "--" and the value of the current string instance is "aa--bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="ada9e-3102">如果這個執行個體不包含任何在字串`separator`，傳回的陣列是由單一元素，其中包含這個執行個體所組成。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3102">If this instance does not contain any of the strings in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="ada9e-3103">如果`options`參數是<xref:System.StringSplitOptions.RemoveEmptyEntries>和這個執行個體的長度為零，方法會傳回空陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3103">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>  
  
 <span data-ttu-id="ada9e-3104">每個項目的`separator`定義不同的分隔符號，其中包含一個或多個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3104">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="ada9e-3105">如果`options`引數<xref:System.StringSplitOptions.None>，和是相鄰的兩個分隔符號或分隔符號位於開頭或結尾的這個執行個體，對應的陣列項目包含<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3105">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-3106">比方說，如果`separator`包含兩個元素，"-"和"\_"，字串執行個體的值是"-\_aa 位\_"，和值`options`引數是<xref:System.StringSplitOptions.None>，方法會傳回的字串陣列下列五個項目：</span><span class="sxs-lookup"><span data-stu-id="ada9e-3106">For example, if `separator` includes  two elements, "-" and "\_", the value of the string instance is "-\_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a sting array with the following five elements:</span></span>  
  
1.  <span data-ttu-id="ada9e-3107"><xref:System.String.Empty?displayProperty=nameWithType>表示空字串"-"索引 0 處的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3107"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" substring at index 0.</span></span>  
  
2.  <span data-ttu-id="ada9e-3108"><xref:System.String.Empty?displayProperty=nameWithType>表示之間的空白字串"-"索引為 0，位於索引 1 的"_"子字串的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3108"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" substring at index 0 and the "_" substring at index 1.</span></span>  
  
3.  <span data-ttu-id="ada9e-3109">"aa"，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3109">"aa",</span></span>  
  
4.  <span data-ttu-id="ada9e-3110"><xref:System.String.Empty?displayProperty=nameWithType>表示索引 4 的"_"子字串的空白字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3110"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" substring at index 4.</span></span>  
  
5.  <span data-ttu-id="ada9e-3111"><xref:System.String.Empty?displayProperty=nameWithType>表示空字串，會遵循 「-」 中 5 的索引處的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3111"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" substring at index 5.</span></span>  
  
### <a name="the-separator-array"></a><span data-ttu-id="ada9e-3112">分隔符號的陣列</span><span class="sxs-lookup"><span data-stu-id="ada9e-3112">The separator array</span></span>  
 <span data-ttu-id="ada9e-3113">如果有任何項目中`separator`包含多個字元，將整個子字串會被視為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3113">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="ada9e-3114">比方說，如果一個項目的`separator`是"10"，嘗試將字串"This10is10a10string。 」</span><span class="sxs-lookup"><span data-stu-id="ada9e-3114">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="ada9e-3115">傳回下列四個元素的陣列: {"This"，"is"，"a"、"string"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3115">returns the following four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="ada9e-3116">}.</span><span class="sxs-lookup"><span data-stu-id="ada9e-3116">}.</span></span>  
  
 <span data-ttu-id="ada9e-3117">如果`separator`參數是`null`不包含任何字元，或空格字元，會假設為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3117">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ada9e-3118">泛空白字元由 Unicode 標準並返回`true`如果將它們傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3118">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ada9e-3119">如果`separator`這個方法多載的呼叫中的參數是`null`，編譯器多載解析失敗。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3119">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="ada9e-3120">若要明確地識別所呼叫的方法，您的程式碼必須指出的型別`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3120">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="ada9e-3121">下列範例示範數種方式可明確地識別這個多載。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3121">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a><span data-ttu-id="ada9e-3122">比較詳細資料</span><span class="sxs-lookup"><span data-stu-id="ada9e-3122">Comparison details</span></span>  
 <span data-ttu-id="ada9e-3123"><xref:System.String.Split%2A>方法會擷取這個字串中，由一或多個中的字串所分隔的子字串`separator`參數，並傳回這些子字串，做為陣列的項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3123">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="ada9e-3124"><xref:System.String.Split%2A>方法會尋找分隔符號執行使用區分大小寫的序數排序規則比較的方式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3124">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="ada9e-3125">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3125">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
 <span data-ttu-id="ada9e-3126"><xref:System.String.Split%2A>方法會忽略的任何項目`separator`的值是`null`或空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3126">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>  
  
 <span data-ttu-id="ada9e-3127">若要避免模稜兩可的結果時中字串`separator`通字元<xref:System.String.Split%2A>作業就會開始從一開始的執行個體中，值的結尾並且比對中的第一個項目`separator`等於中的分隔符號執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3127">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="ada9e-3128">中子字串執行個體中發生的順序優先於中項目的順序`separator`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3128">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>  
  
 <span data-ttu-id="ada9e-3129">例如，請考慮執行個體，其值是"abcdef"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3129">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="ada9e-3130">如果中的第一個項目`separator`"ef"，而第二個元素是"bcde"、 split 作業的結果會是字串陣列，其中包含兩個元素，"a"和"f"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3130">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be a string array that contains two elements, "a" and "f".</span></span> <span data-ttu-id="ada9e-3131">這是因為發生中的執行個體，"bcde"，之子字串，而且比對中的項目`separator`遇到"f"的子字串之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3131">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>  
  
 <span data-ttu-id="ada9e-3132">不過，如果第一個項目`separator`"bcd"，而第二個元素是"bc"、 split 作業的結果會是字串陣列，其中包含兩個元素，"a"和"ef"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3132">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be a string array that contains two elements, "a" and "ef".</span></span> <span data-ttu-id="ada9e-3133">這是因為"bcd"中的第一個分隔符號`separator`符合執行個體中的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3133">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="ada9e-3134">如果分隔符號的順序相反，因此第一個項目"bc"，而且第二個元素是"bcd"，則結果會是字串陣列，其中包含兩個元素，"a"和"def"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3134">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be a string array that contains two elements,  "a" and "def".</span></span>  
  
### <a name="performance-considerations"></a><span data-ttu-id="ada9e-3135">效能考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-3135">Performance considerations</span></span>  
 <span data-ttu-id="ada9e-3136"><xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3136">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ada9e-3137">如果您的應用程式需要最佳效能，或管理記憶體配置很重要，在您的應用程式，請考慮使用<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出字串內子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3137">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ada9e-3138">如果您要分割的分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法在字串中尋找是分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3138">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ada9e-3139">如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出的分隔符號字串的第一個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3139">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ada9e-3140">然後使用<xref:System.String.Compare%2A>方法，以判斷該第一個字元之後的字元是否相等的分隔符號字串的其餘字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3140">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ada9e-3141">此外，如果相同設定的字元用來分隔在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3141">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ada9e-3142">這會大幅降低每個方法呼叫的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3142">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3143">下列範例說明如何藉由呼叫的字串所傳回之陣列的差異<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType>方法有其`options`參數等於<xref:System.StringSplitOptions.None?displayProperty=nameWithType>和<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3143">The following example illustrates the difference in the arrays returned by calling a string's <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> method with its `options` parameter equal to <xref:System.StringSplitOptions.None?displayProperty=nameWithType> and <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 <span data-ttu-id="ada9e-3144">下列範例會定義包含標點符號和空格字元的分隔符號的陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3144">The following example defines an array of separators that include punctuation and white-space characters.</span></span> <span data-ttu-id="ada9e-3145">將此陣列的值以及傳遞<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>至<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>方法會傳回從字串的個別文字所組成的陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3145">Passing this array along with a value of <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> to the <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> method returns an array that consists of the individual words from the string.</span></span>  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 <span data-ttu-id="ada9e-3146">請注意，這個方法會呼叫`options`引數設定為<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3146">Note that the method is called with the `options` argument set to <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ada9e-3147">這可防止傳回的陣列包括<xref:System.String.Empty?displayProperty=nameWithType>表示空的子字串比對標點符號和空格字元之間的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3147">This prevents the returned array from including <xref:System.String.Empty?displayProperty=nameWithType> values that represent empty substring matches between punctuation marks and white-space characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-3148"><paramref name="options" /> 不是其中一個 <see cref="T:System.StringSplitOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3148"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-3149">在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法會傳遞<paramref name="separator" />也就是<see langword="null" />或不包含任何字元，該方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3149">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ada9e-3150">從.NET Framework 4 開始，這兩種方法會使用一組完全相同的泛空白字元的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3150">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ada9e-3151">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3151">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-3152">要傳回的子字串之最大數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3152">The maximum number of substrings to return.</span></span></param>
        <param name="options"><span data-ttu-id="ada9e-3153"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> 表示要省略傳回陣列中的空陣列項目，否則 <see cref="F:System.StringSplitOptions.None" /> 表示要包含傳回陣列中的空陣列項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3153"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="ada9e-3154">根據陣列中的字元分割字串成最大數目的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3154">Splits a string into a maximum number of substrings based on the characters in an array.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3155">陣列，其項目包含了這個字串中由 <paramref name="separator" /> 內的一或多個字元所分隔的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3155">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="ada9e-3156">如需詳細資訊，請參閱＜備註＞一節。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3156">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3157">在傳回陣列中的項目不包含分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3157">Delimiter characters are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="ada9e-3158">如果這個執行個體不包含任何字元`separator`，或`count`參數為 1，傳回的陣列是由單一元素，其中包含這個執行個體所組成。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3158">If this instance does not contain any of the characters in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="ada9e-3159">如果`separator`參數是`null`不包含任何字元，或空格字元，會假設為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3159">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ada9e-3160">泛空白字元由 Unicode 標準並返回`true`如果將它們傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3160">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ada9e-3161">不過，如果`separator`這個方法多載的呼叫中的參數是`null`，編譯器多載解析失敗。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3161">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="ada9e-3162">若要明確地識別所呼叫的方法，您的程式碼必須指出 null 的型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3162">To unambiguously identify the called method, your code must indicate the type of the null.</span></span> <span data-ttu-id="ada9e-3163">下列範例示範數種方式可明確地識別這個多載。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3163">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 <span data-ttu-id="ada9e-3164">如果`count`參數為零，則`options`參數是<xref:System.StringSplitOptions.RemoveEmptyEntries>和這個執行個體的長度為零，則傳回空的陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3164">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="ada9e-3165">每個項目的`separator`定義不同的分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3165">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="ada9e-3166">如果`options`參數是<xref:System.StringSplitOptions.None>，和是相鄰的兩個分隔符號或分隔符號位於開頭或結尾的這個執行個體，對應的陣列項目包含<xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3166">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ada9e-3167">如果有多個`count`在這種情況的子字串第一`count`減 1 的子字串會傳回在第一個`count`減 1 的傳回值，以及剩餘的字元，這個執行個體中的項目會傳回在過去傳回值的項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3167">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="ada9e-3168">如果`count`數目大於可用的子字串會傳回子字串，並擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3168">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
### <a name="performance-considerations"></a><span data-ttu-id="ada9e-3169">效能考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-3169">Performance Considerations</span></span>  
 <span data-ttu-id="ada9e-3170"><xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3170">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ada9e-3171">如果您的應用程式需要最佳效能，或管理記憶體配置很重要，在您的應用程式，請考慮使用<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出字串內子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3171">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ada9e-3172">如果您要分割的分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法在字串中尋找是分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3172">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ada9e-3173">如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出的分隔符號字串的第一個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3173">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ada9e-3174">然後使用<xref:System.String.Compare%2A>方法，以判斷該第一個字元之後的字元是否相等的分隔符號字串的其餘字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3174">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ada9e-3175">此外，如果相同設定的字元用來分隔在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3175">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ada9e-3176">這會大幅降低每個方法呼叫的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3176">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3177">下列範例會使用<xref:System.StringSplitOptions>列舉型別，要包含或排除所產生的子字串<xref:System.String.Split%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3177">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-3178"><paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3178"><paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-3179"><paramref name="options" /> 不是其中一個 <see cref="T:System.StringSplitOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3179"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-3180">在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法會傳遞<paramref name="separator" />也就是<see langword="null" />或不包含任何字元，該方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3180">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ada9e-3181">從.NET Framework 4 開始，這兩種方法會使用一組完全相同的泛空白字元的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3181">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="ada9e-3182">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3182">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="ada9e-3183">要傳回的子字串之最大數目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3183">The maximum number of substrings to return.</span></span></param>
        <param name="options"><span data-ttu-id="ada9e-3184"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> 表示要省略傳回陣列中的空陣列項目，否則 <see cref="F:System.StringSplitOptions.None" /> 表示要包含傳回陣列中的空陣列項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3184"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="ada9e-3185">根據陣列中的字串分割字串成最大數目的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3185">Splits a string into a maximum number of substrings based on the strings in an array.</span></span> <span data-ttu-id="ada9e-3186">您可以指定子字串是否包含空的陣列元素。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3186">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3187">陣列，其項目包含了這個字串中由 <paramref name="separator" /> 內的一或多個字串所分隔的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3187">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span></span> <span data-ttu-id="ada9e-3188">如需詳細資訊，請參閱＜備註＞一節。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3188">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a><span data-ttu-id="ada9e-3189">傳回值的詳細資料</span><span class="sxs-lookup"><span data-stu-id="ada9e-3189">Return value details</span></span>  
 <span data-ttu-id="ada9e-3190">在傳回陣列中的項目不包含分隔符號的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3190">Delimiter strings are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="ada9e-3191">如果這個執行個體不包含在字串的任何`separator`，或`count`參數為 1，傳回的陣列是由單一元素，其中包含這個執行個體所組成。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3191">If this instance does not contain any of the strings in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="ada9e-3192">如果`separator`參數是`null`不包含任何字元，或空格字元，會假設為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3192">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="ada9e-3193">泛空白字元由 Unicode 標準並返回`true`如果將它們傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3193">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ada9e-3194">不過，如果`separator`這個方法多載的呼叫中的參數是`null`，編譯器多載解析失敗。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3194">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="ada9e-3195">若要明確地識別所呼叫的方法，您的程式碼必須指出的型別`null`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3195">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="ada9e-3196">下列範例示範數種方式可明確地識別這個多載。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3196">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 <span data-ttu-id="ada9e-3197">如果`count`參數為零，則`options`參數是<xref:System.StringSplitOptions.RemoveEmptyEntries>和這個執行個體的長度為零，則傳回空的陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3197">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="ada9e-3198">每個項目的`separator`定義不同的分隔符號，其中包含一個或多個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3198">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="ada9e-3199">如果`options`參數是<xref:System.StringSplitOptions.None>，和是相鄰的兩個分隔符號或分隔符號位於開頭或結尾的這個執行個體，對應的陣列項目包含<xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3199">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ada9e-3200">如果有多個`count`在這種情況的子字串第一`count`減 1 的子字串會傳回在第一個`count`減 1 的傳回值，以及剩餘的字元，這個執行個體中的項目會傳回在過去傳回值的項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3200">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="ada9e-3201">如果`count`數目大於可用的子字串會傳回子字串，並擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3201">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
### <a name="the-separator-array"></a><span data-ttu-id="ada9e-3202">分隔符號的陣列</span><span class="sxs-lookup"><span data-stu-id="ada9e-3202">The separator array</span></span>  
 <span data-ttu-id="ada9e-3203">如果有任何項目中`separator`包含多個字元，將整個子字串會被視為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3203">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="ada9e-3204">比方說，如果一個項目的`separator`是"10"，嘗試將字串"This10is10a10string。 」</span><span class="sxs-lookup"><span data-stu-id="ada9e-3204">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="ada9e-3205">傳回此四個元素的陣列: {"This"，"is"，"a"、"string"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3205">returns this four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="ada9e-3206">}.</span><span class="sxs-lookup"><span data-stu-id="ada9e-3206">}.</span></span>  
  
### <a name="comparison-details"></a><span data-ttu-id="ada9e-3207">比較詳細資料</span><span class="sxs-lookup"><span data-stu-id="ada9e-3207">Comparison details</span></span>  
 <span data-ttu-id="ada9e-3208"><xref:System.String.Split%2A>方法會擷取這個字串中，由一或多個中的字串所分隔的子字串`separator`參數，並傳回這些子字串，做為陣列的項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3208">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="ada9e-3209"><xref:System.String.Split%2A>方法會尋找分隔符號執行使用區分大小寫的序數排序規則比較的方式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3209">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="ada9e-3210">如需有關字、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3210">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
 <span data-ttu-id="ada9e-3211"><xref:System.String.Split%2A>方法會忽略的任何項目`separator`的值是`null`或空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3211">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>  
  
 <span data-ttu-id="ada9e-3212">若要避免模稜兩可的結果時字串中`separator`通字元<xref:System.String.Split%2A>方法就會開始從一開始的執行個體中，值的結尾並且比對中的第一個項目`separator`等於中的分隔符號執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3212">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> method proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="ada9e-3213">中子字串執行個體中發生的順序優先於中項目的順序`separator`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3213">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>  
  
 <span data-ttu-id="ada9e-3214">例如，請考慮執行個體，其值是"abcdef"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3214">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="ada9e-3215">如果中的第一個項目`separator`"ef"，而第二個元素是"bcde"、 split 作業的結果會是"a"和"f"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3215">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f".</span></span> <span data-ttu-id="ada9e-3216">這是因為發生中的執行個體，"bcde"，之子字串，而且比對中的項目`separator`遇到"f"的子字串之前。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3216">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>  
  
 <span data-ttu-id="ada9e-3217">不過，如果第一個項目`separator`"bcd"，而第二個元素是"bc"、 split 作業的結果會是"a"和"ef"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3217">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef".</span></span> <span data-ttu-id="ada9e-3218">這是因為"bcd"中的第一個分隔符號`separator`符合執行個體中的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3218">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="ada9e-3219">如果分隔符號的順序相反，因此第一個項目"bc"，而且第二個元素是"bcd"，則結果會是"a"和"def"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3219">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def".</span></span>  
  
### <a name="performance-considerations"></a><span data-ttu-id="ada9e-3220">效能考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-3220">Performance considerations</span></span>  
 <span data-ttu-id="ada9e-3221"><xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3221">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="ada9e-3222">如果您的應用程式需要最佳效能，或管理記憶體配置很重要，在您的應用程式，請考慮使用<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出字串內子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3222">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="ada9e-3223">如果您要分割的分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法在字串中尋找是分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3223">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="ada9e-3224">如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出的分隔符號字串的第一個字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3224">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="ada9e-3225">然後使用<xref:System.String.Compare%2A>方法，以判斷該第一個字元之後的字元是否相等的分隔符號字串的其餘字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3225">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="ada9e-3226">此外，如果相同設定的字元用來分隔在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3226">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="ada9e-3227">這會大幅降低每個方法呼叫的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3227">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3228">下列範例會使用<xref:System.StringSplitOptions>列舉型別，要包含或排除所產生的子字串<xref:System.String.Split%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3228">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-3229"><paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3229"><paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-3230"><paramref name="options" /> 不是其中一個 <see cref="T:System.StringSplitOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3230"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-3231">在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法會傳遞<paramref name="separator" />也就是<see langword="null" />或不包含任何字元，該方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3231">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="ada9e-3232">從.NET Framework 4 開始，這兩種方法會使用一組完全相同的泛空白字元的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3232">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-3233">判斷這個字串執行個體的開頭是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3233">Determines whether the beginning of this string instance matches a specified string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-3234">要比較的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3234">The string to compare.</span></span></param>
        <summary><span data-ttu-id="ada9e-3235">判斷這個字串執行個體的開頭是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3235">Determines whether the beginning of this string instance matches the specified string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3236">如果 <see langword="true" /> 符合這個字串的開頭，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3236"><see langword="true" /> if <paramref name="value" /> matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3237">這個方法會比較`value`長度相同，這個執行個體的開頭的子字串`value`，並傳回指示它們是否相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3237">This method compares `value` to the substring at the beginning of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="ada9e-3238">為相等，`value`必須是空字串 (<xref:System.String.Empty?displayProperty=nameWithType>)，必須是這個相同的執行個體的參考，或必須符合這個執行個體的開頭。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3238">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>  
  
 <span data-ttu-id="ada9e-3239">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3239">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3240">下列範例會定義`StripStartTags`方法，以使用<xref:System.String.StartsWith%28System.String%29>移除 HTML 的方法從字串開頭開始標記。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3240">The following example defines a `StripStartTags` method that uses the <xref:System.String.StartsWith%28System.String%29> method to remove HTML start tags from the beginning of a string.</span></span> <span data-ttu-id="ada9e-3241">請注意，`StripStartTags`呼叫方法以遞迴方式來確認已移除多個 HTML 開始標記，在一行的開頭。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3241">Note that the `StripStartTags` method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed.</span></span> <span data-ttu-id="ada9e-3242">此範例不會移除內嵌在字串中的 HTML 標記。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3242">The example does not remove HTML tags embedded in a string.</span></span>  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-3243"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3243"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-3244">中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫改為呼叫需要明確指定參數的方法和取代預設值的字串比較方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3244">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ada9e-3245">若要判斷字串開頭是否為特定的子字串使用目前文化特性的字串比較規則，請呼叫<see cref="M:System.String.StartsWith(System.String,System.StringComparison)" />的值的方法多載<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3245">To determine whether a string begins with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-3246">要比較的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3246">The string to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="ada9e-3247">列舉值之一，指定這個字串和 <paramref name="value" /> 的比較方式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3247">One of the enumeration values that determines how this string and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="ada9e-3248">判斷當使用指定之比較選項進行比較時，這個字串執行個體的開頭是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3248">Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3249">如果這個執行個體以 <see langword="true" /> 為開頭，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3249"><see langword="true" /> if this instance begins with <paramref name="value" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3250"><xref:System.String.StartsWith%2A>方法會比較`value`在這個字串的開頭的子字串的參數和傳回值，這個值，指出它們是否相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3250">The <xref:System.String.StartsWith%2A> method compares the `value` parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="ada9e-3251">為相等，`value`必須為這個相同字串的參考，必須是空字串 ("")，或必須符合這個字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3251">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the beginning of this string.</span></span> <span data-ttu-id="ada9e-3252">所執行的比較的型別<xref:System.String.StartsWith%2A>方法而定的值`comparisonType`參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3252">The type of comparison performed by the <xref:System.String.StartsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span> <span data-ttu-id="ada9e-3253">比較可以使用目前的文化特性的慣例 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>並<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) 或文化特性而異 (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>並<xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>)，也可以包含的字碼指標的逐字元比較 (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="ada9e-3253">The comparison can use the conventions of the current culture (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> and <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) or the invariant culture (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> and <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), or it can consist of a character-by-character comparison of code points (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span> <span data-ttu-id="ada9e-3254">比較也可以是區分大小寫 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>， <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>，或<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>)，或它可以忽略大小寫 (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>， <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>， <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3254">The comparison can also be case-sensitive (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, or <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), or it can ignore case (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3255">下列範例會搜尋字串"the"開頭的較長的字串開頭的字組"The"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3255">The following example searches for the string "the" at the beginning of a longer string that begins with the word "The".</span></span> <span data-ttu-id="ada9e-3256">如輸出所範例所示，呼叫<xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29>方法，執行區分大小寫，但不區分文化特性的比較無法比對字串，而執行的文化特性和 case insensitive 比較呼叫符合字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3256">As the output from the example shows, a call to the <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> method that performs a culture-insensitive but case-sensitive comparison fails to match the string, while a call that performs a culture- and case-insensitive comparison matches the string.</span></span>  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 <span data-ttu-id="ada9e-3257">下列範例會判斷字串是否以特定的子字串開始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3257">The following example determines whether a string starts with a particular substring.</span></span> <span data-ttu-id="ada9e-3258">它會初始化二維字串陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3258">It initializes a two-dimensional string array.</span></span> <span data-ttu-id="ada9e-3259">第二個維度中的第一個項目包含為字串，和第二個元素包含要搜尋的第一個字串開頭的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3259">The first element in the second dimension contains a string, and the second element contains the string to search for at the start of the first string.</span></span> <span data-ttu-id="ada9e-3260">文化特性、 是否忽略大小寫，以及是否執行序數比較的選擇會影響結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3260">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span> <span data-ttu-id="ada9e-3261">請注意，當字串執行個體包含連音符號，其連續字元的區分文化特性比較成功比對。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3261">Note that when the string instance contains a ligature, culture-sensitive comparisons with its consecutive characters successfully match.</span></span>  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-3262"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3262"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ada9e-3263"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3263"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ada9e-3264">要比較的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3264">The string to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ada9e-3265"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3265"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="ada9e-3266">判斷如何比較此字串和 <paramref name="value" /> 的文化特性資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3266">Cultural information that determines how this string and <paramref name="value" /> are compared.</span></span> <span data-ttu-id="ada9e-3267">如果 <paramref name="culture" /> 是 <see langword="null" />，則會使用目前的文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3267">If <paramref name="culture" /> is <see langword="null" />, the current culture is used.</span></span></param>
        <summary><span data-ttu-id="ada9e-3268">判斷當使用指定之文化特性進行比較時，這個字串執行個體的開頭是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3268">Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3269">如果 <see langword="true" /> 參數符合這個字串的開頭，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3269"><see langword="true" /> if the <paramref name="value" /> parameter matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3270">這個方法會比較`value`參數的長度相同，這個字串開頭的子字串`value`，並傳回值，指出它們是否相等。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3270">This method compares the `value` parameter to the substring at the beginning of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="ada9e-3271">為相等，`value`必須是空字串 (<xref:System.String.Empty?displayProperty=nameWithType>)，必須是這個相同的執行個體的參考，或必須符合這個執行個體的開頭。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3271">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>  
  
 <span data-ttu-id="ada9e-3272">這個方法會執行使用指定的大小寫和文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3272">This method performs a comparison using the specified casing and culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3273">下列範例會判斷字串是否發生在另一個字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3273">The following example determines whether a string occurs at the beginning of another string.</span></span> <span data-ttu-id="ada9e-3274"><xref:System.String.StartsWith%2A>方法呼叫數次使用區分大小寫、 不區分大小寫和不同的文化特性會影響搜尋的結果。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3274">The <xref:System.String.StartsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-3275"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3275"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-3276">從這個執行個體擷取子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3276">Retrieves a substring from this instance.</span></span>  
  
<span data-ttu-id="ada9e-3277">這個成員是多載的。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3277">This member is overloaded.</span></span> <span data-ttu-id="ada9e-3278">如需這個成員的完整資訊，包含語法、使用方式和範例，請按一下多載清單中的名稱。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3278">For complete information about this member, including syntax, usage, and examples, click a name in the overload list.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Index) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Index startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : Index -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ada9e-3279">這個執行個體中子字串之以零為起始的起始字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3279">The zero-based starting character position of a substring in this instance.</span></span></param>
        <summary><span data-ttu-id="ada9e-3280">從這個執行個體擷取子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3280">Retrieves a substring from this instance.</span></span> <span data-ttu-id="ada9e-3281">子字串會在指定的字元位置開始並繼續到字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3281">The substring starts at a specified character position and continues to the end of the string.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3282">與這個執行個體中從 <paramref name="startIndex" /> 開始之子字串相等的字串；如果 <see cref="F:System.String.Empty" /> 等於這個執行個體的長度，則為 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3282">A string that is equivalent to the substring that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3283">您呼叫<xref:System.String.Substring%28System.Int32%29>從指定的字元位置開始，並在字串結尾結束的字串擷取子字串的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3283">You call the <xref:System.String.Substring%28System.Int32%29> method to extract a substring from a string that begins at a specified character position and ends at the end of the string.</span></span> <span data-ttu-id="ada9e-3284">起始字元位置以零為起始的;換句話說，在字串中的第一個字元位於索引 0，索引 1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3284">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="ada9e-3285">若要擷取指定的字元位置開始，並結束字串的結尾之前，請呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3285">To extract a substring that begins at a specified character position and ends before the end of the string, call the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-3286">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3286">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-3287">相反地，它會傳回新的字串起始於`startIndex`目前字串中的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3287">Instead, it returns a new string that begins at the `startIndex` position in the current string.</span></span>  
  
 <span data-ttu-id="ada9e-3288">若要擷取特定字元或字元序列的開頭的子字串，呼叫方法這類<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOf%2A>若要取得的值`startIndex`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3288">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> to get the value of `startIndex`.</span></span> <span data-ttu-id="ada9e-3289">第二個範例說明這方面它會擷取金鑰的值之後的"="的字元開始一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3289">The second example illustrates this; it extracts a key value that begins one character position after the "=" character.</span></span>  
  
 <span data-ttu-id="ada9e-3290">如果`startIndex`等於零，則方法會傳回原封不動的原始字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3290">If `startIndex` is equal to zero, the method returns the original string unchanged.</span></span>  
   
  
## Examples  
 <span data-ttu-id="ada9e-3291">下列範例示範如何取得從字串的子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3291">The following example demonstrates obtaining a substring from a string.</span></span>  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 <span data-ttu-id="ada9e-3292">下列範例會使用<xref:System.String.Substring%2A>方法，以不同的以等號分隔的索引鍵/值配對 （"="） 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3292">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <span data-ttu-id="ada9e-3293"><xref:System.String.IndexOf%2A>方法用來取得的等號字元的字串中的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3293">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.</span></span> <span data-ttu-id="ada9e-3294">若要在呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法會擷取金鑰的名稱，從字串中的第一個字元開始，並擴充的呼叫所傳回的字元數<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3294">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name, which starts from the first character in the string and extends for the number of characters returned by the call to the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="ada9e-3295">若要呼叫<xref:System.String.Substring%28System.Int32%29>方法則會擷取指派給索引鍵的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3295">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="ada9e-3296">它等於字元之外的一個字元位置開始，並延伸至字串結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3296">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-3297"><paramref name="startIndex" /> 小於零或大於此執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3297"><paramref name="startIndex" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Range range);" />
      <MemberSignature Language="F#" Value="member this.Substring : Range -&gt; string" Usage="string.Substring range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ada9e-3298">這個執行個體中子字串之以零為起始的起始字元位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3298">The zero-based starting character position of a substring in this instance.</span></span></param>
        <param name="length"><span data-ttu-id="ada9e-3299">子字串中的字元數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3299">The number of characters in the substring.</span></span></param>
        <summary><span data-ttu-id="ada9e-3300">從這個執行個體擷取子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3300">Retrieves a substring from this instance.</span></span> <span data-ttu-id="ada9e-3301">子字串起始於指定的字元位置，並且具有指定的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3301">The substring starts at a specified character position and has a specified length.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3302">與長度為 <paramref name="length" /> 且在這個執行個體中從 <paramref name="startIndex" /> 開始之子字串相等的字串；如果 <see cref="F:System.String.Empty" /> 等於這個執行個體的長度且 <paramref name="startIndex" /> 為零，則為 <paramref name="length" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3302">A string that is equivalent to the substring of length <paramref name="length" /> that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance and <paramref name="length" /> is zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3303">您呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法，可從指定的字元位置開始和結束的字串結尾之前的字串擷取子字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3303">You call the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method to extract a substring from a string that begins at a specified character position and ends before the end of the string.</span></span> <span data-ttu-id="ada9e-3304">起始字元位置以零為起始的;換句話說，在字串中的第一個字元位於索引 0，索引 1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3304">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="ada9e-3305">若要擷取指定的字元位置開始，並以字串的結尾會繼續，請呼叫<xref:System.String.Substring%28System.Int32%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3305">To extract a substring that begins at a specified character position and continues to the end of the string, call the <xref:System.String.Substring%28System.Int32%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-3306">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3306">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-3307">相反地，它會傳回新字串與字串`length`字元從`startIndex`目前字串中的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3307">Instead, it returns a new string with `length` characters starting from the `startIndex` position in the current string.</span></span>  
  
 <span data-ttu-id="ada9e-3308">`length`參數代表要從目前的字串執行個體中擷取的字元總數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3308">The `length` parameter represents the total number of characters to extract from the current string instance.</span></span> <span data-ttu-id="ada9e-3309">這包括起始的字元索引，請參閱`startIndex`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3309">This includes the starting character found at index  `startIndex`.</span></span>  <span data-ttu-id="ada9e-3310">亦即<xref:System.String.Substring%2A>方法會嘗試從索引擷取字元`startIndex`至索引`startIndex`  +  `length` -1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3310">In other words, the <xref:System.String.Substring%2A> method attempts to extract characters from index `startIndex` to index `startIndex` + `length` - 1.</span></span>  
  
 <span data-ttu-id="ada9e-3311">若要擷取特定字元或字元序列的開頭的子字串，呼叫方法這類<xref:System.String.IndexOf%2A>或是<xref:System.String.LastIndexOf%2A>若要取得的值`startIndex`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3311">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the value of `startIndex`.</span></span>  
  
 <span data-ttu-id="ada9e-3312">如果從子字串延伸`startIndex`在指定的字元順序，您可以呼叫方法例如<xref:System.String.IndexOf%2A>或<xref:System.String.LastIndexOf%2A>取得結束的字元或字元序列的索引。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3312">If the substring extends from `startIndex` to a specified character sequence, you can call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the index of the ending character or character sequence.</span></span>  <span data-ttu-id="ada9e-3313">您可以接著將該值轉換成字串中的索引位置，如下所示：</span><span class="sxs-lookup"><span data-stu-id="ada9e-3313">You can then convert that value to an index position in the string as follows:</span></span>  
  
-   <span data-ttu-id="ada9e-3314">如果您搜尋過的單一字元，是要標記的子字串的結尾`length`參數等於`endIndex`  -  `startIndex` + 1，其中`endIndex`是傳回的值<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3314">If you've searched for a single character that is to mark the end of the substring, the `length` parameter equals  `endIndex` - `startIndex` + 1, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="ada9e-3315">下列範例會從字串擷取"b"字元的連續的區塊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3315">The following example extracts a continuous block of "b" characters from a string.</span></span>  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   <span data-ttu-id="ada9e-3316">如果您搜尋過的多個要標示的子字串的結尾的字元`length`參數等於`endIndex`  +  `endMatchLength`  -  `startIndex`，其中`endIndex`的傳回值<xref:System.String.IndexOf%2A>或是<xref:System.String.IndexOf%2A>方法，和`endMatchLength`標記的子字串結尾的字元序列的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3316">If you've searched for multiple characters that are to mark the end of the substring, the `length` parameter equals  `endIndex` + `endMatchLength` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method, and `endMatchLength` is the length of the character sequence that marks the end of the substring.</span></span> <span data-ttu-id="ada9e-3317">下列範例會擷取包含 XML 的文字區塊`<definition>`項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3317">The following example extracts a block of text that contains an XML `<definition>` element.</span></span>  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   <span data-ttu-id="ada9e-3318">如果字元或字元序列未包含的子字串，最後`length`參數等於`endIndex`  -  `startIndex`，其中`endIndex`是傳回的值<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3318">If the character or character sequence is not included in the end of the substring, the `length` parameter equals `endIndex` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span>  
  
 <span data-ttu-id="ada9e-3319">如果`startIndex`等於零且等於目前的字串，該方法的長度會傳回未變更的原始字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3319">If `startIndex` is equal to zero and  equals the length of the current string, the method returns the original string unchanged.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3320">下列範例說明的簡單呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>從第六個字元位置開始的字串擷取兩個字元的方法 （也就是在索引 5）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3320">The following example illustrates a simple call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method that extracts two characters from a string starting at the sixth character position (that is, at index five).</span></span>  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 <span data-ttu-id="ada9e-3321">下列範例會使用<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>在下列三種情況下，隔離在字串內的子字串的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3321">The following example uses the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method in the following three cases to isolate substrings within a string.</span></span> <span data-ttu-id="ada9e-3322">在兩個情況下的子字串會用來比較，並在第三個情況下會擲回例外狀況因為無效的參數會指定。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3322">In two cases the substrings are used in comparisons, and in the third case an exception is thrown because invalid parameters are specified.</span></span>  
  
-   <span data-ttu-id="ada9e-3323">它會擷取單一字元和字串 （位於索引 2） 中的第三個位置，並比較它與"c"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3323">It extracts the single character and the third position in the string (at index 2) and compares it with a "c".</span></span> <span data-ttu-id="ada9e-3324">此比較傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3324">This comparison returns `true`.</span></span>  
  
-   <span data-ttu-id="ada9e-3325">它會擷取第四個位置中 （位於索引 3） 的字串開始的零個字元，並將它傳遞給<xref:System.String.IsNullOrEmpty%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3325">It extracts zero characters starting at the fourth position in the string (at index 3) and passes it to the <xref:System.String.IsNullOrEmpty%2A> method.</span></span> <span data-ttu-id="ada9e-3326">這個傳回 true，因為呼叫<xref:System.String.Substring%2A>方法會傳回<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3326">This returns true because the call to the <xref:System.String.Substring%2A> method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="ada9e-3327">它會嘗試擷取一個字元在字串中第四個位置開始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3327">It attempts to extract one character starting at the fourth position in the string.</span></span> <span data-ttu-id="ada9e-3328">因為在該位置沒有任何字元，方法呼叫會擲回<xref:System.ArgumentOutOfRangeException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3328">Because there is no character at that position, the method call throws an <xref:System.ArgumentOutOfRangeException> exception.</span></span>  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 <span data-ttu-id="ada9e-3329">下列範例會使用<xref:System.String.Substring%2A>方法，以不同的以等號分隔的索引鍵/值配對 （"="） 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3329">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <span data-ttu-id="ada9e-3330"><xref:System.String.IndexOf%2A>方法用來取得的等號字元的字串中的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3330">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.</span></span> <span data-ttu-id="ada9e-3331">若要在呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法會擷取金鑰的名稱，從字串中的第一個字元開始，並擴充的呼叫所傳回的字元數<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3331">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name, which starts from the first character in the string and extends for the number of characters returned by the call to the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="ada9e-3332">若要呼叫<xref:System.String.Substring%28System.Int32%29>方法則會擷取指派給索引鍵的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3332">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="ada9e-3333">它等於字元之外的一個字元位置開始，並延伸至字串結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3333">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-3334"><paramref name="startIndex" /> 加上 <paramref name="length" /> 表示不在此執行個體中的位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3334"><paramref name="startIndex" /> plus <paramref name="length" /> indicates a position not within this instance.</span></span>  
  
<span data-ttu-id="ada9e-3335">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-3335">-or-</span></span> 
 <span data-ttu-id="ada9e-3336"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3336"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span></exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-3337">傳回列舉值，可逐一查看目前的 <see cref="T:System.String" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3337">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3338">強型別列舉值，可用來逐一查看目前的 <see cref="T:System.String" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3338">A strongly-typed enumerator that can be used to iterate through the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3339">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3339">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3340">它可用時，才<xref:System.String>執行個體轉換成<xref:System.Collections.Generic.IEnumerable%601>介面物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3340">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.Generic.IEnumerable%601> interface object.</span></span> <span data-ttu-id="ada9e-3341">如需詳細資訊，請參閱 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3341">For more information, see the <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-3342">傳回列舉值，可逐一查看目前的 <see cref="T:System.String" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3342">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3343">可用來逐一查看目前字串的列舉程式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3343">An enumerator that can be used to iterate through the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3344">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3344">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3345">只有在 <xref:System.String> 執行個體轉換成 <xref:System.Collections.IEnumerable> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3345">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.IEnumerable> interface.</span></span> <span data-ttu-id="ada9e-3346">如需詳細資訊，請參閱 <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3346">For more information, see the <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3347">這個參數已忽略。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3347">This parameter is ignored.</span></span></param>
        <summary><span data-ttu-id="ada9e-3348">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3348">For a description of this member, see <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3349">如果目前字串的值為 <see langword="true" />，則為 <see cref="F:System.Boolean.TrueString" />；如果目前字串的值為 <see langword="false" />，則為 <see cref="F:System.Boolean.FalseString" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3349"><see langword="true" /> if the value of the current string is <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> if the value of the current string is <see cref="F:System.Boolean.FalseString" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3350">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3350">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3351">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3351">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3352">建議的替代做法是呼叫<xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3352">The recommended alternative is to call the <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-3353">目前字串的值不是 <see cref="F:System.Boolean.TrueString" /> 或 <see cref="F:System.Boolean.FalseString" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3353">The value of the current string is not <see cref="F:System.Boolean.TrueString" /> or <see cref="F:System.Boolean.FalseString" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3354">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3354">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3355">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3355">For a description of this member, see <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3356">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3356">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3357">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3357">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3358">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3358">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3359">建議的替代做法是呼叫<xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3359">The recommended alternative is to call the <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-3360">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3360">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ada9e-3361">目前 <see cref="T:System.String" /> 物件的值是大於 <see cref="F:System.Byte.MaxValue" /> 或小於 <see cref="F:System.Byte.MinValue" /> 的數字。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3361">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Byte.MaxValue" /> or less than <see cref="F:System.Byte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3362">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3362">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3363">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3363">For a description of this member, see <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3364">目前 <see cref="T:System.String" /> 物件中位於索引 0 的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3364">The character at index 0 in the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3365">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3365">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3366">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3366">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3367">建議的替代做法是呼叫<xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3367">The recommended alternative is to call the <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3368">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3368">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3369">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3369">For a description of this member, see <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3370">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3370">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3371">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3371">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3372">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3372">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3373">建議的替代做法是呼叫<xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3373">The recommended alternative is to call the <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3374">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3374">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3375">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3375">For a description of this member, see <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3376">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3376">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3377">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3377">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3378">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3378">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3379">建議的替代做法是呼叫<xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3379">The recommended alternative is to call the <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-3380">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3380">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ada9e-3381">目前 <see cref="T:System.String" /> 物件的值是小於 <see cref="F:System.Decimal.MinValue" /> 或大於 <see cref="F:System.Decimal.MaxValue" /> 的數字。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3381">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Decimal.MinValue" /> or than <see cref="F:System.Decimal.MaxValue" /> greater.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3382">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3382">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3383">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3383">For a description of this member, see <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3384">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3384">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3385">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3385">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3386">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3386">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3387">建議的替代做法是呼叫<xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3387">The recommended alternative is to call the <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-3388">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3388">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ada9e-3389">目前 <see cref="T:System.String" /> 物件的值是小於 <see cref="F:System.Double.MinValue" /> 或大於 <see cref="F:System.Double.MaxValue" /> 的數字。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3389">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Double.MinValue" /> or greater than <see cref="F:System.Double.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3390">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3390">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3391">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3391">For a description of this member, see <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3392">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3392">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3393">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3393">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3394">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3394">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3395">建議的替代做法是呼叫<xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3395">The recommended alternative is to call the <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-3396">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3396">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ada9e-3397">目前 <see cref="T:System.String" /> 物件的值是大於 <see cref="F:System.Int16.MaxValue" /> 或小於 <see cref="F:System.Int16.MinValue" /> 的數字。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3397">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Int16.MaxValue" /> or less than <see cref="F:System.Int16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3398">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3398">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3399">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3399">For a description of this member, see <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3400">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3400">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3401">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3401">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3402">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3402">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3403">建議的替代做法是呼叫<xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3403">The recommended alternative is to call the <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3404">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3404">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3405">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3405">For a description of this member, see <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3406">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3406">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3407">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3407">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3408">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3408">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3409">建議的替代做法是呼叫<xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3409">The recommended alternative is to call the <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3410">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3410">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3411">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3411">For a description of this member, see <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3412">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3412">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3413">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3413">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3414">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3414">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3415">建議的替代做法是呼叫<xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3415">The recommended alternative is to call the <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-3416">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3416">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ada9e-3417">目前 <see cref="T:System.String" /> 物件的值是大於 <see cref="F:System.SByte.MaxValue" /> 或小於 <see cref="F:System.SByte.MinValue" /> 的數字。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3417">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.SByte.MaxValue" /> or less than <see cref="F:System.SByte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3418">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3418">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3419">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3419">For a description of this member, see <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3420">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3420">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3421">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3421">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3422">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3422">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3423">建議的替代做法是呼叫<xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3423">The recommended alternative is to call the <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="ada9e-3424">傳回的物件之類型。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3424">The type of the returned object.</span></span></param>
        <param name="provider"><span data-ttu-id="ada9e-3425">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3425">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3426">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3426">For a description of this member, see <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3427">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3427">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3428">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3428">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3429">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3429">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3430">建議的替代做法是呼叫<xref:System.Convert.ChangeType%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3430">The recommended alternative is to call the <xref:System.Convert.ChangeType%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-3431"><paramref name="type" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3431"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="ada9e-3432">無法將目前 <see cref="T:System.String" /> 物件的值轉換成 <paramref name="type" /> 參數所指定的類型。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3432">The value of the current <see cref="T:System.String" /> object cannot be converted to the type specified by the <paramref name="type" /> parameter.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3433">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3433">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3434">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3434">For a description of this member, see <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3435">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3435">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3436">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3436">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3437">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3437">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3438">建議的替代做法是呼叫<xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3438">The recommended alternative is to call the <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-3439">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3439">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ada9e-3440">目前 <see cref="T:System.String" /> 物件的值是大於 <see cref="F:System.UInt16.MaxValue" /> 或小於 <see cref="F:System.UInt16.MinValue" /> 的數字。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3440">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.UInt16.MaxValue" /> or less than <see cref="F:System.UInt16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3441">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3441">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3442">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3442">For a description of this member, see <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3443">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3443">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3444">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3444">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3445">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3445">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3446">建議的替代做法是呼叫<xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3446">The recommended alternative is to call the <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ada9e-3447">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3447">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ada9e-3448">目前 <see cref="T:System.String" /> 物件的值是大於 <see cref="F:System.UInt32.MaxValue" /> 或小於 <see cref="F:System.UInt32.MinValue" /> 的數字</span><span class="sxs-lookup"><span data-stu-id="ada9e-3448">The value of the current <see cref="T:System.String" /> object is a number greater <see cref="F:System.UInt32.MaxValue" /> or less than <see cref="F:System.UInt32.MinValue" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3449">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3449">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3450">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3450">For a description of this member, see <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3451">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3451">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3452">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="ada9e-3452">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="ada9e-3453">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3453">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="ada9e-3454">建議的替代做法是呼叫<xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3454">The recommended alternative is to call the <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-3455">將這個執行個體中的字元複製到 Unicode 字元陣列中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3455">Copies the characters in this instance to a Unicode character array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-3456">將這個執行個體中的字元複製到 Unicode 字元陣列中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3456">Copies the characters in this instance to a Unicode character array.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3457">Unicode 字元陣列，其項目是這個執行個體的個別字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3457">A Unicode character array whose elements are the individual characters of this instance.</span></span> <span data-ttu-id="ada9e-3458">如果這個執行個體是空字串，則傳回的陣列會是空的且長度為零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3458">If this instance is an empty string, the returned array is empty and has a zero length.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3459">這個方法會複製每個字元 (亦即，每個<xref:System.Char>物件) 中的字元陣列的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3459">This method copies each character (that is, each <xref:System.Char> object) in a string to a character array.</span></span> <span data-ttu-id="ada9e-3460">複製的第一個字元是索引位置為零的傳回的字元陣列;複製的最後一個字元位於索引<xref:System.Array.Length%2A?displayProperty=nameWithType>-1。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3460">The first character copied is at index zero of the returned character array; the last character copied is at index <xref:System.Array.Length%2A?displayProperty=nameWithType> - 1.</span></span>  
  
 <span data-ttu-id="ada9e-3461">若要建立字元陣列中的字元字串，呼叫<xref:System.String.%23ctor%28System.Char%5B%5D%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3461">To create a string from the characters in a character array, call the <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor.</span></span>  
  
 <span data-ttu-id="ada9e-3462">若要建立位元組陣列，包含字串中編碼的字元，執行個體化適當<xref:System.Text.Encoding>物件並呼叫其<xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3462">To create a byte array that contains the encoded characters in a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ada9e-3463">在.NET 中可用之標準編碼的下列部分：</span><span class="sxs-lookup"><span data-stu-id="ada9e-3463">Some of the standard encodings available in .NET include the following:</span></span>  
  
|<span data-ttu-id="ada9e-3464">編碼</span><span class="sxs-lookup"><span data-stu-id="ada9e-3464">Encoding</span></span>|<span data-ttu-id="ada9e-3465">Object</span><span class="sxs-lookup"><span data-stu-id="ada9e-3465">Object</span></span>|  
|--------------|------------|  
|<span data-ttu-id="ada9e-3466">ASCII</span><span class="sxs-lookup"><span data-stu-id="ada9e-3466">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|  
|<span data-ttu-id="ada9e-3467">UTF-7</span><span class="sxs-lookup"><span data-stu-id="ada9e-3467">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|  
|<span data-ttu-id="ada9e-3468">UTF-8</span><span class="sxs-lookup"><span data-stu-id="ada9e-3468">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|  
|<span data-ttu-id="ada9e-3469">UTF-16</span><span class="sxs-lookup"><span data-stu-id="ada9e-3469">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|  
|<span data-ttu-id="ada9e-3470">UTF-32</span><span class="sxs-lookup"><span data-stu-id="ada9e-3470">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|  
  
 <span data-ttu-id="ada9e-3471">如需詳細資訊，請參閱 < [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3471">For more information, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3472">下列範例會呼叫<xref:System.String.ToCharArray%2A>来擷取其字元陣列的字串中字元的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3472">The following example calls the <xref:System.String.ToCharArray%2A> method to extract the characters in a string to a character array.</span></span> <span data-ttu-id="ada9e-3473">它接著會顯示原始的字串和元素陣列中。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3473">It then displays the original string and the elements in the array.</span></span>  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 <span data-ttu-id="ada9e-3474">下列範例會定義字串，包含做為分隔符號分隔的字串中的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3474">The following example defines a string containing the characters that serve as delimiters in a delimited string.</span></span> <span data-ttu-id="ada9e-3475">然後它會呼叫<xref:System.String.ToCharArray%2A>方法用來建立字元陣列可傳遞至<xref:System.String.Split%28System.Char%5B%5D%29>分隔的字串分成其個別的子字串的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3475">It then calls the <xref:System.String.ToCharArray%2A> method to create a character array that can be passed to the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate the delimited string into its individual substrings.</span></span>  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="ada9e-3476">這個執行個體中的子字串開始位置。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3476">The starting position of a substring in this instance.</span></span></param>
        <param name="length"><span data-ttu-id="ada9e-3477">這個執行個體中的子字串長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3477">The length of the substring in this instance.</span></span></param>
        <summary><span data-ttu-id="ada9e-3478">將這個執行個體的指定子字串字元複製到 Unicode 字元陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3478">Copies the characters in a specified substring in this instance to a Unicode character array.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3479">Unicode 字元陣列，其項目是從 <paramref name="length" /> 字元位置起始的這個執行個體中的 <paramref name="startIndex" /> 字元數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3479">A Unicode character array whose elements are the <paramref name="length" /> number of characters in this instance starting from character position <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3480">這個方法會複製到字元陣列中字串的一部分的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3480">This method copies the characters in a portion of a string to a character array.</span></span> <span data-ttu-id="ada9e-3481">若要建立一個範圍的字元陣列中的字元字串，呼叫<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3481">To create a string from a range of characters in a character array, call the  <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span>  
  
 <span data-ttu-id="ada9e-3482">`startIndex`參數是以零為起始。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3482">The `startIndex` parameter is zero-based.</span></span> <span data-ttu-id="ada9e-3483">也就是說，在字串執行個體中的第一個字元的索引為零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3483">That is, the index of the first character in the string instance is zero.</span></span>  
  
 <span data-ttu-id="ada9e-3484">如果`length`為零，傳回的陣列是空的長度為零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3484">If `length` is zero, the returned array is empty and has a zero length.</span></span> <span data-ttu-id="ada9e-3485">如果這個執行個體`null`或空字串 ("")，傳回的陣列是空的長度為零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3485">If this instance is `null` or an empty string (""), the returned array is empty and has a zero length.</span></span>  
  
 <span data-ttu-id="ada9e-3486">若要建立位元組陣列，其中包含編碼的字元字串的一部分，產生適當<xref:System.Text.Encoding>物件並呼叫其<xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3486">To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="ada9e-3487">在.NET 中可用之標準編碼的部分包括：</span><span class="sxs-lookup"><span data-stu-id="ada9e-3487">Some of the standard encodings available in .NET include:</span></span>  
  
|<span data-ttu-id="ada9e-3488">編碼</span><span class="sxs-lookup"><span data-stu-id="ada9e-3488">Encoding</span></span>|<span data-ttu-id="ada9e-3489">Object</span><span class="sxs-lookup"><span data-stu-id="ada9e-3489">Object</span></span>|  
|--------------|------------|  
|<span data-ttu-id="ada9e-3490">ASCII</span><span class="sxs-lookup"><span data-stu-id="ada9e-3490">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|  
|<span data-ttu-id="ada9e-3491">UTF-7</span><span class="sxs-lookup"><span data-stu-id="ada9e-3491">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|  
|<span data-ttu-id="ada9e-3492">UTF-8</span><span class="sxs-lookup"><span data-stu-id="ada9e-3492">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|  
|<span data-ttu-id="ada9e-3493">UTF-16</span><span class="sxs-lookup"><span data-stu-id="ada9e-3493">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|  
|<span data-ttu-id="ada9e-3494">UTF-32</span><span class="sxs-lookup"><span data-stu-id="ada9e-3494">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|  
  
 <span data-ttu-id="ada9e-3495">如需詳細資訊，請參閱 < [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3495">For more information, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3496">下列範例會將字串內子字串轉換為陣列的字元，則列舉並顯示陣列的元素。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3496">The following example converts a substring within a string to an array of characters, then enumerates and displays the elements of the array.</span></span>  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ada9e-3497"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3497"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
<span data-ttu-id="ada9e-3498">-或-</span><span class="sxs-lookup"><span data-stu-id="ada9e-3498">-or-</span></span> 
 <span data-ttu-id="ada9e-3499"><paramref name="startIndex" /> 加上 <paramref name="length" /> 大於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3499"><paramref name="startIndex" /> plus <paramref name="length" /> is greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-3500">傳回此字串轉換為小寫的版本。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3500">Returns a copy of this string converted to lowercase.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-3501">傳回此字串轉換為小寫的版本。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3501">Returns a copy of this string converted to lowercase.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3502">小寫的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3502">A string in lowercase.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3503">這個方法會考量目前的文化特性的大小寫規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3503">This method takes into account the casing rules of the current culture.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-3504">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3504">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-3505">相反地，它會傳回目前的執行個體中的所有字元都轉換成小寫的新字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3505">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ada9e-3506">安全性考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-3506">Security Considerations</span></span>  
 <span data-ttu-id="ada9e-3507">呼叫結果大小寫作業<xref:System.String.ToLower>方法會將目前的文化特性的大小寫慣例列入考量。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3507">The casing operation that results from calling the <xref:System.String.ToLower> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="ada9e-3508">如果您需要大寫或小寫版本的作業系統識別項，例如檔案名稱，具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3508">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span> <span data-ttu-id="ada9e-3509">這會產生每個文化特性相同的結果 (不同於<xref:System.String.ToLower>方法)，並更有效率地執行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3509">This produces the same result in every culture (unlike the <xref:System.String.ToLower> method) and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3510">下列範例會將數個混合大小寫的字串轉換成小寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3510">The following example converts several mixed case strings to lowercase.</span></span>  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-3511">中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串大小寫方法，來替代預設值，並改為呼叫需要明確指定參數的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3511">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ada9e-3512">若要將字元轉換為小寫使用目前文化特性的大小寫慣例，呼叫<see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />的值的方法多載<see cref="P:System.Globalization.CultureInfo.CurrentCulture" />針對其<paramref name="culture" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3512">To convert a character to lowercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="ada9e-3513">提供文化特性大小寫規則的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3513">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="ada9e-3514">使用指定之文化特性的大小寫規則，傳回這個字串轉換成小寫的複本。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3514">Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3515">目前字串的小寫對應項。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3515">The lowercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3516">指定的文化特性的大小寫規則`culture`參數可讓您判斷變更的字串大小寫的方式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3516">The casing rules of the culture specified by the `culture` parameter determine the way the case of the string is changed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-3517">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3517">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-3518">相反地，它會傳回目前的執行個體中的所有字元都轉換成小寫的新字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3518">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ada9e-3519">安全性考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-3519">Security Considerations</span></span>  
 <span data-ttu-id="ada9e-3520">如果您傳遞<xref:System.String.ToLower%28System.Globalization.CultureInfo%29>方法<xref:System.Globalization.CultureInfo>以外的其他物件<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>，大小寫作業將會納入考量的特定文化特性的規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3520">If you pass the <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="ada9e-3521">如果您需要大寫或小寫版本的作業系統識別項，例如檔案名稱，具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3521">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ada9e-3522">這樣會產生每個文化特性相同的結果，並更有效率地執行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3522">This produces the same result in every culture and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3523">下列範例會將轉換為小寫字元，使用英文-美國及土耳其文的文化特性的大寫字元的兩個字串，然後比較小寫的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3523">The following example converts two strings of uppercase characters to lowercase characters using the English-United States and Turkish-Turkey cultures, then compares the lowercase strings.</span></span> <span data-ttu-id="ada9e-3524">大寫的字串完全相同，不同之處在於 Unicode LATIN CAPITAL LETTER 我在一個字串中的每個項目，另一個字串包含 LATIN CAPITAL LETTER I 與點上方。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3524">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-3525"><paramref name="culture" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3525"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-3526">使用不因文化特性而異的大小寫規則，傳回轉換成小寫的這個 <see cref="T:System.String" /> 物件之複本。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3526">Returns a copy of this <see cref="T:System.String" /> object converted to lowercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3527">目前字串的小寫對應項。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3527">The lowercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3528">文化特性而異表示不區分文化特性的文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3528">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="ada9e-3529">相關聯的英文語言使用，但不是能搭配特定國家或地區。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3529">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="ada9e-3530">如需詳細資訊，請參閱 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 屬性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3530">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="ada9e-3531">如果您的應用程式相依於大小寫的字串，變更不會受到目前文化特性使用的可預測方式<xref:System.String.ToLowerInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3531">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToLowerInvariant%2A> method.</span></span> <span data-ttu-id="ada9e-3532"><xref:System.String.ToLowerInvariant%2A>方法就相當於`ToLower(CultureInfo.InvariantCulture)`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3532">The <xref:System.String.ToLowerInvariant%2A> method is equivalent to `ToLower(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="ada9e-3533">字串集合必須出現在使用者介面控制項中可預測的順序時，建議的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3533">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-3534">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3534">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-3535">相反地，它會傳回目前的執行個體中的所有字元都轉換成小寫的新字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3535">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ada9e-3536">安全性考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-3536">Security Considerations</span></span>  
 <span data-ttu-id="ada9e-3537">如果您需要大寫或小寫版本的作業系統識別項，例如檔案名稱，具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3537">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3538">下列範例會定義包含有多種語言中的一個字的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3538">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="ada9e-3539"><xref:System.String.ToLowerInvariant%2A>方法用來填入每個單字的不區分大小寫版本的平行陣列元素。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3539">The <xref:System.String.ToLowerInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="ada9e-3540"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法用來排序依據以確保項目，會出現在相同的順序，不論語言為何小寫的陣列中項目順序的區分大小寫陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3540">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the lowercase array to ensure that elements appear in the same order regardless of language.</span></span>  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-3541">將這個執行個體的值轉換為 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3541">Converts the value of this instance to a <see cref="T:System.String" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-3542">傳回這個 <see cref="T:System.String" /> 執行個體；不會實際執行轉換。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3542">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3543">目前的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3543">The current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3544">這個方法只會傳回目前的字串不變，因為沒有需要直接呼叫它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3544">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span> <span data-ttu-id="ada9e-3545">它通常隱含地呼叫中的複合格式化作業，如範例所示。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3545">It is usually called implicitly in a composite formatting operation, as the example shows.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3546">下列範例示範<xref:System.String.ToString%2A>方法。請注意，此範例不會明確呼叫<xref:System.String.ToString%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3546">The following example demonstrates the <xref:System.String.ToString%2A> method.Note that the example does not explicitly call the <xref:System.String.ToString%2A> method.</span></span> <span data-ttu-id="ada9e-3547">相反地，呼叫該方法所隱含[複合格式](~/docs/standard/base-types/composite-formatting.md)功能。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3547">Instead, the method is called implicitly by the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature.</span></span>  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ada9e-3548">(保留) 物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3548">(Reserved) An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ada9e-3549">傳回這個 <see cref="T:System.String" /> 執行個體；不會實際執行轉換。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3549">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3550">目前的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3550">The current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3551">`provider` 為保留字，以及目前參與這項作業。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3551">`provider` is reserved, and does not currently participate in this operation.</span></span>  
  
 <span data-ttu-id="ada9e-3552">這個方法只會傳回目前的字串不變，因為沒有需要直接呼叫它。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3552">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-3553">傳回此字串轉換為大寫的版本。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3553">Returns a copy of this string converted to uppercase.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-3554">傳回此字串轉換為大寫的版本。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3554">Returns a copy of this string converted to uppercase.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3555">目前字串的大寫對應項。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3555">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3556">此方法會使用目前文化特性的大小寫規則，將目前的執行個體中的每個字元轉換成其對等大寫。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3556">This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent.</span></span> <span data-ttu-id="ada9e-3557">如果字元沒有對等大寫，它會原封不動包含在傳回的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3557">If a character does not have an uppercase equivalent, it is included unchanged in the returned string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-3558">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3558">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-3559">相反地，它會傳回目前的執行個體中的所有字元都轉換成大寫的新字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3559">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
 <span data-ttu-id="ada9e-3560"><xref:System.String.ToUpper%2A>方法通常用來將字串轉換成大寫，這樣就可以使用不區分大小寫的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3560">The <xref:System.String.ToUpper%2A> method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison.</span></span> <span data-ttu-id="ada9e-3561">更好的方法，以執行不區分大小寫的比較是呼叫字串比較方法具有<xref:System.StringComparison>參數設為其值<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>進行區分文化特性、 不區分大小寫的比較。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3561">A better method to perform case-insensitive comparison is to call a string comparison method that has a <xref:System.StringComparison> parameter whose value you set to <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> for a culture-sensitive, case-insensitive comparison.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ada9e-3562">安全性考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-3562">Security Considerations</span></span>  
 <span data-ttu-id="ada9e-3563">呼叫結果大小寫作業<xref:System.String.ToUpper>方法會將目前的文化特性的大小寫慣例列入考量。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3563">The casing operation that results from calling the <xref:System.String.ToUpper> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="ada9e-3564">如果您需要大寫或小寫版本的作業系統識別項，例如檔案名稱，具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3564">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ada9e-3565">這會產生每個文化特性相同的結果 (不同於<xref:System.String.ToUpper>方法)，並更有效率地執行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3565">This produces the same result in every culture (unlike the <xref:System.String.ToUpper> method) and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3566">下列範例會呼叫<xref:System.String.ToUpper%2A>方法，將一系列的單字元字串包含基本拉丁、 拉丁文 1 補充和拉丁文擴充-A 字元集中的每個字元的轉換。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3566">The following example calls the <xref:System.String.ToUpper%2A> method to convert a series of one-character strings that contain each character in the Basic Latin, Latin-1 Supplement, and Latin Extended-A character sets.</span></span> <span data-ttu-id="ada9e-3567">然後，它會顯示每個字串，其大寫的字元是不同於其小寫的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3567">It then displays each string whose uppercase character is different from its lowercase character.</span></span>  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-3568">中所述[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串大小寫方法，來替代預設值，並改為呼叫需要明確指定參數的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3568">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="ada9e-3569">若要將字串轉換為大寫使用目前文化特性的大小寫慣例，呼叫<see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" />的值的方法多載<see cref="P:System.Globalization.CultureInfo.CurrentCulture" />針對其<paramref name="culture" />參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3569">To convert a string to uppercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="ada9e-3570">提供文化特性大小寫規則的物件。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3570">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="ada9e-3571">使用指定之文化特性的大小寫規則，傳回這個字串轉換成大寫的複本。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3571">Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3572">目前字串的大寫對應項。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3572">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3573">指定的文化特性的大小寫規則`culture`參數可讓您判斷變更的字串大小寫的方式。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3573">The casing rules of the culture specified by the `culture` parameter determine the way the case of a string is changed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-3574">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3574">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-3575">相反地，它會傳回目前的執行個體中的所有字元都轉換成大寫的新字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3575">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ada9e-3576">安全性考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-3576">Security Considerations</span></span>  
 <span data-ttu-id="ada9e-3577">如果您傳遞<xref:System.String.ToUpper%28System.Globalization.CultureInfo%29>方法<xref:System.Globalization.CultureInfo>以外的其他物件<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>，大小寫作業將會納入考量的特定文化特性的規則。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3577">If you pass the <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="ada9e-3578">如果您需要大寫或小寫版本的作業系統識別項，例如檔案名稱，具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3578">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ada9e-3579">這樣會產生每個文化特性相同的結果，並更有效率地執行。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3579">This produces the same result in every culture and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3580">下列範例會將小寫字元的字串轉換成大寫字元，使用英文-美國及土耳其文的文化特性的兩個字串，然後比較大寫的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3580">The following example converts a string of lowercase characters to two strings of uppercase characters using the English-United States and Turkish-Turkey cultures, then compares the uppercase strings.</span></span> <span data-ttu-id="ada9e-3581">大寫的字串完全相同，不同之處在於 Unicode LATIN CAPITAL LETTER 我在一個字串中的每個項目，另一個字串包含 LATIN CAPITAL LETTER I 與點上方。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3581">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ada9e-3582"><paramref name="culture" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3582"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-3583">使用不因文化特性而異的大小寫規則，傳回轉換成大寫的這個 <see cref="T:System.String" /> 物件之複本。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3583">Returns a copy of this <see cref="T:System.String" /> object converted to uppercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3584">目前字串的大寫對應項。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3584">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3585">文化特性而異表示不區分文化特性的文化特性。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3585">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="ada9e-3586">相關聯的英文語言使用，但不是能搭配特定國家或地區。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3586">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="ada9e-3587">如需詳細資訊，請參閱 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 屬性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3587">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="ada9e-3588">如果您的應用程式相依於大小寫的字串，變更不會受到目前文化特性使用的可預測方式<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3588">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="ada9e-3589"><xref:System.String.ToUpperInvariant%2A>方法就相當於`ToUpper(CultureInfo.InvariantCulture)`。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3589">The <xref:System.String.ToUpperInvariant%2A> method is equivalent to `ToUpper(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="ada9e-3590">字串集合必須出現在使用者介面控制項中可預測的順序時，建議的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3590">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-3591">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3591">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-3592">相反地，它會傳回目前的執行個體中的所有字元都轉換成大寫的新字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3592">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="ada9e-3593">安全性考量</span><span class="sxs-lookup"><span data-stu-id="ada9e-3593">Security Considerations</span></span>  
 <span data-ttu-id="ada9e-3594">如果您需要大寫或小寫版本的作業系統識別項，例如檔案名稱，具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3594">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3595">下列範例會定義包含有多種語言中的一個字的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3595">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="ada9e-3596"><xref:System.String.ToUpperInvariant%2A>方法用來填入每個單字的不區分大小寫版本的平行陣列元素。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3596">The <xref:System.String.ToUpperInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="ada9e-3597"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法用來排序依據以確保項目，會出現在相同的順序，不論語言為何大寫的陣列中項目順序的區分大小寫陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3597">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the uppercase array to ensure that elements appear in the same order regardless of language.</span></span>  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ada9e-3598">傳回新字串，其中已經移除出現在目前 <see cref="T:System.String" /> 物件中之所有開頭與結尾的一組指定的字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3598">Returns a new string in which all leading and trailing occurrences of a set of specified characters from the current <see cref="T:System.String" /> object are removed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ada9e-3599">從目前的 <see cref="T:System.String" /> 物件中移除所有的開頭和結尾空白字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3599">Removes all leading and trailing white-space characters from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3600">從目前字串的開頭和結尾移除所有空白字元後，所保留下來的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3600">The string that remains after all white-space characters are removed from the start and end of the current string.</span></span> <span data-ttu-id="ada9e-3601">如果在目前的執行個體中無法修剪任何字元，則方法傳回未變更的目前執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3601">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3602"><xref:System.String.Trim%2A>方法從目前字串中移除所有開頭和尾端空白字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3602">The <xref:System.String.Trim%2A> method removes from the current string all leading and trailing white-space characters.</span></span> <span data-ttu-id="ada9e-3603">發現非空格字元時，每個前置和尾端的修剪作業就會停止。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3603">Each leading and trailing trim operation stops when a non-white-space character is encountered.</span></span> <span data-ttu-id="ada9e-3604">例如，如果目前字串為"abc xyz"，<xref:System.String.Trim%2A>方法會傳回"abc xyz"。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3604">For example, if the current string is "   abc   xyz   ", the <xref:System.String.Trim%2A> method returns "abc   xyz".</span></span> <span data-ttu-id="ada9e-3605">若要移除字串中的字組之間的空格字元，請使用[.NET 規則運算式](~/docs/standard/base-types/regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3605">To remove white-space characters between words in a string, use [.NET Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-3606">如果<xref:System.String.Trim%2A>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3606">If the <xref:System.String.Trim%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-3607">相反地，它會傳回新字串，在目前的執行個體中找到之所有開頭和尾端的空格字元都會被移除。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3607">Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.</span></span>  
  
 <span data-ttu-id="ada9e-3608">如果目前字串等於<xref:System.String.Empty>或空格字元，包含目前的執行個體中的所有字元，則方法會傳回<xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3608">If the current string equals <xref:System.String.Empty> or all the characters in the current instance consist of white-space characters, the method returns <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ada9e-3609">泛空白字元是由 Unicode 標準定義。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3609">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="ada9e-3610"><xref:System.String.Trim>方法會移除任何產生傳回值的開頭和尾端字元`true`傳遞至時<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3610">The <xref:System.String.Trim> method removes any leading and trailing characters that produce a return value of `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3611">下列範例會使用<xref:System.String.Trim?displayProperty=nameWithType>方法，以從使用者輸入再將它們串連的字串中移除任何額外的空白字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3611">The following example uses the <xref:System.String.Trim?displayProperty=nameWithType> method to remove any extra white space from strings entered by the user before concatenating them.</span></span>  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-3612">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本維護的內部清單，這個方法會修剪的空格字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3612">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintain an internal list of white-space characters that this method trims.</span></span> <span data-ttu-id="ada9e-3613">開頭[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，方法會修剪所有 Unicode 泛空白字元 (也就是個字元產生<see langword="true" />傳回值時傳遞至<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3613">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="ada9e-3614">這項變更，因為<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本中移除兩個字元，零寬度的空格 (U + 200B) 和零寬度的不分行空格 (U + FEFF)，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，以及更新版本無法移除。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3614">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove.</span></span> <span data-ttu-id="ada9e-3615">颾魤 ㄛ<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本不會修剪三種 Unicode 空白字元：蒙古文母音分隔符號 (U + 180E) 」、 「 窄的不中斷空格 (U + 202F)，以及 「 媒體數學空間 (U + 205F) 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3615">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="ada9e-3616">要移除的 Unicode 字元陣列或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3616">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-3617">從目前的 <see cref="T:System.String" /> 物件中移除陣列中指定之一組字元的所有開頭和結尾指定項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3617">Removes all leading and trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3618">從目前的字串開頭和結尾處移除 <paramref name="trimChars" /> 參數中所有出現的字元後，所保留下來的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3618">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the start and end of the current string.</span></span> <span data-ttu-id="ada9e-3619">如果 <paramref name="trimChars" /> 是 <see langword="null" /> 或空陣列，則反而會移除空白字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3619">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span></span> <span data-ttu-id="ada9e-3620">如果在目前的執行個體中無法修剪任何字元，則方法傳回未變更的目前執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3620">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3621"><xref:System.String.Trim%2A>方法會移除目前的字串中的所有開頭和尾端字元`trimChars`參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3621">The <xref:System.String.Trim%2A> method removes from the current string all leading and trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="ada9e-3622">每個前置和尾端空白位置修剪作業停駐點時不在字元`trimChars`為止。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3622">Each leading and trailing trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="ada9e-3623">比方說，如果目前字串為"123abc456xyz789 」 以及`trimChars`包含的數字"1"到"9"，從<xref:System.String.Trim%2A>方法會傳回"abc456xyz 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3623">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.Trim%2A> method returns "abc456xyz".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-3624">如果<xref:System.String.Trim%2A>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3624">If the <xref:System.String.Trim%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-3625">相反地，它會傳回新的字串中所有開頭和尾端`trimChars`在目前的執行個體中找到的字元會被移除。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3625">Instead, it returns a new string in which all leading and trailing `trimChars` characters found in the current instance are removed.</span></span>  
  
 <span data-ttu-id="ada9e-3626">如果目前字串等於<xref:System.String.Empty>中的字元，包含目前的執行個體中的所有字元`trimChars`陣列，此方法會傳回<xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3626">If the current string equals <xref:System.String.Empty> or all the characters in the current instance consist of characters in the `trimChars` array, the method returns <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="ada9e-3627">如果`trimChars`已`null`或空陣列，這個方法會移除會導致方法傳回的任何前置或尾端字元`true`傳遞至時<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法</span><span class="sxs-lookup"><span data-stu-id="ada9e-3627">If `trimChars` is `null` or an empty array, this method removes any leading or trailing characters that result in the method returning `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method,</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3628">下列範例會使用<xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType>方法來移除字串中的空間、 星號 （\*） 和所有格符號 （'） 字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3628">The following example uses the <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> method to remove space, asterisk (\*), and apostrophe (') characters from a string.</span></span>  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-3629">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本維護的內部清單，這個方法會修剪如果的空格字元<paramref name="trimChars" />是<see langword="null" />或空陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3629">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="ada9e-3630">開頭[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，如果<paramref name="trimChars" />是<see langword="null" />或空陣列，此方法會修剪所有 Unicode 泛空白字元 (也就是個字元產生<see langword="true" />傳回的值時傳遞至<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3630">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="ada9e-3631">這項變更，因為<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本中移除兩個字元，零寬度的空格 (U + 200B) 和零寬度的不分行空格 (U + FEFF)，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，以及更新版本無法移除。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3631">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove.</span></span> <span data-ttu-id="ada9e-3632">颾魤 ㄛ<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本不會修剪三種 Unicode 空白字元：蒙古文母音分隔符號 (U + 180E) 」、 「 窄的不中斷空格 (U + 202F)，以及 「 媒體數學空間 (U + 205F) 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3632">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="ada9e-3633">要移除的 Unicode 字元陣列或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3633">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-3634">從目前的 <see cref="T:System.String" /> 物件中移除陣列中指定之一組字元的所有結尾指定項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3634">Removes all trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3635">從目前的字串結尾處移除 <paramref name="trimChars" /> 參數中所有出現的字元後，所保留下來的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3635">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the end of the current string.</span></span> <span data-ttu-id="ada9e-3636">如果 <paramref name="trimChars" /> 是 <see langword="null" /> 或空陣列，則反而會移除 Unicode 空白字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3636">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, Unicode white-space characters are removed instead.</span></span> <span data-ttu-id="ada9e-3637">如果在目前的執行個體中無法修剪任何字元，則方法傳回未變更的目前執行個體。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3637">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3638"><xref:System.String.TrimEnd%2A>方法會移除目前的字串中的所有行尾字元`trimChars`參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3638">The <xref:System.String.TrimEnd%2A> method removes from the current string all trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="ada9e-3639">修剪作業停止時的第一個字元不在`trimChars`發生在字串結尾。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3639">The trim operation stops when the first character that is not in `trimChars` is encountered at the end of the string.</span></span> <span data-ttu-id="ada9e-3640">比方說，如果目前字串為"123abc456xyz789 」 以及`trimChars`包含的數字"1"到"9"，從<xref:System.String.TrimEnd%2A>方法會傳回"123abc456xyz 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3640">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.TrimEnd%2A> method returns "123abc456xyz".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-3641">如果<xref:System.String.TrimEnd%2A>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3641">If the <xref:System.String.TrimEnd%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-3642">相反地，它會傳回新字串中找到的所有尾端字元`trimChars`會從目前字串中移除。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3642">Instead, it returns a new string in which all trailing characters found in `trimChars` are removed from the current string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3643">下列範例示範如何使用<xref:System.String.TrimEnd%28System.Char%5B%5D%29>修剪空白字元或標點符號，從字串結尾的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3643">The following example demonstrates how you can use the <xref:System.String.TrimEnd%28System.Char%5B%5D%29> method to trim white space or punctuation marks from the end of a string.</span></span>  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-3644">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本維護的內部清單，這個方法會修剪如果的空格字元<paramref name="trimChars" />是<see langword="null" />或空陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3644">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="ada9e-3645">開頭[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，如果<paramref name="trimChars" />是<see langword="null" />或空陣列，此方法會修剪所有 Unicode 泛空白字元 (也就是個字元產生<see langword="true" />傳回的值時傳遞至<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3645">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="ada9e-3646">這項變更，因為<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本中移除兩個字元，零寬度的空格 (U + 200B) 和零寬度的不分行空格 (U + FEFF)，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，以及更新版本無法移除。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3646">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove.</span></span> <span data-ttu-id="ada9e-3647">颾魤 ㄛ<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本不會修剪三種 Unicode 空白字元：蒙古文母音分隔符號 (U + 180E) 」、 「 窄的不中斷空格 (U + 202F)，以及 「 媒體數學空間 (U + 205F) 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3647">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="ada9e-3648">要移除的 Unicode 字元陣列或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3648">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ada9e-3649">從目前的 <see cref="T:System.String" /> 物件中移除陣列中指定之一組字元的所有開頭指定項目。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3649">Removes all leading occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="ada9e-3650">從目前的字串開頭處移除 <paramref name="trimChars" /> 參數中所有出現的字元後，所保留下來的字串。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3650">The string that remains after all occurrences of characters in the <paramref name="trimChars" /> parameter are removed from the start of the current string.</span></span> <span data-ttu-id="ada9e-3651">如果 <paramref name="trimChars" /> 是 <see langword="null" /> 或空陣列，則反而會移除空白字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3651">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ada9e-3652"><xref:System.String.TrimStart%2A>方法會移除目前的字串中的所有前置字元`trimChars`參數。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3652">The <xref:System.String.TrimStart%2A> method removes from the current string all leading characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="ada9e-3653">修剪作業停止時不在字元`trimChars`為止。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3653">The trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="ada9e-3654">比方說，如果目前字串為"123abc456xyz789 」 以及`trimChars`包含的數字"1"到"9"，從<xref:System.String.TrimStart%2A>方法會傳回"abc456xyz789 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3654">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.TrimStart%2A> method returns "abc456xyz789".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ada9e-3655">如果<xref:System.String.TrimStart%2A>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3655">If the <xref:System.String.TrimStart%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="ada9e-3656">相反地，它會傳回新字串，在目前的執行個體中找到的所有前置空白字元字元會被移除。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3656">Instead, it returns a new string in which all leading white space characters found in the current instance are removed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ada9e-3657">下列範例示範基本功能的<xref:System.String.TrimStart%2A>方法：</span><span class="sxs-lookup"><span data-stu-id="ada9e-3657">The following example demonstrates the basic functionality of the <xref:System.String.TrimStart%2A> method:</span></span>

 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

 <span data-ttu-id="ada9e-3658">下列範例會使用<xref:System.String.TrimStart%2A>修剪空白字元和註解字元的原始程式碼程式行的方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3658">The following example uses the <xref:System.String.TrimStart%2A> method to trim white space and comment characters from lines of source code.</span></span> <span data-ttu-id="ada9e-3659">`StripComments`方法會包裝對<xref:System.String.TrimStart%2A>並將它傳遞字元陣列，包含空格和註解字元，也就是單引號 （'） 在 Visual Basic 和 C# 中的斜線 （/）。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3659">The `StripComments` method wraps a call to <xref:System.String.TrimStart%2A> and passes it a character array that contains a space and the comment character, which is an apostrophe ( ' ) in Visual Basic and a slash ( / ) in C#.</span></span> <span data-ttu-id="ada9e-3660"><xref:System.String.TrimStart%2A>也會呼叫方法來評估的字串是否為註解時，請移除前置空白字元。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3660">The <xref:System.String.TrimStart%2A> method is also called to remove leading white space when evaluating whether a string is a comment.</span></span>  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 <span data-ttu-id="ada9e-3661">下列範例說明如何呼叫 `StripComments` 方法。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3661">The following example then illustrates a call to the `StripComments` method.</span></span>  
  
 [!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
 [!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="ada9e-3662">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本維護的內部清單，這個方法會修剪如果的空格字元<paramref name="trimChars" />是<see langword="null" />或空陣列。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3662">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="ada9e-3663">開頭[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，如果<paramref name="trimChars" />是<see langword="null" />或空陣列，此方法會修剪所有 Unicode 泛空白字元 (也就是個字元產生<see langword="true" />傳回的值時傳遞至<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3663">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="ada9e-3664">這項變更，因為<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本中移除兩個字元，零寬度的空格 (U + 200B) 和零寬度的不分行空格 (U + FEFF)，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，以及更新版本無法移除。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3664">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove.</span></span> <span data-ttu-id="ada9e-3665">颾魤 ㄛ<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本不會修剪三種 Unicode 空白字元：蒙古文母音分隔符號 (U + 180E) 」、 「 窄的不中斷空格 (U + 202F)，以及 「 媒體數學空間 (U + 205F) 」。</span><span class="sxs-lookup"><span data-stu-id="ada9e-3665">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>