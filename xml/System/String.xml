<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="String.xml" source-language="en-US" target-language="zh-TW">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52995513b1f67d4db1b556f9a57e9c9f8d760d982.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2995513b1f67d4db1b556f9a57e9c9f8d760d982</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Represents text as a sequence of UTF-16 code units.</source>
          <target state="translated">以一連串的 UTF-16 字碼單位表示文字。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string is a sequential collection of characters that is used to represent text.</source>
          <target state="translated">字串是用來代表文字的字元的循序集合。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A <ph id="ph1">&lt;xref:System.String&gt;</ph> object is a sequential collection of <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> objects that represent a string; a <ph id="ph3">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> object corresponds to a UTF-16 code unit.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.String&gt;</ph>物件是循序集合<ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph>物件來代表字串;<ph id="ph3">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph>物件會對應至的 utf-16 字碼單位。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The value of the <ph id="ph1">&lt;xref:System.String&gt;</ph> object is the content of the sequential collection of <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> objects, and that value is immutable (that is, it is read-only).</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.String&gt;</ph>物件的循序集合的內容<ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph>物件和值是不變 （也就是說，它位於唯讀）。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about the immutability of strings, see the <bpt id="p1">[</bpt>Immutability and the StringBuilder class<ept id="p1">](#Immutability)</ept> section later in this topic.</source>
          <target state="translated">字串的不變性的相關資訊，請參閱<bpt id="p1">[</bpt>不變性和 StringBuilder 類別<ept id="p1">](#Immutability)</ept>本主題稍後的章節。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The maximum size of a <ph id="ph1">&lt;xref:System.String&gt;</ph> object in memory is 2GB, or about 1 billion characters.</source>
          <target state="translated">大小上限<ph id="ph1">&lt;xref:System.String&gt;</ph>在記憶體中的物件是 2 GB 或大約 1 億個字元。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this section:</source>
          <target state="translated">本節內容：</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Instantiating a String object<ept id="p1">](#Instantiation)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>具現化字串物件<ept id="p1">](#Instantiation)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Char objects and Unicode characters<ept id="p1">](#Characters)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Char 物件和 Unicode 字元<ept id="p1">](#Characters)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Strings and The Unicode Standard<ept id="p1">](#Unicode)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>字串和 Unicode 標準<ept id="p1">](#Unicode)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Strings and embedded null characters<ept id="p1">](#EmbeddedNulls)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>字串和內嵌的 null 字元<ept id="p1">](#EmbeddedNulls)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Strings and indexes<ept id="p1">](#Indexes)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>字串與索引<ept id="p1">](#Indexes)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Null strings and empty strings<ept id="p1">](#Nulls)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Null 字串值和空白字串<ept id="p1">](#Nulls)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Immutability and the StringBuilder class<ept id="p1">](#Immutability)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>不變性和 StringBuilder 類別<ept id="p1">](#Immutability)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Ordinal vs. culture-sensitive operations<ept id="p1">](#CultureSensitive)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>序數和區分文化特性的作業<ept id="p1">](#CultureSensitive)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>正規化<ept id="p1">](#Normalization)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>依類別目錄的字串作業<ept id="p1">](#ByCategory)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Instantiating a String object</source>
          <target state="translated">具現化字串物件</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.String&gt;</ph> object in the following ways:</source>
          <target state="translated">您可以具現化<ph id="ph1">&lt;xref:System.String&gt;</ph>物件如下：</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By assigning a string literal to a <ph id="ph1">&lt;xref:System.String&gt;</ph> variable.</source>
          <target state="translated">將字串常值指定<ph id="ph1">&lt;xref:System.String&gt;</ph>變數。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the most commonly used method for creating a string.</source>
          <target state="translated">這是最常使用的方法來建立字串。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses assignment to create several strings.</source>
          <target state="translated">下列範例會使用指派，建立數個字串。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that in C#, because the backslash (<ph id="ph1">\\</ph>) is an escape character, literal backslashes in a string must be escaped or the entire string must be <ph id="ph2">@-quoted</ph>.</source>
          <target state="translated">請注意，在 C# 中，因為反斜線 (<ph id="ph1">\\</ph>) 逸出字元，必須逸出字串中的常值反斜線或整個字串必須<ph id="ph2">@-quoted</ph>。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By calling a <ph id="ph1">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">藉由呼叫<ph id="ph1">&lt;xref:System.String&gt;</ph>類別建構函式。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example instantiates strings by calling several class constructors.</source>
          <target state="translated">下列範例會產生字串，藉由呼叫數個類別建構函式。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters.</source>
          <target state="translated">請注意，有些建構函式會包含字元陣列或做為參數的帶正負號的位元組陣列的指標。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Visual Basic does not support calls to these constructors.</source>
          <target state="translated">Visual Basic 不支援這些建構函式的呼叫。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For detailed information about <ph id="ph1">&lt;xref:System.String&gt;</ph> constructors, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">如需詳細資訊<ph id="ph1">&lt;xref:System.String&gt;</ph>建構函式，請參閱<ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph>建構函式的摘要。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By using the string concatenation operator (+ in C# and &amp; or + in Visual Basic) to create a single string from any combination of <ph id="ph1">&lt;xref:System.String&gt;</ph> instances and string literals.</source>
          <target state="translated">使用字串串連運算子 (+ 在 C# 和 （&amp; c) 或 + 在 Visual Basic 中) 從的任何組合建立單一字串<ph id="ph1">&lt;xref:System.String&gt;</ph>執行個體和字串常值。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the use of the string concatenation operator.</source>
          <target state="translated">下列範例說明如何使用字串串連運算子。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By retrieving a property or calling a method that returns a string.</source>
          <target state="translated">擷取屬性，或呼叫的方法，傳回的字串。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the methods of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class to extract a substring from a larger string.</source>
          <target state="translated">下列範例會使用的方法<ph id="ph1">&lt;xref:System.String&gt;</ph>類別，以從較大的字串擷取子字串。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By calling a formatting method to convert a value or object to its string representation.</source>
          <target state="translated">藉由呼叫格式化方法要為其字串表示轉換的值或物件。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the                <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature to embed the string representation of two objects into a string.</source>
          <target state="translated">下列範例會使用<bpt id="p1">[</bpt>複合格式化<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>內嵌兩個物件的字串表示，轉換為字串的功能。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Char objects and Unicode characters</source>
          <target state="translated">Char 物件和 Unicode 字元</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character.</source>
          <target state="translated">在字串中的每一個字元是由 Unicode 純量值，也稱為 Unicode 字碼指標或 Unicode 字元的序數 （數值） 定義。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
          <target state="translated">每個字碼指標使用 utf-16 編碼，進行編碼，而每個項目編碼方式的數字值由<ph id="ph1">&lt;xref:System.Char&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that, because a <ph id="ph1">&lt;xref:System.String&gt;</ph> instance consists of a sequential collection of UTF-16 code units, it is possible to create a <ph id="ph2">&lt;xref:System.String&gt;</ph> object that is not a well-formed Unicode string.</source>
          <target state="translated">請注意，因為<ph id="ph1">&lt;xref:System.String&gt;</ph>循序集合的 utf-16 字碼單位執行個體所組成，您可以建立<ph id="ph2">&lt;xref:System.String&gt;</ph>不是語式正確的 Unicode 字串的物件。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate.</source>
          <target state="translated">比方說，就可以建立沒有對應的高 surrogate 的低 surrogate 的字串。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Although some methods, such as the methods of encoding and decoding objects in the <ph id="ph1">&lt;xref:System.Text&gt;</ph> namespace, may performs checks to ensure that strings are well-formed, <ph id="ph2">&lt;xref:System.String&gt;</ph> class members don't ensure that a string is well-formed.</source>
          <target state="translated">雖然某些方法，例如使用的編碼和解碼物件方法<ph id="ph1">&lt;xref:System.Text&gt;</ph>命名空間，可能會執行檢查以確定字串為格式正確，<ph id="ph2">&lt;xref:System.String&gt;</ph>類別成員不確定該字串會是語式正確。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A single <ph id="ph1">&lt;xref:System.Char&gt;</ph> object usually represents a single code point; that is, the numeric value of the <ph id="ph2">&lt;xref:System.Char&gt;</ph> equals the code point.</source>
          <target state="translated">單一<ph id="ph1">&lt;xref:System.Char&gt;</ph>物件通常代表單一字碼指標，也就是數字值<ph id="ph2">&lt;xref:System.Char&gt;</ph>等於字碼指標。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the code point for the character "a" is U+0061.</source>
          <target state="translated">例如，字碼指標"的字元 a"是 U + 0061。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, a code point might require more than one encoded element (more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph> object).</source>
          <target state="translated">不過，字碼指標可能會需要多個編碼項目 (一個以上<ph id="ph1">&lt;xref:System.Char&gt;</ph>物件)。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The Unicode standard defines two types of characters that correspond to multiple <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.</source>
          <target state="translated">Unicode 標準會定義兩種類型的字元會對應至多個<ph id="ph1">&lt;xref:System.Char&gt;</ph>物件： graphemes，並對應至 Unicode 補充平面中的字元的 Unicode 補充字碼指標。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A grapheme is represented by a base character followed by one or more combining characters.</source>
          <target state="translated">字母是由基底的字元，後面接著一個或多個組合字元表示。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the character ä is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object whose code point is U+0061 followed by a <ph id="ph2">&lt;xref:System.Char&gt;</ph> object whose code point is U+0308.</source>
          <target state="translated">例如，ä 的字元由 a<ph id="ph1">&lt;xref:System.Char&gt;</ph>物件，其字碼指標為 U + 0061 後面接著 a<ph id="ph2">&lt;xref:System.Char&gt;</ph>物件，其字碼指標為 U + 0308年。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This character can also be defined by a single <ph id="ph1">&lt;xref:System.Char&gt;</ph> object that has a code point of U+00E4.</source>
          <target state="translated">這個字元也可以定義由單一<ph id="ph1">&lt;xref:System.Char&gt;</ph>具有的字碼指標 U + 00E4 物件。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not.</source>
          <target state="translated">如下列範例所示，區分文化特性的比較相等表示這些兩種表示法相等，雖然一般的序數比較並不會。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, if the two strings are normalized, an ordinal comparison also indicates that they are equal.</source>
          <target state="translated">不過，如果兩個字串正規化，序數比較也會指出它們是否相等。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(For more information on normalizing strings, see the <bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept> section.)</source>
          <target state="translated">(如需有關正規化字串的詳細資訊，請參閱<bpt id="p1">[</bpt>正規化<ept id="p1">](#Normalization)</ept>&gt; 一節。)</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A Unicode supplementary code point (a surrogate pair) is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object whose code point is a high surrogate followed by a <ph id="ph2">&lt;xref:System.Char&gt;</ph> object whose code point is a low surrogate.</source>
          <target state="translated">增補的字碼指標 （surrogate 字組） 由 Unicode<ph id="ph1">&lt;xref:System.Char&gt;</ph>其字碼指標是否為高 surrogate 的物件後面<ph id="ph2">&lt;xref:System.Char&gt;</ph>其字碼指標是否為低 surrogate 的物件。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The code units of high surrogates range from U+D800 to U+DBFF.</source>
          <target state="translated">高 surrogate 範圍從 U + D800 到 U + DBFF 的程式碼單元。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The code units of low surrogates range from U+DC00 to U+DFFF.</source>
          <target state="translated">低 surrogate 範圍是從 U + DC00 到 U + dfff 範圍內的程式碼單元。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes.</source>
          <target state="translated">Surrogate 字組用來代表 16 的 Unicode 補充平面中的字元。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example creates a surrogate character and passes it to the <ph id="ph1">&lt;xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> method to determine whether it is a surrogate pair.</source>
          <target state="translated">下列範例會建立 surrogate 字元，並將其傳遞給<ph id="ph1">&lt;xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph>方法，以判斷其是否為 surrogate 字組。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Strings and The Unicode Standard</source>
          <target state="translated">字串和 Unicode 標準</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Characters in a string are represented by UTF-16 encoded code units, which correspond to <ph id="ph1">&lt;xref:System.Char&gt;</ph> values.</source>
          <target state="translated">字串中的字元都由這對應於 utf-16 編碼字碼單位<ph id="ph1">&lt;xref:System.Char&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each character in a string has an associated Unicode character category, which is represented in the .NET Framework by the <ph id="ph1">&lt;xref:System.Globalization.UnicodeCategory&gt;</ph> enumeration.</source>
          <target state="translated">在字串中的每個字元的相關聯的 Unicode 字元類別，表示由.NET Framework 中<ph id="ph1">&lt;xref:System.Globalization.UnicodeCategory&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The category of a character or a surrogate pair can be determined by calling the <ph id="ph1">&lt;xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">字元或 surrogate 字組的類別目錄由呼叫<ph id="ph1">&lt;xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET maintains its own table of characters and their corresponding categories, which ensures that a specific version of a .NET implementation running on different platforms returns identical character category information.</source>
          <target state="translated">.NET 會維護其資料表的字元和其對應的類別，可確保在不同平台上執行的.NET 實作的特定版本，會傳回相同的字元類別目錄資訊。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following table lists .NET versions and the versions of the Unicode Standard on which their character categories are based.</source>
          <target state="translated">下表列出.NET 版本和 Unicode 標準所根據的字元類別的版本。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework version</source>
          <target state="translated">.NET Framework 版本</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Version of the Unicode Standard</source>
          <target state="translated">Unicode 標準版本</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 4.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode4.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 4.0.0 版<ept id="p1">](http://www.unicode.org/versions/Unicode4.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework 2.0</source>
          <target state="translated">.NET Framework 2.0</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 8.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 8.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Core (all versions)</source>
          <target state="translated">.NET core （所有版本）</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 8.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 8.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, the .NET Framework supports string comparison and sorting based on the Unicode standard.</source>
          <target state="translated">此外，.NET Framework 支援字串比較和排序 Unicode 標準為基礎。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In versions of the .NET Framework through the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the .NET Framework maintains its own table of string data.</source>
          <target state="translated">透過.NET Framework 版本中<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>，.NET Framework 會維護自己的字串資料的資料表。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is also true of versions of the .NET Framework starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on Windows 7.</source>
          <target state="translated">這也是如此開頭的.NET framework 版本<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>在 Windows 7 上執行。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>Window 8 和更新版本的 Windows 作業系統上執行，執行階段委派字串比較和排序作業的作業系統。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following table lists the versions of the .NET Framework and the versions of the Unicode Standard on which character comparison and sorting are based.</source>
          <target state="translated">下表列出.NET framework 版本和 Unicode 標準字元的比較和排序所依據的版本。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework version</source>
          <target state="translated">.NET Framework 版本</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Version of the Unicode Standard</source>
          <target state="translated">Unicode 標準版本</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 4.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode4.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 4.0.0 版<ept id="p1">](http://www.unicode.org/versions/Unicode4.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework 2.0</source>
          <target state="translated">.NET Framework 2.0</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later on Windows 7</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> 及更新版本，在 Windows 7 上</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later on Windows 8 and later Windows operating systems</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> 及更新 Windows 8 和更新版本的 Windows 作業系統版本</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Unicode Standard 版本 6.3.0<ept id="p1">](http://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In .NET Core, sorting and comparison operations are based on <bpt id="p1">[</bpt>Version 8.0.0 of the Unicode Standard<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept>.</source>
          <target state="translated">.NET Core 中排序及比較作業會根據<bpt id="p1">[</bpt>Unicode 標準版本 8.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode8.0.0/)</ept>。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Strings and embedded null characters</source>
          <target state="translated">字串和內嵌的 null 字元</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the .NET Framework, a <ph id="ph1">&lt;xref:System.String&gt;</ph> object can include embedded null characters, which count as a part of the string's length.</source>
          <target state="translated">在.NET Framework 中，<ph id="ph1">&lt;xref:System.String&gt;</ph>物件可以包含內嵌的 null 字元，計算字串長度的一部分。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, in some languages such as C and C++, a null character indicates the end of a string;it is not considered a part of the string and is not counted as part of the string's length.</source>
          <target state="translated">不過，在某些語言如 C 和 c + + 中，null 字元表示字串的結尾，它不被視為字串的一部分，而且不會計入為字串的長度的一部分。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to <ph id="ph1">&lt;xref:System.String&gt;</ph> objects:</source>
          <target state="translated">這表示不一定有效時套用到 C 和 c + + 程式設計人員 」 或 「 撰寫 C 或 c + + 程式庫可能會對字串相關的下列一般假設<ph id="ph1">&lt;xref:System.String&gt;</ph>物件：</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The value returned by the <ph id="ph1">`strlen`</ph> or <ph id="ph2">`wcslen`</ph> functions does not necessarily equal <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">所傳回的值<ph id="ph1">`strlen`</ph>或<ph id="ph2">`wcslen`</ph>函式不一定等於<ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The string created by the <ph id="ph1">`strcpy_s`</ph> or <ph id="ph2">`wcscpy_s`</ph> functions is not necessarily identical to the string created by the <ph id="ph3">&lt;xref:System.String.Copy%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建立的字串<ph id="ph1">`strcpy_s`</ph>或<ph id="ph2">`wcscpy_s`</ph>函式不一定等於建立的字串<ph id="ph3">&lt;xref:System.String.Copy%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You should ensure that native C and C++ code that instantiates <ph id="ph1">&lt;xref:System.String&gt;</ph> objects, and code that is passed <ph id="ph2">&lt;xref:System.String&gt;</ph> objects through platform invoke, don't assume that an embedded null character marks the end of the string.</source>
          <target state="translated">您應該確定具現化該原生 C 和 c + + 程式碼<ph id="ph1">&lt;xref:System.String&gt;</ph>物件和程式碼傳遞<ph id="ph2">&lt;xref:System.String&gt;</ph>物件可透過平台叫用，請勿假設內嵌的 null 字元標示字串的結尾。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched.</source>
          <target state="translated">字串是排序 （或比較） 時，會搜尋字串時，也會以不同方式處理內嵌的 null 字元在字串中。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture.</source>
          <target state="translated">執行區分文化特性的比較兩個字串，包括使用文化特性而異的比較時，會忽略 null 字元。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>They are considered only for ordinal or case-insensitive ordinal comparisons.</source>
          <target state="translated">將它們視為只是針對序數或不區分大小寫的序數比較。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, embedded null characters are always considered when searching a string with methods such as <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.StartsWith%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.IndexOf%2A&gt;</ph>.</source>
          <target state="translated">相反地，內嵌的 null 字元時，會永遠考慮這類方法搜尋字串<ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.String.StartsWith%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.String.IndexOf%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Strings and indexes</source>
          <target state="translated">字串與索引</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An index is the position of a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object (not a Unicode character) in a <ph id="ph2">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">索引是位置<ph id="ph1">&lt;xref:System.Char&gt;</ph>中的物件 （不屬於 Unicode 字元） <ph id="ph2">&lt;xref:System.String&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero.</source>
          <target state="translated">索引是負值，以零為起始的數字，以從索引位置為零的字串中的第一個位置開始。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A number of search methods, such as <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, return the index of a character or substring in the string instance.</source>
          <target state="translated">一個數字的搜尋方法，例如<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>、 傳回字元的索引或子字串的字串執行個體。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property lets you access individual <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects by their index position in the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph>屬性可讓您存取個別<ph id="ph2">&lt;xref:System.Char&gt;</ph>依字串中的索引位置的物件。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects in a string by using code such as the following.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph>屬性為預設屬性 （在 Visual Basic) 或索引子 （在 C# 中)，您可以存取個別<ph id="ph2">&lt;xref:System.Char&gt;</ph>字串使用下列程式碼中的物件。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This code looks for white space or punctuation characters in a string to determine how many words the string contains.</source>
          <target state="translated">此程式碼會尋找泛空白字元或標點符號字元，以判斷字串包含幾個文字字串中。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the <ph id="ph1">&lt;xref:System.String&gt;</ph> class implements the <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface, you can also iterate through the <ph id="ph3">&lt;xref:System.Char&gt;</ph> objects in a string by using a <ph id="ph4">`foreach`</ph> construct, as the following example shows.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.String&gt;</ph>類別會實作<ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph>介面，您可以也逐一<ph id="ph3">&lt;xref:System.Char&gt;</ph>中使用的字串物件<ph id="ph4">`foreach`</ph>建構，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
          <target state="translated">連續索引值可能不會對應至連續的 Unicode 字元，因為的 Unicode 字元可能會編碼為多個<ph id="ph1">&lt;xref:System.Char&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs.</source>
          <target state="translated">特別是，字串可能包含多字元由基底字元後面的一或多個組合字元或 surrogate 字組所組成的文字單元。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To work with Unicode characters instead of <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects, use the <ph id="ph2">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> classes.</source>
          <target state="translated">若要使用 Unicode 字元，而不是<ph id="ph1">&lt;xref:System.Char&gt;</ph>物件，使用<ph id="ph2">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph>和<ph id="ph3">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the difference between code that works with <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects and code that works with Unicode characters.</source>
          <target state="translated">下列範例說明可搭配程式碼之間的差異<ph id="ph1">&lt;xref:System.Char&gt;</ph>物件與處理 Unicode 字元碼。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It compares the number of characters or text elements in each word of a sentence.</source>
          <target state="translated">它會比較字元或在每個字的句子中的文字項目的數目。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The string includes two sequences of a base character followed by a combining character.</source>
          <target state="translated">字串包含兩個基底的字元，後面接著組合字元的序列。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This example works with text elements by using the <ph id="ph1">&lt;xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> class to enumerate all the text elements in a string.</source>
          <target state="translated">使用這個範例適用於文字項目與<ph id="ph1">&lt;xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType&gt;</ph>方法和<ph id="ph2">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph>列舉字串中的所有文字元素的類別。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also retrieve an array that contains the starting index of each text element by calling the <ph id="ph1">&lt;xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">您也可以擷取陣列，其中包含每個文字項目的起始的索引，藉由呼叫<ph id="ph1">&lt;xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about working with units of text rather than individual <ph id="ph1">&lt;xref:System.Char&gt;</ph> values, see the <ph id="ph2">&lt;xref:System.Globalization.StringInfo&gt;</ph> class.</source>
          <target state="translated">如需有關使用的文字，而非個別單位<ph id="ph1">&lt;xref:System.Char&gt;</ph>值，請參閱<ph id="ph2">&lt;xref:System.Globalization.StringInfo&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Null strings and empty strings</source>
          <target state="translated">Null 字串值和空白字串</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string that has been declared but has not been assigned a value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">已宣告但尚未指派值的字串是<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Attempting to call methods on that string throws a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</source>
          <target state="translated">嘗試在該字串上呼叫方法會擲回<ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A null string is different from an empty string, which is a string whose value is "" or <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Null 字串是不同的是的字串，其值是空字串""或<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In some cases, passing either a null string or an empty string as an argument in a method call throws an exception.</source>
          <target state="translated">在某些情況下，傳遞 null 字串或空字串做為引數的方法呼叫會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, passing a null string to the <ph id="ph1">&lt;xref:System.Int32.Parse%2A?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>, and passing an empty string throws a <ph id="ph3">&lt;xref:System.FormatException&gt;</ph>.</source>
          <target state="translated">例如，傳遞 null 字串給<ph id="ph1">&lt;xref:System.Int32.Parse%2A?displayProperty=nameWithType&gt;</ph>方法會擲回<ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>，並傳遞空字串會擲回<ph id="ph3">&lt;xref:System.FormatException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In other cases, a method argument can be either a null string or an empty string.</source>
          <target state="translated">在其他情況下，為方法引數可以是 null 字串或是空字串。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if you are providing an <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.</source>
          <target state="translated">例如，如果您要提供<ph id="ph1">&lt;xref:System.IFormattable&gt;</ph>類別實作，您想要使用一般 ("G") 格式規範等同 null 字串和空字串。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes the following two convenience methods that enable you to test whether a string is <ph id="ph2">`null`</ph> or empty:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String&gt;</ph>類別包含下列兩個便利的方法可讓您可測試字串是否<ph id="ph2">`null`</ph>或空白：</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph>, which indicates whether a string is either <ph id="ph2">`null`</ph> or is equal to  <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph>指出字串是否為<ph id="ph2">`null`</ph>或等於<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This method eliminates the need to use code such as the following:</source>
          <target state="translated">這個方法就不需要使用程式碼如下所示：</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph>, which indicates whether a string is <ph id="ph2">`null`</ph>, equals <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, or consists exclusively of white-space characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph>指出字串是否<ph id="ph2">`null`</ph>，等於<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>，或只包含空白字元。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This method eliminates the need to use code such as the following:</source>
          <target state="translated">這個方法就不需要使用程式碼如下所示：</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method in the <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> implementation of a custom <ph id="ph3">`Temperature`</ph> class.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph>方法中的<ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph>的自訂實作<ph id="ph3">`Temperature`</ph>類別。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The method supports the "G", "C", "F", and "K" format strings.</source>
          <target state="translated">此方法支援"G"、"C"、"F"和"K"格式字串。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If an empty format string or a format string whose value is <ph id="ph1">`null`</ph> is passed to the method, its value is changed to the "G" format string.</source>
          <target state="translated">如果是空的格式字串或格式字串的值是<ph id="ph1">`null`</ph>會傳遞至方法，其值變更為"G"格式字串。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Immutability and the StringBuilder class</source>
          <target state="translated">不變性和 StringBuilder 類別</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A <ph id="ph1">&lt;xref:System.String&gt;</ph> object is called immutable (read-only), because its value cannot be modified after it has been created.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.String&gt;</ph>物件稱為不可變 （唯讀），因為它建立之後便無法修改其值。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that appear to modify a <ph id="ph1">&lt;xref:System.String&gt;</ph> object actually return a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object that contains the modification.</source>
          <target state="translated">方法會將修改<ph id="ph1">&lt;xref:System.String&gt;</ph>物件實際上會傳回新<ph id="ph2">&lt;xref:System.String&gt;</ph>包含修改物件。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty.</source>
          <target state="translated">字串是不可變的因為執行的字串操作常式重複新增或刪除來顯示為單一的字串可以精確顯著的效能負面影響。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F.</source>
          <target state="translated">例如，下列程式碼會使用隨機號碼產生器建立具有在範圍內要 0x052F 0x0001 1000 個字元的字串。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Although the code appears to use string concatenation to append a new character to the existing string named <ph id="ph1">`str`</ph>, it actually creates a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each concatenation operation.</source>
          <target state="translated">雖然程式碼會顯示使用字串串連來將新字元附加至現有的字串，名為<ph id="ph1">`str`</ph>，它會建立新<ph id="ph2">&lt;xref:System.String&gt;</ph>每個串連作業的物件。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> class instead of the <ph id="ph2">&lt;xref:System.String&gt;</ph> class for operations that make multiple changes to the value of a string.</source>
          <target state="translated">您可以使用<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>類別而不是<ph id="ph2">&lt;xref:System.String&gt;</ph>變更多個字串值的作業類別。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Unlike instances of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class, <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string.</source>
          <target state="translated">不同的執行個體於<ph id="ph1">&lt;xref:System.String&gt;</ph>類別<ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph>是可變動的物件; 當您串連、 附加、 或刪除從字串的子字串時，作業將會在單一字串。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When you have finished modifying the value of a <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object, you can call its <ph id="ph2">&lt;xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType&gt;</ph> method to convert it to a string.</source>
          <target state="translated">當您完成修改的值<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>物件，您可以呼叫其<ph id="ph2">&lt;xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType&gt;</ph>方法，以將它轉換為字串。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example replaces the <ph id="ph1">&lt;xref:System.String&gt;</ph> used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> object.</source>
          <target state="translated">下列範例會取代<ph id="ph1">&lt;xref:System.String&gt;</ph>前一個範例中用來串連來與 0x052F 0x0001 範圍中的 1000 個隨機字元<ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinal vs. culture-sensitive operations</source>
          <target state="translated">序數和區分文化特性的作業</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Members of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class perform either ordinal or culture-sensitive (linguistic) operations on a <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">成員<ph id="ph1">&lt;xref:System.String&gt;</ph>類別上執行序數或區分文化特性 （語言） 作業<ph id="ph2">&lt;xref:System.String&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal operation acts on the numeric value of each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
          <target state="translated">序數的作業處理程式碼的每個數值<ph id="ph1">&lt;xref:System.Char&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive operation acts on the value of the <ph id="ph1">&lt;xref:System.String&gt;</ph> object, and takes culture-specific casing, sorting, formatting, and parsing rules into account.</source>
          <target state="translated">區分文化特性的作業處理程式碼的值<ph id="ph1">&lt;xref:System.String&gt;</ph>物件，並採用特定文化特性大小寫、 排序、 格式和剖析規則納入考量。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture.</source>
          <target state="translated">明確宣告的文化特性或目前的文化特性隱含的內容中，執行區分文化特性的作業。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The two kinds of operations can produce very different results when they are performed on the same string.</source>
          <target state="translated">它們在相同的字串上執行時，兩種運算會產生非常不同的結果。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework also supports culture-insensitive linguistic string operations by using the invariant culture (<ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>), which is loosely based on the culture settings of the English language independent of region.</source>
          <target state="translated">.NET Framework 也支援不區分文化特性的語言字串作業所使用的文化特性而異 (<ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>)，這鬆散根據英文語言的地區無關的文化特性設定。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Unlike other <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of the .NET Framework.</source>
          <target state="translated">不同於其他<ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph>保證設定、 文化特性而異的設定都維持一致的單一電腦上，從系統的系統，以及.NET Framework 的版本。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.</source>
          <target state="translated">跨所有文化特性而異的文化特性可以是所見，做為一種黑色方塊，以確保穩定性的字串比較和排序。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison.</source>
          <target state="translated">如果應用程式決定安全性的相關符號的識別項，例如檔案名稱或具名管道，或保存的資料，例如 XML 檔案中以文字為基礎的資料相關作業應該使用序數比較，而不是區分文化特性的比較。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.</source>
          <target state="translated">這是因為區分文化特性比較可以作用中，產生不同的結果，根據文化特性而取決於二進位值的比較字元的序數比較。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Most methods that perform string operations include an overload that has a parameter of type <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation.</source>
          <target state="translated">大部分執行字串作業的方法包括參數類型的多載<ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>，可讓您指定方法是否執行的序數或區分文化特性的作業。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In general, you should call this overload to make the intent of your method call clear.</source>
          <target state="translated">一般情況下，您應該呼叫此多載，以讓您的方法呼叫更清晰。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For best practices and guidance for using ordinal and culture-sensitive operations on strings, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">最佳作法及使用序數和區分文化特性的字串作業的指引，請參閱<bpt id="p1">[</bpt>使用字串的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Operations for <bpt id="p1">[</bpt>casing<ept id="p1">](#casing)</ept>, <bpt id="p2">[</bpt>parsing and formatting<ept id="p2">](#parsing)</ept>, <bpt id="p3">[</bpt>comparison and sorting<ept id="p3">](#comparison)</ept>, and <bpt id="p4">[</bpt>testing for equality<ept id="p4">](#equality)</ept> can be either ordinal or culture-sensitive.</source>
          <target state="translated">作業<bpt id="p1">[</bpt>大小寫<ept id="p1">](#casing)</ept>，<bpt id="p2">[</bpt>格式化和剖析<ept id="p2">](#parsing)</ept>，<bpt id="p3">[</bpt>比較和排序<ept id="p3">](#comparison)</ept>，和<bpt id="p4">[</bpt>測試是否相等<ept id="p4">](#equality)</ept>可以是序數或區分文化特性。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following sections discuss each category of operation.</source>
          <target state="translated">下列章節會討論每個作業類別目錄。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You should always call a method overload that makes the intent of your method call clear.</source>
          <target state="translated">您應該一律呼叫的方法多載，可在方法呼叫更清晰。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, instead of calling the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method with a value of <ph id="ph3">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> for the <ph id="ph4">`comparisonType`</ph> argument.</source>
          <target state="translated">比方說，而不是呼叫<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph>方法來執行區分文化特性比較的兩個字串，使用目前的文化特性的慣例，您應該呼叫<ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph>方法，其值為<ph id="ph3">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>如<ph id="ph4">`comparisonType`</ph>引數。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>使用字串的最佳做法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Casing</source>
          <target state="translated">大小寫</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase.</source>
          <target state="translated">大小寫規則會決定如何變更大小寫的 Unicode 字元;例如，從小寫為大寫。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Often, a casing operation is performed before a string comparison.</source>
          <target state="translated">通常，大小寫進行字串比較之前。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a string might be converted to uppercase so that it can be compared with another uppercase string.</source>
          <target state="translated">例如，字串可能會轉換成大寫，以便與另一個大寫的字串。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can convert the characters in a string to lowercase by calling the <ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method, and you can convert them to uppercase by calling the <ph id="ph3">&lt;xref:System.String.ToUpper%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">您可以將轉換成小寫藉由呼叫字串中的字元<ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph>方法，而且您可以將它們轉換成大寫藉由呼叫<ph id="ph3">&lt;xref:System.String.ToUpper%2A&gt;</ph>或<ph id="ph4">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, you can use the <ph id="ph1">&lt;xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType&gt;</ph> method to convert a string to title case.</source>
          <target state="translated">此外，您可以使用<ph id="ph1">&lt;xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType&gt;</ph>方法，將字串轉換為字首大寫。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture.</source>
          <target state="translated">大小寫作業可以根據目前文化特性、 指定的文化特性或文化特性而異的規則。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture.</source>
          <target state="translated">大小寫對應可以使用的文化特性而有所不同，因為大小寫作業的結果可以根據而異的文化特性。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The actual differences in casing are of three kinds:</source>
          <target state="translated">實際大小寫的差異有三種：</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131).</source>
          <target state="translated">大小寫的 LATIN CAPITAL LETTER I 對應的差異 (U + 0049)，拉丁小字母 I (U + 0069)，LATIN CAPITAL LETTER 我使用點 (U + 0130)，高於和拉丁小字母無點 I (U + 0131)。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE.</source>
          <target state="translated">TR-TR （土耳其文 （土耳其）） 和 az-Latn-AZ （亞塞拜然，拉丁） 文化特性中，在 tr，az，az Latn 中性文化特性，拉丁文大寫字母 1 的小寫對應項拉丁文小字母無點 1，且拉丁文小字母 1 的大寫對應項高於 LATIN CAPITAL LETTER 我與點。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.</source>
          <target state="translated">在其他文化特性，包括 文化特性而異，拉丁小字母 I 與 LATIN CAPITAL LETTER 進行小寫和大寫對等項目。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison.</source>
          <target state="translated">下列範例示範如何設計的字串比較，以避免檔案系統存取權可能會失敗它依賴區分文化特性大小寫比較。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(The casing conventions of the invariant culture should have been used.)</source>
          <target state="translated">（文化特性而異的大小寫慣例應該已使用。）</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Differences in case mappings between the invariant culture and all other cultures.</source>
          <target state="translated">大小寫對應中所有其他文化特性而異的文化特性之間的差異。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character.</source>
          <target state="translated">在這些情況下，使用文化特性而異的大小寫規則變更為大寫或小寫的字元會傳回相同的字元。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For all other cultures, it returns a different character.</source>
          <target state="translated">針對其他文化特性，它會傳回不同的字元。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Some of the affected characters are listed in the following table.</source>
          <target state="translated">某些受影響的字元會在下表中列出。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Character</source>
          <target state="translated">字元</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If changed to</source>
          <target state="translated">如果變更為</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Returns</source>
          <target state="translated">Returns</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>MICRON SIGN (U+00B5)</source>
          <target state="translated">MICRON 登 (U + 00B5)</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">大寫</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>GREEK CAPITAL LETTER MU (U+-39C)</source>
          <target state="translated">希臘文的大寫字母 MU (U +-39 C)</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</source>
          <target state="translated">拉丁文大寫字母 I 點上方 (U + 0130)</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Lowercase</source>
          <target state="translated">小寫</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER I (U+0069)</source>
          <target state="translated">拉丁文小字母 I (U + 0069)</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER DOTLESS I (U+0131)</source>
          <target state="translated">無點拉丁小寫字母 I (U + 0131)</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">大寫</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER I (U+0049)</source>
          <target state="translated">拉丁文大寫字母 I (U + 0049)</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER LONG S (U+017F)</source>
          <target state="translated">拉丁文小寫字母長 S (U + 017F)</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">大寫</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER S (U+0053)</source>
          <target state="translated">LATIN CAPITAL LETTER S (U + 0053)</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)</source>
          <target state="translated">上方有勾的小寫字母 Z LATIN CAPITAL LETTER A (U + 01C 5)</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Lowercase</source>
          <target state="translated">小寫</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER DZ WITH CARON (U+01C6)</source>
          <target state="translated">上方有勾的拉丁小寫字母 DZ (U + 01C 6)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>COMBINING GREEK YPOGEGRAMMENI (U+0345)</source>
          <target state="translated">結合希臘 YPOGEGRAMMENI (U + 0345)</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">大寫</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>GREEK CAPITAL LETTER IOTA (U+0399)</source>
          <target state="translated">希臘文的大寫字母 IOTA (U + 0399)</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Differences in case mappings of two-letter mixed-case pairs in the ASCII character range.</source>
          <target state="translated">ASCII 字元範圍內的兩個字母大小字母混合的組的大小寫對應的差異。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair.</source>
          <target state="translated">大部分的文化特性中的兩個字母大小字母混合的組等於的對等的兩個字母大寫或小寫組。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:</source>
          <target state="translated">這是不在下列的文化特性中，下列兩個字母組，則為 true，因為它們會在每個案例進行比較雙拼詞：</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture.</source>
          <target state="translated">「 lJ"和"nJ"HR-HR （克羅埃西亞文 （克羅埃西亞）） 文化特性。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.</source>
          <target state="translated">「 cH"CS-CZ （捷克文 （捷克共和國）） 和 sk SK （斯洛伐克文 （斯洛伐克）） 文化特性而有所不同。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"aA" in the da-DK (Danish (Denmark)) culture.</source>
          <target state="translated">"aA"DA-DK （丹麥文 （丹麥）） 文化特性。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture.</source>
          <target state="translated">"cS"、"dZ"、"dZS"、"nY"、"sZ"、"置入"和"zs"表示 HU-HU （匈牙利文 （匈牙利）） 文化特性中。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.</source>
          <target state="translated">「 cH"和"lL"es ES_tradnl （西班牙文 （西班牙，傳統排序）） 文化特性。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture.</source>
          <target state="translated">「 cH"、"gI"、"kH"、"nG""nH"、"pH"，"qU'，「 日 」 和 「 tR"vi VN （越南文 （越南）） 文化特性中的。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.</source>
          <target state="translated">不過，很少會發生區分文化特性的比較這些字組的建立問題，這種情況，因為這些配對是固定的字串或識別項中不常發生。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.</source>
          <target state="translated">下列範例會說明一些在大小寫規則時將字串轉換成大寫的文化特性之間的差異。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parsing and formatting</source>
          <target state="translated">格式化和剖析</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting and parsing are inverse operations.</source>
          <target state="translated">格式化和剖析都是反向作業。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time.</source>
          <target state="translated">格式化規則會決定如何將一個值，例如日期和時間或數字，轉換為其字串表示，而剖析規則會決定如何將字串表示轉換成一個值，例如日期和時間。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Both formatting and parsing rules are dependent on cultural conventions.</source>
          <target state="translated">格式化和剖析規則均依存於文化特性的慣例。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string.</source>
          <target state="translated">下列範例說明如何解譯特定文化特性的日期字串時，可能會發生模稜兩可。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.</source>
          <target state="translated">而不需要知道用來產生日期字串文化特性的慣例，不可能知道 03/01/2011年，3/1/2011，01/03/2011年代表 2011 年 1 月 3 日或 2011 年 3 月 1 日。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.</source>
          <target state="translated">同樣地，如下列範例所示，單一字串可能會產生不同的日期，根據在剖析作業中會使用其慣例的文化特性。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String comparison and sorting</source>
          <target state="translated">字串比較和排序</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Conventions for comparing and sorting strings vary from culture to culture.</source>
          <target state="translated">比較和排序字串的慣例改變文化。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the sort order may be based on phonetics or on the visual representation of characters.</source>
          <target state="translated">例如，排序次序可能會根據語音或字元的視覺表示法。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In East Asian languages, characters are sorted by the stroke and radical of ideographs.</source>
          <target state="translated">在東亞語言中，字元都是依據筆劃來排序和文字字根進行。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Sorting also depends on the order languages and cultures use for the alphabet.</source>
          <target state="translated">排序也取決於順序語言和文化特性使用的字母。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the Danish language has an "Æ" character that it sorts after "Z" in the alphabet.</source>
          <target state="translated">例如，丹麥文的 "Æ" 字元在字母順序中排列在 "Z" 之後。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture.</source>
          <target state="translated">此外，比較可以是區分大小寫或區分大小寫，並且在某些情況下的大小寫規則也因文化特性。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.</source>
          <target state="translated">序數比較，相反地，使用時比較和排序字串的字串中的個別字元的 Unicode 字碼指標。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other.</source>
          <target state="translated">排序規則決定彼此的 Unicode 字元的字母順序和兩個字串比較。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> method compares two strings based on the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph>方法比較為基礎的兩個字串<ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the parameter value is <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>, the method performs an ordinal comparison.</source>
          <target state="translated">如果參數值為<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>，此方法會執行會使用目前文化特性; 慣例語言比較，如果參數值為<ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>，此方法會執行序數比較。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".</source>
          <target state="translated">因此，如下列範例所示，如果目前的文化特性是美國英文、 第一次呼叫<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph>方法 （使用區分文化特性的比較） 會考慮"a"小於"A"，但相同的方法 （使用序數比較） 的第二個呼叫會考慮"a"大於"A"。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework supports word, string, and ordinal sort rules:</source>
          <target state="translated">.NET Framework 支援 word、 字串和序數排序規則：</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them.</source>
          <target state="translated">文字排序執行區分文化特性比較的字串，其中某些非英數字元的 Unicode 字元可能會有特殊的權重。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list.</source>
          <target state="translated">例如，連字號 （-） 可能會有非常小的加權指派給它，以便 「 coop 」 和 「 聯合"會相互並排顯示已排序的清單中。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For a list of the <ph id="ph1">&lt;xref:System.String&gt;</ph> methods that compare two strings using word sort rules, see the <bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept> section.</source>
          <target state="translated">取得一份<ph id="ph1">&lt;xref:System.String&gt;</ph>方法來比較兩個字串使用字組的排序規則，請參閱<bpt id="p1">[</bpt>依類別目錄字串運算<ept id="p1">](#ByCategory)</ept>&gt; 一節。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string sort also performs a culture-sensitive comparison.</source>
          <target state="translated">字串排序也會執行區分文化特性的比較。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters.</source>
          <target state="translated">很類似於 word 排序，但是沒有特殊案例，而所有的非英數符號前面所有英數字元的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Two strings can be compared using string sort rules by calling the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType&gt;</ph> method overloads that have an <ph id="ph2">`options`</ph> parameter that is supplied a value of <ph id="ph3">&lt;xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">可以藉由呼叫使用字串的排序規則比較兩個字串<ph id="ph1">&lt;xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType&gt;</ph>方法的多載<ph id="ph2">`options`</ph>參數所提供的值<ph id="ph3">&lt;xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that this is the only method that the .NET Framework provides to compare two strings using string sort rules.</source>
          <target state="translated">請注意，這是.NET Framework 提供比較兩個字串，使用字串的排序規則的唯一方法。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal sort compares strings based on the numeric value of each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object in the string.</source>
          <target state="translated">序數排序比較根據每個數值的字串<ph id="ph1">&lt;xref:System.Char&gt;</ph>字串中的物件。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points.</source>
          <target state="translated">序數比較是自動區分大小寫，因為小寫和大寫字元的版本具有不同的字碼指標。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, if case is not important, you can specify an ordinal comparison that ignores case.</source>
          <target state="translated">不過，如果案例並不重要，您可以指定會忽略大小寫的序數比較。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result.</source>
          <target state="translated">這就相當於將轉換為大寫，使用文化特性而異，然後在結果上執行序數比較字串。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For a list of the <ph id="ph1">&lt;xref:System.String&gt;</ph> methods that compare two strings using ordinal sort rules, see the <bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept> section.</source>
          <target state="translated">取得一份<ph id="ph1">&lt;xref:System.String&gt;</ph>方法來比較兩個字串，使用序數排序規則，請參閱<bpt id="p1">[</bpt>依類別目錄字串運算<ept id="p1">](#ByCategory)</ept>&gt; 一節。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object, including the invariant culture that is specified by the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">區分文化特性的比較是明確或隱含使用任何比較<ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>物件，包括異的文化特性所指定<ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The implicit culture is the current culture, which is specified by the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">隱含的文化特性是所指定的目前文化特性<ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <ph id="ph1">&lt;xref:System.Char.IsLetter%2A?displayProperty=nameWithType&gt;</ph> property returns <ph id="ph2">`true`</ph>) across cultures.</source>
          <target state="translated">沒有相當大的變化，字母字元的排序順序 (也就是字元的<ph id="ph1">&lt;xref:System.Char.IsLetter%2A?displayProperty=nameWithType&gt;</ph>屬性會傳回<ph id="ph2">`true`</ph>) 跨文化特性。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object to a string comparison method such as <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph>.</source>
          <target state="translated">您可以指定使用藉由提供特定文化特性的慣例的文化特性比較<ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>這類物件的字串比較方法<ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, or any member of the <ph id="ph3">&lt;xref:System.Globalization.CompareOptions&gt;</ph> enumeration other than <ph id="ph4">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph5">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> to an appropriate overload of the <ph id="ph6">&lt;xref:System.String.Compare%2A&gt;</ph> method.</source>
          <target state="translated">您可以指定使用目前文化特性的慣例，藉由提供文化特性比較<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>， <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>，或任何成員<ph id="ph3">&lt;xref:System.Globalization.CompareOptions&gt;</ph>以外的列舉<ph id="ph4">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph>或<ph id="ph5">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>適當多載<ph id="ph6">&lt;xref:System.String.Compare%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not.</source>
          <target state="translated">通常適合進行排序而序數比較不是區分文化特性的比較。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.</source>
          <target state="translated">序數比較是通常適用於判斷兩個字串是否相等 (也就是判斷識別) 而不是區分文化特性的比較。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the difference between culture-sensitive and ordinal comparison.</source>
          <target state="translated">下列範例說明區分文化特性和序數比較之間的差異。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The example evaluates three strings, "Apple", "Æble", and "AEble", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method is called).</source>
          <target state="translated">此範例會評估三個字串、"Apple"、"Æble，"和"AEble"，使用序數比較和 DA-DK 和 EN-US 文化特性的慣例 (其中每一個都是預設文化特性時<ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>方法呼叫)。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the Danish language treats the character "Æ" as an individual letter and sorts it after "Z" in the alphabet, the string "Æble" is greater than "Apple".</source>
          <target state="translated">由於丹麥文"Æ"字元視為單一字母，而且字母表中將它排列在"Z"之後，字串"Æble"大於"Apple"。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, "Æble" is not considered equivalent to "AEble", so "Æble" is also greater than "AEble".</source>
          <target state="translated">不過，"Æble"是不被視為相等於"AEble"，因此也是"AEble 「 大於 」 Æble"。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The en-US culture doesn't include the letter"Æ" but treats it as equivalent to "AE", which explains why  "Æble" is less than "Apple" but equal to "AEble".</source>
          <target state="translated">EN-US 文化特性並不包含字母"Æ"，但會將它視為相當於"AE"，其中說明為什麼"Æble"小於"Apple"但為等於"AEble"。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinal comparison, on the other hand, considers "Apple" to be less than "Æble", and "Æble" to be greater than "AEble".</source>
          <target state="translated">序數比較，相反地，會視為必須小於"Æble 」 和"Æble"必須是大於"AEble"的"Apple"。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Use the following general guidelines to choose an appropriate sorting or string comparison method:</source>
          <target state="translated">您可以使用下列一般指導方針來選擇適當的排序或字串比較方法：</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture.</source>
          <target state="translated">如果您想根據使用者的文化特性來排序字串，您應該將目前的文化特性的慣例為基礎進行排序。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the user's culture changes, the order of sorted strings will also change accordingly.</source>
          <target state="translated">如果使用者的文化特性變更，排序字串的順序將也會據此變更。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a thesaurus application should always sort words based on the user's culture.</source>
          <target state="translated">例如，同義字應用程式應該永遠排序根據使用者的文化特性的字。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents that culture to a comparison method.</source>
          <target state="translated">如果您想根據特定的文化特性的慣例來排序字串，您應該排列這些資料行藉由提供<ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>物件，代表該文化特性的比較方法。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.</source>
          <target state="translated">比方說，教導學生特定語言設計的應用程式，在您想要排序的字串根據其中一個說出該語言的文化特性的慣例。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison.</source>
          <target state="translated">如果您要維持不變，跨文化特性的字串順序，您應該排列這些而異的文化特性的慣例為基礎，或使用序數比較。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.</source>
          <target state="translated">例如，您會使用序數排序來組織檔案、 處理程序、 mutex 的名稱或具名管道。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">如需牽涉到安全性決策 （例如使用者名稱是否有效） 的比較，您應該一律執行相等序數測試藉由呼叫的多載<ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET Framework.</source>
          <target state="translated">區分文化特性的排序和大小寫字串比較中使用規則取決於.NET Framework 版本。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the .NET Framework <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on the <ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph> operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard.</source>
          <target state="translated">在.NET Framework<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>上執行<ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph>作業系統、 排序、 大小寫、 正規化和 Unicode 的字元資訊符合 Unicode 6.0 標準。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On other operating systems, it conforms to the Unicode 5.0 standard.</source>
          <target state="translated">在其他作業系統，其符合 Unicode 5.0 標準。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about word, string, and ordinal sort rules, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> topic.</source>
          <target state="translated">如需 word、 字串和序數排序規則的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>主題。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For additional recommendations on when to use each rule, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">如需其他建議何時使用每個規則，請參閱<bpt id="p1">[</bpt>使用字串的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinarily, you don't call string comparison methods such as <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> directly to determine the sort order of strings.</source>
          <target state="translated">通常，在未呼叫字串比較方法，例如<ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>直接以決定字串的排序次序。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Instead, comparison methods are called by sorting methods such as <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">相反地，比較方法會呼叫這類排序方法<ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>或<ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use.</source>
          <target state="translated">下列範例會執行四個不同排序作業 （使用目前文化特性、 使用文化特性而異的文字排序、 序數排序，以及使用而異的文化特性的字串排序文字排序） 而不需要明確地呼叫字串比較方法，雖然這些字元會指定要使用的比較類型。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that each type of sort produces a unique ordering of strings in its array.</source>
          <target state="translated">請注意，每種類型的排序會產生唯一的字串陣列中所用的排序。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Internally, the.NET Framework uses sort keys to support culturallysensitive string comparison.</source>
          <target state="translated">就內部而言，.net Framework 會使用排序索引鍵，以支援 culturallysensitive 字串比較。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic.</source>
          <target state="translated">每個字元的字串中指定排序權重，包括字母、 大小寫和變音符號的數種類別。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A sort key, represented by the <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> class, provides a repository of these weights for a particular string.</source>
          <target state="translated">排序索引鍵，由<ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph>類別，這些加權的儲存機制，提供特定的字串。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses.</source>
          <target state="translated">如果您的應用程式執行大量搜尋或排序作業，在同一組字串時，您就可以改善其效能所產生並儲存它所使用的所有字串的排序索引鍵。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When a sort or comparison operation is required, you use the sort keys instead of the strings.</source>
          <target state="translated">需要排序或比較作業時，您可以使用的排序索引鍵而不要使用字串。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> class.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> 類別。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you don't specify a string comparison convention, sorting methods such as <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> perform a culture-sensitive, case-sensitive sort on strings.</source>
          <target state="translated">如果您未指定字串比較慣例，排序方法例如<ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph>執行字串區分文化特性，區分大小寫排序。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates how changing the current culture affects the order of sorted strings in an array.</source>
          <target state="translated">下列範例說明如何變更目前的文化特性會影響排序字串陣列中的順序。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It creates an array of three strings.</source>
          <target state="translated">它會建立三個字串的陣列。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>First, it sets the <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> property to en-US and calls the <ph id="ph2">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">首先，它會設定<ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph>屬性設為 EN-US 並呼叫<ph id="ph2">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The resulting sort order is based on sorting conventions for the English (United States) culture.</source>
          <target state="translated">產生的排序次序為基礎的排序英文 （美國） 文化特性的慣例。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Next, the example sets the <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> property to da-DK and calls the <ph id="ph2">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> method again.</source>
          <target state="translated">接下來，範例會將設定<ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph>屬性 DA-DK 和呼叫<ph id="ph2">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>方法一次。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).</source>
          <target state="translated">請注意如何產生的排序次序與不同 EN-US 結果因為排序慣例用於丹麥文 （丹麥）。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your primary purpose in comparing strings is to determine whether they are equal, you should call the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如果您在比較字串的主要目的是要判斷是否相等，您應該呼叫<ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Typically, you should use <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> to perform an ordinal comparison.</source>
          <target state="translated">一般而言，您應該使用<ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph>来執行序數比較。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> method is intended primarily to sort strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph>方法主要為了排序字串。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String search methods, such as <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, also can perform culture-sensitive or ordinal string comparisons.</source>
          <target state="translated">字串搜尋方法，例如<ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>，也可以執行區分文化特性或序數字串比較。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">下列範例說明使用序數和區分文化特性比較的差異<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "œ".</source>
          <target state="translated">區分文化特性的搜尋目前的文化特性是英文 （美國） 會視為 「 oe"符合"œ"連字的子字串。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> and finds a match at the beginning of the string.</source>
          <target state="translated">因為選擇性連字號 (U + 00AD) 是零寬度的字元，所以搜尋視為選擇性連字號相當於<ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>和字串的開頭處找到符合項目。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal search, on the other hand, does not find a match in either case.</source>
          <target state="translated">序數搜尋，相反地，找不到相符項目在任一情況下。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Searching Strings</source>
          <target state="translated">搜尋字串</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String search methods, such as <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.</source>
          <target state="translated">字串搜尋方法，例如<ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>，也可以執行區分文化特性或指定之字串中找到的序數字串比較，以判斷是否字元或子字串。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The search methods in the <ph id="ph1">&lt;xref:System.String&gt;</ph> class that search for an individual character, such as the <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method, or one of a set of characters,   such as the <ph id="ph3">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, all perform an ordinal search.</source>
          <target state="translated">中的搜尋方法<ph id="ph1">&lt;xref:System.String&gt;</ph>類別搜尋個別的字元，例如<ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法，或其中一個的一組字元，例如<ph id="ph3">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法，所有執行的序數搜尋。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To perform a culture-sensitive search for a character, you must call a <ph id="ph1">&lt;xref:System.Globalization.CompareInfo&gt;</ph> method such as <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">若要執行區分文化特性的搜尋的字元，您必須呼叫<ph id="ph1">&lt;xref:System.Globalization.CompareInfo&gt;</ph>方法，例如<ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph>或<ph id="ph3">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different.</source>
          <target state="translated">請注意，搜尋字元，使用序數和區分文化特性的比較的結果可以是非常不同。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a search for a precomposed Unicode character such as the ligature "Æ" (U+00C6) might match any occurrence of its components in the correct sequence, such as "AE" (U+041U+0045), depending on the culture.</source>
          <target state="translated">比方說，搜尋預先組成的 Unicode 字元，例如"Æ"連字 (U + 00 C 6) 可能符合正確的順序，例如"AE 」 及其元件的任何項目 （U + 041U + 0045），根據文化特性。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the difference between the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> methods when searching for an individual character.</source>
          <target state="translated">下列範例說明之間的差異<ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph>方法搜尋的個別字元時。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The ligature "æ" (U+00E6) is found in the string "aerial" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.</source>
          <target state="translated">連字的"æ"(U + 00E6) 中找到字串"空照圖 」 時使用 EN-US 文化特性的慣例，但不是使用 DA-DK 文化特性的慣例或時執行序數比較。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, <ph id="ph1">&lt;xref:System.String&gt;</ph> class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>.</source>
          <target state="translated">相反地，<ph id="ph1">&lt;xref:System.String&gt;</ph>類別方法的搜尋字串，而不是字元執行區分文化特性的搜尋如果搜尋選項未明確指定型別參數所<ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sole exception is <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, which performs an ordinal search.</source>
          <target state="translated">唯一的例外狀況是<ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>，它會執行序數搜尋。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Testing for equality</source>
          <target state="translated">測試相等</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Use the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> method to determine the relationship of two strings in the sort order.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph>方法，以判斷兩個字串在排序次序的關聯性。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Typically, this is a culture-sensitive operation.</source>
          <target state="translated">一般而言，這是區分文化特性的作業。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In contrast, call the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> method to test for equality.</source>
          <target state="translated">相較之下，呼叫<ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph>方法來測試是否相等。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.</source>
          <target state="translated">因為相等測試通常會比較使用者輸入的一些已知的字串，例如有效的使用者名稱、 密碼或檔案系統路徑，通常是序數的作業。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It is possible to test for equality by calling the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> method and determining whether the return value is zero.</source>
          <target state="translated">可以藉由呼叫測試是否相等<ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph>方法，並判斷傳回的值是否為零。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, this practice is not recommended.</source>
          <target state="translated">不過，不建議這種做法。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To determine whether two strings are equal, you should call one of the overloads of the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">若要判斷兩個字串是否相等，您應該呼叫其中一個多載的<ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The preferred overload to call is either the instance <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> method or the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, because both methods include a <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=nameWithType&gt;</ph> parameter that explicitly specifies the type of comparison.</source>
          <target state="translated">慣用的多載來呼叫是任一個執行個體<ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph>方法或靜態<ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph>方法，因為這兩種方法包含<ph id="ph3">&lt;xref:System.StringComparison?displayProperty=nameWithType&gt;</ph>明確指定的比較類型的參數。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead.</source>
          <target state="translated">下列範例會說明執行區分文化特性的比較相等時應改為使用其中一種為序數的危險。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://".</source>
          <target state="translated">在此情況下，程式碼的意圖是要禁止檔案系統存取所執行的 URL 與字串"FILE:// 開頭的不區分大小寫的比較，以"FILE:// 或"file:// 開頭的 Url。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "İ" instead of "I".</source>
          <target state="translated">不過，如果以"file:// 開頭的 URL 上使用土耳其文 （土耳其） 文化特性執行區分文化特性的比較時，相等的比較會失敗，因為土耳其文的大寫對應項的小寫字母"i"是"İ"而不是"I"。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>As a result, file system access is inadvertently permitted.</source>
          <target state="translated">如此一來，不小心允許檔案系統存取權。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.</source>
          <target state="translated">相反地，如果執行序數比較，則成功的相等比較，並會拒絕檔案系統存取。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalization</source>
          <target state="translated">正規化</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Some Unicode characters have multiple representations.</source>
          <target state="translated">某些 Unicode 字元有多個表示方式。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, any of the following code points can represent the letter "ắ":</source>
          <target state="translated">例如，下列字碼指標的任何可代表字母"ắ":</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>U+1EAF</source>
          <target state="translated">U + 1EAF</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>U+0103 U+0301</source>
          <target state="translated">U+0103 U+0301</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>U+0061 U+0306 U+0301</source>
          <target state="translated">U+0061 U+0306 U+0301</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Multiple representations for a single character complicate searching, sorting, matching, and other string operations.</source>
          <target state="translated">搜尋、 排序、 比對，及其他字串作業，讓更加複雜的單一字元的多種表示。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations.</source>
          <target state="translated">Unicode 標準會定義稱為會傳回一個為其相等的二進位表示法的任何 Unicode 字元的二進位表示法的正規化的程序。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalization can use several algorithms, called normalization forms, that follow different rules.</source>
          <target state="translated">正規化可以使用數種演算法，稱為正規化表單，可遵循的規則不同。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework supports Unicode normalization forms C, D, KC, and KD.</source>
          <target state="translated">.NET Framework 支援的 Unicode 正規化表單 C、 D、 KC 和 KD。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.</source>
          <target state="translated">當字串已經正規化成相同的正規化格式時，它們可以使用序數比較來比較。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects in each string.</source>
          <target state="translated">序數比較是 Unicode 的對應純量值的二進位比較<ph id="ph1">&lt;xref:System.Char&gt;</ph>每個字串中的物件。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes a number of methods that can perform an ordinal comparison, including the following:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String&gt;</ph>類別包含數個方法可以執行序數比較，包括下列：</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Any overload of the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Equals%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph>,  <ph id="ph4">&lt;xref:System.String.EndsWith%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOf%2A&gt;</ph>, and <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> methods that includes a <ph id="ph7">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
          <target state="translated">任何多載<ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.String.Equals%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.String.EndsWith%2A&gt;</ph>， <ph id="ph5">&lt;xref:System.String.IndexOf%2A&gt;</ph>，和<ph id="ph6">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>方法包含<ph id="ph7">&lt;xref:System.StringComparison&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The method performs an ordinal comparison if you supply a value of <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase&gt;</ph> for this parameter.</source>
          <target state="translated">如果您提供的值，這個方法會執行序數比較<ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>或<ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase&gt;</ph>這個參數。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> method.</source>
          <target state="translated">多載<ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that use ordinal comparison by default, such as <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Replace%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.Split%2A&gt;</ph>.</source>
          <target state="translated">根據預設，使用序數比較，例如方法<ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.String.Replace%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.String.Split%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that search for a <ph id="ph1">&lt;xref:System.Char&gt;</ph> value or for the elements in a <ph id="ph2">&lt;xref:System.Char&gt;</ph> array in a string instance.</source>
          <target state="translated">方法會搜尋<ph id="ph1">&lt;xref:System.Char&gt;</ph>值或中的項目<ph id="ph2">&lt;xref:System.Char&gt;</ph>陣列的字串執行個體。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Such methods include <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>.</source>
          <target state="translated">這類方法包括<ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph>和<ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can determine whether a string is normalized to normalization form C by calling the <ph id="ph1">&lt;xref:System.String.IsNormalized?displayProperty=nameWithType&gt;</ph> method, or you can call the <ph id="ph2">&lt;xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> method to determine whether a string is normalized to a specified normalization form.</source>
          <target state="translated">您可以判斷字串是否會正規化為正規化格式 C 藉由呼叫<ph id="ph1">&lt;xref:System.String.IsNormalized?displayProperty=nameWithType&gt;</ph>方法，或者您可以呼叫<ph id="ph2">&lt;xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph>方法，以判斷字串是否會正規化為指定的正規化格式。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also call the <ph id="ph1">&lt;xref:System.String.Normalize?displayProperty=nameWithType&gt;</ph> method to convert a string to normalization form C, or you can call the <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> method to convert a string to a specified normalization form.</source>
          <target state="translated">您也可以呼叫<ph id="ph1">&lt;xref:System.String.Normalize?displayProperty=nameWithType&gt;</ph>方法，以將字串轉換為正規化格式 C，或您可以呼叫<ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph>方法，將字串轉換為指定的正規化格式。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For step-by-step information about normalizing and comparing strings, see the <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> methods.</source>
          <target state="translated">逐步解說正規化和比較字串的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph>和<ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following simple example illustrates string normalization.</source>
          <target state="translated">下列簡易範例說明字串正規化。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It defines the letter "ố" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings.</source>
          <target state="translated">它以三個不同的方式在三個不同的字串，定義的字母"ố 」，並使用以判斷每個字串，不同於其他兩個字串的序數比較相等。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form.</source>
          <target state="translated">它然後將每個字串轉換成支援的正規化格式，並再次執行序數比較每個字串中指定的正規化格式。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In each case, the second test for equality shows that the strings are equal.</source>
          <target state="translated">在每個案例中，第二個等號比較測試會顯示字串相等。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about normalization and normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>, as well as <bpt id="p1">[</bpt>Unicode Standard Annex #15: Unicode Normalization Forms<ept id="p1">](http://unicode.org/reports/tr15/)</ept> and the <bpt id="p2">[</bpt>Normalization FAQ<ept id="p2">](http://www.unicode.org/faq/normalization.html)</ept> on the unicode.org website.</source>
          <target state="translated">多個正規化和正規化表單的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>，以及<bpt id="p1">[</bpt>Unicode 標準附錄 #15: Unicode 正規化表單<ept id="p1">](http://unicode.org/reports/tr15/)</ept>和<bpt id="p2">[</bpt>正規化常見問題集<ept id="p2">](http://www.unicode.org/faq/normalization.html)</ept>上unicode.org 網站。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String operations by category</source>
          <target state="translated">依類別目錄的字串作業</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String&gt;</ph>類別會提供比較字串、 測試字串是否相等、 尋找字元的成員，或在字串中，修改字串，擷取組合字串，格式化值、 複製字串，及正規化字串的字串中的子字串的子字串。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Comparing strings</source>
          <target state="translated">比較字串</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can compare strings to determine their relative position in the sort order by using the following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods:</source>
          <target state="translated">您可以比較字串，以判斷兩者在排序次序的相對位置，使用下列<ph id="ph1">&lt;xref:System.String&gt;</ph>方法：</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> returns an integer that indicates the relationship of one string to a second string in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> 傳回一個整數，表示一個字串在排序次序為第二個字串的關聯性。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> 傳回一個整數，指出要根據其字碼指標比較的第二個字串的一個字串的關聯性。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> returns an integer that indicates the relationship of the current string instance to a second string in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> 傳回一個整數，指出目前的字串執行個體在排序次序為第二個字串的關聯性。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method provides the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> and <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> implementations for the <ph id="ph4">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph>方法提供<ph id="ph2">&lt;xref:System.IComparable&gt;</ph>和<ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph>實作<ph id="ph4">&lt;xref:System.String&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Testing strings for equality</source>
          <target state="translated">測試字串相等</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method to determine whether two strings are equal.</source>
          <target state="translated">您呼叫<ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph>方法，以判斷兩個字串是否相等。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The instance <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> and the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored.</source>
          <target state="translated">執行個體<ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph>和靜態<ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph>多載可讓您指定比較是否區分文化特性或序數，以及是否會被視為或是忽略大小寫。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.</source>
          <target state="translated">大部分測試相等為序數，且應一律序數決定可以存取系統資源 （例如檔案系統物件） 的比較相等。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Finding characters in a string</source>
          <target state="translated">尋找字串中的字元</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes two kinds of search methods:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String&gt;</ph>類別包含兩種搜尋方法：</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that return a <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> value to indicate whether a particular substring is present in a string instance.</source>
          <target state="translated">方法會傳回<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>可指出特定的子字串是否出現在字串執行個體的值。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>These include the <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph> methods.</source>
          <target state="translated">這些包括<ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.String.EndsWith%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that indicate the starting position of a substring in a string instance.</source>
          <target state="translated">表示子字串的字串執行個體的開始位置的方法。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>These include the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph> methods.</source>
          <target state="translated">這些包括<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions.</source>
          <target state="translated">如果您想要搜尋特定的模式，而不是特定的子字串的字串，您應該使用規則運算式。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱 <bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Modifying a string</source>
          <target state="translated">修改的字串。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes the following methods that appear to modify the value of a string:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String&gt;</ph>類別包含下列方法會將修改字串的值：</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> inserts a string into the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> 將字串插入至目前<ph id="ph2">&lt;xref:System.String&gt;</ph>執行個體。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> inserts one or more occurrences of a specified character at the beginning of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> 將指定之字元的一個或多個插入字串的開頭。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> inserts one or more occurrences of a specified character at the end of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> 將指定之字元的一個或多個插入字串的結尾。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> deletes a substring from the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> 刪除從目前的子字串<ph id="ph2">&lt;xref:System.String&gt;</ph>執行個體。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> replaces a substring with another substring in the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> 在目前的另一個子字串，取代子字串<ph id="ph2">&lt;xref:System.String&gt;</ph>執行個體。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> convert all the characters in a string to lowercase.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> 和<ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph>字串中的所有字元都轉換成小寫。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> convert all the characters in a string to uppercase.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> 和<ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph>字串中的所有字元都轉換成大寫。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> removes all occurrences of a character from the beginning and end of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> 移除開頭和結尾字串的所有出現的字元。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> removes all occurrences of a character from the end of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> 從字串的結尾移除所有出現的字元。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> removes all occurrences of a character from the beginning of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> 從字串開頭中移除所有出現的字元。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All string modification methods return a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">所有字串修改方法都會都傳回新<ph id="ph1">&lt;xref:System.String&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>They don't modify the value of the current instance.</source>
          <target state="translated">它們就不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Extracting substrings from a string</source>
          <target state="translated">從字串擷取子字串</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method separates a single string into multiple strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>方法會將單一字串分隔成多個字串。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.</source>
          <target state="translated">方法的多載可讓您指定多個分隔符號，來判斷最大數目的子字串，它會擷取方法，並判斷是否包含在所傳回的字串之間空字串 （分隔符號相鄰時，會發生問題）。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Combining strings</source>
          <target state="translated">結合字串</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods can be used for string concatenation:</source>
          <target state="translated">下列<ph id="ph1">&lt;xref:System.String&gt;</ph>方法可用於字串串連：</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> combines one or more substrings into a single string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> 結合成單一字串的一個或多個子字串。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> concatenates one or more substrings into a single element and adds a separator between each substring.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> 串連一或多個成單一元素的子字串，並將每一個子字串之間的分隔符號。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting values</source>
          <target state="translated">格式化值</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph>方法使用複合格式功能的某些物件或值的字串表示法取代字串中的一個或多個預留位置。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method is often used to do the following:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>方法通常用來執行下列動作：</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of a numeric value in a string.</source>
          <target state="translated">若要在字串中內嵌之數值的字串表示。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of a date and time value in a string.</source>
          <target state="translated">若要將日期和時間值的字串表示嵌入字串。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of an enumeration value in a string.</source>
          <target state="translated">若要在字串中嵌入的列舉值的字串表示。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of some object that supports the <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interface in a string.</source>
          <target state="translated">若要內嵌支援某些物件的字串表示<ph id="ph1">&lt;xref:System.IFormattable&gt;</ph>字串中的介面。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To right-justify or left-justify a substring in a field within a larger string.</source>
          <target state="translated">若要靠右對齊或靠左對齊的較大的字串內的欄位中的子字串。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For detailed information about formatting operations and examples, see the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload summary.</source>
          <target state="translated">如需格式化作業和範例的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>多載摘要。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Copying a string</source>
          <target state="translated">複製字串</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can call the following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods to make a copy of a string:</source>
          <target state="translated">您可以呼叫下列<ph id="ph1">&lt;xref:System.String&gt;</ph>方法來進行字串的複本：</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> returns a reference to an existing <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> 將參考傳回給現有<ph id="ph2">&lt;xref:System.String&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> creates a copy of an existing string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> 建立現有字串的複本。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> copies a portion of a string to a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> 將字串的部分複製到字元陣列。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalizing a string</source>
          <target state="translated">正規化字串</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In Unicode, a single character can have multiple code points.</source>
          <target state="translated">在 Unicode 中，單一字元可以有多個字碼指標。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalization converts these equivalent characters into the same binary representation.</source>
          <target state="translated">正規化會將這些對等的字元轉換成相同的二進位表示法。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Normalize%2A?displayProperty=nameWithType&gt;</ph> method performs the normalization, and the <ph id="ph2">&lt;xref:System.String.IsNormalized%2A?displayProperty=nameWithType&gt;</ph> method determines whether a string is normalized.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Normalize%2A?displayProperty=nameWithType&gt;</ph>方法會執行正規化，而<ph id="ph2">&lt;xref:System.String.IsNormalized%2A?displayProperty=nameWithType&gt;</ph>方法會判斷字串是否都正規化。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information and an example, see the <bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept> section earlier in this topic.</source>
          <target state="translated">如需詳細資訊和範例，請參閱<bpt id="p1">[</bpt>正規化<ept id="p1">](#Normalization)</ept>稍早在本主題中的區段。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This type is thread safe.</source>
          <target state="translated">此型別具備執行緒安全。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this section:</source>
          <target state="translated">本節內容：</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Overloaded constructor syntax<ept id="p1">](#Syntax)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>多載建構函式語法<ept id="p1">](#Syntax)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Parameters<ept id="p1">](#Params)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>參數<ept id="p1">](#Params)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Exceptions<ept id="p1">](#Exceptions)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>例外狀況<ept id="p1">](#Exceptions)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#Tasks)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>沒有呼叫的方法？<ept id="p1">](#Tasks)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Creating strings<ept id="p1">](#Creating_Strings)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>建立字串<ept id="p1">](#Creating_Strings)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Handling repetitive strings<ept id="p1">](#Repetitive)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>處理重複字串<ept id="p1">](#Repetitive)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Examples of instantiating strings:</source>
          <target state="translated">具現化字串的範例：</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using string assignment<ept id="p1">](#Ctor1_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>使用字串指派<ept id="p1">](#Ctor1_Example)</ept></target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a character array<ept id="p1">](#Ctor2_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>使用的字元陣列<ept id="p1">](#Ctor2_Example)</ept></target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a portion of a character array and repeating a single character<ept id="p1">](#Ctor3_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>使用字元陣列的一部分，並重複單一字元<ept id="p1">](#Ctor3_Example)</ept></target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a pointer to a character array<ept id="p1">](#Ctor4_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>使用的字元陣列的指標<ept id="p1">](#Ctor4_Example)</ept></target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using  a pointer and a range of an array<ept id="p1">](#Ctor5_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>使用指標以及陣列的範圍<ept id="p1">](#Ctor5_Example)</ept></target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a pointer to a signed byte array<ept id="p1">](#Ctor6_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>使用帶正負號的位元組陣列的指標<ept id="p1">](#Ctor6_Example)</ept></target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Version information<ept id="p1">](#Versions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>版本資訊<ept id="p1">](#Versions)</ept></target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Overloaded constructor syntax</source>
          <target state="translated">多載建構函式語法</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String constructors fall into two categories: those without pointer parameters, and those with pointer parameters.</source>
          <target state="translated">字串建構函式分為兩類： 不使用指標參數，以及使用指標的參數。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructors that use pointers are not CLS-compliant.</source>
          <target state="translated">使用指標的建構函式不符合 CLS 標準。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, Visual Basic does not support the use of pointers, and C# requires code that uses pointers to run in an unsafe context.</source>
          <target state="translated">此外，Visual Basic 不支援使用指標，以及 C# 需要使用指標 unsafe 內容中執行的程式碼。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>unsafe<ept id="p1">](~/docs/csharp/language-reference/keywords/unsafe.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱 <bpt id="p1">[</bpt>unsafe<ept id="p1">](~/docs/csharp/language-reference/keywords/unsafe.md)</ept>。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For additional guidance on choosing an overload, see <bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#Tasks)</ept></source>
          <target state="translated">如需有關選擇最多載的其他指引，請參閱<bpt id="p1">[</bpt>沒有呼叫的方法？<ept id="p1">](#Tasks)</ept></target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Initializes the new instance to the value indicated by an array of Unicode characters.</source>
          <target state="translated">初始化新的執行個體的 Unicode 字元陣列所指示的值。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This constructor copies Unicode characters(<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor2_Example)</ept>).</source>
          <target state="translated">這個建構函式會將 Unicode 字元的複製 (<bpt id="p1">[</bpt>範例<ept id="p1">](#Ctor2_Example)</ept>)。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Initializes the new instance to the value indicated by an array of Unicode characters, a starting character position within that array, and a length (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>).</source>
          <target state="translated">初始化新的執行個體的 Unicode 字元，該陣列，且長度內起始字元位置陣列所指示的值 (<bpt id="p1">[</bpt>範例<ept id="p1">](#Ctor3_Example)</ept>)。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Initializes the new instance to the value indicated by a specified Unicode character repeated a specified number of times (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>).</source>
          <target state="translated">初始化指定的 Unicode 字元所指示的新執行個體的值重複指定的次數 (<bpt id="p1">[</bpt>範例<ept id="p1">](#Ctor3_Example)</ept>)。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of Unicode characters that is terminated by a null character (U+0000 or '\0').</source>
          <target state="translated"><bpt id="p1">**</bpt>（不符合 CLS 標準）<ept id="p1">**</ept>初始化新的執行個體終止的 null 字元的 Unicode 字元陣列的指標所指示的值 (U + 0000 或 '\0')。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor4_Example)</ept>).</source>
          <target state="translated">(<bpt id="p1">[</bpt>範例<ept id="p1">](#Ctor4_Example)</ept>)。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">權限： <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>，需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of Unicode characters, a starting character position within that array, and a length.</source>
          <target state="translated"><bpt id="p1">**</bpt>（不符合 CLS 標準）<ept id="p1">**</ept>初始化新的執行個體的 Unicode 字元，該陣列，且長度內起始字元位置陣列的指標所指示的值。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor copies the Unicode characters from <ph id="ph1">`value`</ph> starting at index <ph id="ph2">`startIndex`</ph> and ending at index <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph> – 1 (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor5_Example)</ept>).</source>
          <target state="translated">建構函式的字元複製到 Unicode 從<ph id="ph1">`value`</ph>索引處開始<ph id="ph2">`startIndex`</ph>和結束索引<ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph> – 1 (<bpt id="p1">[</bpt>範例<ept id="p1">](#Ctor5_Example)</ept>)。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">權限： <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>，需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers.</source>
          <target state="translated"><bpt id="p1">**</bpt>（不符合 CLS 標準）<ept id="p1">**</ept>初始化新的執行個體的 8 位元帶正負號的整數陣列的指標所指示的值。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">陣列會假設為表示使用目前的系統字碼頁編碼的字串 (也就指定的編碼方式<ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor processes characters from <ph id="ph1">`value`</ph> starting from the location specified by the pointer until a null character (0x00) is reached (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor6_Example)</ept>).</source>
          <target state="translated">建構函式會處理從字元<ph id="ph1">`value`</ph>從 null 字元 (0x00) 為止，指標所指定的位置開始 (<bpt id="p1">[</bpt>範例<ept id="p1">](#Ctor6_Example)</ept>)。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">權限： <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>，需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</source>
          <target state="translated"><bpt id="p1">**</bpt>（不符合 CLS 標準）<ept id="p1">**</ept>初始化新的執行個體的 8 位元帶正負號的整數，該陣列，且長度內開始位置陣列的指標所指示的值。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">陣列會假設為表示使用目前的系統字碼頁編碼的字串 (也就指定的編碼方式<ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor processes characters from value starting at <ph id="ph1">`startIndex`</ph> and ending at <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1 (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor6_Example)</ept>).</source>
          <target state="translated">建構函式會處理從開始值的字元<ph id="ph1">`startIndex`</ph>結束為<ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1 (<bpt id="p1">[</bpt>範例<ept id="p1">](#Ctor6_Example)</ept>)。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">權限： <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>，需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>（不符合 CLS 標準）<ept id="p1">**</ept>初始化新的執行個體的 8 位元帶正負號的整數，長度，該陣列內開始位置陣列的指標所指示的值和<ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">權限： <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>，需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parameters</source>
          <target state="translated">參數</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here is a complete list of parameters used by <ph id="ph1">&lt;xref:System.String&gt;</ph> constructors that don't include a pointer parameter.</source>
          <target state="translated">以下是完整的清單所使用的參數<ph id="ph1">&lt;xref:System.String&gt;</ph>不包括指標參數的建構函式。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For the parameters used by each overload, see the overload syntax above.</source>
          <target state="translated">每個多載所使用的參數，請參閱上述的多載語法。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parameter</source>
          <target state="translated">參數</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Type</source>
          <target state="translated">類型</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Char&gt;</ph>[]</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Char&gt;</ph>[]</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An array of Unicode characters.</source>
          <target state="translated">Unicode 字元陣列。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A Unicode character.</source>
          <target state="translated">Unicode 字元。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The starting position in <ph id="ph1">`value`</ph> of the first character in the new string.</source>
          <target state="translated">中的開始位置<ph id="ph1">`value`</ph>新的字串中的第一個字元。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: 0</source>
          <target state="translated">預設值： 0</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The number of characters in <ph id="ph1">`value`</ph> to include in the new string.</source>
          <target state="translated">中的字元數<ph id="ph1">`value`</ph>包含在新的字串。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">預設值： <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The number of times the character <ph id="ph1">`c`</ph> is repeated in the new string.</source>
          <target state="translated">次數字元<ph id="ph1">`c`</ph>會在新的字串中重複。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`count`</ph> is zero, the value of the new object is <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`count`</ph>為零，新物件的值是<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here is a complete list of parameters used by <ph id="ph1">&lt;xref:System.String&gt;</ph> constructors that include a pointer parameter.</source>
          <target state="translated">以下是完整的清單所使用的參數<ph id="ph1">&lt;xref:System.String&gt;</ph>包含指標參數的建構函式。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For the parameters used by each overload, see the overload syntax above.</source>
          <target state="translated">每個多載所使用的參數，請參閱上述的多載語法。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parameter</source>
          <target state="translated">參數</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Type</source>
          <target state="translated">類型</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A pointer to a null-terminated array of Unicode characters or an array of 8-bit signed integers.</source>
          <target state="translated">以 null 結束的 Unicode 字元陣列或 8 位元帶正負號的整數陣列的指標。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph> or an empty array, the value of the new string is <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`value`</ph>是<ph id="ph2">`null`</ph>或空陣列，而新字串的值是<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The index of the array element that defines the first character in the new string.</source>
          <target state="translated">定義新的字串中的第一個字元之陣列項目的索引。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: 0</source>
          <target state="translated">預設值： 0</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The number of array elements to use to create the new string.</source>
          <target state="translated">要用來建立新的字串陣列元素數目。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If length is zero, the constructor creates a string whose value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果長度為零，建構函式會建立的字串，其值是<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">預設值： <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An object that specifies how the <ph id="ph1">`value`</ph> array is encoded.</source>
          <target state="translated">物件，指定如何<ph id="ph1">`value`</ph>編碼陣列。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>, or the system's current ANSI code page</source>
          <target state="translated">預設值： <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>，或系統的目前 ANSI 字碼頁</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Exceptions</source>
          <target state="translated">例外狀況</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's a list of exceptions thrown by constructors that don't include pointer parameters.</source>
          <target state="translated">以下是不包含指標參數的建構函式所擲回的例外狀況的清單。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Exception</source>
          <target state="translated">例外</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Condition</source>
          <target state="translated">條件</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Thrown by</source>
          <target state="translated">所擲回</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> 為 <ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`startIndex`</ph>,<ph id="ph2">`length`</ph>, or <ph id="ph3">`count`</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph><ph id="ph2">`length`</ph>，或<ph id="ph3">`count`</ph>小於零。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sum of <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> is greater than the number of elements in <ph id="ph3">`value`</ph>.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> 和 <ph id="ph2">`length`</ph> 的總和大於 <ph id="ph3">`value`</ph> 中的元素數目。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`count`</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">`count`</ph> 小於零。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's a list of exceptions thrown by constructors that include pointer parameters.</source>
          <target state="translated">以下是包含指標參數的建構函式所擲回的例外狀況的清單。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Exception</source>
          <target state="translated">例外</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Condition</source>
          <target state="translated">條件</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Thrown by</source>
          <target state="translated">所擲回</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> specifies an array that contains an invalid Unicode character.</source>
          <target state="translated"><ph id="ph1">`value`</ph> 指定的陣列，包含無效的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> or <ph id="ph2">`value`</ph><ph id="ph3"> + </ph><ph id="ph4">`startIndex`</ph> specifies an address that is less than 64K.</source>
          <target state="translated"><ph id="ph1">`value`</ph> 或<ph id="ph2">`value`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`startIndex`</ph>指定的位址小於 64k。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A new <ph id="ph1">&lt;xref:System.String&gt;</ph> instance could not be initialized from the <ph id="ph2">`value`</ph> byte array because <ph id="ph3">`value`</ph> does not use the default code page encoding.</source>
          <target state="translated">新<ph id="ph1">&lt;xref:System.String&gt;</ph>無法初始化執行個體，從<ph id="ph2">`value`</ph>位元組陣列，因為<ph id="ph3">`value`</ph>不會使用預設字碼頁編碼。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All constructors with pointers.</source>
          <target state="translated">使用指標的所有建構函式。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> is null.</source>
          <target state="translated"><ph id="ph1">`value`</ph> 為 null。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The current process does not have read access to all the addressed characters.</source>
          <target state="translated">目前的處理序沒有讀取所有定址字元的權限。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`startIndex`</ph> or <ph id="ph2">`length`</ph> is less than zero, <ph id="ph3">`value`</ph><ph id="ph4"> + </ph><ph id="ph5">`startIndex`</ph> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> 或 <ph id="ph2">`length`</ph> 小於零、<ph id="ph3">`value`</ph><ph id="ph4"> + </ph><ph id="ph5">`startIndex`</ph> 導致指標溢位，或目前的處理序沒有所有定址字元的讀取權限。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The length of the new string is too large to allocate.</source>
          <target state="translated">新字串長度太大而無法配置。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All constructors with pointers.</source>
          <target state="translated">使用指標的所有建構函式。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph>, or <ph id="ph2">`value`</ph><ph id="ph3"> + </ph><ph id="ph4">`startIndex`</ph><ph id="ph5"> + </ph><ph id="ph6">`length`</ph> – 1, specifies an invalid address.</source>
          <target state="translated"><ph id="ph1">`value`</ph>或<ph id="ph2">`value`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`startIndex`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`length`</ph> – 1，指定了無效的位址。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Which method do I call?</source>
          <target state="translated">沒有呼叫的方法？</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To</source>
          <target state="translated">以</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Call or use</source>
          <target state="translated">呼叫或使用</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string.</source>
          <target state="translated">建立字串。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Assignment from a string literal or an existing string (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor1_Example)</ept>)</source>
          <target state="translated">從字串常值或現有的字串指派 (<bpt id="p1">[</bpt>範例<ept id="p1">](#Ctor1_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from an entire character array.</source>
          <target state="translated">從整個字元陣列建立字串。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor2_Example)</ept>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> (<bpt id="p1">[</bpt>範例<ept id="p1">](#Ctor2_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Createa string from a portion of a character array.</source>
          <target state="translated">建立字串，從字元陣列的一部分。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>範例<ept id="p1">](#Ctor3_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string that repeats the same character multiple times.</source>
          <target state="translated">建立重複多次的相同字元的字串。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>範例<ept id="p1">](#Ctor3_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from a pointer to a Unicode or wide character array.</source>
          <target state="translated">從指標建立字串，以 Unicode 或寬字元陣列。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from a portion of a Unicode or wide character array by using its pointer.</source>
          <target state="translated">使用它的指標，從 Unicode 或寬字元陣列的一部分建立字串。</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from a C++ <ph id="ph1">`char`</ph> array.</source>
          <target state="translated">從 c + + 建立字串<ph id="ph1">`char`</ph>陣列。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph>, <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph>, <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph></target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from ASCII characters.</source>
          <target state="translated">建立從 ASCII 字元的字串。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Creating strings</source>
          <target state="translated">建立字串</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The most commonly used technique for creating strings programmatically is simple assignment, as illustrated in <bpt id="p1">[</bpt>this example<ept id="p1">](#Ctor1_Example)</ept>.</source>
          <target state="translated">最常使用的技術以程式設計方式建立字串是簡單指派，如所示<bpt id="p1">[</bpt>本例<ept id="p1">](#Ctor1_Example)</ept>。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class also includes four types of constructor overloads that let you create strings from the following values:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String&gt;</ph>類別也包含四種類型的建構函式多載可讓您從下列值建立字串：</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a character array (an array of UTF-16-encoded characters).</source>
          <target state="translated">從字元陣列 （UTF 16 編碼的字元陣列）。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from the characters in the entire array or a portion of it.</source>
          <target state="translated">您可以建立新<ph id="ph1">&lt;xref:System.String&gt;</ph>整個陣列或其一部分之字元的物件。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> constructor copies all the characters in the array to the new string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph>建構函式所有的字元複製到陣列中的新字串。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor copies the characters from index <ph id="ph2">`startIndex`</ph> to index <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph> – 1 to the new string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>建構函式的字元複製到從索引<ph id="ph2">`startIndex`</ph>索引<ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph> – 1，以新的字串。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`length`</ph> is zero, the value of the new string is <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`length`</ph>為零，而新字串的值是<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your code repeatedly instantiates strings that have the same value, you can improve application performance by using an alternate means of creating strings.</source>
          <target state="translated">如果您的程式碼重複具現化具有相同的值的字串，您可以藉由建立字串的其他方式來改善應用程式的效能。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Handling repetitive strings<ept id="p1">](#Repetitive)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>處理重複字串<ept id="p1">](#Repetitive)</ept>。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a single character that is duplicated zero, one, or more times, by using the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">從單一字元也就是重複的零，一次或多次使用<ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`count`</ph> is zero, the value of the new string is <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`count`</ph>為零，而新字串的值是<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a pointer to a null-terminated character array, by using the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> or <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">以 null 結束的字元陣列的指標，從使用<ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph>或<ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Either the entire array or a specified range can be used to initialize the string.</source>
          <target state="translated">整個陣列或指定的範圍，都可以用來初始化字串。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor copies a sequence of Unicode characters starting from the specified pointer or from the specified pointer plus <ph id="ph1">`startIndex`</ph> and continuing to the end of the array or for <ph id="ph2">`length`</ph> characters.</source>
          <target state="translated">建構函式會複製啟動從指定的指標或加上的指定指標的 Unicode 字元序列<ph id="ph1">`startIndex`</ph>繼續執行到結尾的陣列或<ph id="ph2">`length`</ph>字元。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`value`</ph> is a null pointer or <ph id="ph2">`length`</ph> is zero, the constructor creates a string whose value is <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`value`</ph>為 null 指標或<ph id="ph2">`length`</ph>為零，建構函式會建立的字串，其值是<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the copy operation proceeds to the end of the array and the array is not null-terminated, the constructor behavior is system-dependent.</source>
          <target state="translated">如果複製作業繼續進行陣列的結尾，而且陣列不是以 null 結束，則建構函式行為是系統而定。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Such a condition might cause an access violation.</source>
          <target state="translated">這種情況可能會造成存取違規。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the array contains any embedded null characters (U+0000 or '\0') and the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is called, the string instance contains <ph id="ph2">`length`</ph> characters including any embedded nulls.</source>
          <target state="translated">如果陣列包含任何內嵌的 null 字元 (U + 0000 或 '\0') 和<ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>呼叫的多載，就會包含字串執行個體<ph id="ph2">`length`</ph>字元，包括任何內嵌的 null。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">下列範例會顯示 10 個元素的陣列，其中包含兩個 null 字元的指標傳遞至時，會發生什麼事<ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</source>
          <target state="translated">因為位址是陣列的開頭，而且若要加入至字串陣列中的所有項目，建構函式具現化具有 10 個字元，包括兩個內嵌的 null 的字串。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, if the same array is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> constructor, the result is a four-character string that does not include the first null character.</source>
          <target state="translated">另一方面，如果相同的陣列傳遞至<ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph>建構函式，結果是不包含第一個 null 字元的四個字元字串。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The array must contain Unicode characters.</source>
          <target state="translated">陣列必須包含 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In C++, this means that the character array must be defined either as the managed <ph id="ph1">&lt;xref:System.Char&gt;</ph>[] type or the unmanaged<ph id="ph2">`wchar_t`</ph>[] type.</source>
          <target state="translated">在 c + +，這表示的字元陣列必須是定義為 managed <ph id="ph1">&lt;xref:System.Char&gt;</ph>[] 型別或未受<ph id="ph2">`wchar_t`</ph>[] 型別。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> overload is called and the array is not null-terminated, or if the <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is called and <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph>-1 includes a range that it outside the memory allocated for the sequence of characters, the behavior of the constructor is system-dependent, and an access violation may occur.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph>呼叫的多載和陣列不是以 null 結尾，或如果<ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>呼叫的多載和<ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph>-1 包含順序的字元，而它之外的記憶體配置的範圍建構函式的行為是系統而定，並可能會發生存取違規。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, on the Intel Itanium processor, calls to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor may throw a <ph id="ph2">&lt;xref:System.DataMisalignedException&gt;</ph> exception.</source>
          <target state="translated">此外，Intel Itanium 處理器上呼叫<ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>建構函式可能會擲回<ph id="ph2">&lt;xref:System.DataMisalignedException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If this occurs, call the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> instead.</source>
          <target state="translated">如果發生這種情況，呼叫<ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>改為。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a pointer to a signed byte array.</source>
          <target state="translated">從帶正負號的位元組陣列的指標。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Either the entire array or a specified range can be used to initialize the string.</source>
          <target state="translated">整個陣列或指定的範圍，都可以用來初始化字串。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sequence of bytes can be interpreted by using the default code page encoding, or an encoding can be specified in the constructor call.</source>
          <target state="translated">可以使用預設字碼頁編碼方式，來解譯的位元組序列，或可以指定建構函式呼叫中的編碼方式。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the constructor tries to instantiate a string from an entire array that is not null-terminated, or if the range of the array from <ph id="ph1">`value`</ph><ph id="ph2"> + </ph><ph id="ph3">`startIndex`</ph> to <ph id="ph4">`value`</ph><ph id="ph5"> + </ph><ph id="ph6">`startIndex`</ph><ph id="ph7"> + </ph><ph id="ph8">`length`</ph> -1 is outside of the memory allocated for the array, the behavior of this constructor is system-dependent, and an access violation may occur.</source>
          <target state="translated">如果建構函式會嘗試具現化不是以 null 結束的整個陣列的字串，或是如果從陣列範圍<ph id="ph1">`value`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`startIndex`</ph>至<ph id="ph4">`value`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`startIndex`</ph> <ph id="ph7"> + </ph> <ph id="ph8">`length`</ph> -1 的記憶體配置的陣列，這個建構函式的行為是系統而定，而且發生存取違規，可能會發生。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The three constructors that include a signed byte array as a parameter are designed primarily to convert a C++ <ph id="ph1">`char`</ph> array to a string, as shown in this example:</source>
          <target state="translated">包含帶正負號的位元組陣列做為參數的三個建構函式主要設計來轉換 c + +<ph id="ph1">`char`</ph>陣列為字串，此範例中所示：</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the array contains any null characters ('\0') or bytes whose value is 0 and the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is called, the string instance contains <ph id="ph2">`length`</ph> characters including any embedded nulls.</source>
          <target state="translated">如果其值為 0 的任何 null 字元 ('\0') 或位元組陣列和<ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>呼叫的多載，就會包含字串執行個體<ph id="ph2">`length`</ph>字元，包括任何內嵌的 null。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">下列範例會顯示 10 個元素的陣列，其中包含兩個 null 字元的指標傳遞至時，會發生什麼事<ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</source>
          <target state="translated">因為位址是陣列的開頭，而且若要加入至字串陣列中的所有項目，建構函式具現化具有 10 個字元，包括兩個內嵌的 null 的字串。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, if the same array is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> constructor, the result is a four-character string that does not include the first null character.</source>
          <target state="translated">另一方面，如果相同的陣列傳遞至<ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph>建構函式，結果是不包含第一個 null 字元的四個字元字串。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> and <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructors interpret <ph id="ph3">`value`</ph> by using the default ANSI code page, calling these constructors with identical byte arrays may create strings that have different values on different systems.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph>和<ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>建構函式解譯<ph id="ph3">`value`</ph>藉由使用預設 ANSI 字碼頁，在呼叫這些建構函式具有相同的位元組陣列可能會建立不同的系統有不同的值的字串。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Handling repetitive strings</source>
          <target state="translated">處理重複字串</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Apps that parse or decode streams of text often use the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor or the <ph id="ph2">&lt;xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to convert sequences of characters into a string.</source>
          <target state="translated">剖析或通常解碼的文字資料流的應用程式使用<ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>建構函式或<ph id="ph2">&lt;xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>方法，以將字元序列轉換成字串。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Repeatedly creating new strings with the same value instead of creating and reusing one string wastes memory.</source>
          <target state="translated">重複使用相同的值，而不是建立及重複使用一個字串中建立新的字串會浪費記憶體。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you are likely to create the same string value repeatedly by calling the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor, even if you don't know in advance what those identical string values may be, you can use a lookup table instead.</source>
          <target state="translated">如果您可能會重複呼叫來建立相同的字串值<ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>建構函式，即使您不知道中前進這些相同的字串值可能是，您可以改為使用查閱資料表。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, suppose you read and parse a stream of characters from a file that contains XML tags and attributes.</source>
          <target state="translated">例如，假設您已閱讀並剖析 XML 標記和屬性包含的檔案，從字元資料流。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When you parse the stream, you repeatedly encounter certain tokens (that is, sequences of characters that have a symbolic meaning).</source>
          <target state="translated">當您剖析資料流時，您重複遇到特定權杖 （也就是具有符號的意義的字元序列）。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Tokens equivalent to the strings "0", "1", "true", and "false" are likely to occur frequently in an XML stream.</source>
          <target state="translated">相當於"0"，"1"，"true"和"false"字串的語彙基元是可能會在經常出現在 XML 資料流。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Instead of converting each token into a new string, you can create a <ph id="ph1">&lt;xref:System.Xml.NameTable?displayProperty=nameWithType&gt;</ph> object to hold commonly occurring strings.</source>
          <target state="translated">而不是將每個語彙基元轉換成新的字串，您可以建立<ph id="ph1">&lt;xref:System.Xml.NameTable?displayProperty=nameWithType&gt;</ph>物件來保存經常出現的字串。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.Xml.NameTable&gt;</ph> object improves performance, because it retrieves stored strings without allocating temporary memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.NameTable&gt;</ph>物件可改進效能，因為它會擷取儲存的字串，而不需配置的暫存記憶體。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When you encounter a token, use the <ph id="ph1">&lt;xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to retrieve the token from the table.</source>
          <target state="translated">當您遇到語彙基元時，使用<ph id="ph1">&lt;xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>方法來擷取資料表中的語彙基元。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the token exists, the method returns the corresponding string.</source>
          <target state="translated">如果權杖存在，則方法會傳回對應的字串。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the token does not exist, use the <ph id="ph1">&lt;xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to insert the token into the table and to get the corresponding string.</source>
          <target state="translated">如果語彙基元不存在，使用<ph id="ph1">&lt;xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>方法插入資料表中的語彙基元，並取得對應的字串。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 1: Using string assignment</source>
          <target state="translated">範例 1： 使用字串指派</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example creates a new string by assigning it a string literal.</source>
          <target state="translated">下列範例會藉由指定字串常值建立新的字串。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It creates a second string by assigning the value of the first string to it.</source>
          <target state="translated">它會建立第二個字串指派給它的第一個字串的值。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>These are the two most common ways to instantiate a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">這些是兩個最常見方式，並具現化新<ph id="ph1">&lt;xref:System.String&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 2: Using a character array</source>
          <target state="translated">範例 2： 使用的字元陣列</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from a character array.</source>
          <target state="translated">下列範例示範如何建立新<ph id="ph1">&lt;xref:System.String&gt;</ph>字元陣列中的物件。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 3: Using a portion of a character array and repeating a single character</source>
          <target state="translated">範例 3： 使用字元陣列的一部分，並重複單一字元</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from a portion of a character array, and how to create a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object that contains multiple occurrences of a single character.</source>
          <target state="translated">下列範例示範如何建立新<ph id="ph1">&lt;xref:System.String&gt;</ph>部份字元陣列，以及如何建立新物件<ph id="ph2">&lt;xref:System.String&gt;</ph>物件，其中包含單一字元的多個項目。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 4: Using a pointer to a character array</source>
          <target state="translated">範例 4： 使用的字元陣列的指標</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from a pointer to an array of characters.</source>
          <target state="translated">下列範例示範如何建立新<ph id="ph1">&lt;xref:System.String&gt;</ph>指標的字元陣列的物件。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The C# example must be compiled by using the <ph id="ph1">`/unsafe`</ph> compiler switch.</source>
          <target state="translated">必須編譯 C# 範例使用<ph id="ph1">`/unsafe`</ph>編譯器參數。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 5: Instantiating a string from a pointer and a range of an array</source>
          <target state="translated">範例 5： 具現化的字串指標，而且陣列的範圍</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example examines the elements of a character array for either a period or an exclamation point.</source>
          <target state="translated">下列範例會將字元陣列的項目檢查句號或驚嘆號。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If one is found, it instantiates a string from the characters in the array that precede the punctuation symbol.</source>
          <target state="translated">如果找到一個物件，它會具現化前面標點符號的字元陣列中的字串。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If not, it instantiates a string with the entire contents of the array.</source>
          <target state="translated">如果沒有，它會具現化的字串陣列的整個內容。</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The C# example must be compiled using the <ph id="ph1">`/unsafe`</ph> compiler switch.</source>
          <target state="translated">必須編譯 C# 範例，使用<ph id="ph1">`/unsafe`</ph>編譯器參數。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 6: Instantiating a string from a pointer to a signed byte array</source>
          <target state="translated">範例 6： 具現化的字串指標的帶正負號的位元組陣列</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how you can create an instance of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class with the <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> constructor.</source>
          <target state="translated">下列範例會示範如何建立執行個體<ph id="ph1">&lt;xref:System.String&gt;</ph>類別<ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Version information</source>
          <target state="translated">版本資訊</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework</source>
          <target state="translated">.NET Framework</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</source>
          <target state="translated">所有多載支援： 4.5、 4、 3.5、 3.0、 2.0、 1.1、 1.0</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework Client Profile</source>
          <target state="translated">.NET Framework Client Profile</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads are supported in: 4, 3.5 SP1</source>
          <target state="translated">所有多載支援： 4、 3.5 SP1</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Portable Class Library</source>
          <target state="translated">可攜式類別庫</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads without an <ph id="ph1">&lt;xref:System.SByte&gt;</ph><ph id="ph2">`*`</ph> parameter are supported</source>
          <target state="translated">所有多載，而不<ph id="ph1">&lt;xref:System.SByte&gt;</ph><ph id="ph2">`*`</ph>參數支援</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET for Windows Store apps</source>
          <target state="translated">適用於 Windows 市集應用程式的 .NET</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads without an <ph id="ph1">&lt;xref:System.SByte&gt;</ph><ph id="ph2">`*`</ph> parameter are supported in: Windows 8</source>
          <target state="translated">所有多載，而不<ph id="ph1">&lt;xref:System.SByte&gt;</ph><ph id="ph2">`*`</ph>支援參數： Windows 8</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source>A pointer to a null-terminated array of Unicode characters.</source>
          <target state="translated">Unicode 字元之 Null 終端陣列的指標。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of Unicode characters.</source>
          <target state="translated">將 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 類別的新執行個體初始化為 Unicode 字元陣列的指定指標所指示的值。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">如範例和完整的使用方式資訊有關這個主題以及其他<ph id="ph1">`String`</ph>建構函式多載，請參閱<ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph>建構函式的摘要。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source>The current process does not have read access to all the addressed characters.</source>
          <target state="translated">目前的處理序沒有讀取所有定址字元的權限。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifies an array that contains an invalid Unicode character, or <ph id="ph2">&lt;paramref name="value" /&gt;</ph> specifies an address less than 64000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 指定了包含無效 Unicode 字元的陣列，或 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 指定了小於 64000 的位址。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[])">
          <source>An array of Unicode characters.</source>
          <target state="translated">Unicode 字元陣列。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by an array of Unicode characters.</source>
          <target state="translated">將 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 類別的新執行個體初始化為 Unicode 字元陣列所指示的值。</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char[])">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">如範例和完整的使用方式資訊有關這個主題以及其他<ph id="ph1">`String`</ph>建構函式多載，請參閱<ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph>建構函式的摘要。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>A pointer to a null-terminated array of 8-bit signed integers.</source>
          <target state="translated">以 null 結束之 8 位元帶正負號整數的陣列指標。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>The integers are interpreted using the current system code page encoding (that is, the encoding specified by <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph>).</source>
          <target state="translated">整數會使用目前的系統字碼頁編碼來解譯 (也就是由 <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph> 所指定的編碼)。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a pointer to an array of 8-bit signed integers.</source>
          <target state="translated">將 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 類別的新執行個體初始化為 8 位元帶正負號整數 (Signed Integer) 陣列的指標所指示的值。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">如範例和完整的使用方式資訊有關這個主題以及其他<ph id="ph1">`String`</ph>建構函式多載，請參閱<ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph>建構函式的摘要。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> could not be initialized using <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, assuming <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is encoded in ANSI.</source>
          <target state="translated">無法使用 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 初始化 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的新執行個體，假設 <ph id="ph3">&lt;paramref name="value" /&gt;</ph> 是 ANSI 編碼。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>The length of the new string to initialize, which is determined by the null termination character of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, is too large to allocate.</source>
          <target state="translated">要初始化的新字串長度，由 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 之 null 結束字元所決定，該長度太長而無法配置。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifies an invalid address.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 指定了無效的位址。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>A Unicode character.</source>
          <target state="translated">Unicode 字元。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>The number of times <bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept> occurs.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept> 發生的次數。</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified Unicode character repeated a specified number of times.</source>
          <target state="translated">將 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 類別的新執行個體初始化為由重複指定次數的指定 Unicode 字元所指示的值。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">如範例和完整的使用方式資訊有關這個主題以及其他<ph id="ph1">`String`</ph>建構函式多載，請參閱<ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph>建構函式的摘要。</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 小於零。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>A pointer to an array of Unicode characters.</source>
          <target state="translated">Unicode 字元陣列的指標。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">開始位置在 <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 內。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 內要使用的字元數。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</source>
          <target state="translated">將 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 類別的新執行個體初始化為 Unicode 字元陣列、在陣列內起始字元的位置以及長度等等的指定指標所指示的值。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">如範例和完整的使用方式資訊有關這個主題以及其他<ph id="ph1">`String`</ph>建構函式多載，請參閱<ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph>建構函式的摘要。</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero, <ph id="ph3">&lt;paramref name="value" /&gt;</ph><ph id="ph4"> + </ph><ph id="ph5">&lt;paramref name="startIndex" /&gt;</ph> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 小於零、<ph id="ph3">&lt;paramref name="value" /&gt;</ph><ph id="ph4"> + </ph><ph id="ph5">&lt;paramref name="startIndex" /&gt;</ph> 導致指標溢位，或目前的處理序沒有所有定址字元的讀取權限。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifies an array that contains an invalid Unicode character, or <ph id="ph2">&lt;paramref name="value" /&gt;</ph><ph id="ph3"> + </ph><ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> specifies an address less than 64000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 指定包含無效 Unicode 字元的陣列，或 <ph id="ph2">&lt;paramref name="value" /&gt;</ph><ph id="ph3"> + </ph><ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> 指定小於 64000 的位址。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>An array of Unicode characters.</source>
          <target state="translated">Unicode 字元陣列。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">開始位置在 <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 內。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 內要使用的字元數。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</source>
          <target state="translated">將 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 類別的新執行個體初始化為 Unicode 字元陣列、在陣列內起始字元的位置和長度等等所指示的值。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">如範例和完整的使用方式資訊有關這個主題以及其他<ph id="ph1">`String`</ph>建構函式多載，請參閱<ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph>建構函式的摘要。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 小於零。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>The sum of <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 的總和大於 <ph id="ph3">&lt;paramref name="value" /&gt;</ph> 中的元素數目。</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>A pointer to an array of 8-bit signed integers.</source>
          <target state="translated">8 位元帶正負號整數陣列的指標。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The integers are interpreted using the current system code page encoding (that is, the encoding specified by <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph>).</source>
          <target state="translated">整數會使用目前的系統字碼頁編碼來解譯 (也就是由 <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph> 所指定的編碼)。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">開始位置在 <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 內。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 內要使用的字元數。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</source>
          <target state="translated">將 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 類別的新執行個體初始化為 8 位元帶正負號整數的陣列、在該陣列內開始位置和長度的指定指標所指示的值。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">如範例和完整的使用方式資訊有關這個主題以及其他<ph id="ph1">`String`</ph>建構函式多載，請參閱<ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph>建構函式的摘要。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 小於零。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is too large for the current platform; that is, the address calculation overflowed.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 指定的位址對於目前的平台而言太大，也就是位址計算溢位。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The length of the new string to initialize is too large to allocate.</source>
          <target state="translated">要初始化的新字串長度太大而無法配置。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is less than 64K.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 指定的位址小於 64K。</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> could not be initialized using <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, assuming <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is encoded in ANSI.</source>
          <target state="translated">無法使用 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 初始化 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的新執行個體，假設 <ph id="ph3">&lt;paramref name="value" /&gt;</ph> 是 ANSI 編碼。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="length" /&gt;</ph> collectively specify an invalid address.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>、<ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 和 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 共同指定了無效的位址。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>A pointer to an array of 8-bit signed integers.</source>
          <target state="translated">8 位元帶正負號整數陣列的指標。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">開始位置在 <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 內。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 內要使用的字元數。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>An object that specifies how the array referenced by <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> is encoded.</source>
          <target state="translated">物件，指定以 <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 參考之陣列的編碼方式。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>enc<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, ANSI encoding is assumed.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>enc<ept id="p1">&lt;/c&gt;</ept> 為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，則假設使用 ANSI 編碼方式。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">將 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 類別的新執行個體初始化為 8 位元帶正負號整數的陣列、在該陣列內開始位置、長度和 <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> 物件的指定指標所指示的值。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">如範例和完整的使用方式資訊有關這個主題以及其他<ph id="ph1">`String`</ph>建構函式多載，請參閱<ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph>建構函式的摘要。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 小於零。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is too large for the current platform; that is, the address calculation overflowed.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 指定的位址對於目前的平台而言太大，也就是位址計算溢位。</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The length of the new string to initialize is too large to allocate.</source>
          <target state="translated">要初始化的新字串長度太大而無法配置。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is less than 64K.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 指定的位址小於 64K。</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> could not be initialized using <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, assuming <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is encoded as specified by <ph id="ph4">&lt;paramref name="enc" /&gt;</ph>.</source>
          <target state="translated">無法使用 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 初始化 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的新執行個體 (假設 <ph id="ph3">&lt;paramref name="value" /&gt;</ph> 是以 <ph id="ph4">&lt;paramref name="enc" /&gt;</ph> 指定的方式編碼)。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="length" /&gt;</ph> collectively specify an invalid address.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>、<ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 和 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 共同指定了無效的位址。</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任立即呼叫者。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">這個成員無法供部分信任或安全性透明程式碼。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="P:System.String.Chars(System.Int32)">
          <source>A position in the current string.</source>
          <target state="translated">目前字串中的位置。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="P:System.String.Chars(System.Int32)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Char" /&gt;</ph> object at a specified position in the current <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.Char" /&gt;</ph> 物件中指定位置的 <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>The object at position <ph id="ph1">&lt;paramref name="index" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="index" /&gt;</ph> 位置的物件。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>The <ph id="ph1">`index`</ph> parameter is zero-based.</source>
          <target state="translated"><ph id="ph1">`index`</ph>參數以零為起始。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>This property returns the <ph id="ph1">&lt;xref:System.Char&gt;</ph> object at the position specified by the <ph id="ph2">`index`</ph> parameter.</source>
          <target state="translated">這個屬性會傳回<ph id="ph1">&lt;xref:System.Char&gt;</ph>物件所指定位置<ph id="ph2">`index`</ph>參數。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>However, a Unicode character might be represented by more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</source>
          <target state="translated">不過，您可能會將 Unicode 字元表示由多個<ph id="ph1">&lt;xref:System.Char&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> class to work with Unicode characters instead of <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph>類別，以使用 Unicode 字元，而非<ph id="ph2">&lt;xref:System.Char&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>For more information, see the "Char Objects and Unicode Characters" section in the <ph id="ph1">&lt;xref:System.String&gt;</ph> class overview.</source>
          <target state="translated">如需詳細資訊，請參閱 「 Char 物件和 Unicode 字元 」 一節<ph id="ph1">&lt;xref:System.String&gt;</ph>類別概觀。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>In C#, the <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property is an indexer.</source>
          <target state="translated">在 C# 中，<ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph>屬性是索引子。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>In Visual Basic, it is the default property of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated">在 Visual Basic 中，它是預設屬性<ph id="ph1">&lt;xref:System.String&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>Each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object in the string can be accessed by using code such as the following.</source>
          <target state="translated">每個<ph id="ph1">&lt;xref:System.Char&gt;</ph>可以使用下列程式碼存取字串中的物件。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>The following example demonstrates how you can use this indexer in a routine to validate a string.</source>
          <target state="translated">下列範例會示範如何使用這個索引子在常式驗證字串。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="P:System.String.Chars(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than or equal to the length of this object or less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 大於或等於此物件的長度或小於零。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.String.Clone">
          <source>Returns a reference to this instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">傳回對 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 這個執行個體的參考。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.String.Clone">
          <source>This instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的這個執行個體。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Clone">
          <source>The return value is not an independent copy of this instance; it is simply another view of the same data.</source>
          <target state="translated">傳回的值不是這個執行個體的獨立複本它是只是另一個檢視相同的資料。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Clone">
          <source>Use the <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.CopyTo%2A&gt;</ph> method to create a separate <ph id="ph3">&lt;xref:System.String&gt;</ph> object with the same value as this instance.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.CopyTo%2A&gt;</ph>方法來建立個別<ph id="ph3">&lt;xref:System.String&gt;</ph>物件具有相同的值與這個執行個體。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Clone">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> method simply returns the existing string instance, there is little reason to call it directly.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph>方法只會傳回現有的字串執行個體中，沒有什麼道理直接呼叫它。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">比較兩個指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件，並傳回一個整數，指出它們在排序順序中的相對位置。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads of the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method return a 32-bit signed integer indicating the lexical relationship between the two comparands.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> 方法的所有多載會傳回 32 位元帶正負號整數，指出兩個比較元之間的語彙關係。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Value</source>
          <target state="translated">值</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Condition</source>
          <target state="translated">條件</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Less than zero</source>
          <target state="translated">小於零</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The first substring precedes the second substring in the sort order.</source>
          <target state="translated">第一個子字串在排序次序中位於第二個的子字串。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Zero</source>
          <target state="translated">零</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The substrings occur in the same position in the sort order, or <ph id="ph1">`length`</ph> is zero.</source>
          <target state="translated">子字串出現在排序次序中的相同位置，或 <ph id="ph1">`length`</ph> 為零。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Greater than zero</source>
          <target state="translated">大於零</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The first substring follows the second substring in the sort order.</source>
          <target state="translated">第一個子字串會遵循第二個的子字串在排序次序。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Whenever possible, you should call an overload of the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method that includes a <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
          <target state="translated">可能的話，您應該呼叫的多載<ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>方法包含<ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>使用字串的最佳做法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>The first string to compare.</source>
          <target state="translated">要比較的第一個字串。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>The second string to compare.</source>
          <target state="translated">要比較的第二個字串。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">比較兩個指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件，並傳回一個整數，指出它們在排序順序中的相對位置。</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>在排序次序中，<ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 會排在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 之前。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 出現在排序次序中的位置和 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 相同。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>在排序次序中，<ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 會排在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 之後。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">例如，某些字元的組合視為單一字元，或以特定方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元或請依照它。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">使用字組的排序規則來進行比較。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">當比較字串時，您應該呼叫<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph>方法，會要求您明確指定此方法會使用的字串比較的類型。</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>使用字串的最佳做法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">一或兩個比較元可以是<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">當探索到的不等比較或這兩個字串都比較之後，則會結束比較。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，然後其餘字元的字串被視為較大。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">傳回值是執行的最後一個比對的結果。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">比較路徑名稱為"file"使用序數比較。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">若要這樣做的正確程式碼如下所示：</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method to compare three sets of strings.</source>
          <target state="translated">下列範例會呼叫<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph>方法來比較三個字串集合。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>In the following example, the <ph id="ph1">`ReverseStringComparer`</ph> class demonstrates how you can evaluate two strings with the <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> method.</source>
          <target state="translated">在下列範例中，<ph id="ph1">`ReverseStringComparer`</ph>類別會示範如何評估兩個字串與<ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">字元集包含可忽略的字元。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String)" /&gt;</ph>方法執行區分文化特性的比較時不會考慮這類字元。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a culture-sensitive comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">例如，如果執行下列程式碼<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，區分文化特性的比較"動物 」 與 「 ani 郵件 」 （使用選擇性連字號或 U + 00AD），表示兩個字串相等。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> method and supply a value of either <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">`comparisonType`</ph> parameter.</source>
          <target state="translated">若要識別可忽略的字元字串比較中，呼叫<ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph>方法並提供值的其中一個<ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph>或<ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph>如<ph id="ph4">`comparisonType`</ph>參數。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The first string to compare.</source>
          <target state="translated">要比較的第一個字串。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The second string to compare.</source>
          <target state="translated">要比較的第二個字串。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示在比較時忽略大小寫，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">比較兩個指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件，忽略或區分兩者的大小寫，並傳回一個整數，表示兩者在排序順序中的相對位置。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>在排序次序中，<ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 會排在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 之前。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 出現在排序次序中的位置和 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 相同。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>在排序次序中，<ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 會排在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 之後。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">例如，某些字元的組合視為單一字元，或以特定方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元或請依照它。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">使用字組的排序規則來進行比較。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">當比較字串時，您應該呼叫<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph>方法，會要求您明確指定此方法會使用的字串比較的類型。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>使用字串的最佳做法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">一或兩個比較元可以是<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">當探索到的不等比較或這兩個字串都比較之後，則會結束比較。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，然後其餘字元的字串被視為較大。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">傳回值是執行的最後一個比對的結果。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">比較路徑名稱為"file"使用序數比較。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">若要這樣做的正確程式碼如下所示：</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The following example demonstrates that the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29&gt;</ph> method is equivalent to using <ph id="ph2">&lt;xref:System.String.ToUpper%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.String.ToLower%2A&gt;</ph> when comparing strings.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29&gt;</ph>方法相當於使用<ph id="ph2">&lt;xref:System.String.ToUpper%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.String.ToLower%2A&gt;</ph>比較字串時。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">字元集包含可忽略的字元。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /&gt;</ph>方法執行區分文化特性的比較時不會考慮這類字元。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a culture-sensitive, case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">例如，如果執行下列程式碼<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，區分文化特性、 不區分大小寫的比較"動物 」 與 「 Ani 郵件 」 （使用選擇性連字號或 U + 00AD），表示兩個字串相等。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> method and supply a value of either <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">若要識別可忽略的字元字串比較中，呼叫<ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph>方法並提供值的其中一個<ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph>或<ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph>如<ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The first string to compare.</source>
          <target state="translated">要比較的第一個字串。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The second string to compare.</source>
          <target state="translated">要比較的第二個字串。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules to use in the comparison.</source>
          <target state="translated">其中一個列舉值，指定要用於比較的規則。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">使用指定的規則比較兩個指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件，並傳回一個整數，表示兩者在排序順序中的相對位置。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>在排序次序中，<ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 會排在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 之前。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 在排序次序中的位置和 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 相同。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>在排序次序中，<ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 會排在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 之後。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph>參數會指出是否比較應該使用的目前或而異的文化特性、 接受或忽略大小寫的比較元，或使用 word （區分文化特性） 或序數 （不區分文化特性） 的排序規則。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">一或兩個比較元可以是<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">當探索到的不等比較或這兩個字串都比較之後，則會結束比較。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</source>
          <target state="translated">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，其餘字元的字串被視為較大。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">傳回值是執行的最後一個比對的結果。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">比較路徑名稱為"file"使用序數比較。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">若要這樣做的正確程式碼如下所示：</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The following example compares three versions of the letter "I".</source>
          <target state="translated">下列範例會比較三個字母的版本"I"。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</source>
          <target state="translated">文化特性、 是否忽略大小寫，以及是否執行序數比較的選擇會影響結果。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see cref="T:System.StringComparison" /&gt;</ph> is not supported.</source>
          <target state="translated">不支援 <ph id="ph1">&lt;see cref="T:System.StringComparison" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">字元集包含可忽略的字元。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph>方法執行區分文化特性的比較時不會考慮這類字元。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">若要識別可忽略的字元在比較中，提供的值<ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph>或<ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>如<ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The first string to compare.</source>
          <target state="translated">要比較的第一個字串。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The second string to compare.</source>
          <target state="translated">要比較的第二個字串。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示在比較時忽略大小寫，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific comparison information.</source>
          <target state="translated">物件，提供文化特性相關的比較資訊。</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">比較兩個指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件，忽略或區分兩者的大小寫，並使用特定文化特性資訊來影響比較，然後傳回一個整數，表示兩者在排序順序中的相對位置。</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>在排序次序中，<ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 會排在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 之前。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 出現在排序次序中的位置和 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 相同。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>在排序次序中，<ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 會排在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 之後。</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">比較會使用<ph id="ph1">`culture`</ph>參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">例如，某些字元的組合視為單一字元，或以特定方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元或請依照它。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">使用字組的排序規則來進行比較。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">一或兩個比較元可以是<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">當探索到的不等比較或這兩個字串都比較之後，則會結束比較。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，然後其餘字元的字串被視為較大。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">傳回值是執行的最後一個比對的結果。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">比較路徑名稱為"file"使用序數比較。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">若要這樣做的正確程式碼如下所示：</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example demonstrates how culture can affect a comparison.</source>
          <target state="translated">下列範例示範文化特性如何影響比較。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>In Czech - Czech Republic culture, "ch" is a single character that is greater than "d".</source>
          <target state="translated">捷克文-捷克共和國文化特性，在"ch"會是單一字元，大於"d"。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>However, in English - United States culture, "ch" consists of two characters, and "c" is less than "d".</source>
          <target state="translated">不過，英文-美國文化特性"ch 」 包含兩個字元，而且"c"小於"d"。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">字元集包含可忽略的字元。</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph>方法執行區分文化特性的比較時不會考慮這類字元。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) using the invariant culture indicates that the two strings are equivalent.</source>
          <target state="translated">例如，如果執行下列程式碼<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，「 動物 」 與 「 Ani 郵件 」 （使用選擇性連字號或 U + 00AD） 的不區分大小寫比較使用不變的文化特性會指出兩個字串相等。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method and supply a value of either <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">若要識別可忽略的字元字串比較中，呼叫<ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph>方法並提供值的其中一個<ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph>或<ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph>如<ph id="ph4">&lt;paramref name="options" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The first string to compare.</source>
          <target state="translated">要比較的第一個字串。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The second string to compare.</source>
          <target state="translated">要比較的第二個字串。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The culture that supplies culture-specific comparison information.</source>
          <target state="translated">提供特定文化特性之比較資訊的文化特性。</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Options to use when performing the comparison (such as ignoring case or symbols).</source>
          <target state="translated">執行比較時要使用的選項 (例如忽略大小寫或符號)。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</source>
          <target state="translated">比較兩個指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件，使用指定的比較選項及特定文化特性資訊影響比較，然後傳回整數，這個整數表示這兩個字串在排序次序中彼此的關聯性。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>A 32-bit signed integer that indicates the lexical relationship between <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> and <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>, as shown in the following table</source>
          <target state="translated">32 位元帶正負號的整數，這個整數表示 <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> 之間的語彙關係，如下表所示。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>在排序次序中，<ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 會排在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 之前。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 出現在排序次序中的位置和 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 相同。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>在排序次序中，<ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 會排在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 之後。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</source>
          <target state="translated">比較會使用<ph id="ph1">`culture`</ph>參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">例如，某些字元的組合視為單一字元、 大寫和小寫字元進行比較以特定的方式，可以指定特定文化特性或字元的排序次序取決於字元，與其前面或後面。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method is designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph>方法主要針對用於排序或依字母順序排列作業。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</source>
          <target state="translated">此外，它不應該使用方法呼叫的主要目的是要判斷兩個字串是否相等 （也就是當方法呼叫的目的是要測試傳回值為零） 時。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">若要判斷兩個字串是否相等，請呼叫<ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison can be further specified by the <ph id="ph1">`options`</ph> parameter, which consists of one or more members of the <ph id="ph2">&lt;xref:System.Globalization.CompareOptions&gt;</ph> enumeration.</source>
          <target state="translated">比較可以進一步指定<ph id="ph1">`options`</ph>參數，其中包含一個或多個成員<ph id="ph2">&lt;xref:System.Globalization.CompareOptions&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> values have no effect.</source>
          <target state="translated">不過，因為此方法的目的是要進行區分文化特性的字串比較，<ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>值沒有任何作用。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Either or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">可以是任一個或兩個比較元<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>By definition, any string, including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, compares greater than a null reference, and two null references compare equal to each other.</source>
          <target state="translated">根據定義，任何字串，包括<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>，比較彼此相等的比較大於 null 參考，且兩個 null 參考。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">當探索到的不等比較或這兩個字串都比較之後，則會結束比較。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</source>
          <target state="translated">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，其餘字元的字串被視為較大。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The following example compares two strings in three different ways: using linguistic comparison for the en-US culture; using linguistic case-sensitive comparison for the en-US culture; and using an ordinal comparison.</source>
          <target state="translated">下列範例會比較兩個字串以三個不同的方式： 語言比較，會使用 EN-US 文化特性;會使用 EN-US 文化特性; 語言區分大小寫的比較並使用序數比較。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It illustrates how the three methods of comparison produce three different results.</source>
          <target state="translated">它會說明如何比較的三種方法會產生三個不同的結果。</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph>方法執行區分文化特性的比較時不會考慮這類字元。</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">若要識別可忽略的字元在比較中，提供的值<ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph>或<ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph>如<ph id="ph3">&lt;paramref name="options" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">要用於比較中的第一個字串。</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept> 中子字串的位置。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">要用於比較的第二個字串。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept> 中子字串的位置。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">要比較之子字串的字元數上限。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">比較兩個指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件子字串，並傳回一個整數，指出它們在排序順序中的相對位置。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>A 32-bit signed integer indicating the lexical relationship between the two comparands.</source>
          <target state="translated">32 位元帶正負號整數，指出兩比較元的語彙關係。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 中的子字串的排序次序在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 中的子字串之前。</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>子字串出現在排序次序中的相同位置，或 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 為零。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 中的子字串的排序次序在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 中的子字串之後。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">要比較之子字串開始<ph id="ph1">`strA`</ph>在<ph id="ph2">`indexA`</ph>和<ph id="ph3">`strB`</ph>在<ph id="ph4">`indexB`</ph>。</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero.</source>
          <target state="translated">同時<ph id="ph1">`indexA`</ph>和<ph id="ph2">`indexB`</ph>都是以零為起始，也就是中的第一個字元<ph id="ph3">`strA`</ph>和<ph id="ph4">`strB`</ph>位在位置零。</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">第一個子字串的長度等於長度<ph id="ph1">`strA`</ph>減去<ph id="ph2">`indexA`</ph>再加 1。</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">第二個的子字串長度的長度等於<ph id="ph1">`strB`</ph>減去<ph id="ph2">`indexB`</ph>再加 1。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">要比較的字元數為較小的兩個子字串的長度和<ph id="ph1">`length`</ph>。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated"><ph id="ph1">`indexA`</ph>， <ph id="ph2">`indexB`</ph>，和<ph id="ph3">`length`</ph>參數必須是非負值。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">例如，某些字元的組合視為單一字元，或以特定方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元或請依照它。</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">使用字組的排序規則來進行比較。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">當比較字串時，您應該呼叫<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph>方法，會要求您明確指定此方法會使用的字串比較的類型。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>使用字串的最佳做法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">一或兩個比較元可以是<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">當探索到的不等比較，或兩個子字串有相較，則會結束比較。</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，然後其餘字元的字串被視為較大。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">傳回值是執行的最後一個比對的結果。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">比較路徑名稱為"file"使用序數比較。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">若要這樣做的正確程式碼如下所示：</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The following example compares two substrings.</source>
          <target state="translated">下列範例會比較這兩個子字串。</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> 大於 <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> 大於 <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>、<ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 是負數。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，且 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 大於零。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">字元集包含可忽略的字元。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /&gt;</ph>方法在執行語言或區分文化特性的比較時不會考慮這些字元。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>To recognize ignorable characters in your comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method and supply a value of <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">若要識別可忽略的字元在比較中，呼叫<ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph>方法提供的值<ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph>或<ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph>如<ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">要用於比較中的第一個字串。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept> 中子字串的位置。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">要用於比較的第二個字串。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept> 中子字串的位置。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">要比較之子字串的字元數上限。</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示在比較時忽略大小寫，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">比較兩個指定之 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的子字串，忽略或區分兩者的大小寫，並傳回一個整數，表示兩者在排序順序中的相對位置。</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 中的子字串的排序次序在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 中的子字串之前。</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>子字串出現在排序次序中的相同位置，或 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 為零。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 中的子字串的排序次序在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 中的子字串之後。</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph>, and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">要比較之子字串開始<ph id="ph1">`strA`</ph>在<ph id="ph2">`indexA`</ph>，然後在<ph id="ph3">`strB`</ph>在<ph id="ph4">`indexB`</ph>。</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero.</source>
          <target state="translated">同時<ph id="ph1">`indexA`</ph>和<ph id="ph2">`indexB`</ph>都是以零為起始，也就是中的第一個字元<ph id="ph3">`strA`</ph>和<ph id="ph4">`strB`</ph>位在位置零。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">第一個子字串的長度等於長度<ph id="ph1">`strA`</ph>減去<ph id="ph2">`indexA`</ph>再加 1。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">第二個的子字串長度的長度等於<ph id="ph1">`strB`</ph>減去<ph id="ph2">`indexB`</ph>再加 1。</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">要比較的字元數為較小的兩個子字串的長度和<ph id="ph1">`length`</ph>。</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated"><ph id="ph1">`indexA`</ph>， <ph id="ph2">`indexB`</ph>，和<ph id="ph3">`length`</ph>參數必須是非負值。</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">例如，某些字元的組合視為單一字元，或以特定方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元或請依照它。</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">使用字組的排序規則來進行比較。</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">當比較字串時，您應該呼叫<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph>方法，會要求您明確指定此方法會使用的字串比較的類型。</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>使用字串的最佳做法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">一或兩個比較元可以是<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">當探索到的不等比較，或兩個子字串有相較，則會結束比較。</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，然後其餘字元的字串被視為較大。</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">傳回值是執行的最後一個比對的結果。</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The path name needs to be compared in an invariant manner.</source>
          <target state="translated">路徑名稱必須以而異的方式進行比較。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The correct code to do this is as follows.</source>
          <target state="translated">若要這樣做的正確程式碼如下所示。</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The following example performs two comparisons of two substrings that only differ in case.</source>
          <target state="translated">下列範例案例中執行兩個只有一個地方不同的子字串的兩個的比較。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The first comparison ignores case and the second comparison considers case.</source>
          <target state="translated">第一個比較會忽略大小寫，第二個比較會考量大小寫。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> 大於 <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> 大於 <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>、<ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 是負數。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Either <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，且 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 大於零。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">字元集包含可忽略的字元。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /&gt;</ph>方法在執行語言或區分文化特性的比較時不會考慮這些字元。</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>To recognize ignorable characters in your comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method and supply a value of <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">若要識別可忽略的字元在比較中，呼叫<ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph>方法提供的值<ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph>或<ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph>如<ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">要用於比較中的第一個字串。</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept> 中子字串的位置。</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">要用於比較的第二個字串。</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept> 中子字串的位置。</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">要比較之子字串的字元數上限。</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules to use in the comparison.</source>
          <target state="translated">其中一個列舉值，指定要用於比較的規則。</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">使用指定的規則比較兩個指定之 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的子字串，並傳回一個整數，表示兩者在排序順序中的相對位置。</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 中的子字串的排序次序在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 中的子字串之前。</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or the <ph id="ph3">&lt;paramref name="length" /&gt;</ph> parameter is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>子字串出現在排序次序中的相同位置，或 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 參數為零。</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follllows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 中的子字串的排序次序在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 中的子字串之後。</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">要比較之子字串開始<ph id="ph1">`strA`</ph>在<ph id="ph2">`indexA`</ph>和<ph id="ph3">`strB`</ph>在<ph id="ph4">`indexB`</ph>。</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero, not position one.</source>
          <target state="translated">同時<ph id="ph1">`indexA`</ph>和<ph id="ph2">`indexB`</ph>都是以零為起始，也就是中的第一個字元<ph id="ph3">`strA`</ph>和<ph id="ph4">`strB`</ph>是於零，並放在其中一個。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">第一個子字串的長度等於長度<ph id="ph1">`strA`</ph>減去<ph id="ph2">`indexA`</ph>再加 1。</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">第二個的子字串長度的長度等於<ph id="ph1">`strB`</ph>減去<ph id="ph2">`indexB`</ph>再加 1。</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">要比較的字元數為較小的兩個子字串的長度和<ph id="ph1">`length`</ph>。</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated"><ph id="ph1">`indexA`</ph>， <ph id="ph2">`indexB`</ph>，和<ph id="ph3">`length`</ph>參數必須是非負值。</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph>參數會指出是否比較應該使用的目前或而異的文化特性、 接受或忽略大小寫的比較元，或使用 word （區分文化特性） 或序數 （不區分文化特性） 的排序規則。</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">一或兩個比較元可以是<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">當探索到的不等比較，或兩個子字串有相較，則會結束比較。</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</source>
          <target state="translated">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，其餘字元的字串被視為較大。</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">傳回值是執行的最後一個比對的結果。</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">比較路徑名稱為"file"使用序數比較。</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">若要這樣做的正確程式碼如下所示：</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The following example compares two substrings.</source>
          <target state="translated">下列範例會比較這兩個子字串。</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> 大於 <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> 大於 <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>、<ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 是負數。</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Either <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，且 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 大於零。</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">字元集包含可忽略的字元。</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph>方法在執行語言或區分文化特性的比較時不會考慮這些字元。</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">若要識別可忽略的字元在比較中，提供的值<ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph>或<ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>如<ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">要用於比較中的第一個字串。</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept> 中子字串的位置。</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">要用於比較的第二個字串。</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept> 中子字串的位置。</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">要比較之子字串的字元數上限。</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示在比較時忽略大小寫，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific comparison information.</source>
          <target state="translated">物件，提供文化特性相關的比較資訊。</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">比較兩個指定之 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的子字串，忽略或區分兩者的大小寫，並使用文化特性資訊來影響比較，然後傳回一個整數，表示兩者在排序順序中的相對位置。</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>An integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">整數，表示兩個比較元 (Comparand) 之間的語彙關係。</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 中的子字串的排序次序在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 中的子字串之前。</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>子字串出現在排序次序中的相同位置，或 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 為零。</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 中的子字串的排序次序在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 中的子字串之後。</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph>, and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">要比較之子字串開始<ph id="ph1">`strA`</ph>在<ph id="ph2">`indexA`</ph>，然後在<ph id="ph3">`strB`</ph>在<ph id="ph4">`indexB`</ph>。</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero, not position one.</source>
          <target state="translated">同時<ph id="ph1">`indexA`</ph>和<ph id="ph2">`indexB`</ph>都是以零為起始，也就是中的第一個字元<ph id="ph3">`strA`</ph>和<ph id="ph4">`strB`</ph>是於零，並放在其中一個。</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">第一個子字串的長度等於長度<ph id="ph1">`strA`</ph>減去<ph id="ph2">`indexA`</ph>再加 1。</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">第二個的子字串長度的長度等於<ph id="ph1">`strB`</ph>減去<ph id="ph2">`indexB`</ph>再加 1。</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">要比較的字元數為較小的兩個子字串的長度和<ph id="ph1">`length`</ph>。</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated"><ph id="ph1">`indexA`</ph>， <ph id="ph2">`indexB`</ph>，和<ph id="ph3">`length`</ph>參數必須是非負值。</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">比較會使用<ph id="ph1">`culture`</ph>參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">例如，某些字元的組合視為單一字元，或以特定方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元或請依照它。</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">使用字組的排序規則來進行比較。</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">一或兩個比較元可以是<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">當探索到的不等比較，或兩個子字串有相較，則會結束比較。</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，然後其餘字元的字串被視為較大。</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">傳回值是執行的最後一個比對的結果。</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">比較路徑名稱為"file"使用序數比較。</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">若要這樣做的正確程式碼如下所示：</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example compares two substrings using different cultures and ignoring the case of the substrings.</source>
          <target state="translated">下列範例會比較這兩個子字串使用不同的文化特性並忽略大小寫的子字串。</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The choice of culture affects how the letter "I" is compared.</source>
          <target state="translated">文化特性的選擇會影響如何的字母"I"都是比較。</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> 大於 <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> 大於 <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>、<ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 是負數。</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Either <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，且 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 大於零。</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">字元集包含可忽略的字元。</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph>方法在執行語言或區分文化特性的比較時不會考慮這些字元。</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>To recognize ignorable characters in your comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method and supply a value of <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">若要識別可忽略的字元在比較中，呼叫<ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph>方法提供的值<ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph>或<ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph>如<ph id="ph4">&lt;paramref name="options" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">要用於比較中的第一個字串。</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The starting position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept> 中子字串的開始位置。</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">要用於比較的第二個字串。</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The starting position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept> 中子字串的開始位置。</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">要比較之子字串的字元數上限。</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>An object that supplies culture-specific comparison information.</source>
          <target state="translated">物件，提供文化特性相關的比較資訊。</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Options to use when performing the comparison (such as ignoring case or symbols).</source>
          <target state="translated">執行比較時要使用的選項 (例如忽略大小寫或符號)。</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</source>
          <target state="translated">比較兩個指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的子字串，使用指定的比較選項及特定文化特性資訊影響比較，然後傳回整數，這個整數表示這兩個子字串在排序次序中彼此的關聯性。</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>An integer that indicates the lexical relationship between the two substrings, as shown in the following table.</source>
          <target state="translated">整數，這個整數表示兩個子字串之間的語彙關係，如下表所示。</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 中的子字串的排序次序在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 中的子字串之前。</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>子字串出現在排序次序中的相同位置，或 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 為零。</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 中的子字串的排序次序在 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 中的子字串之後。</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at position <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at position <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">要比較之子字串開始<ph id="ph1">`strA`</ph>位置<ph id="ph2">`indexA`</ph>和<ph id="ph3">`strB`</ph>位置<ph id="ph4">`indexB`</ph>。</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The length of the first substring is the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph>.</source>
          <target state="translated">第一個子字串的長度是長度<ph id="ph1">`strA`</ph>減去<ph id="ph2">`indexA`</ph>。</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The length of the second substring is the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph>.</source>
          <target state="translated">第二個的子字串的長度是長度<ph id="ph1">`strB`</ph>減去<ph id="ph2">`indexB`</ph>。</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">要比較的字元數為較小的兩個子字串的長度和<ph id="ph1">`length`</ph>。</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated"><ph id="ph1">`indexA`</ph>， <ph id="ph2">`indexB`</ph>，和<ph id="ph3">`length`</ph>參數必須是非負值。</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</source>
          <target state="translated">比較會使用<ph id="ph1">`culture`</ph>參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">例如，某些字元的組合視為單一字元、 大寫和小寫字元進行比較以特定的方式，可以指定特定文化特性或字元的排序次序取決於字元，與其前面或後面。</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method is designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph>方法主要針對用於排序或依字母順序排列作業。</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</source>
          <target state="translated">此外，它不應該使用方法呼叫的主要目的是要判斷這兩個子字串是否相等 （也就是當方法呼叫的目的是要測試傳回值為零） 時。</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">若要判斷兩個字串是否相等，請呼叫<ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>One or both of <ph id="ph1">`strA`</ph> and <ph id="ph2">`strB`</ph> can be <ph id="ph3">`null`</ph>.</source>
          <target state="translated">一或兩個<ph id="ph1">`strA`</ph>和<ph id="ph2">`strB`</ph>可以<ph id="ph3">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>By definition, any string, including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, compares greater than a null reference, and two null references compare equal to each other.</source>
          <target state="translated">根據定義，任何字串，包括<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>，比較彼此相等的比較大於 null 參考，且兩個 null 參考。</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison can be further specified by the <ph id="ph1">`options`</ph> parameter, which consists of one or more members of the <ph id="ph2">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">比較可以進一步指定<ph id="ph1">`options`</ph>參數，其中包含一個或多個成員<ph id="ph2">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> values have no effect.</source>
          <target state="translated">不過，因為此方法的目的是要進行區分文化特性的字串比較，<ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>值沒有任何作用。</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">當探索到的不等比較，或兩個子字串有相較，則會結束比較。</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</source>
          <target state="translated">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，其餘字元的字串被視為較大。</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">傳回值是執行的最後一個比對的結果。</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method to compare the last names of two people.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph>方法來比較兩個人員的姓氏。</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It then lists them in alphabetical order.</source>
          <target state="translated">它接著會列出它們依字母順序。</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> 大於 <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> 大於 <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>、<ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 是負數。</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Either <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，且 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 大於零。</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">字元集包含可忽略的字元。</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph>方法在執行語言或區分文化特性的比較時不會考慮這些字元。</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">若要識別可忽略的字元在比較中，提供的值<ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph>或<ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph>如<ph id="ph3">&lt;paramref name="options" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Compares two <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> objects in each string.</source>
          <target state="translated">藉由評估每個字串中對應的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件之數字值，比較兩個 <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>The first string to compare.</source>
          <target state="translated">要比較的第一個字串。</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>The second string to compare.</source>
          <target state="translated">要比較的第二個字串。</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> objects in each string.</source>
          <target state="translated">藉由評估每個字串中對應的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件之數字值，比較兩個指定 <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>An integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">整數，表示兩個比較元 (Comparand) 之間的語彙關係。</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is less than <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 小於 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> and <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> are equal.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 和 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 相等。</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is greater than <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 大於 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>This method performs a case-sensitive comparison using ordinal sort rules.</source>
          <target state="translated">這個方法會執行區分大小寫比較，使用序數排序規則。</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>To perform a case-insensitive comparison using ordinal sort rules, call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method with the <ph id="ph2">`comparisonType`</ph> argument set to <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">若要執行不區分大小寫比較，使用序數排序規則，呼叫<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph>方法<ph id="ph2">`comparisonType`</ph>引數設定為<ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>Because <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> is a static method, <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> can be <ph id="ph4">`null`</ph>.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph>是靜態方法，<ph id="ph2">`strA`</ph>和<ph id="ph3">`strB`</ph>可以<ph id="ph4">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>If both values are <ph id="ph1">`null`</ph>, the method returns 0 (zero), which indicates that <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> are equal.</source>
          <target state="translated">如果這兩個值<ph id="ph1">`null`</ph>，方法會傳回 0 （零），這表示<ph id="ph2">`strA`</ph>和<ph id="ph3">`strB`</ph>相等。</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>If only one of the values is <ph id="ph1">`null`</ph>, the method considers the non-null value to be greater.</source>
          <target state="translated">如果只有其中一個值為<ph id="ph1">`null`</ph>，方法會考慮較大的非 null 值。</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>The following example performs and ordinal comparison of two strings that only differ in case.</source>
          <target state="translated">下列範例會執行並序數比較兩個字串只有大小寫不同。</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">要用於比較中的第一個字串。</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The starting index of the substring in <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept> 中子字串的起始索引。</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">要用於比較的第二個字串。</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The starting index of the substring in <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept> 中子字串的起始索引。</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">要比較之子字串的字元數上限。</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> objects in each substring.</source>
          <target state="translated">藉由評估每個子字串中對應的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件之數字值，比較兩個指定的 <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> 物件之子字串。</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is less than the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 中的子字串小於 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 中的子字串。</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings are equal, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>子字串相等，或者 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 為零。</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is greater than the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> 中的子字串大於 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> 中的子字串。</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated"><ph id="ph1">`indexA`</ph>， <ph id="ph2">`indexB`</ph>，和<ph id="ph3">`length`</ph>參數必須是非負值。</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The number of characters compared is the lesser of the length of <ph id="ph1">`strA`</ph> less <ph id="ph2">`indexA`</ph>, the length of <ph id="ph3">`strB`</ph> less <ph id="ph4">`indexB`</ph>, and <ph id="ph5">`length`</ph>.</source>
          <target state="translated">比較的字元數為較小的長度<ph id="ph1">`strA`</ph>較少<ph id="ph2">`indexA`</ph>，長度<ph id="ph3">`strB`</ph>較少<ph id="ph4">`indexB`</ph>，和<ph id="ph5">`length`</ph>。</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>This method performs a case-sensitive comparison using ordinal sort rules.</source>
          <target state="translated">這個方法會執行區分大小寫比較，使用序數排序規則。</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>To perform a case-insensitive comparison using ordinal sort rules, call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method with the <ph id="ph2">`comparisonType`</ph> argument set to <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">若要執行不區分大小寫比較，使用序數排序規則，呼叫<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph>方法<ph id="ph2">`comparisonType`</ph>引數設定為<ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Because <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> is a static method, <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> can be <ph id="ph4">`null`</ph>.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph>是靜態方法，<ph id="ph2">`strA`</ph>和<ph id="ph3">`strB`</ph>可以<ph id="ph4">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>If both values are <ph id="ph1">`null`</ph>, the method returns 0 (zero), which indicates that <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> are equal.</source>
          <target state="translated">如果這兩個值<ph id="ph1">`null`</ph>，方法會傳回 0 （零），這表示<ph id="ph2">`strA`</ph>和<ph id="ph3">`strB`</ph>相等。</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>If only one of the values is <ph id="ph1">`null`</ph>, the method considers the non-null value to be greater.</source>
          <target state="translated">如果只有其中一個值為<ph id="ph1">`null`</ph>，方法會考慮較大的非 null 值。</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>This following example demonstrates that <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> use different sort orders.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph>使用不同排序順序。</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph4">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，<ph id="ph3">&lt;paramref name="indexA" /&gt;</ph> 大於 <ph id="ph4">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，<ph id="ph3">&lt;paramref name="indexB" /&gt;</ph> 大於 <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>、<ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 是負數。</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Compares this instance with a specified object or <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and returns an integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified object or <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">比較這個執行個體與指定的物件或 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>，並傳回一個整數，指出這個執行個體在排序次序中，位於指定物件或 <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> 之前、之後或相同位置。</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Both overloads of the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method perform culture-sensitive and case-sensitive comparison.</source>
          <target state="translated">這兩個多載<ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph>方法執行區分文化特性和區分大小寫的比較。</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You cannot use this method to perform culture-insensitive or ordinal comparisons.</source>
          <target state="translated">您無法使用這個方法來執行不區分文化特性或序數比較。</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For code clarity, we recommend that you avoid the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method and call the <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> method instead.</source>
          <target state="translated">程式碼的清楚起見，我們建議您避免<ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph>方法，並呼叫<ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph>方法改為。</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>An object that evaluates to a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">評估為 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的物件。</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>Compares this instance with a specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">比較這個執行個體與指定的 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>，並且指出這個執行個體在排序次序中，位於所指定 <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> 之前、之後或相同位置。</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">32 位元帶正負號的整數，指出這個執行個體在排序次序中，位於 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 參數之前、之後或相同位置。</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance precedes <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>這個執行個體位於 <ph id="ph3">&lt;paramref name="value" /&gt;</ph> 之前。</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance has the same position in the sort order as <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>這個執行個體在排序次序中的位置與 <ph id="ph3">&lt;paramref name="value" /&gt;</ph> 相同。</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance follows <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>這個執行個體位於 <ph id="ph3">&lt;paramref name="value" /&gt;</ph> 之後。</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">`value`</ph> must be a <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">`value`</ph> 必須是<ph id="ph2">&lt;xref:System.String&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method was designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph>方法依設計主要是用於排序或依字母順序排列作業。</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</source>
          <target state="translated">此外，它不應該使用當方法呼叫的主要目的是要判斷兩個字串是否相等。</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">若要判斷兩個字串是否相等，請呼叫<ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>For more information about the behavior of this method, see the Remarks section of the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">這個方法的行為的詳細資訊，請參閱的 &lt; 備註 &gt; 一節<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.Object&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>Because it attempts to compare a <ph id="ph1">&lt;xref:System.String&gt;</ph> instance to a <ph id="ph2">`TestClass`</ph> object, the method throws an <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">因為它嘗試比較<ph id="ph1">&lt;xref:System.String&gt;</ph>執行個體<ph id="ph2">`TestClass`</ph>物件，方法會擲回<ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">字元集包含可忽略的字元。</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.Object)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.Object)" /&gt;</ph>方法執行區分文化特性的比較時不會考慮這類字元。</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">例如，如果執行下列程式碼<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，"動物 」 與 「 ani 郵件 」 （使用選擇性連字號或 U + 00AD） 的比較，表示兩個字串相等。</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> method.</source>
          <target state="translated">若要識別可忽略的字元字串比較中，呼叫<ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>The string to compare with this instance.</source>
          <target state="translated">要和這個執行個體比較的字串。</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>Compares this instance with a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.</source>
          <target state="translated">比較這個執行個體與指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件，並且表示這個執行個體在排序次序中，位於所指定字串之前、之後或相同位置。</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <ph id="ph1">&lt;paramref name="strB" /&gt;</ph> parameter.</source>
          <target state="translated">32 位元帶正負號的整數，指出這個執行個體在排序次序中，位於 <ph id="ph1">&lt;paramref name="strB" /&gt;</ph> 參數之前、之後或相同位置。</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> 值</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>條件</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph>小於零</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance precedes <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>這個執行個體位於 <ph id="ph3">&lt;paramref name="strB" /&gt;</ph> 之前。</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 零</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance has the same position in the sort order as <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>這個執行個體在排序次序中的位置與 <ph id="ph3">&lt;paramref name="strB" /&gt;</ph> 相同。</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 大於零</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance follows <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph>這個執行個體位於 <ph id="ph3">&lt;paramref name="strB" /&gt;</ph> 之後。</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method was designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph>方法依設計主要是用於排序或依字母順序排列作業。</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</source>
          <target state="translated">此外，它不應該使用當方法呼叫的主要目的是要判斷兩個字串是否相等。</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">若要判斷兩個字串是否相等，請呼叫<ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>For more information about the behavior of this method, see the Remarks section of the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">這個方法的行為的詳細資訊，請參閱的 &lt; 備註 &gt; 一節<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>This method implements the <ph id="ph1">&lt;xref:System.IComparable%601?displayProperty=nameWithType&gt;</ph> interface and performs slightly better than the <ph id="ph2">&lt;xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, because it does not have to determine whether the <ph id="ph3">`strB`</ph> argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <ph id="ph4">&lt;xref:System.Object&gt;</ph> to a <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">這個方法會實作<ph id="ph1">&lt;xref:System.IComparable%601?displayProperty=nameWithType&gt;</ph>介面並執行稍微優於<ph id="ph2">&lt;xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法，因為它沒有判斷是否<ph id="ph3">`strB`</ph>引數是可變動的值型別，必須為 boxed 而且不需要轉換其從參數<ph id="ph4">&lt;xref:System.Object&gt;</ph>至<ph id="ph5">&lt;xref:System.String&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method to compare the current string instance with another string.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph>方法來比較目前的字串執行個體，以另一個字串。</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The following example demonstrates generic and non-generic versions of the CompareTo method for several value and reference types.</source>
          <target state="translated">下列範例會示範 CompareTo 方法的數個值和參考類型的泛型和非泛型版本。</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">字元集包含可忽略的字元。</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.String)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.String)" /&gt;</ph>方法執行區分文化特性的比較時不會考慮這類字元。</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">例如，如果執行下列程式碼<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，"動物 」 與 「 ani 郵件 」 （使用選擇性連字號或 U + 00AD） 的比較，表示兩個字串相等。</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> method.</source>
          <target state="translated">若要識別可忽略的字元字串比較中，呼叫<ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Concatenates one or more instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, or the <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> representations of the values of one or more instances of <ph id="ph3">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">串連一或多個 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 執行個體，或者一或多個 <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> 執行個體值的 <ph id="ph3">&lt;see cref="T:System.Object" /&gt;</ph> 表示。</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>A collection object that implements <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> and whose generic type argument is <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">集合物件，這個物件實作 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>，且其泛型類型引數為 <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>Concatenates the members of a constructed <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> collection of type <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">串連類型 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> 之已建構的 <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> 集合的成員。</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The concatenated strings in <ph id="ph1">&lt;paramref name="values" /&gt;</ph>, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph3">&lt;paramref name="values" /&gt;</ph> is an empty <ph id="ph4">&lt;see langword="IEnumerable(Of String)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> 中的串連字串，或如果 <ph id="ph3">&lt;paramref name="values" /&gt;</ph> 是空白的 <ph id="ph4">&lt;see langword="IEnumerable(Of String)" /&gt;</ph>則為 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
          <target state="translated">方法會串連中的每個物件<ph id="ph1">`values`</ph>; 它不會新增任何分隔符號。</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>To specify a delimiter between each member of <ph id="ph1">`values`</ph>, call the <ph id="ph2">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method.</source>
          <target state="translated">若要指定的每個成員之間的分隔符號<ph id="ph1">`values`</ph>，呼叫<ph id="ph2">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null element in <ph id="ph2">`values`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>字串來取代任何 null 元素<ph id="ph2">`values`</ph>。</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">`values`</ph> is an empty <ph id="ph2">`IEnumerable(Of String)`</ph>, the method returns <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`values`</ph>是空白<ph id="ph2">`IEnumerable(Of String)`</ph>，方法會傳回<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph> exception.</source>
          <target state="translated">如果<ph id="ph1">`values`</ph>是<ph id="ph2">`null`</ph>，方法會擲回<ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">`IEnumerable(Of String)`</ph> collection without first converting the elements to a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> 是便利的方法，可讓您在串連每個項目<ph id="ph2">`IEnumerable(Of String)`</ph>集合，而不先將項目轉換成字串陣列。</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions.</source>
          <target state="translated">它特別適合使用 Language-Integrated Query (LINQ) 查詢運算式。</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example passes a <ph id="ph1">`List(Of String)`</ph> object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</source>
          <target state="translated">下列範例會傳遞<ph id="ph1">`List(Of String)`</ph>物件，其中包含英文字母給 lambda 運算式會選取等於或大於特定的字母 （即，在範例中，"M"） 的字母大寫或小寫字母。</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The <ph id="ph1">`IEnumerable(Of String)`</ph> collection that is returned by the <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> method is passed to the <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method to display the result as a single string.</source>
          <target state="translated"><ph id="ph1">`IEnumerable(Of String)`</ph>所傳回的集合<ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph>方法傳遞至<ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph>方法來顯示以單一字串結果。</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>It assigns the result to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object of type <ph id="ph2">&lt;xref:System.String&gt;</ph>, which it then passes to the <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method.</source>
          <target state="translated">它會將結果指派<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>型別的物件<ph id="ph2">&lt;xref:System.String&gt;</ph>，這會接著傳遞給<ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object)">
          <source>The object to represent, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">要表示的物件，或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object)">
          <source>Creates the string  representation of a specified object.</source>
          <target state="translated">建立指定之物件的字串表示。</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object)">
          <source>The string representation of the value of <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph>, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph3">&lt;paramref name="arg0" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arg0" /&gt;</ph> 值的字串表示；如果 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> 為 <ph id="ph3">&lt;paramref name="arg0" /&gt;</ph>，則為 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%29&gt;</ph> method represents <ph id="ph2">`arg0`</ph> as a string by calling its parameterless <ph id="ph3">`ToString`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%28System.Object%29&gt;</ph>方法代表<ph id="ph2">`arg0`</ph>藉由呼叫其無參數的字串為<ph id="ph3">`ToString`</ph>方法。</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>An object array that contains the elements to concatenate.</source>
          <target state="translated">包含要串連之項目的物件陣列。</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>Concatenates the string representations of the elements in a specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> array.</source>
          <target state="translated">串連指定之 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> 陣列中項目的字串表示法。</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>The concatenated string representations of the values of the elements in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> 中之項目值的串連字串表示。</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>The method concatenates each object in <ph id="ph1">`args`</ph> by calling the parameterless <ph id="ph2">`ToString`</ph> method of that object; it does not add any delimiters.</source>
          <target state="translated">方法會串連中的每個物件<ph id="ph1">`args`</ph>藉由呼叫無參數<ph id="ph2">`ToString`</ph>方法，該物件; 它不會新增任何分隔符號。</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null object in the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> 用來在陣列中的任何 null 物件取代。</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Object&gt;</ph> array.</source>
          <target state="translated">下列範例示範如何使用<ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.Object&gt;</ph>陣列。</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>Out of memory.</source>
          <target state="translated">記憶體不足。</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>This method is not called by C++ code.</source>
          <target state="translated">由 c + + 程式碼，不會呼叫這個方法。</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>The C++ compiler resolves calls to <ph id="ph1">&lt;see cref="Overload:System.String.Concat" /&gt;</ph> that have four or more object parameters as a call to <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph>.</source>
          <target state="translated">C + + 編譯器會解析呼叫<ph id="ph1">&lt;see cref="Overload:System.String.Concat" /&gt;</ph>具有四個或多個物件的參數與呼叫<ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>An array of string instances.</source>
          <target state="translated">字串執行個體的陣列。</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>Concatenates the elements of a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> array.</source>
          <target state="translated">串連指定 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 陣列中的項目。</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>The concatenated elements of <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> 的串連項目。</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String[])">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
          <target state="translated">方法會串連中的每個物件<ph id="ph1">`values`</ph>; 它不會新增任何分隔符號。</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String[])">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null object in the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>字串來取代任何陣列中的 null 物件。</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String[])">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method with a <ph id="ph2">&lt;xref:System.String&gt;</ph> array.</source>
          <target state="translated">下列範例示範如何使用<ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.String&gt;</ph>陣列。</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>Out of memory.</source>
          <target state="translated">記憶體不足。</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The first object to concatenate.</source>
          <target state="translated">要串連的第一個物件。</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The second object to concatenate.</source>
          <target state="translated">要串連的第二個物件。</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>Concatenates the string representations of two specified objects.</source>
          <target state="translated">串連兩個指定之物件的字串表示。</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The concatenated string representations of the values of <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph> and <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arg0" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph> 之值的串連字串表示。</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The method concatenates <ph id="ph1">`arg0`</ph> and <ph id="ph2">`arg1`</ph> by calling the parameterless <ph id="ph3">`ToString`</ph> method of <ph id="ph4">`arg0`</ph> and <ph id="ph5">`arg1`</ph>; it does not add any delimiters.</source>
          <target state="translated">方法會串連<ph id="ph1">`arg0`</ph>和<ph id="ph2">`arg1`</ph>藉由呼叫無參數<ph id="ph3">`ToString`</ph>方法<ph id="ph4">`arg0`</ph>和<ph id="ph5">`arg1`</ph>; 它不會新增任何分隔符號。</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> 會使用來取代任何 null 引數。</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").</source>
          <target state="translated">如果是引數的陣列參考，方法會串連字串，表示該陣列，而不是其成員 (例如，"System.String[]")。</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>The first string to concatenate.</source>
          <target state="translated">要串連的第一個字串。</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>The second string to concatenate.</source>
          <target state="translated">要串連的第二個字串。</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>Concatenates two specified instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">串連 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的兩個指定執行個體。</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>The concatenation of <ph id="ph1">&lt;paramref name="str0" /&gt;</ph> and <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str0" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="str1" /&gt;</ph> 的串連。</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>The method concatenates <ph id="ph1">`str0`</ph> and <ph id="ph2">`str1`</ph>; it does not add any delimiters.</source>
          <target state="translated">方法會串連<ph id="ph1">`str0`</ph>和<ph id="ph2">`str1`</ph>; 它不會新增任何分隔符號。</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
          <target state="translated">您可以也使用您語言的字串串連運算子，例如<ph id="ph1">`+`</ph>在 C# 中，或<ph id="ph2">`&amp;`</ph>和<ph id="ph3">`+`</ph>在 Visual Basic 中)</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>, to concatenate strings.</source>
          <target state="translated">將字串串連。</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>字串來取代任何 null 引數。</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>The following example concatenates a person's first, middle, and last name.</source>
          <target state="translated">下列範例會串連個人的名字、 中間名和姓氏的名稱。</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The first object to concatenate.</source>
          <target state="translated">要串連的第一個物件。</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The second object to concatenate.</source>
          <target state="translated">要串連的第二個物件。</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The third object to concatenate.</source>
          <target state="translated">要串連的第三個物件。</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>Concatenates the string representations of three specified objects.</source>
          <target state="translated">串連三個指定之物件的字串表示。</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The concatenated string representations of the values of <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="arg2" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arg0" /&gt;</ph>、<ph id="ph2">&lt;paramref name="arg1" /&gt;</ph> 和 <ph id="ph3">&lt;paramref name="arg2" /&gt;</ph> 之值的串連字串表示。</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The method concatenates <ph id="ph1">`arg0`</ph>, <ph id="ph2">`arg1`</ph>, and <ph id="ph3">`arg2`</ph> by calling the parameterless <ph id="ph4">`ToString`</ph> method of each object; it does not add any delimiters.</source>
          <target state="translated">方法會串連<ph id="ph1">`arg0`</ph>， <ph id="ph2">`arg1`</ph>，和<ph id="ph3">`arg2`</ph>藉由呼叫無參數<ph id="ph4">`ToString`</ph>方法的每個物件; 它不會新增任何分隔符號。</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> 會使用來取代任何 null 引數。</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The first string to concatenate.</source>
          <target state="translated">要串連的第一個字串。</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The second string to concatenate.</source>
          <target state="translated">要串連的第二個字串。</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The third string to concatenate.</source>
          <target state="translated">要串連的第三個字串。</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>Concatenates three specified instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">串連 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的三個指定執行個體。</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The concatenation of <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="str2" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str0" /&gt;</ph>、<ph id="ph2">&lt;paramref name="str1" /&gt;</ph> 和 <ph id="ph3">&lt;paramref name="str2" /&gt;</ph> 的串連。</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The method concatenates <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, and <ph id="ph3">`str2`</ph>; it does not add any delimiters.</source>
          <target state="translated">方法會串連<ph id="ph1">`str0`</ph>， <ph id="ph2">`str1`</ph>，和<ph id="ph3">`str2`</ph>; 它不會新增任何分隔符號。</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
          <target state="translated">您可以也使用您語言的字串串連運算子，例如<ph id="ph1">`+`</ph>在 C# 中，或<ph id="ph2">`&amp;`</ph>和<ph id="ph3">`+`</ph>在 Visual Basic 中)</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>, to concatenate strings.</source>
          <target state="translated">將字串串連。</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>字串來取代任何 null 引數。</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method to concatenate three strings and displays the result.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph>方法來串連三個字串，並顯示結果。</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The first object to concatenate.</source>
          <target state="translated">要串連的第一個物件。</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The second object to concatenate.</source>
          <target state="translated">要串連的第二個物件。</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The third object to concatenate.</source>
          <target state="translated">要串連的第三個物件。</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The fourth object to concatenate.</source>
          <target state="translated">要串連的第四個物件。</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</source>
          <target state="translated">串連四個指定的物件之字串表示和選擇性變數長度參數清單中所指定的任何物件。</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The concatenated string representation of each value in the parameter list.</source>
          <target state="translated">參數清單中每個值的已串連字串表示。</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">此應用程式開發介面不符合 CLS 標準。</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The CLS-compliant alternative is <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">符合 CLS 標準的替代項目為 <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The C# and Visual Basic compilers automatically resolve a call to this method as a call to <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">C# 和 Visual Basic 編譯器自動解決與呼叫此方法的呼叫<ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The method concatenates each object in the parameter list by calling its parameterless <ph id="ph1">`ToString`</ph> method; it does not add any delimiters.</source>
          <target state="translated">此方法透過呼叫其無參數串連參數清單中的每個物件<ph id="ph1">`ToString`</ph>方法; 它不會新增任何分隔符號。</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> 會使用來取代任何 null 引數。</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The last parameter of the  <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method is an optional comma-delimited list of one or more additional objects to concatenate.</source>
          <target state="translated">最後一個參數<ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph>方法是串連的一個或多個其他物件的選擇性逗號分隔清單。</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> method to concatenate a list of variable parameters.</source>
          <target state="translated">下列範例說明使用<ph id="ph1">&lt;xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph>来串連的變數參數清單的方法。</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>In this case, the method is called with nine parameters.</source>
          <target state="translated">在此情況下，方法被呼叫有 9 個參數。</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>This method is marked with the <ph id="ph1">&lt;see langword="vararg" /&gt;</ph> keyword, which means that it supports a variable number of parameters.</source>
          <target state="translated">這個方法會標示<ph id="ph1">&lt;see langword="vararg" /&gt;</ph>關鍵字，這表示它支援多個參數。</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The method can be called from Visual C++, but it cannot be called from C# or Visual Basic code.</source>
          <target state="translated">可以從 Visual c + + 中，呼叫此方法，但不能從 C# 或 Visual Basic 程式碼呼叫。</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The C# and Visual Basic compilers resolve calls to <ph id="ph1">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph> as calls to <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object[])" /&gt;</ph>.</source>
          <target state="translated">C# 和 Visual Basic 編譯器將呼叫解析為<ph id="ph1">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph>做為呼叫<ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The first string to concatenate.</source>
          <target state="translated">要串連的第一個字串。</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The second string to concatenate.</source>
          <target state="translated">要串連的第二個字串。</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The third string to concatenate.</source>
          <target state="translated">要串連的第三個字串。</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The fourth string to concatenate.</source>
          <target state="translated">要串連的第四個字串。</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>Concatenates four specified instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">串連 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的四個指定執行個體。</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The concatenation of <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>, <ph id="ph3">&lt;paramref name="str2" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="str3" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str0" /&gt;</ph>、<ph id="ph2">&lt;paramref name="str1" /&gt;</ph>、<ph id="ph3">&lt;paramref name="str2" /&gt;</ph> 和 <ph id="ph4">&lt;paramref name="str3" /&gt;</ph> 的串連。</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The method concatenates <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, <ph id="ph3">`str2`</ph>, and <ph id="ph4">`str3`</ph>; it does not add any delimiters.</source>
          <target state="translated">方法會串連<ph id="ph1">`str0`</ph>， <ph id="ph2">`str1`</ph>， <ph id="ph3">`str2`</ph>，和<ph id="ph4">`str3`</ph>; 它不會新增任何分隔符號。</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
          <target state="translated">您可以也使用您語言的字串串連運算子，例如<ph id="ph1">`+`</ph>在 C# 中，或<ph id="ph2">`&amp;`</ph>和<ph id="ph3">`+`</ph>在 Visual Basic 中)</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>, to concatenate strings.</source>
          <target state="translated">將字串串連。</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null object in the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>字串來取代任何陣列中的 null 物件。</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The following example defines an array of four-letter words and stores their individual letters to a string array in order to scramble them.</source>
          <target state="translated">下列範例定義的四個-字母的文字陣列，並將字串陣列，其個別字母儲存才能弄亂它們。</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29&gt;</ph> method to reassemble the scrambled words.</source>
          <target state="translated">然後它會呼叫<ph id="ph1">&lt;xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29&gt;</ph>方法來切割變碼的單字。</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The type of the members of <bpt id="p1">&lt;c&gt;</bpt>values<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">之成員的型別<bpt id="p1">&lt;c&gt;</bpt>值<ept id="p1">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>A collection object that implements the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> interface.</source>
          <target state="translated">集合物件，這個物件實作 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> 介面。</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>Concatenates the members of an <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> implementation.</source>
          <target state="translated">串連 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> 實作的成員。</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The concatenated members in <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> 中的串連成員。</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
          <target state="translated">方法會串連中的每個物件<ph id="ph1">`values`</ph>; 它不會新增任何分隔符號。</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>字串來取代任何 null 引數。</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection without first converting the elements to strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> 是便利的方法，可讓您在串連每個項目<ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>而不先將項目轉換為字串的集合。</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions, as the example illustrates.</source>
          <target state="translated">就非常有用使用 Language-Integrated Query (LINQ) 查詢運算式，如範例所示。</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The string representation of each object in the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection is derived by calling that object's <ph id="ph2">`ToString`</ph> method.</source>
          <target state="translated">在每個物件的字串表示<ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>集合藉由呼叫該物件衍生<ph id="ph2">`ToString`</ph>方法。</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The following example defines a very simple <ph id="ph1">`Animal`</ph> class that contains the name of an animal and the order to which it belongs.</source>
          <target state="translated">下列範例會定義非常簡單<ph id="ph1">`Animal`</ph>類別，其中包含代表動物以及其所屬的順序的名稱。</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>It then defines a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object to contain a number of <ph id="ph2">`Animal`</ph> objects.</source>
          <target state="translated">然後它會定義<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>物件包含的數字<ph id="ph2">`Animal`</ph>物件。</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> extension method is called to extract the <ph id="ph2">`Animal`</ph> objects whose <ph id="ph3">`Order`</ph> property equals "Rodent".</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph>擴充方法呼叫以擷取<ph id="ph2">`Animal`</ph>物件<ph id="ph3">`Order`</ph>屬性等於"齧齒動物"。</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The result is passed to the <ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> method and displayed to the console.</source>
          <target state="translated">結果會傳遞至<ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph>方法並顯示到主控台。</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source>The string to seek.</source>
          <target state="translated">要搜尋的字串。</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source>Returns a value indicating whether a specified substring occurs within this string.</source>
          <target state="translated">傳回值，這個值表示指定的子字串是否會出現在這個字串內。</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter occurs within this string, or if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is the empty string (""); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 參數出現在這個字串內，或是 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 為空字串 ("")，則為 <ph id="ph3">&lt;paramref name="value" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The search begins at the first character position of this string and continues through the last character position.</source>
          <target state="translated">這個字串的第一個字元位置開始搜尋，並繼續完成最後一個字元位置。</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method.</source>
          <target state="translated">若要判斷字串是否包含指定的子字串使用序數比較 （例如，區分文化特性的比較或不區分大小寫的序數比較） 以外的項目，您可以建立自訂的方法。</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The following example illustrates one such approach.</source>
          <target state="translated">下列範例將示範一個這類方法。</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>It defines a <ph id="ph1">&lt;xref:System.String&gt;</ph> extension method  that includes a <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter and indicates whether a string contains a substring when using the specified form of string comparison.</source>
          <target state="translated">它會定義<ph id="ph1">&lt;xref:System.String&gt;</ph>擴充方法，其中包含<ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>參數，表示使用指定的格式字串比較的字串是否包含子字串。</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The following example then calls the <ph id="ph1">`Contains`</ph> extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.</source>
          <target state="translated">下列範例會接著呼叫<ph id="ph1">`Contains`</ph>擴充方法，以判斷子字串是否要使用序數比較和區分大小寫的序數比較時的字串中找到。</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>If you are interested in the position of the substring <ph id="ph1">`value`</ph> in the current instance, you can call the <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to get the starting position of its first occurrence, or you can call the <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method to get the starting position of its last occurrence.</source>
          <target state="translated">如果您有興趣的子字串的位置<ph id="ph1">`value`</ph>在目前的執行個體，您可以呼叫<ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法來取得的開始位置的第一個相符項，或者您可以呼叫<ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>方法來取得的開始位置其上一次。</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The example includes a call to the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method if a substring is found in a string instance.</source>
          <target state="translated">此範例包含呼叫<ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph>方法，如果找到子字串的字串執行個體。</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The following example determines whether the string "fox" is a substring of a familiar quotation.</source>
          <target state="translated">下列範例會判斷"fox"字串是否具有類似引號的子字串。</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>If "fox" is found in the string, it also displays its starting position.</source>
          <target state="translated">如果字串中找到"fox"，它也會顯示其開始位置。</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source>The string to copy.</source>
          <target state="translated">要複製的字串。</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source>Creates a new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> with the same value as a specified <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">使用與指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 相同的值，建立 <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> 的新執行個體。</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source>A new string with the same value as <ph id="ph1">&lt;paramref name="str" /&gt;</ph>.</source>
          <target state="translated">具有與 <ph id="ph1">&lt;paramref name="str" /&gt;</ph> 相同值的新字串。</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.String&gt;</ph> object that has the same value as the original string but represents a different object reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph>方法會傳回<ph id="ph2">&lt;xref:System.String&gt;</ph>具有相同的值做為原始字串，但代表不同的物件參考的物件。</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>It differs from an assignment operation, which assigns an existing string reference to an additional object variable.</source>
          <target state="translated">它與不同的指派作業，將現有的字串參考其他物件變數指派。</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>The example illustrates the difference.</source>
          <target state="translated">此範例會說明其間的差異。</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>The following example creates two string objects with different values.</source>
          <target state="translated">下列範例會建立兩個字串物件與不同的值。</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>When it calls the <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> method to assign the first value to the second string, the output indicates that the strings represent different object references although their values are now equal.</source>
          <target state="translated">當呼叫<ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph>方法來將第一個值指派給第二個字串，輸出會指出雖然其值現在是否相等的字串，代表不同的物件參考。</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>On the other hand, when the first string is assigned to the second string, the two strings have identical values because they represent the same object reference.</source>
          <target state="translated">相反地，當第一個字串指派給第二個字串時，兩個字串有相同的值因為它們代表相同的物件參考。</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The index of the first character in this instance to copy.</source>
          <target state="translated">這個要複製的執行個體中第一個字元的索引。</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>An array of Unicode characters to which characters in this instance are copied.</source>
          <target state="translated">複製這個執行個體之字元的目標 Unicode 字元陣列。</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The index in <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept> at which the copy operation begins.</source>
          <target state="translated">在 <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept> 中開始複製作業的索引。</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The number of characters in this instance to copy to <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">這個執行個體中要複製到 <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept> 的字元數。</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</source>
          <target state="translated">將字元的指定數目從這個執行個體的指定位置，複製到 Unicode 字元陣列的指定位置。</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>This method copies <ph id="ph1">`count`</ph> characters from the <ph id="ph2">`sourceIndex`</ph> position of this instance to the <ph id="ph3">`destinationIndex`</ph> position of <ph id="ph4">`destination`</ph> character array.</source>
          <target state="translated">這個方法會複製<ph id="ph1">`count`</ph>字元<ph id="ph2">`sourceIndex`</ph>這個執行個體的位置<ph id="ph3">`destinationIndex`</ph>位置<ph id="ph4">`destination`</ph>字元陣列。</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>This method does not resize the <ph id="ph1">`destination`</ph> character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <ph id="ph2">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">這個方法不會調整大小<ph id="ph1">`destination`</ph>字元陣列; 它必須有足夠數目的項目，容納已複製的字元，或在方法擲回<ph id="ph2">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">`sourceIndex`</ph> and <ph id="ph2">`destinationIndex`</ph> are zero-based.</source>
          <target state="translated"><ph id="ph1">`sourceIndex`</ph> 和<ph id="ph2">`destinationIndex`</ph>是以零起始。</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destination" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destination" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="count" /&gt;</ph> is negative</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph>、<ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="count" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> does not identify a position in the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> 未識別目前執行個體中的位置。</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> does not identify a valid index in the <ph id="ph2">&lt;paramref name="destination" /&gt;</ph> array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> 未識別 <ph id="ph2">&lt;paramref name="destination" /&gt;</ph> 陣列中的有效索引。</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of the substring from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of this instance</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 大於從 <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> 到這個執行個體結尾的子字串長度。</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of the subarray from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of the <ph id="ph3">&lt;paramref name="destination" /&gt;</ph> array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 大於從 <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> 到 <ph id="ph3">&lt;paramref name="destination" /&gt;</ph> 陣列結尾的子陣列長度。</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="F:System.String.Empty">
          <source>Represents the empty string.</source>
          <target state="translated">表示空字串。</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" uid="F:System.String.Empty">
          <source>This field is read-only.</source>
          <target state="translated">此欄位為唯讀。</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.String.Empty">
          <source>The value of this field is the zero-length string, "".</source>
          <target state="translated">這個欄位的值是零長度字串""。</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.String.Empty">
          <source>In application code, this field is most commonly used in assignments to initialize a string variable to an empty string.</source>
          <target state="translated">在應用程式碼中，這個欄位是最常用於指派中初始化為空字串的字串變數。</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.String.Empty">
          <source>To test whether the value of a string is either <ph id="ph1">`null`</ph> or <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, use the <ph id="ph3">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method.</source>
          <target state="translated">若要測試的字串值是否<ph id="ph1">`null`</ph>或<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>，使用<ph id="ph3">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Determines whether the end of this string instance matches a specified string.</source>
          <target state="translated">判斷這個字串執行個體的結尾是否符合指定的字串。</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source>The string to compare to the substring at the end of this instance.</source>
          <target state="translated">要在這個執行個體結束時，與子字串比較的字串。</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source>Determines whether the end of this string instance matches the specified string.</source>
          <target state="translated">判斷這個字串執行個體的結尾是否符合指定的字串。</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> matches the end of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 符合這個執行個體的結尾，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>This method compares <ph id="ph1">`value`</ph> to the substring at the end of this instance that is the same length as <ph id="ph2">`value`</ph>, and returns an indication whether they are equal.</source>
          <target state="translated">這個方法會比較<ph id="ph1">`value`</ph>是相同的長度做為這個執行個體的結尾子字串<ph id="ph2">`value`</ph>，並傳回表示是否相等。</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same instance or match the end of this instance.</source>
          <target state="translated">若要視為相等，<ph id="ph1">`value`</ph>必須是相同的執行個體的參考，或比對這個執行個體的結尾。</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>The following example indicates whether each string in an array ends with a period (".").</source>
          <target state="translated">下列範例表示一個陣列中的每個字串是否以句號結尾 ("。")。</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>The following example defines a <ph id="ph1">`StripEndTags`</ph> method that uses the <ph id="ph2">&lt;xref:System.String.EndsWith%28System.String%29&gt;</ph> method to remove HTML end tags from the end of a line.</source>
          <target state="translated">下列範例會定義<ph id="ph1">`StripEndTags`</ph>方法使用<ph id="ph2">&lt;xref:System.String.EndsWith%28System.String%29&gt;</ph>方法從行尾移除 HTML 結尾標記。</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>Note that the  <ph id="ph1">`StripEndTags`</ph> method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.</source>
          <target state="translated">請注意，<ph id="ph1">`StripEndTags`</ph>呼叫以遞迴方式來確認移除該行結尾的多個 HTML 結尾標記的方法。</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">中所述<bpt id="p1">[</bpt>使用字串的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>To determine whether a string ends with a particular substring by using the string comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">若要判斷字串是否結束特定的子字串以使用目前文化特性的字串比較規則，請呼叫<ph id="ph1">&lt;see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /&gt;</ph>方法多載，其值為<ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph>針對其<ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The string to compare to the substring at the end of this instance.</source>
          <target state="translated">要在這個執行個體結束時，與子字串比較的字串。</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>One of the enumeration values that determines how this string and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">列舉值之一，指定這個字串和 <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 的比較方式。</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</source>
          <target state="translated">判斷當使用指定的比較選項進行比較時，這個字串執行個體的結尾是否符合指定的字串。</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter matches the end of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 參數符合這個字串的結尾，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method compares the <ph id="ph2">`value`</ph> parameter to the substring at the end of this string and returns a value that indicates whether they are equal.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph>方法會比較<ph id="ph2">`value`</ph>在這個字串的結尾的子字串的參數和傳回值，指出它們是否相等。</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same string, must be the empty string (""), or must match the end of this string.</source>
          <target state="translated">若要視為相等，<ph id="ph1">`value`</ph>必須是相同的字串的參考，必須是空字串 ("")，或必須符合這個字串的結尾。</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The type of comparison performed by the <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method depends on the value of the <ph id="ph2">`comparisonType`</ph> parameter.</source>
          <target state="translated">所執行的比較類型<ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph>方法取決於值<ph id="ph2">`comparisonType`</ph>參數。</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The following example determines whether a string ends with a particular substring.</source>
          <target state="translated">下列範例會判斷字串是否以特定的子字串結束。</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</source>
          <target state="translated">文化特性、 是否忽略大小寫，以及是否執行序數比較的選擇會影響結果。</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The string to compare to the substring at the end of this instance.</source>
          <target state="translated">要在這個執行個體結束時，與子字串比較的字串。</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示在比較時忽略大小寫，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Cultural information that determines how this instance and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">判斷如何比較此執行個體和 <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 的文化特性資訊。</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current culture is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> 是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，則會使用目前的文化特性。</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Determines whether the end of this string instance matches the specified string when compared using the specified culture.</source>
          <target state="translated">判斷當使用指定之文化特性進行比較時，這個字串執行個體的結尾是否符合指定的字串。</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter matches the end of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 參數符合這個字串的結尾，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method compares the <ph id="ph1">`value`</ph> parameter to the substring at the end of this string that is the same length as <ph id="ph2">`value`</ph>, and returns a value that indicates whether they are equal.</source>
          <target state="translated">這個方法會比較<ph id="ph1">`value`</ph>參數在此與相同長度的字串結尾的子字串<ph id="ph2">`value`</ph>，並傳回值，指出它們是否相等。</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same instance or match the end of this string.</source>
          <target state="translated">若要視為相等，<ph id="ph1">`value`</ph>必須是相同的執行個體的參考或符合這個字串的結尾。</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method performs a word (culture-sensitive) comparison using the specified casing and culture.</source>
          <target state="translated">這個方法會執行使用指定的大小寫和文化特性的字組 （區分文化特性） 比較。</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example determines whether a string occurs at the end of another string.</source>
          <target state="translated">下列範例會判斷字串是否發生在另一個字串結尾處。</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph>幾次使用區分大小寫、 不區分大小寫和不同的文化特性會影響搜尋的結果呼叫方法。</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Determines whether two <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects have the same value.</source>
          <target state="translated">判斷兩個 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件是否具有相同的值。</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source>The string to compare to this instance.</source>
          <target state="translated">要與這個執行個體比較的字串。</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source>Determines whether this instance and a specified object, which must also be a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object, have the same value.</source>
          <target state="translated">判斷這個執行個體和指定的物件 (同時還必須是 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件) 是否具有相同的值。</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> is a <ph id="ph3">&lt;see cref="T:System.String" /&gt;</ph> and its value is the same as this instance; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> 是 <ph id="ph3">&lt;see cref="T:System.String" /&gt;</ph>，且其值與這個執行個體相同，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the method returns <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，則方法會傳回 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.Object)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source>The string to compare to this instance.</source>
          <target state="translated">要與這個執行個體比較的字串。</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source>Determines whether this instance and another specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object have the same value.</source>
          <target state="translated">判斷這個執行個體和另一個指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件是否具有相同的值。</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is the same as the value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 參數的值與這個執行個體的值相同，則為 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the method returns <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，則方法會傳回 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.It compares the title-cased word "File" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I (U+0131) instead of LATIN SMALL LETTER I (U+0069).</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph>方法。它會比較使用標題大小寫 「 檔案 」 with 字相等的 word、 其小寫的對等項目、 其大寫對等項目和包含拉丁小字母無點 I 字 (U + 0131) 而不是拉丁文小字母 I (U + 0069)。</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String)">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Equals%28System.String%29&gt;</ph> method performs an ordinal comparison, only the comparison with an identical word returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.String.Equals%28System.String%29&gt;</ph>方法會執行序數比較，使用了相同的字組比較傳回<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">要比較的第一個字串，或是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">要比較的第二個字串，或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>Determines whether two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects have the same value.</source>
          <target state="translated">判斷兩個指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件是否具有相同的值。</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of <ph id="ph2">&lt;paramref name="a" /&gt;</ph> is the same as the value of <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 的值與 <ph id="ph2">&lt;paramref name="a" /&gt;</ph> 的值相同，則為 <ph id="ph3">&lt;paramref name="b" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>If both <ph id="ph1">&lt;paramref name="a" /&gt;</ph> and <ph id="ph2">&lt;paramref name="b" /&gt;</ph> are <ph id="ph3">&lt;see langword="null" /&gt;</ph>, the method returns <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="a" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="b" /&gt;</ph> 都是 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，則這個方法會傳回 <ph id="ph4">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The string to compare to this instance.</source>
          <target state="translated">要與這個執行個體比較的字串。</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies how the strings will be compared.</source>
          <target state="translated">其中一個列舉值，指定字串的比較方式。</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>Determines whether this string and a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object have the same value.</source>
          <target state="translated">判斷這個字串和指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件是否具有相同的值。</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>A parameter specifies the culture, case, and sort rules used in the comparison.</source>
          <target state="translated">參數可指定用於比較的文化特性、大小寫及排序規則。</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is the same as this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 參數的值與這個字串相同，則為 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph>參數會指出是否比較應該使用的目前或而異的文化特性、 接受或忽略大小寫的兩個字串進行比較，或使用 word 或序數排序規則。</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The following example creates a string array that consists of an uppercase "I", a lowercase "i", and a dotless "ı".</source>
          <target state="translated">下列範例會建立字串陣列，其中包含以大寫"I"、"i"的小寫和無點"ı"。</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> method to compare them by using each possible <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration value.</source>
          <target state="translated">然後它會呼叫<ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph>方法來加以比較使用每一個可能的<ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>列舉值。</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The following example compares four sets of words by using each member of the <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">下列範例會使用的每個成員來比較四組字<ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</source>
          <target state="translated">比較使用英文 （美國） 和沙米文 （瑞典上方） 文化特性的慣例。</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</source>
          <target state="translated">請注意，字串"encyclopædia"和"百科全書"都會被視為對等項目在 EN-US 文化特性，但不是在沙米文 （北瑞典） 文化特性。</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">要比較的第一個字串，或是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">要比較的第二個字串，或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the comparison.</source>
          <target state="translated">其中一個列舉值，指定比較的規則。</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>Determines whether two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects have the same value.</source>
          <target state="translated">判斷兩個指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件是否具有相同的值。</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>A parameter specifies the culture, case, and sort rules used in the comparison.</source>
          <target state="translated">參數可指定用於比較的文化特性、大小寫及排序規則。</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;paramref name="a" /&gt;</ph> parameter is equal to the value of the <ph id="ph3">&lt;paramref name="b" /&gt;</ph> parameter; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 參數的值等於 <ph id="ph2">&lt;paramref name="a" /&gt;</ph> 參數的值，則為 <ph id="ph3">&lt;paramref name="b" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph>參數會指出是否比較應該使用的目前或而異的文化特性、 接受或忽略大小寫的兩個字串進行比較，或使用 word 或序數排序規則。</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The following example compares four sets of words by using each member of the <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">下列範例會使用的每個成員來比較四組字<ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</source>
          <target state="translated">比較使用英文 （美國） 和沙米文 （瑞典上方） 文化特性的慣例。</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</source>
          <target state="translated">請注意，字串"encyclopædia"和"百科全書"都會被視為對等項目在 EN-US 文化特性，但不是在沙米文 （北瑞典） 文化特性。</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Converts the value of objects to strings based on the formats specified and inserts them into another string.</source>
          <target state="translated">根據指定的格式將物件的值轉換為字串，並將它們插入到另一個字串。</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>If you are new to the <ph id="ph1">`String.Format`</ph> method, see the <bpt id="p1">[</bpt>Get started with the String.Format method<ept id="p1">](#Starting)</ept> section for a quick overview.</source>
          <target state="translated">如果您不熟悉 <ph id="ph1">`String.Format`</ph> 方法，請參閱 <bpt id="p1">[</bpt>String.Format 方法入門<ept id="p1">](#Starting)</ept>一節以取得快速概觀。</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>See the <bpt id="p1">[</bpt>Remarks<ept id="p1">](#remarks-top)</ept> section for general documentation for the <ph id="ph1">`String.Format`</ph> method.</source>
          <target state="translated">如需 <ph id="ph1">`String.Format`</ph> 方法的一般文件，請參閱<bpt id="p1">[</bpt>備註<ept id="p1">](#remarks-top)</ept>一節。</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this section:</source>
          <target state="translated">本節內容：</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Get started with the String.Format method<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>String.Format 方法入門<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#FTaskList)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>沒有呼叫的方法？<ept id="p1">](#FTaskList)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Format method in brief<ept id="p1">](#Format_Brief)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Format 方法簡介<ept id="p1">](#Format_Brief)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Format item<ept id="p1">](#FormatItem)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>格式項目<ept id="p1">](#FormatItem)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>How arguments are formatted<ept id="p1">](#HowFormatted)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>引數格式化的方式<ept id="p1">](#HowFormatted)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Format items that have the same index<ept id="p1">](#SameIndex)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>格式項目具有相同的索引<ept id="p1">](#SameIndex)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Formatting and culture<ept id="p1">](#Format_Culture)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>格式和文化特性<ept id="p1">](#Format_Culture)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Custom formatting operations<ept id="p1">](#Format_Custom)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>自訂格式化作業<ept id="p1">](#Format_Custom)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>String.Format Q &amp; A<ept id="p1">](#QA)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>String.Format Q &amp; A<ept id="p1">](#QA)</ept></target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Get started with the String.Format method</source>
          <target state="translated">String.Format 方法入門</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Use <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> if you need to insert the value of an object, variable, or expression into another string.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph>如果您要插入到另一個字串的物件、 變數或運算式的值。</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, you can insert the value of a <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> value into a string to display it to the user as a single string:</source>
          <target state="translated">例如，您可以在其中插入的值<ph id="ph1">&lt;xref:System.Decimal&gt;</ph>顯示給使用者以單一字串的字串值：</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>And you can control that value's formatting:</source>
          <target state="translated">而且，您可以控制該數值的格式：</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Besides formatting, you can also control alignment and spacing.</source>
          <target state="translated">除了格式，您也可以控制對齊和間距。</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Inserting a string</source>
          <target state="translated">將字串插入</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> starts with a format string, followed by one or more objects or expressions that will be converted to strings and inserted at a specified place in the format string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> 開始使用的格式字串，後面接著一個或多個物件會轉換成字串並插入格式字串中的指定位置的運算式。</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example:</source>
          <target state="translated">例如: </target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">`{0}`</ph> in the format string is a format item.</source>
          <target state="translated"><ph id="ph1">`{0}`</ph>格式字串是格式項目。</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`0`</ph> is the index of the object whose string value will be inserted at that position.</source>
          <target state="translated"><ph id="ph1">`0`</ph> 這是的物件的字串值將會插入該位置的索引。</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(Indexes start at 0.) If the object to be inserted is not a string, its <ph id="ph1">`ToString`</ph> method is called to convert it to one before inserting it in the result string.</source>
          <target state="translated">（索引 0 開始。）如果要插入的物件不是字串，其<ph id="ph1">`ToString`</ph>呼叫方法，將它轉換成插入結果字串中之前的其中一個。</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's another example that uses two format items and two objects in the object list:</source>
          <target state="translated">以下是使用 [物件] 清單中的兩個格式項目和兩個物件的另一個範例：</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can have as many format items and as many objects in the object list as you want, as long as the index of every format item has a matching object in the object list.</source>
          <target state="translated">您可以擁有最多的格式項目，而且想為您的 [物件] 清單中的許多物件，只要每個格式項目的索引物件清單中有相符的物件。</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You also don't have to worry about which overload you call; the compiler will select the appropriate one for you.</source>
          <target state="translated">您也不必擔心相關的多載呼叫。編譯器會選擇適合您。</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Controlling formatting</source>
          <target state="translated">控制格式設定</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can follow the index in a format item with a format string to control how an object is formatted.</source>
          <target state="translated">您可以遵循格式字串來控制如何格式化物件的格式項目中的索引。</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, <ph id="ph1">`{0:d}`</ph> applies the "d" format string to the first object in the object list.</source>
          <target state="translated">例如， <ph id="ph1">`{0:d}`</ph> "d"格式字串適用於物件清單中的第一個物件。</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here is an example with a single object and two format items:</source>
          <target state="translated">以下是以單一物件的範例和兩個格式項目：</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A number of types support format strings, including all numeric types (both                                          <bpt id="p1">[</bpt>standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and                                          <bpt id="p2">[</bpt>custom<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept> format strings), all dates and times (both                                          <bpt id="p3">[</bpt>standard<ept id="p3">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and                                          <bpt id="p4">[</bpt>custom<ept id="p4">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept> format strings) and time intervals (both                                          <bpt id="p5">[</bpt>standard<ept id="p5">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> and                                          <bpt id="p6">[</bpt>custom<ept id="p6">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept> format strings), all enumeration types                                          <bpt id="p7">[</bpt>enumeration types<ept id="p7">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>, and                                          <bpt id="p8">[</bpt>GUIDs<ept id="p8">](https://msdn.microsoft.com/library/97af8hh4.aspx)</ept>.</source>
          <target state="translated">類型支援的數字格式字串，包括所有數字類型 (兩者<bpt id="p1">[</bpt>標準<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>和<bpt id="p2">[</bpt>自訂<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>格式字串)、 所有日期和時間 (both<bpt id="p3">[</bpt>標準<ept id="p3">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept>和<bpt id="p4">[</bpt>自訂<ept id="p4">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>格式字串) 和時間間隔 (兩者<bpt id="p5">[</bpt>標準d<ept id="p5">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept>和<bpt id="p6">[</bpt>自訂<ept id="p6">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>格式字串)，所有列舉型別<bpt id="p7">[</bpt>列舉型別<ept id="p7">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>，和                                         <bpt id="p8">[</bpt>Guid<ept id="p8">](https://msdn.microsoft.com/library/97af8hh4.aspx)</ept>。</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also add support for format strings to your own types.</source>
          <target state="translated">您也可以將格式字串的支援加入自己的型別中。</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Controlling spacing</source>
          <target state="translated">控制間距</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can define the width of the string that is inserted into the result string by using syntax such as <ph id="ph1">`{0,12}`</ph>, which inserts a 12-character string.</source>
          <target state="translated">您可以定義使用像是語法插入結果字串之字串的寬度<ph id="ph1">`{0,12}`</ph>，其中插入 12 個字元的字串。</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this case, the string representation of the first object is right-aligned in the 12-character field.</source>
          <target state="translated">在此情況下，第一個物件的字串表示處於靠右對齊 12 個字元的欄位。</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(If the string representation of the first object is more than 12 characters in length, though, the preferred field width is ignored, and the entire string is inserted into the result string.)</source>
          <target state="translated">（如果第一個物件的字串表示的長度超過 12 個字元，不過，會略過慣用的欄位寬度，且整個字串插入結果字串。）</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example defines a 6-character field to hold the string "Year" and some year strings, as well as an 15-character field to hold the string "Population" and some population data.</source>
          <target state="translated">下列範例會定義 6 個字元的欄位，來容納字串 「 年 」 和某些年字串，以及 15 個字元的欄位來容納字串 「 母體擴展 」 以及一些母體擴展的資料。</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that the characters are right-aligned in the field.</source>
          <target state="translated">請注意，字元靠右對齊欄位中。</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Controlling alignment</source>
          <target state="translated">控制對齊方式</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By default, strings are right-aligned within their field if you specify a field width.</source>
          <target state="translated">根據預設，字串才靠右對齊，其欄位中指定欄位寬度。</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To left-align strings in a field, you preface the field width with a negative sign, such as <ph id="ph1">`{0,-12}`</ph> to define a 12-character right-aligned field.</source>
          <target state="translated">若要靠左對齊欄位中的字串，您前面上欄位寬度，以負號，例如<ph id="ph1">`{0,-12}`</ph>定義 12 個字元，靠右對齊的欄位。</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example is similar to the previous one, except that it left-aligns both labels and data.</source>
          <target state="translated">下列範例是類似於上一個，，不同之處在於它靠左對齊的標籤和資料。</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> makes use of the composite formatting feature.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> 使用複合格式功能。</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Composite Formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>複合格式設定<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Which method do I call?</source>
          <target state="translated">沒有呼叫的方法？</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To</source>
          <target state="translated">以</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Call</source>
          <target state="translated">Call</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format one or more objects by using the conventions of the current culture.</source>
          <target state="translated">使用目前文化特性的慣例來格式化一個或多個物件。</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Except for the overloads that include a <ph id="ph1">`provider`</ph> parameter, the remaining <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> overloads include a <ph id="ph3">&lt;xref:System.String&gt;</ph> parameter followed by one or more object parameters.</source>
          <target state="translated">除了包含多載<ph id="ph1">`provider`</ph>參數，其餘<ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph>多載包括<ph id="ph3">&lt;xref:System.String&gt;</ph>參數後面接著一個或多個物件參數。</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because of this, you don't have to determine which <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload you intend to call.</source>
          <target state="translated">因為這個緣故，您不需要判斷哪一個<ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>您想要呼叫的多載。</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Your language compiler selects the appropriate overload from among the overloads that don't have a <ph id="ph1">`provider`</ph> parameter, based on your argument list.</source>
          <target state="translated">您的語言編譯器會選擇從沒有多載中的適當多載<ph id="ph1">`provider`</ph>根據引數清單的參數。</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if your argument list has five arguments, the compiler calls the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">例如，如果引數清單有五個引數，編譯器會呼叫<ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format one or more objects by using the conventions of a specific culture.</source>
          <target state="translated">使用特定文化特性的慣例來格式化一個或多個物件。</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload that begins with a <ph id="ph2">`provider`</ph> parameter is followed by a <ph id="ph3">&lt;xref:System.String&gt;</ph> parameter and one or more object parameters.</source>
          <target state="translated">每個<ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>開頭的多載<ph id="ph2">`provider`</ph>參數後面<ph id="ph3">&lt;xref:System.String&gt;</ph>參數和一個或多個物件的參數。</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because of this, you don't have to determine which specific <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload you intend to call.</source>
          <target state="translated">因為這個緣故，您不需要判斷哪一個特定<ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>您想要呼叫的多載。</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Your language compiler selects the appropriate overload from among the overloads that have a <ph id="ph1">`provider`</ph> parameter, based on your argument list.</source>
          <target state="translated">您的語言編譯器會選取適當的多載具有多載，從<ph id="ph1">`provider`</ph>根據引數清單的參數。</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if your argument list has five arguments, the compiler calls the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">例如，如果引數清單有五個引數，編譯器會呼叫<ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Perform a custom formatting operation either with an <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> implementation or an <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> implementation.</source>
          <target state="translated">不論是透過執行自訂格式化作業<ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph>實作或<ph id="ph2">&lt;xref:System.IFormattable&gt;</ph>實作。</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Any of the four overloads with a <ph id="ph1">`provider`</ph> parameter.</source>
          <target state="translated">任何具有四個多載<ph id="ph1">`provider`</ph>參數。</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The compiler selects the appropriate overload from among the overloads that have a <ph id="ph1">`provider`</ph> parameter, based on your argument list.</source>
          <target state="translated">編譯器會選擇適當的多載，從具有的多載<ph id="ph1">`provider`</ph>根據引數清單的參數。</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The Format method in brief</source>
          <target state="translated">Format 方法簡介</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each overload of the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to include zero-based indexed placeholders, called <bpt id="p2">*</bpt>format items<ept id="p2">*</ept>, in a composite format string.</source>
          <target state="translated">每個多載<ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>方法會使用<bpt id="p1">[</bpt>複合格式功能<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>以包含以零為起始的索引的位置，稱為<bpt id="p2">*</bpt>設定項目的格式<ept id="p2">*</ept>，複合格式字串中。</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>At run time, each format item is replaced with the string representation of the corresponding argument in a parameter list.</source>
          <target state="translated">在執行階段，每個格式項目會取代對應的引數在參數清單中的字串表示。</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the value of the argument is <ph id="ph1">`null`</ph>, the format item is replaced with <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果引數的值為<ph id="ph1">`null`</ph>，格式項目取代<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following call to the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> method includes a format string with three format items, {0}, {1}, and {2}, and an argument list with three items.</source>
          <target state="translated">例如，下列呼叫<ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph>方法包括三個格式項目、 與 {0}、 {1}，{2}，格式字串和引數清單具有三個項目。</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The format item</source>
          <target state="translated">格式項目</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A format item has this syntax:</source>
          <target state="translated">格式項目具有下列語法：</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Brackets denote optional elements.</source>
          <target state="translated">方括號表示選擇性的項目。</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The opening and closing braces are required.</source>
          <target state="translated">需要左和右大括號。</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(To include a literal opening or closing brace in the format string, see the "Escaping Braces" section in the <bpt id="p1">[</bpt>Composite Formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> article.)</source>
          <target state="translated">(包含常值的左或右大括弧在格式字串中，請參閱 「 逸出大括號 」 一節<bpt id="p1">[</bpt>複合格式化<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>文件。)</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a format item to format a currency value might appear like this:</source>
          <target state="translated">比方說，若要格式化貨幣值的格式項目可能會出現如下：</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A format item has the following elements:</source>
          <target state="translated">格式項目具有下列項目：</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">*</bpt>index<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>index<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The zero-based index of the argument whose string representation is to be included at this position in the string.</source>
          <target state="translated">以零為起始的索引為其字串表示的引數包含在這個字串中的位置。</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If this argument is <ph id="ph1">`null`</ph>, an empty string will be included at this position in the string.</source>
          <target state="translated">如果這個引數是<ph id="ph1">`null`</ph>，空字串會包含在這個字串中的位置。</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">*</bpt>alignment<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>對齊方式<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Optional.</source>
          <target state="translated">選擇性。</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A signed integer that indicates the total length of the field into which the argument is inserted and whether it is right-aligned (a positive integer) or left-aligned (a negative integer).</source>
          <target state="translated">帶正負號的整數，指出欄位的總長度成插入引數，它會靠右對齊 （正整數），或靠左對齊 （負整數）。</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you omit <bpt id="p1">*</bpt>alignment<ept id="p1">*</ept>, the string representation of the corresponding argument is inserted in a field with no leading or trailing spaces.</source>
          <target state="translated">如果您省略<bpt id="p1">*</bpt>對齊<ept id="p1">*</ept>，對應的引數的字串表示插入任何開頭或尾端空格的欄位中。</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the value of <bpt id="p1">*</bpt>alignment<ept id="p1">*</ept> is less than the length of the argument to be inserted, <bpt id="p2">*</bpt>alignment<ept id="p2">*</ept> is ignored and the length of the string representation of the argument is used as the field width.</source>
          <target state="translated">如果值<bpt id="p1">*</bpt>對齊<ept id="p1">*</ept>插入，引數的長度小於<bpt id="p2">*</bpt>對齊<ept id="p2">*</ept>會忽略和引數的字串表示的長度當做欄位寬度。</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">*</bpt>formatString<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>formatString<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Optional.</source>
          <target state="translated">選擇性。</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string that specifies the format of the corresponding argument's result string.</source>
          <target state="translated">字串，指定對應引數的結果字串的格式。</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you omit <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>, the corresponding argument's parameterless <ph id="ph1">`ToString`</ph> method is called to produce its string representation.</source>
          <target state="translated">如果您省略<bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>，對應的引數的無參數<ph id="ph1">`ToString`</ph>呼叫方法來產生它的字串表示。</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you specify <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>, the argument referenced by the format item must implement the <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interface.</source>
          <target state="translated">如果您指定<bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>，格式項目所參考的引數必須實作<ph id="ph1">&lt;xref:System.IFormattable&gt;</ph>介面。</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Types that support format strings include:</source>
          <target state="translated">支援格式字串的類型包括：</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All integral and floating-point types.</source>
          <target state="translated">所有的整數和浮點數型別。</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>標準數值格式字串<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>和<bpt id="p2">[</bpt>自訂數值格式字串<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.DateTime&gt;</ph> and <ph id="ph2">&lt;xref:System.DateTimeOffset&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.DateTime&gt;</ph> 和 <ph id="ph2">&lt;xref:System.DateTimeOffset&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>標準日期和時間格式字串<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept>和<bpt id="p2">[</bpt>自訂日期和時間格式字串<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All enumeration types.</source>
          <target state="translated">所有列舉類型。</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Enumeration Format Strings<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>列舉格式字串<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Standard TimeSpan Format Strings<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom TimeSpan Format Strings<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.)</source>
          <target state="translated">(請參閱<bpt id="p1">[</bpt>標準 TimeSpan 格式字串<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept>和<bpt id="p2">[</bpt>自訂 TimeSpan 格式字串<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>GUIDs.</source>
          <target state="translated">GUID。</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See the <ph id="ph1">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method.)</source>
          <target state="translated">(請參閱<ph id="ph1">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph>方法。)</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, note that any custom type can implement <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> or extend an existing type's <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> implementation.</source>
          <target state="translated">不過，請注意，任何自訂的類型可以實作<ph id="ph1">&lt;xref:System.IFormattable&gt;</ph>擴充現有的類型或<ph id="ph2">&lt;xref:System.IFormattable&gt;</ph>實作。</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the <ph id="ph1">`alignment`</ph> and <ph id="ph2">`formatString`</ph> arguments to produce formatted output.</source>
          <target state="translated">下列範例會使用<ph id="ph1">`alignment`</ph>和<ph id="ph2">`formatString`</ph>引數才能產生格式化的輸出。</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How arguments are formatted</source>
          <target state="translated">引數格式化的方式</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format items are processed sequentially from the beginning of the string.</source>
          <target state="translated">格式項目會依序處理，從字串的開頭。</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each format item has an index that corresponds to an object in the method's argument list.</source>
          <target state="translated">每個格式項目有對應至方法的引數清單中的物件索引。</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method retrieves the argument and derives its string representation as follows:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>方法擷取的引數，並衍生其字串表示，如下所示：</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the argument is <ph id="ph1">`null`</ph>, the method inserts <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> into the result string.</source>
          <target state="translated">如果引數是<ph id="ph1">`null`</ph>，此方法會插入<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>插入結果字串。</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You don't have to be converned with handling an <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> for null arguments.</source>
          <target state="translated">您不需要具備處理 converned <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> null 引數。</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you call the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> overload and the <ph id="ph2">`provider`</ph> parameter implements the <ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph> interface, the argument is passed to the <ph id="ph4">`provider`</ph> object's <ph id="ph5">&lt;xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如果您呼叫<ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph>多載而<ph id="ph2">`provider`</ph>參數實作<ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph>介面，引數傳遞到<ph id="ph4">`provider`</ph>物件的<ph id="ph5">&lt;xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the format item includes a <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept> argument, it is passed as the first argument to the method.</source>
          <target state="translated">如果格式項目包含<bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>引數，傳遞時的第一個引數的方法。</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> implementation is able to provide formatting services, it returns the string representation of the argument; otherwise, it returns <ph id="ph2">`null`</ph> and the next step executes.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph>實作是能夠提供格式化服務，它會傳回引數的字串表示; 否則它會傳回<ph id="ph2">`null`</ph>和下一個步驟執行。</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the argument implements the <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interface, its <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> implementation is called.</source>
          <target state="translated">如果引數實作<ph id="ph1">&lt;xref:System.IFormattable&gt;</ph>介面，其<ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph>呼叫實作。</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The argument's parameterless <ph id="ph1">`ToString`</ph> method, which is either overridden or inherited from the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class, is called.</source>
          <target state="translated">引數的無參數<ph id="ph1">`ToString`</ph>方法，這個方法會覆寫，或繼承自<ph id="ph2">&lt;xref:System.Object&gt;</ph>類別，稱為。</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For an example that intercepts calls to the <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> method and allows you to see what information the <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> method passes to a formatting method for each format item in a composite format string, see <bpt id="p1">[</bpt>Example: An intercept provider and Roman numeral formatter<ept id="p1">](#Format7_Example)</ept>.</source>
          <target state="translated">如需範例，會呼叫攔截<ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph>方法，可讓您查看哪些資訊<ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph>方法傳遞至格式化的方法，以便在複合格式字串中，每個格式項目請參閱<bpt id="p1">[</bpt>範例： 截距，提供者和羅馬數字格式器<ept id="p1">](#Format7_Example)</ept>。</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format items that have the same index</source>
          <target state="translated">格式項目具有相同的索引</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.FormatException&gt;</ph> exception if the index of an index item is greater than or equal to the number of arguments in the argument list.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>方法會擲回<ph id="ph2">&lt;xref:System.FormatException&gt;</ph>例外狀況，如果索引項目的索引是大於或等於引數清單中的引數。</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, <ph id="ph1">`format`</ph> can include more format items than there are arguments, as long as multiple format items have the same index.</source>
          <target state="translated">不過，<ph id="ph1">`format`</ph>可以包含多個格式項目比引數，只要多個格式項目具有相同的索引。</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the call to the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> method in following example, the argument list has a single argument, but the format string includes two format items: one displays the decimal value of a number, and the other displays its hexadecimal value.</source>
          <target state="translated">在呼叫<ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph>在下列範例中，引數清單的方法具有單一引數，但是格式字串包含兩個格式項目： 一個顯示數字的十進位值與另一個則顯示十六進位值。</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting and culture</source>
          <target state="translated">格式和文化特性</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Generally, objects in the argument list are converted to their string representations by using the conventions of the current culture, which is returned by the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">一般而言，引數清單中的物件會轉換成其字串表示法傳回使用目前的文化特性的慣例<ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can control this behavior by calling one of the overloads of <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> that includes a <ph id="ph2">`provider`</ph> parameter.</source>
          <target state="translated">您可以透過呼叫其中一個多載來控制此行為<ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>包含<ph id="ph2">`provider`</ph>參數。</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation that supplies custom and culture-specific formatting information that is used to moderate the formatting process.</source>
          <target state="translated"><ph id="ph1">`provider`</ph>參數是<ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph>處理實作，提供自訂和特定文化特性格式資訊用來進行中等程度的格式。</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> interface has a single member, <ph id="ph2">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph>, which is responsible for returning the object that provides formatting information.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>介面具有單一成員， <ph id="ph2">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph>，這是負責傳回的物件，提供格式設定資訊。</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework has three <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> implementations that provide culture-specific formatting:</source>
          <target state="translated">.NET Framework 有三個<ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>實作，以提供特定文化特性的格式：</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns a culture-specific <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for formatting numeric values and a culture-specific <ph id="ph3">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph> object for formatting date and time values.</source>
          <target state="translated">其<ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph>方法會傳回特定文化特性<ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph>格式化數值和特定文化特性物件<ph id="ph3">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph>來格式化日期和時間值的物件。</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph>, which is used for culture-specific formatting of date and time values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph>用於特定文化特性格式化的日期和時間值。</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A&gt;</ph> method returns itself.</source>
          <target state="translated">其<ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A&gt;</ph>方法會傳回本身。</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph>, which is used for culture-specific formatting of numeric values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph>用於特定文化特性的數值格式。</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> property returns itself.</source>
          <target state="translated">其<ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph>屬性會傳回本身。</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Custom formatting operations</source>
          <target state="translated">自訂格式化作業</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also call the any of the overloads of the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method that have a <ph id="ph2">`provider`</ph> parameter of type <ph id="ph3">&lt;xref:System.IFormatProvider&gt;</ph> to perform custom formatting operations.</source>
          <target state="translated">您也可以呼叫的多載任一<ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>方法具有<ph id="ph2">`provider`</ph>型別的參數<ph id="ph3">&lt;xref:System.IFormatProvider&gt;</ph>執行自訂的格式設定作業。</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, you could format an integer as an identification number or as a telephone number.</source>
          <target state="translated">例如，您無法格式化整數當做識別碼或電話號碼。</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To perform custom formatting, your <ph id="ph1">`provider`</ph> argument must implement both the <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> and <ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph> interfaces.</source>
          <target state="translated">若要執行自訂的格式，您<ph id="ph1">`provider`</ph>引數必須同時實作<ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph>和<ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph>介面。</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method is passed an <ph id="ph2">&lt;xref:System.ICustomFormatter&gt;</ph> implementation as the <ph id="ph3">`provider`</ph> argument, the <ph id="ph4">&lt;xref:System.String.Format%2A&gt;</ph> method calls its   <ph id="ph5">&lt;xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType&gt;</ph> implementation and requests an object of type <ph id="ph6">&lt;xref:System.ICustomFormatter&gt;</ph>.</source>
          <target state="translated">當<ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>方法傳遞<ph id="ph2">&lt;xref:System.ICustomFormatter&gt;</ph>實作做為<ph id="ph3">`provider`</ph>引數，<ph id="ph4">&lt;xref:System.String.Format%2A&gt;</ph>方法會呼叫其<ph id="ph5">&lt;xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType&gt;</ph>實作要求類型的物件和<ph id="ph6">&lt;xref:System.ICustomFormatter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It then calls the returned <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> object's <ph id="ph2">&lt;xref:System.ICustomFormatter.Format%2A&gt;</ph> method to format each format item in the composite string passed to it.</source>
          <target state="translated">然後它會呼叫傳回<ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph>物件的<ph id="ph2">&lt;xref:System.ICustomFormatter.Format%2A&gt;</ph>方法來格式化複合字串中的每個格式項目傳遞給它。</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about providing custom formatting solutions, see <bpt id="p1">[</bpt>How to: Define and Use Custom Numeric Format Providers<ept id="p1">](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)</ept> and <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph>.</source>
          <target state="translated">如需提供自訂格式解決方案的詳細資訊，請參閱<bpt id="p1">[</bpt>如何： 定義及使用自訂數值格式提供者<ept id="p1">](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)</ept>和<ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For an example that converts integers to formatted custom numbers, see <bpt id="p1">[</bpt>Example: A custom formatting operation<ept id="p1">](#Format6_Example)</ept>.</source>
          <target state="translated">如需將整數轉換為格式化自訂的數字的範例，請參閱<bpt id="p1">[</bpt>範例： 自訂格式化作業<ept id="p1">](#Format6_Example)</ept>。</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For an example that converts unsigned bytes to Roman numerals, see <bpt id="p1">[</bpt>Example: An intercept provider and Roman numeral formatter<ept id="p1">](#Format7_Example)</ept>.</source>
          <target state="translated">如需將不帶正負號的位元組轉換為羅馬數字的範例，請參閱<bpt id="p1">[</bpt>範例： 截距，提供者和羅馬數字格式器<ept id="p1">](#Format7_Example)</ept>。</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example: A custom formatting operation</source>
          <target state="translated">範例： 自訂格式化作業</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This example defines a format provider that formats an integer value as a customer account number in the form x-xxxxx-xx.</source>
          <target state="translated">這個範例會定義整數值格式化為客戶帳戶編號中表單 x-xxxxx-xx 的格式提供者。</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example: An intercept provider and Roman numeral formatter</source>
          <target state="translated">範例： 截距，提供者和羅馬數字格式器</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This example defines a custom format provider that implements the <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> and <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interfaces to do two things:</source>
          <target state="translated">這個範例會定義自訂的格式提供者實作<ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph>和<ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph>介面做兩件事：</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It displays the parameters passed to its <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">它會顯示參數傳遞至其<ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph>實作。</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This enables us to see what parameters the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method is passing to the custom formatting implementation for each object that it tries to format.</source>
          <target state="translated">這可讓我們查看哪些參數<ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph>方法將傳遞至自訂的格式實作每個物件，它會嘗試格式化。</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This can be useful when you're debugging your application.</source>
          <target state="translated">當您在偵錯您的應用程式，這非常有用。</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the object to be formatted is an unsigned byte value that is to be formatted by using the "R" standard format string, the custom formatter formats the numeric value as a Roman numeral.</source>
          <target state="translated">要格式化的物件是否要使用"R"標準格式字串格式化為不帶正負號的位元組值，將自訂格式器會格式化為羅馬數字的數字的值。</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String.Format Q &amp; A</source>
          <target state="translated">String.Format Q &amp; A</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Why do you recommend string interpolation over calls to the <ph id="ph1">`String.Format`</ph> method?</source>
          <target state="translated">為什麼建議字串插值對呼叫<ph id="ph1">`String.Format`</ph>方法？</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String interpolation is:</source>
          <target state="translated">字串插值是：</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>More flexible.</source>
          <target state="translated">更有彈性。</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It can be used in any string without requiring a call to a method that supports composite formatting.</source>
          <target state="translated">它可以是任何字串中不需要使用支援複合格式方法的呼叫。</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Otherwise, you have to call the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method or another method that supports composite formatting, such as <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">否則，您必須呼叫<ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>方法或另一個方法，支援複合格式，例如<ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph>或<ph id="ph3">&lt;xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>More readable.</source>
          <target state="translated">更容易閱讀。</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the expression to insert into a string appears in the interpolated expression rather than in a argument list, interpolated strings are far easier to code and to read.</source>
          <target state="translated">因為插值運算式中，而不是引數清單中，會出現要插入的字串運算式，字串插值都很不容易，程式碼以及可讀取。</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because of their greater readability, interpolated strings can replace not only calls to composite format methods, but they can also be used in string concatenation operations to produce more concise, clearer code.</source>
          <target state="translated">由於其更大的可讀性，字串插值可以取代不只呼叫複合格式方法，但是它們也可用在字串串連作業以產生更簡潔、 清楚的程式碼。</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A comparison of the following two code examples illustrates the superiority of interpolated strings over string concatenation and calls to composite formatting methods.</source>
          <target state="translated">比較下列兩個程式碼範例說明字串插值的優勢，透過字串串連和複合格式方法的呼叫。</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The use of multiple string concatenation operations in the following example produces verbose and hard-to-read code.</source>
          <target state="translated">在下列範例中的多個字串串連作業的使用會產生詳細和硬讀取程式碼。</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In contrast, the use of interpolated strings in the following example produce much clearer, more concise code than the string concatenation statement and the call to the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method in the previous example.</source>
          <target state="translated">相反地，在下列範例中，字串插值的使用會產生更輕鬆、 更簡潔比字串串連陳述式和呼叫的程式碼<ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>前一個範例中的方法。</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Where can I find a list of the predefined format strings that can be used with format items?</source>
          <target state="translated">哪裡可以找到的預先定義的格式字串清單，可以搭配的格式項目？</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For all integral and floating-point types, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">對於所有的整數和浮點數類型，請參閱<bpt id="p1">[</bpt>標準數值格式字串<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>和<bpt id="p2">[</bpt>自訂數值格式字串<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For date and time values, see <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</source>
          <target state="translated">如需日期和時間值，請參閱<bpt id="p1">[</bpt>標準日期和時間格式字串<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept>和<bpt id="p2">[</bpt>自訂日期和時間格式字串<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For enumeration values, see <bpt id="p1">[</bpt>Enumeration Format Strings<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.</source>
          <target state="translated">列舉值，請參閱<bpt id="p1">[</bpt>列舉格式字串<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> values, see  <bpt id="p1">[</bpt>Standard TimeSpan Format Strings<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom TimeSpan Format Strings<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.</source>
          <target state="translated">如<ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph>值，請參閱<bpt id="p1">[</bpt>標準 TimeSpan 格式字串<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept>和<bpt id="p2">[</bpt>自訂 TimeSpan 格式字串<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For <ph id="ph1">&lt;xref:System.Guid&gt;</ph> values, see the Remarks section of the <ph id="ph2">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> reference page.</source>
          <target state="translated">如<ph id="ph1">&lt;xref:System.Guid&gt;</ph>值，請參閱 &lt; 備註 &gt; 一節的<ph id="ph2">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph>參考頁面。</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I control the alignment of the result strings that replace format items?</source>
          <target state="translated">如何控制結果字串時，取代的項目格式的對齊方式？</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The general syntax of a format item is:</source>
          <target state="translated">格式項目的一般語法如下：</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>where <bpt id="p1">*</bpt>alignment<ept id="p1">*</ept> is a signed integer that defines the field width.</source>
          <target state="translated">其中<bpt id="p1">*</bpt>對齊<ept id="p1">*</ept>是帶正負號的整數，定義欄位寬度。</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If this value is negative, text in the field is left-aligned.</source>
          <target state="translated">如果此值為負數，欄位中的文字是靠左對齊。</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If it is positive, text is right-aligned.</source>
          <target state="translated">如果是正數，文字是靠右對齊。</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I control the number of digits after the decimal separator?</source>
          <target state="translated">如何控制十進位分隔符號之後的數字位數？</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All <bpt id="p1">[</bpt>standard numeric format strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> except "D" (which is used with integers only), "G", "R", and "X" allow a precision specifier that defines the number of decimal digits in the result string.</source>
          <target state="translated">所有<bpt id="p1">[</bpt>標準數值格式字串<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>except （可搭配只有整數） 的"D"、"G"、"R"，和"X"允許精確度規範定義結果字串中的小數位數數目。</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses standard numeric format strings to control the number of decimal digits in the result string.</source>
          <target state="translated">下列範例會使用標準數值格式字串來控制結果字串中的小數位數數目。</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you're using a <bpt id="p1">[</bpt>custom numeric format string<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, use the "0" format specifier to control the number of decimal digits in the result string, as the following example shows.</source>
          <target state="translated">如果您使用<bpt id="p1">[</bpt>自訂數值格式字串<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>，使用"0"格式規範來控制在結果字串中，如下列範例所示的小數位數數目。</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I control the number of integral digits?</source>
          <target state="translated">如何控制整數位數數的字？</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By default, formatting operations only display non-zero integral digits.</source>
          <target state="translated">根據預設，格式化作業只會顯示非零的整數位數。</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you are formatting integers, you can use a precision specifier with the "D" and "X" standard format strings to control the number of digits.</source>
          <target state="translated">如果您正在格式化的整數，您可以使用"D"和"X"標準格式字串的有效位數規範來控制的位數。</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can pad an integer or floating-point number with leading zeros to produce a result string with a specified number of integral digits by using the "0" <bpt id="p1">[</bpt>custom numeric format specifier<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, as the following example shows.</source>
          <target state="translated">您可以在使用 「 0 」 產生的結果字串，以指定的數字的整數位數的整數或浮點數，加上前置零填補<bpt id="p1">[</bpt>自訂數值格式規範<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How many items can I include in the format list?</source>
          <target state="translated">在 [格式] 清單中可以包含多少個項目？</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>There is no practical limit.</source>
          <target state="translated">沒有任何實用的限制。</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The second parameter of the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method is tagged with the <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> attribute, which allows you to include either a delimited list or an object array as your format list.</source>
          <target state="translated">第二個參數<ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph>方法會標記為<ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph>屬性，可讓您包含分隔的清單或物件陣列做為格式清單。</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I include literal braces ("{" and "}") in the result string?</source>
          <target state="translated">如何包含常值的大括號 ("{"和"}") 在結果字串中？</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, how do you prevent the following method call from throwing a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> exception?</source>
          <target state="translated">例如，如何避免下列方法呼叫擲回<ph id="ph1">&lt;xref:System.FormatException&gt;</ph>例外狀況？</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A single opening or closing brace is always interpreted as the beginning or end of a format item.</source>
          <target state="translated">左或右大括號會解譯為開頭或結尾的格式項目。</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To be interpreted literally, it must be escaped.</source>
          <target state="translated">若要解譯為常值，則必須逸出。</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You escape a brace by adding another brace ("{{" and "}}" instead of "{" and "}"), as in the following method call:</source>
          <target state="translated">您加入另一個大括號逸出括號 ("{{"和"}}"而不是"{"和"}")，在下列的方法呼叫中：</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, even escaped braces are easily misinterpreted.</source>
          <target state="translated">不過，即使逸出大括號會輕鬆地譯。</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>We recommend that you include braces in the format list and use format items to insert them in the result string, as the following example shows.</source>
          <target state="translated">我們建議您在 [格式] 清單中包含大括號，並將下列範例所示將其插入結果字串中使用的格式項目。</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Why does my call to the String.Format method throw a FormatException?</source>
          <target state="translated">為什麼我 String.Format 方法呼叫擲回 FormatException？</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The most common cause of the exception is that the index of a format item doesn't correspond to an object in the format list.</source>
          <target state="translated">最常見的例外狀況的原因是格式項目的索引未對應到 [格式] 清單中的物件。</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Usually this indicates that you've misnumbered the indexes of format items or you've forgotten to include an object in the format list.</source>
          <target state="translated">通常這表示您已經 misnumbered 格式項目的索引，或您忘了在 [格式] 清單中包含的物件。</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Attempting to include an unescaped left or right brace character also throws a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph>.</source>
          <target state="translated">嘗試將包含未逸出向左或右大括號字元也會擲回<ph id="ph1">&lt;xref:System.FormatException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Occasionally, the exception is the result of a typo; for example, a typical mistake is to mistype "[" (the left bracket) instead of "{" (the left brace).</source>
          <target state="translated">有時候，例外狀況會錯字; 的結果例如，一般的錯誤是打錯"["（左括號） 而不是"{"（左大括號）。</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the Format(System.IFormatProvider,System.String,System.Object[]) method supports parameter arrays, why does my code throw an exception when I use an array?</source>
          <target state="translated">如果 Format(System.IFormatProvider,System.String,System.Object[]) 方法支援參數陣列，為什麼的確我的程式碼會擲回例外狀況時使用陣列嗎？</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following code throws a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> exception:</source>
          <target state="translated">例如，下列程式碼會擲回<ph id="ph1">&lt;xref:System.FormatException&gt;</ph>例外狀況：</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is a problem of compiler overload resolution.</source>
          <target state="translated">這是編譯器多載解析的問題。</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the compiler cannot convert an array of integers to an object array, it treats the integer array as a single argument, so it calls the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> method.</source>
          <target state="translated">因為編譯器無法轉換成物件陣列的整數的陣列，它會將整數陣列視為單一引數，因此它會呼叫<ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The exception is thrown because there are four format items but only a single item in the format list.</source>
          <target state="translated">因為有四個格式項目，但單一項目 [格式] 清單中的，會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because neither Visual Basic nor C# can convert an integer array to an object array, you have to perform the conversion yourself before calling the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Visual Basic 或 C# 都不可以轉換成物件陣列的整數陣列，所以您必須自行執行轉換，然後再呼叫<ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example provides one implementation.</source>
          <target state="translated">下列範例提供一個實作。</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Numerous examples that call the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method are interspersed through the <bpt id="p1">[</bpt>Remarks<ept id="p1">](#remarks)</ept> section of this article.</source>
          <target state="translated">呼叫的數個範例<ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph>方法散佈透過<bpt id="p1">[</bpt>備註<ept id="p1">](#remarks)</ept>本文一節。</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also download a complete set of <ph id="ph1">`String.Format`</ph> examples, which are included a <bpt id="p1">[</bpt>.NET Core 2.0 project for C#<ept id="p1">](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip)</ept> and a <bpt id="p2">[</bpt>.NET Core 2.0 project for Visual Basic<ept id="p2">](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip)</ept>, from the <bpt id="p3">[</bpt>dotnet/docs GitHub repository<ept id="p3">](https://github.com/dotnet/docs)</ept>.</source>
          <target state="translated">您也可以下載完整的<ph id="ph1">`String.Format`</ph>範例中，也就是包含<bpt id="p1">[</bpt>C#.NET Core 2.0 專案<ept id="p1">](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip)</ept>和<bpt id="p2">[</bpt>適用於 Visual Basic.NET Core 2.0 專案<ept id="p2">](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip)</ept>，從<bpt id="p3">[</bpt>dotnet/文件GitHub 儲存機制<ept id="p3">](https://github.com/dotnet/docs)</ept>。</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following are some of the examples included in the article:</source>
          <target state="translated">以下是某些發行項中包含的範例：</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a format string</source>
          <target state="translated">建立的格式字串</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Inserting a string<ept id="p1">](#inserting-a-string)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>將字串插入<ept id="p1">](#inserting-a-string)</ept></target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The format item<ept id="p1">](#the-format-item)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>格式項目<ept id="p1">](#the-format-item)</ept></target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Format items that have the same index<ept id="p1">](#format-items-that-have-the-same-index)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>格式項目具有相同的索引<ept id="p1">](#format-items-that-have-the-same-index)</ept></target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Control formatted output</source>
          <target state="translated">控制格式化的輸出</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling formatting<ept id="p1">](#controlling-formatting)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>控制格式設定<ept id="p1">](#controlling-formatting)</ept></target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling spacing<ept id="p1">](#controlling-spacing)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>控制間距<ept id="p1">](#controlling-spacing)</ept></target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling alignment<ept id="p1">](#controlling-alignment)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>控制對齊方式<ept id="p1">](#controlling-alignment)</ept></target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling the number of integral digits<ept id="p1">](#how-do-i-control-the-number-of-integral-digits)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>控制整數位數的數目<ept id="p1">](#how-do-i-control-the-number-of-integral-digits)</ept></target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling the number of digits after the decimal separator<ept id="p1">](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>控制小數分隔符號之後的數字的數目<ept id="p1">](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)</ept></target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Including literal braces in a result string<ept id="p1">](#braces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>結果字串中包括常值的大括號<ept id="p1">](#braces)</ept></target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Make format strings culture-sensitive</source>
          <target state="translated">進行區分文化特性的格式字串</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Culture-sensitive formatting<ept id="p1">](#culture-sensitive-formatting)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>文化特性格式<ept id="p1">](#culture-sensitive-formatting)</ept></target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Customize the formatting operation</source>
          <target state="translated">自訂格式化作業</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>A custom formatting operation<ept id="p1">](#example-a-custom-formatting-operation)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>自訂格式化作業<ept id="p1">](#example-a-custom-formatting-operation)</ept></target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>An intercept provider and Roman numeral formatter<ept id="p1">](#example-an-intercept-provider-and-roman-numeral-formatter)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>截距，提供者和羅馬數字格式器<ept id="p1">](#example-an-intercept-provider-and-roman-numeral-formatter)</ept></target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>複合格式字串<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>The object to format.</source>
          <target state="translated">要格式化的物件。</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>Replaces one or more format items in a string with the string representation of a specified object.</source>
          <target state="translated">以指定物件的字串表示，取代字串中的一或多個格式項目。</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which any format items are replaced by the string representation of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 的複本，其中的所有格式項目已由 <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> 的字串表示取代。</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of an expression to its string representation and to embed that representation in a string.</source>
          <target state="translated">這個方法會使用<bpt id="p1">[</bpt>複合格式功能<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>運算式的值轉換成其字串表示，以及該表示嵌入字串。</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object)">
          <source>Example: Formatting a single argument</source>
          <target state="translated">範例： 格式為單一引數</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> method to embed an individual's age in the middle of a string.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph>內嵌字串中間的個人的年齡的方法。</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>The format item in <ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 中的格式項目無效。</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>The index of a format item is not zero.</source>
          <target state="translated">格式項目的索引不是零。</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>複合格式字串<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>An object array that contains zero or more objects to format.</source>
          <target state="translated">物件陣列，包含零或多個要格式化的物件。</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</source>
          <target state="translated">以指定陣列中對應物件的字串表示，取代指定之字串中的格式項目。</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representation of the corresponding objects in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 的複本，其中的格式項目已由 <ph id="ph2">&lt;paramref name="args" /&gt;</ph> 中對應物件的字串表示取代。</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of four or more expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">這個方法會使用<bpt id="p1">[</bpt>複合格式功能<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>四個或多個運算式的值轉換成其字串表示法，並在這些表示法嵌入字串。</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Since the <ph id="ph1">`args`</ph> parameter is marked with the <ph id="ph2">&lt;xref:System.ParamArrayAttribute?displayProperty=nameWithType&gt;</ph> attribute, you can pass the objects to the method as individual arguments or as an <ph id="ph3">&lt;xref:System.Object&gt;</ph> array.</source>
          <target state="translated">因為<ph id="ph1">`args`</ph>參數標示為<ph id="ph2">&lt;xref:System.ParamArrayAttribute?displayProperty=nameWithType&gt;</ph>屬性，您可以將物件傳遞至方法做為個別引數，或做為<ph id="ph3">&lt;xref:System.Object&gt;</ph>陣列。</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Example: Formatting more than three arguments</source>
          <target state="translated">範例： 格式化超過三個引數</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>This example creates a string that contains data on the high and low temperature on a particular date.</source>
          <target state="translated">這個範例會建立字串，包含在特定日期的高低溫度資料。</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>The composite format string has five format items in the C# example and six in the Visual Basic example.</source>
          <target state="translated">複合格式字串有五個格式項目，在 C# 範例和六個 in Visual Basic 範例。</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Two of the format items define the width of their corresponding value's string representation, and the first format item also includes a standard date and time format string.</source>
          <target state="translated">兩個格式項目定義及其對應值的字串表示，寬度，並將第一個格式項目也會包含標準日期和時間格式字串。</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>You can also pass the objects to be formatted as an array rather than a an argument list.</source>
          <target state="translated">您也可以傳遞要格式化為陣列的物件而非引數清單。</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> or <ph id="ph2">&lt;paramref name="args" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="args" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>The index of a format item is less than zero, or greater than or equal to the length of the <ph id="ph1">&lt;paramref name="args" /&gt;</ph> array.</source>
          <target state="translated">格式項目的索引小於零，或者大於或等於 <ph id="ph1">&lt;paramref name="args" /&gt;</ph> 陣列的長度。</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>複合格式字串<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>The object to format.</source>
          <target state="translated">要格式化的物件。</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>Replaces the format item or items in a specified string with the string representation of the corresponding object.</source>
          <target state="translated">以對應物件的字串表示，取代指定之字串中的一或多個格式項目。</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>A parameter supplies culture-specific formatting information.</source>
          <target state="translated">參數提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format item or items have been replaced by the string representation of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 的複本，其中的一或多個格式項目已由 <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> 的字串表示取代。</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of an expression to its string representation and to embed that representation in a string.</source>
          <target state="translated">這個方法會使用<bpt id="p1">[</bpt>複合格式功能<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>運算式的值轉換成其字串表示，以及該表示嵌入字串。</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">執行轉換，此方法會使用區分文化特性的格式設定或自訂格式器。</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>The method converts <ph id="ph1">`arg0`</ph> to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">方法會將轉換<ph id="ph1">`arg0`</ph>為其字串表示，藉由呼叫其<bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept>方法或，如果物件的對應格式項目會藉由呼叫包含格式字串，其<bpt id="p2">**</bpt>ToString (字串，IFormatProvider）<ept id="p2">**</ept>方法。</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">如果這些方法不存在，則會呼叫物件的無參數<bpt id="p1">**</bpt>ToString<ept id="p1">**</ept>方法。</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> or <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>The index of a format item is less than zero, or greater than or equal to one.</source>
          <target state="translated">格式項目的索引小於零或大於等於一。</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>複合格式字串<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>An object array that contains zero or more objects to format.</source>
          <target state="translated">物件陣列，包含零或多個要格式化的物件。</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>Replaces the format items in a string with the string representations of corresponding objects in a specified array.</source>
          <target state="translated">以指定陣列中對應物件的字串表示，取代字串中的格式項目。</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>A parameter supplies culture-specific formatting information.</source>
          <target state="translated">參數提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representation of the corresponding objects in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 的複本，其中的格式項目已由 <ph id="ph2">&lt;paramref name="args" /&gt;</ph> 中對應物件的字串表示取代。</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert four or more expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">這個方法會使用<bpt id="p1">[</bpt>複合格式功能<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>將四個或多個運算式轉換成其字串表示法，以及這些表示法嵌入字串。</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">執行轉換，此方法會使用區分文化特性的格式設定或自訂格式器。</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>The method converts each <ph id="ph1">&lt;xref:System.Object&gt;</ph> argument to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">方法會將轉換每個<ph id="ph1">&lt;xref:System.Object&gt;</ph>引數為其字串表示，藉由呼叫其<bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept>方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其<bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept>方法。</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">如果這些方法不存在，則會呼叫物件的無參數<bpt id="p1">**</bpt>ToString<ept id="p1">**</ept>方法。</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>Example: Culture-sensitive formatting</source>
          <target state="translated">範例： 區分文化特性的格式化</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>This example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method to display the string representation of some date and time values and numeric values by using several different cultures.</source>
          <target state="translated">這個範例會使用<ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph>方法，以顯示一些日期和時間值和數值的字串表示，使用數個不同的文化特性。</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> or <ph id="ph2">&lt;paramref name="args" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="args" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>The index of a format item is less than zero, or greater than or equal to the length of the <ph id="ph1">&lt;paramref name="args" /&gt;</ph> array.</source>
          <target state="translated">格式項目的索引小於零，或者大於或等於 <ph id="ph1">&lt;paramref name="args" /&gt;</ph> 陣列的長度。</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>複合格式字串<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">要格式化的第一個物件。</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">要格式化的第二個物件。</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of two specified objects.</source>
          <target state="translated">以兩個指定物件的字串表示，取代字串中的格式項目。</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which format items are replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> and <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 的複本，其中的格式項目已由 <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> 和 <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> 的字串表示取代。</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of two expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">這個方法會使用<bpt id="p1">[</bpt>複合格式功能<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>將兩個運算式的值轉換成其字串表示法，並在字串中嵌入這些表示法。</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>Example: Formatting two arguments</source>
          <target state="translated">範例： 設定格式化的兩個引數</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>This example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29&gt;</ph> method to display time and temperature data stored in a generic <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> object.</source>
          <target state="translated">這個範例會使用<ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29&gt;</ph>方法，以顯示儲存在一般時間和溫度資料<ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>Note that the format string has three format items, although there are only two objects to format.</source>
          <target state="translated">請注意在格式字串有三個格式項目，雖然只有兩個要格式化的物件。</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>This is because the first object in the list (a date and time value) is used by two format items: The first format item displays the time, and the second displays the date.</source>
          <target state="translated">這是因為清單 （日期和時間值） 中的第一個物件由兩個格式項目： 第一個格式項目顯示，並且第二個顯示的日期。</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>The index of a format item is not zero or one.</source>
          <target state="translated">格式項目的索引不是零或一。</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>複合格式字串<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">要格式化的第一個物件。</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">要格式化的第二個物件。</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of two specified objects.</source>
          <target state="translated">以兩個指定物件的字串表示，取代字串中的格式項目。</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>A parameter supplies culture-specific formatting information.</source>
          <target state="translated">參數提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which format items are replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> and <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 的複本，其中的格式項目已由 <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> 和 <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> 的字串表示取代。</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert two expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">這個方法會使用<bpt id="p1">[</bpt>複合格式功能<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>來將兩個運算式轉換成其字串表示法，並在字串中嵌入這些表示法。</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">執行轉換，此方法會使用區分文化特性的格式設定或自訂格式器。</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The method converts each <ph id="ph1">&lt;xref:System.Object&gt;</ph> argument to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">方法會將轉換每個<ph id="ph1">&lt;xref:System.Object&gt;</ph>引數為其字串表示，藉由呼叫其<bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept>方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其<bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept>方法。</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">如果這些方法不存在，則會呼叫物件的無參數<bpt id="p1">**</bpt>ToString<ept id="p1">**</ept>方法。</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph>, <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph><ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The index of a format item is less than zero, or greater than or equal to two.</source>
          <target state="translated">格式項目的索引小於零或大於等於二。</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>複合格式字串<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">要格式化的第一個物件。</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">要格式化的第二個物件。</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The third object to format.</source>
          <target state="translated">要格式化的第三個物件。</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of three specified objects.</source>
          <target state="translated">以三個指定物件的字串表示，取代字串中的格式項目。</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 的複本，其中的格式項目已由 <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>、<ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> 和 <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph> 的字串表示取代。</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of three expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">這個方法會使用<bpt id="p1">[</bpt>複合格式功能<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>三個運算式的值轉換成其字串表示法，並在這些表示法嵌入字串。</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>Example: Formatting three arguments</source>
          <target state="translated">範例： 設定格式化的三個引數</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>This example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> method to create a string that illustrates the result of a Boolean <ph id="ph2">`And`</ph> operation with two integer values.</source>
          <target state="translated">這個範例會使用<ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph>方法來建立字串，其中說明的布林值結果<ph id="ph2">`And`</ph>具有兩個整數值的作業。</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>Note that the format string includes six format items, but the method has only three items in its parameter list, because each item is formatted in two different ways.</source>
          <target state="translated">請注意，格式字串包含六個格式項目，但是方法只有三個項目在其參數清單中，因為每個項目會以兩個不同的方式格式化。</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The index of a format item is less than zero, or greater than two.</source>
          <target state="translated">格式項目的索引小於零或大於二。</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>複合格式字串<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">要格式化的第一個物件。</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">要格式化的第二個物件。</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The third object to format.</source>
          <target state="translated">要格式化的第三個物件。</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of three specified objects.</source>
          <target state="translated">以三個指定物件的字串表示，取代字串中的格式項目。</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>An parameter supplies culture-specific formatting information.</source>
          <target state="translated">參數提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 的複本，其中的格式項目已由 <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>、<ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> 和 <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph> 的字串表示取代。</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert three expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">這個方法會使用<bpt id="p1">[</bpt>複合格式功能<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>將三個運算式轉換成其字串表示法，以及這些表示法嵌入字串。</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">執行轉換，此方法會使用區分文化特性的格式設定或自訂格式器。</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The method converts each <ph id="ph1">&lt;xref:System.Object&gt;</ph> argument to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">方法會將轉換每個<ph id="ph1">&lt;xref:System.Object&gt;</ph>引數為其字串表示，藉由呼叫其<bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept>方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其<bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept>方法。</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">如果這些方法不存在，則會呼叫物件的無參數<bpt id="p1">**</bpt>ToString<ept id="p1">**</ept>方法。</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph>, <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph>、<ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>、<ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph> 為 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The index of a format item is less than zero, or greater than or equal to three.</source>
          <target state="translated">格式項目的索引小於零或大於等於三。</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" uid="M:System.String.GetEnumerator">
          <source>Retrieves an object that can iterate through the individual characters in this string.</source>
          <target state="translated">擷取可以逐一查看這個字串中個別字元的物件。</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" uid="M:System.String.GetEnumerator">
          <source>An enumerator object.</source>
          <target state="translated">列舉程式物件。</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>Rather than calling the <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.CharEnumerator&gt;</ph> object that you then use to enumerate a string, you should instead use your language's iteration construct ( in C#,  in C++/CLR, and  in Visual Basic).</source>
          <target state="translated">而不是呼叫<ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph>方法來擷取<ph id="ph2">&lt;xref:System.CharEnumerator&gt;</ph>物件，然後使用列舉字串，您應該改為使用您語言的反覆項目建構 (在 C# 中，在 C + + CLR，以及在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source><bpt id="p1">[</bpt>foreach<ept id="p1">](~/docs/csharp/language-reference/keywords/foreach-in.md)</ept> in C#,                  <bpt id="p2">[</bpt>for each<ept id="p2">](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79)</ept> in C++/CLR, and                  <bpt id="p3">[</bpt>For Each<ept id="p3">](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)</ept> in Visual Basic).</source>
          <target state="translated"><bpt id="p1">[</bpt>foreach<ept id="p1">](~/docs/csharp/language-reference/keywords/foreach-in.md)</ept>在 C# 中，<bpt id="p2">[</bpt>每個<ept id="p2">](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79)</ept>在 C + + CLR 和<bpt id="p3">[</bpt>每個<ept id="p3">](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)</ept>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>This method enables you to iterate the individual characters in a string.</source>
          <target state="translated">這個方法可讓您逐一查看字串中的個別字元。</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>For example, the Visual Basic <ph id="ph1">`For Each`</ph> and C# <ph id="ph2">`foreach`</ph> statements invoke this method to return a <ph id="ph3">&lt;xref:System.CharEnumerator&gt;</ph> object that can provide read-only access to the characters in this string instance.</source>
          <target state="translated">例如，Visual Basic<ph id="ph1">`For Each`</ph>和 C#<ph id="ph2">`foreach`</ph>陳述式會叫用此方法以傳回<ph id="ph3">&lt;xref:System.CharEnumerator&gt;</ph>可以提供唯讀存取，這個字串執行個體中的字元的物件。</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>The following example iterates the characters in several strings and displays information about their individual characters.</source>
          <target state="translated">下列範例會逐一查看數個字串中的字元，並顯示其個別字元的相關資訊。</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>It uses the language iteration construct rather than a call to the <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> method.</source>
          <target state="translated">它會使用語言反覆項目建構，而不是呼叫<ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" uid="M:System.String.GetHashCode">
          <source>Returns the hash code for this string.</source>
          <target state="translated">傳回這個字串的雜湊碼。</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" uid="M:System.String.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">32 位元帶正負號的整數雜湊碼。</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The behavior of <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> is dependent on its implementation, which might change from one version of the common language runtime to another.</source>
          <target state="translated">行為<ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph>相依於它的實作，可能會變更到另一個版本的 common language runtime。</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>A reason why this might happen is to improve the performance of <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">為什麼這可能會發生的原因是要提升的效能<ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>If two string objects are equal, the <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> method returns identical values.</source>
          <target state="translated">如果兩個 string 物件是否相等，<ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph>方法會傳回相同的值。</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>However, there is not a unique hash code value for each unique string value.</source>
          <target state="translated">不過，沒有任何每個唯一字串值的唯一雜湊碼值。</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Different strings can return the same hash code.</source>
          <target state="translated">不同的字串可以傳回相同的雜湊碼。</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The hash code itself is not guaranteed to be stable.</source>
          <target state="translated">雜湊程式碼本身並非是穩定。</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Hash codes for identical strings can differ across versions of the .NET Framework and across platforms (such as 32-bit and 64-bit) for a single version of the .NET Framework.</source>
          <target state="translated">.NET Framework 的版本和跨平台 （例如，32 位元和 64 位元） 的單一版本的.NET framework 相同字串的雜湊程式碼可能會不同。</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>In some cases, they can even differ by application domain.</source>
          <target state="translated">在某些情況下，它們可以甚至不同由應用程式定義域。</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>This implies two subsequent runs of the same program may return different hash codes.</source>
          <target state="translated">這表示兩個後續執行相同的程式可能會傳回不同的雜湊碼。</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.</source>
          <target state="translated">如此一來，雜湊碼應該永遠不會使用外部應用程式定義域中建立，它們應該永遠不會做為集合中的索引鍵欄位，它們應該永遠不會保存。</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Finally, don't use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</source>
          <target state="translated">最後，不要使用雜湊程式碼而不是如果您需要的密碼編譯強式雜湊，密碼編譯雜湊函式所傳回的值。</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>For cryptographic hashes, use a class derived from the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">密碼編譯雜湊，若為使用衍生自類別<ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph>或<ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>For more information about hash codes, see <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需雜湊程式碼的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>In desktop apps, you can use the             <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm&gt; element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept> to generate unique hash codes on a per application domain basis.</source>
          <target state="translated">在桌面應用程式，您可以使用<bpt id="p1">[</bpt> <ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm &gt; 項目<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>產生唯一的雜湊程式碼在每個應用程式定義域做為基準。</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</source>
          <target state="translated">這可減少衝突的數目，並改善整體效能的插入和使用雜湊資料表的查閱。</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The following example shows how to use the                <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm&gt; element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>.</source>
          <target state="translated">下列範例示範如何使用<bpt id="p1">[</bpt> <ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm &gt; 項目<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It defines a  to generate unique hash codes on a per application domain basis.</source>
          <target state="translated">它會定義以產生唯一的雜湊程式碼在每個應用程式定義域做為基準。</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</source>
          <target state="translated">這可減少衝突的數目，並改善整體效能的插入和使用雜湊資料表的查閱。</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The following example shows how to use the .</source>
          <target state="translated">下列範例示範如何使用。</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It defines a <ph id="ph1">`DisplayString`</ph> class that includes a private string constant, <ph id="ph2">`s`</ph>, whose value is "This is a string."</source>
          <target state="translated">它會定義<ph id="ph1">`DisplayString`</ph>類別，其中包含私用的字串常數， <ph id="ph2">`s`</ph>，其值為"This is 字串"。</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It also includes a <ph id="ph1">`ShowStringHashCode`</ph> method that displays the string value and its hash code along with the name of the application domain in which the method is executing.</source>
          <target state="translated">它也包含 <ph id="ph1">`ShowStringHashCode`</ph> 方法，這個方法會將字串值及其雜湊碼與方法執行所在之應用程式定義域的名稱一起顯示。</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>When you run the example without supplying a configuration file, it displays output similar to the following.</source>
          <target state="translated">當您在沒有提供組態檔的情況下執行此範例，它會顯示類似下列的輸出。</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Note that the hash codes for the string are identical in the two application domains.</source>
          <target state="translated">請注意，字串的雜湊碼在兩個應用程式定義域中相同。</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.</source>
          <target state="translated">不過，如果您將下列組態檔加入至範例的目錄，然後執行這個範例，相同字串的雜湊碼將會因為應用程式定義域不同而有所不同。</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>When the configuration file is present, the example displays the following output:</source>
          <target state="translated">當組態檔存在時，這個範例會顯示下列輸出：</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Hash codes are used to insert and retrieve keyed objects from hash tables efficiently.</source>
          <target state="translated">雜湊程式碼用來插入和有效率地擷取雜湊表中的索引鍵的物件。</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>However, hash codes don't uniquely identify strings.</source>
          <target state="translated">不過，雜湊程式碼不可唯一識別字串。</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings.</source>
          <target state="translated">相同的字串具有相同的雜湊碼，但 common language runtime 也可以將相同的雜湊程式碼指派給不同的字串。</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>In addition, hash codes can vary by version of the .NET Framework, by platform within a single version, and by application domain.</source>
          <target state="translated">此外，.NET Framework 版本、 平台內的單一版本，和應用程式定義域，可能會不同雜湊碼。</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.</source>
          <target state="translated">因為這個緣故，您不應該序列化，或保存雜湊程式碼的值，也不應使用它們作為雜湊表或字典中索引鍵。</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>For additional information about the use of hash codes and the <ph id="ph1">`GetHashCode`</ph> method, see <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需使用雜湊程式碼的其他資訊和<ph id="ph1">`GetHashCode`</ph>方法，請參閱<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> method using various input strings.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph>方法使用不同的輸入字串。</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The value returned by <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> is platform-dependent.</source>
          <target state="translated">所傳回的值<ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph>平台而異。</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It differs on the 32-bit and 64-bit versions of the .NET Framework.</source>
          <target state="translated">在 32 位元和 64 位元版本的.NET framework 上不相同。</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It also can differ between versions of the .NET Framework.</source>
          <target state="translated">它也可以不同的.NET framework 版本之間。</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" uid="M:System.String.GetTypeCode">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.TypeCode" /&gt;</ph> for class <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">傳回類別 <ph id="ph1">&lt;see cref="T:System.TypeCode" /&gt;</ph> 的 <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" uid="M:System.String.GetTypeCode">
          <source>The enumerated constant, <ph id="ph1">&lt;see cref="F:System.TypeCode.String" /&gt;</ph>.</source>
          <target state="translated">列舉常數 <ph id="ph1">&lt;see cref="F:System.TypeCode.String" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetTypeCode">
          <source>The following example displays the <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> enumerated constant for the <ph id="ph2">&lt;xref:System.String&gt;</ph> type.</source>
          <target state="translated">下列範例會顯示<ph id="ph1">&lt;xref:System.TypeCode&gt;</ph>列舉的常數的<ph id="ph2">&lt;xref:System.String&gt;</ph>型別。</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the zero-based index of the first occurrence of a specified Unicode character or string within this instance.</source>
          <target state="translated">報告這個執行個體中指定之 Unicode 字元或字串第一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the character or string is not found in this instance.</source>
          <target state="translated">如果在此執行個體中找不到該字元或字串，此方法會傳回 -1。</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char)">
          <source>A Unicode character to seek.</source>
          <target state="translated">要搜尋的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char)">
          <source>Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</source>
          <target state="translated">報告這個字串中指定之 Unicode 字元第一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not.</source>
          <target state="translated">如果找到該字元，則為 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 以零為起始的索引位置，如果找不到為 -1。</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">若要執行區分文化特性的搜尋，請使用<ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>The following example demonstrates how you can search a <ph id="ph1">&lt;xref:System.String&gt;</ph> for a character using the <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範如何搜尋<ph id="ph1">&lt;xref:System.String&gt;</ph>字元使用<ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>The string to seek.</source>
          <target state="translated">要搜尋的字串。</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
          <target state="translated">回報這個執行個體中指定之字串第一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not.</source>
          <target state="translated">如果找到該字串，則為 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 以零為起始的索引位置，如未找到，則為 -1。</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is 0.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則傳回值是 0。</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>The search begins at the first character position of this instance and continues until the last character position.</source>
          <target state="translated">搜尋會從這個執行個體，第一個字元位置開始，並接著直到最後一個字元位置。</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">執行區分文化特性的搜尋時，如果 <ph id="ph1">`value`</ph> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</source>
          <target state="translated">如果<ph id="ph1">`value`</ph>只包含一個或多個可忽略的字元，<ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph>方法一律會傳回 0 （零），表示比對位於目前的執行個體的開頭。</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">在下列範例中，<ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph>方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)、"n"，後面接著選擇性連字號和選擇性的連字號後面接著"m"）。</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">只有其中一個字串包含選擇性連字號。</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in <ph id="ph2">`value`</ph>.</source>
          <target state="translated">如果執行範例<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，在每個案例中，因為選擇性連字號是可忽略的字元，結果會與相同選擇性連字號不包含在<ph id="ph2">`value`</ph>。</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.</source>
          <target state="translated">當搜尋軟連，方法會傳回 0 （零），表示它已在字串的開頭找到相符項目。</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>The following example searches for the "n" in "animal".</source>
          <target state="translated">下列範例會搜尋"n"中"動物"。</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Because string indexes begin at zero rather than one, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method indicates that the "n" is at position 1.</source>
          <target state="translated">由於字串索引從零，而不是一個開始<ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph>方法表示"n"是在位置 1。</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to determine the starting position of an animal name in a sentence.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法，以判斷動物名稱的句子中的開始位置。</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>It then uses this position to insert an adjective that describes the animal into the sentence.</source>
          <target state="translated">然後會使用這個位置插入形容詞所描述的代表動物句子插入。</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">中所述<bpt id="p1">[</bpt>使用字串的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>To find the first index of a substring within a string instance by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">`comparisonType`</ph> parameter.</source>
          <target state="translated">若要尋找的字串執行個體的子字串的第一個索引，使用目前文化特性的比較規則，請呼叫<ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph>方法多載，其值為<ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph>針對其<ph id="ph3">`comparisonType`</ph>參數。</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>A Unicode character to seek.</source>
          <target state="translated">要搜尋的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</source>
          <target state="translated">報告這個字串中指定之 Unicode 字元第一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The search starts at a specified character position.</source>
          <target state="translated">搜尋從指定的字元位置開始。</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the string if that character is found, or -1 if it is not.</source>
          <target state="translated">如果找到該字元，則為從字串起始處之 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 的以零為起始索引位置，如果找不到，則為 -1。</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>Index numbering starts from 0.</source>
          <target state="translated">索引編號從 0 開始。</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> 參數的範圍可以從 0 到字串執行個體的長度。</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
          <target state="translated">如果<ph id="ph1">`startIndex`</ph>等於字串執行個體的長度，此方法會傳回-1。</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The search ranges from <ph id="ph1">`startIndex`</ph> to the end of the string.</source>
          <target state="translated">搜尋範圍是從<ph id="ph1">`startIndex`</ph>以字串的結尾。</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">若要執行區分文化特性的搜尋，請使用<ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 (zero) or greater than the length of the string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 小於 0 (零) 或大於字串的長度。</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">要搜尋的字串。</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
          <target state="translated">回報這個執行個體中指定之字串第一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The search starts at a specified character position.</source>
          <target state="translated">搜尋從指定的字元位置開始。</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">如果找到該字串，則為從目前執行個體起始處之 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 的以零為起始索引位置；如果找不到，則為 -1。</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則傳回值是 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Index numbering starts from 0.</source>
          <target state="translated">索引編號從 0 開始。</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> 參數的範圍可以從 0 到字串執行個體的長度。</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
          <target state="translated">如果<ph id="ph1">`startIndex`</ph>等於字串執行個體的長度，此方法會傳回-1。</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and continues until the last character position.</source>
          <target state="translated">搜尋開始於<ph id="ph1">`startIndex`</ph>字元位置，這個執行個體，並接著直到最後一個字元位置。</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">執行區分文化特性的搜尋時，如果 <ph id="ph1">`value`</ph> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">如果<ph id="ph1">`value`</ph>只包含一個或多個可忽略的字元，<ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph>方法一律會傳回<ph id="ph3">`startIndex`</ph>，即開始搜尋的字元位置。</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings.</source>
          <target state="translated">在下列範例中，<ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph>方法用來尋找後面接著"m"兩個字串中選擇性連字號 (U + 00AD) 的位置。</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">只有其中一個字串包含必要的子字串。</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string.</source>
          <target state="translated">如果執行範例<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引。</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The following example searches for all occurrences of a specified string within a target string.</source>
          <target state="translated">下列範例會搜尋所有出現的目標字串中指定的字串。</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 (zero) or greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 小於 0 (零) 或大於這個字串的長度。</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">中所述<bpt id="p1">[</bpt>使用字串的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>To find the first index of a substring that occurs after a particular character position by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">`comparisonType`</ph> parameter.</source>
          <target state="translated">若要尋找特定的字元位置之後的子字串，就會發生的第一個索引，使用目前文化特性的比較規則，請呼叫<ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph>方法多載，其值為<ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph>針對其<ph id="ph3">`comparisonType`</ph>參數。</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">要搜尋的字串。</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">其中一個列舉值，指定搜尋規則。</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">報告目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件中指定之字串第一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>A parameter specifies the type of search to use for the specified string.</source>
          <target state="translated">參數會指定要用於指定字串的搜尋類型。</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not.</source>
          <target state="translated">如果找到該字串，則為 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 的索引位置，如果沒有找到，則為 -1。</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is 0.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則傳回值是 0。</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph>參數會指定要搜尋<ph id="ph2">`value`</ph>參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用文字或序數比較規則。</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method that find the first occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">下列 exampledemonstrates 三個多載的<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>尋找另一個使用的不同值的字串內的字串的第一個出現位置的方法<ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是有效的 <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">執行區分文化特性的搜尋 (也就是說，如果 <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> 或 <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>) 時，如果 <ph id="ph4">&lt;paramref name="value" /&gt;</ph> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</source>
          <target state="translated">如果<ph id="ph1">&lt;paramref name="value" /&gt;</ph>只包含一個或多個可忽略的字元，<ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph>方法一律會傳回 0 （零），表示比對位於目前的執行個體的開頭。</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">在下列範例中，<ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph>方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)、"n"，後面接著選擇性連字號和選擇性的連字號後面接著"m"）。</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">只有其中一個字串包含選擇性連字號。</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</source>
          <target state="translated">如果執行範例<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，因為選擇性連字號是可忽略的字元，區分文化特性的搜尋傳回相同的值，它就會傳回如果搜尋字串中未包含選擇性連字號。</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</source>
          <target state="translated">序數搜尋，不過，順利在一個字串中尋找選擇性連字號，並報告它不存在從第二個字串。</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>A Unicode character to seek.</source>
          <target state="translated">要搜尋的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">要檢視的字元位置數目。</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified character in this instance.</source>
          <target state="translated">報告這個執行個體中指定之字元第一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
          <target state="translated">搜尋從指定的字元位置開始，並檢視指定數目的字元位置。</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the string if that character is found, or -1 if it is not.</source>
          <target state="translated">如果找到該字元，則為從字串起始處之 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 的以零為起始索引位置，如果找不到，則為 -1。</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">搜尋開始於<ph id="ph1">`startIndex`</ph>，並且會繼續<ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1。</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">在字元<ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph>未包含在搜尋中。</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>Index numbering starts from 0 (zero).</source>
          <target state="translated">索引編號從 0 （零） 開始。</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> 參數的範圍可以從 0 到字串執行個體的長度。</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">若要執行區分文化特性的搜尋，請使用<ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 大於這個字串的長度。</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 大於這個字串減 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">要搜尋的字串。</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">要檢視的字元位置數目。</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
          <target state="translated">回報這個執行個體中指定之字串第一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
          <target state="translated">搜尋從指定的字元位置開始，並檢視指定數目的字元位置。</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">如果找到該字串，則為從目前執行個體起始處之 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 的以零為起始索引位置；如果找不到，則為 -1。</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則傳回值是 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Index numbering starts from 0 (zero).</source>
          <target state="translated">索引編號從 0 （零） 開始。</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> 參數的範圍可以從 0 到字串執行個體的長度。</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">搜尋開始於<ph id="ph1">`startIndex`</ph>，並且會繼續<ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1。</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">在字元<ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph>未包含在搜尋中。</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">執行區分文化特性的搜尋時，如果 <ph id="ph1">`value`</ph> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">如果<ph id="ph1">`value`</ph>只包含一個或多個可忽略的字元，<ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>方法一律會傳回<ph id="ph3">`startIndex`</ph>，即開始搜尋的字元位置。</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</source>
          <target state="translated">在下列範例中，<ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>方法用來尋找選擇性連字號 (U + 00AD) 後面接著"m"中的第三個透過兩個字串中的第六個字元位置開始的位置。</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">只有其中一個字串包含必要的子字串。</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">如果執行範例<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The following example finds the index of all occurrences of the string "he" within a substring of another string.</source>
          <target state="translated">下列範例會尋找的索引字串的所有項目之"he"另一個字串的子字串內。</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Note that the number of characters to be searched must be recalculated for each search iteration.</source>
          <target state="translated">請注意要搜尋的字元數，必須重新計算針對每個搜尋反覆項目。</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 大於這個字串的長度。</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 大於這個字串減 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">中所述<bpt id="p1">[</bpt>使用字串的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>To use the comparison rules of the current culture to perform this operation, call the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">`comparisonType`</ph> parameter.</source>
          <target state="translated">若要使用目前文化特性的比較規則，執行這項作業，請呼叫<ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph>方法多載，其值為<ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph>針對其<ph id="ph3">`comparisonType`</ph>參數。</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">要搜尋的字串。</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">其中一個列舉值，指定搜尋規則。</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">報告目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件中指定之字串第一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Parameters specify the starting search position in the current string and the type of search to use for the specified string.</source>
          <target state="translated">參數會指定目前字串中的開始搜尋位置和要用於指定字串的搜尋類型。</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The zero-based index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">如果找到該字串，則為從目前執行個體起始處之 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 參數的以零為起始索引位置；如果找不到，則為 -1。</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則傳回值是 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Index numbering starts from 0.</source>
          <target state="translated">索引編號從 0 開始。</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> 參數的範圍可以從 0 到字串執行個體的長度。</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
          <target state="translated">如果<ph id="ph1">`startIndex`</ph>等於字串執行個體的長度，此方法會傳回-1。</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph>參數會指定要搜尋<ph id="ph2">`value`</ph>參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用文字或序數比較規則。</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method that find the first occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">下列 exampledemonstrates 三個多載的<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>尋找另一個使用的不同值的字串內的字串的第一個出現位置的方法<ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 (zero) or greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 小於 0 (零) 或大於這個字串的長度。</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是有效的 <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">執行區分文化特性的搜尋 (也就是說，如果 <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> 或 <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>) 時，如果 <ph id="ph4">&lt;paramref name="value" /&gt;</ph> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">如果<ph id="ph1">&lt;paramref name="value" /&gt;</ph>只包含一個或多個可忽略的字元，<ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph>方法一律會傳回<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>，即開始搜尋的字元位置。</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting with the third character position in two strings.</source>
          <target state="translated">在下列範例中，<ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph>方法用來尋找選擇性連字號 (U + 00AD) 後面接著"m"中兩個字串的第三個字元位置開始的位置。</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">只有其中一個字串包含必要的子字串。如果執行範例<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">要搜尋的字串。</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The number of character positions to examine.</source>
          <target state="translated">要檢視的字元位置數目。</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">其中一個列舉值，指定搜尋規則。</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">報告目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件中指定之字串第一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</source>
          <target state="translated">參數會指定目前字串中的開始搜尋位置、目前字串中要搜尋的字元數目，以及要用於指定字串的搜尋類型。</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The zero-based index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">如果找到該字串，則為從目前執行個體起始處之 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 參數的以零為起始索引位置；如果找不到，則為 -1。</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則傳回值是 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Index numbering starts from 0 (zero).</source>
          <target state="translated">索引編號從 0 （零） 開始。</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> 參數的範圍可以從 0 到字串執行個體的長度。</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">搜尋開始於<ph id="ph1">`startIndex`</ph>，並且會繼續<ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1。</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">在字元<ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph>未包含在搜尋中。</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph>參數會指定要搜尋<ph id="ph2">`value`</ph>參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用文字或序數比較規則。</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method that find the first occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">下列 exampledemonstrates 三個多載的<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>尋找另一個使用的不同值的字串內的字串的第一個出現位置的方法<ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 大於這個執行個體的長度。</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 大於這個字串減 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是有效的 <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">執行區分文化特性的搜尋 (也就是說，如果 <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> 或 <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>) 時，如果 <ph id="ph4">&lt;paramref name="value" /&gt;</ph> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">如果<ph id="ph1">&lt;paramref name="value" /&gt;</ph>只包含一個或多個可忽略的字元，<ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph>方法一律會傳回<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>，即開始搜尋的字元位置。</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</source>
          <target state="translated">在下列範例中，<ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph>方法用來尋找選擇性連字號 (U + 00AD) 後面接著"m"中的第三個透過兩個字串中的第六個字元位置開始的位置。</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">只有其中一個字串包含必要的子字串。</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">如果執行範例<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>When it performs an ordinal comparison, however, it finds the substring only in the first string.</source>
          <target state="translated">當它執行序數比較時，不過，它會尋找子字串只能在第一個字串中。</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</source>
          <target state="translated">請注意，就第一個字串，其中包含選擇性連字號後面接著"m"，此方法無法傳回選擇性連字號的索引執行區分文化特性的比較時，而是傳回"m"的索引。</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">報告指定 Unicode 字元陣列中的任何字元於這個執行個體中第一個符合項目的索引。</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the characters in the array are not found in this instance.</source>
          <target state="translated">如果在此執行個體中找不到陣列中的字元，此方法會傳回 -1。</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Unicode 字元陣列，含有一或多個要搜尋的字元。</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">報告指定的 Unicode 字元陣列中，任何字元在這個執行個體中第一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>The zero-based index position of the first occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">在此執行個體中，<ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> 中的任何字元第一次出現的所在索引位置 (以零為起始)，如果找不到 <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> 中的字元，則為 -1。</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`anyOf`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>If <ph id="ph1">`anyOf`</ph> is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).</source>
          <target state="translated">如果<ph id="ph1">`anyOf`</ph>是空陣列，字串的開頭比對的方法會尋找 （亦即，索引位置為零）。</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">若要執行區分文化特性的搜尋，請使用<ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>The following example finds the first vowel in a string.</source>
          <target state="translated">下列範例會在字串中尋找第一個母音。</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Unicode 字元陣列，含有一或多個要搜尋的字元。</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">報告指定的 Unicode 字元陣列中，任何字元在這個執行個體中第一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search starts at a specified character position.</source>
          <target state="translated">搜尋從指定的字元位置開始。</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The zero-based index position of the first occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">在此執行個體中，<ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> 中的任何字元第一次出現的所在索引位置 (以零為起始)，如果找不到 <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> 中的字元，則為 -1。</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to one less than the length of the string instance.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph>參數的範圍可以從 0 到字串執行個體的長度減一。</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search ranges from <ph id="ph1">`startIndex`</ph> to the end of the string.</source>
          <target state="translated">搜尋範圍是從<ph id="ph1">`startIndex`</ph>以字串的結尾。</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`anyOf`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
          <target state="translated">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有當 Unicode 純量值都相同，字元會視為等於另一個字元。</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">若要執行區分文化特性的搜尋，請使用<ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The following example finds the index of the occurrence of any character of the string "is" within a substring of another string.</source>
          <target state="translated">下列範例會尋找的索引字串的任何字元一次出現"is"另一個字串的子字串內。</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the number of characters in this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 大於這個執行個體中的字元數。</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Unicode 字元陣列，含有一或多個要搜尋的字元。</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">要檢視的字元位置數目。</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">報告指定的 Unicode 字元陣列中，任何字元在這個執行個體中第一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
          <target state="translated">搜尋從指定的字元位置開始，並檢視指定數目的字元位置。</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The zero-based index position of the first occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">在此執行個體中，<ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> 中的任何字元第一次出現的所在索引位置 (以零為起始)，如果找不到 <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> 中的字元，則為 -1。</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">搜尋開始於<ph id="ph1">`startIndex`</ph>，並且會繼續<ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1。</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">在字元<ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph>未包含在搜尋中。</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to one less than the length of the string instance.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph>參數的範圍可以從 0 到字串執行個體的長度減一。</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
          <target state="translated">搜尋<ph id="ph1">`anyOf`</ph>會區分大小寫。</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
          <target state="translated">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有當 Unicode 純量值都相同，字元會視為等於另一個字元。</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">若要執行區分文化特性的搜尋，請使用<ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The following example finds the index of the occurrence of any character of the string "aid" within a substring of another string.</source>
          <target state="translated">下列範例會尋找另一個字串的子字串內的任何字元的字串"aid"的項目索引。</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is greater than the number of characters in this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 大於這個執行個體的字元數。</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The zero-based index position of the insertion.</source>
          <target state="translated">插入的索引位置 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The string to insert.</source>
          <target state="translated">要插入的字串。</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>Returns a new string in which a specified string is inserted at a specified index position in this instance.</source>
          <target state="translated">傳回新字串，其中已在這個執行個體中指定的索引位置插入指定的字串。</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>A new string that is equivalent to this instance, but with <ph id="ph1">&lt;paramref name="value" /&gt;</ph> inserted at position <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">與這個執行個體相等的新字串，但是在 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 位置插入了 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to the length of this instance, <ph id="ph2">`value`</ph> is appended to the end of this instance.</source>
          <target state="translated">如果<ph id="ph1">`startIndex`</ph>等於這個執行個體的長度<ph id="ph2">`value`</ph>附加至這個執行個體的結尾。</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>Instead, it returns a new string in which <ph id="ph1">`value`</ph> is inserted into the current instance.</source>
          <target state="translated">相反地，它會傳回新字串，其中<ph id="ph1">`value`</ph>插入至目前的執行個體。</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>For example, the return value of <ph id="ph1">`"abc".Insert(2, "XYZ")`</ph> is "abXYZc".</source>
          <target state="translated">例如，傳回值的<ph id="ph1">`"abc".Insert(2, "XYZ")`</ph>是 「 abXYZc"。</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The following example inserts a space character in the fourth character position (the character at index 3) of a string.</source>
          <target state="translated">下列範例會將空格字元在字串的第四個字元位置 （位於索引 3 的字元）。</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The following console application prompts the users to enter one or more adjectives to describe two animals.</source>
          <target state="translated">下列主控台應用程式會提示使用者輸入一或多個以描述兩個動物形容詞。</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> method to insert the text entered by the user into a string.</source>
          <target state="translated">然後它會呼叫<ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph>方法插入到字串的使用者所輸入的文字。</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is negative or greater than the length of this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 為負值或大於這個執行個體的長度。</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source>A string to search for in the intern pool.</source>
          <target state="translated">要在保留集區中搜尋的字串。</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source>Retrieves the system's reference to the specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">擷取指定的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的系統參考。</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source>The system's reference to <ph id="ph1">&lt;paramref name="str" /&gt;</ph>, if it is interned; otherwise, a new reference to a string with the value of <ph id="ph2">&lt;paramref name="str" /&gt;</ph>.</source>
          <target state="translated">如果已經保留，則為系統的 <ph id="ph1">&lt;paramref name="str" /&gt;</ph> 參考，否則為具有 <ph id="ph2">&lt;paramref name="str" /&gt;</ph> 值之字串的新參考。</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program.</source>
          <target state="translated">Common language runtime 可以節省字串儲存體，藉由維護稱為保留集區，其中包含每個唯一的常值字串，宣告或以程式設計方式建立在程式中的單一參考的資料表。</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Consequently, an instance of a literal string with a particular value only exists once in the system.</source>
          <target state="translated">因此，具有特定值的常值字串的執行個體只存在一次在系統中。</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.</source>
          <target state="translated">比方說，如果您將相同的常值字串指派給數個變數時，執行階段擷取的常值字串來保留集區從相同的參考，並將它指派給每個變數。</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method uses the intern pool to search for a string equal to the value of <ph id="ph2">`str`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph>方法會使用保留集區中，搜尋字串的值等於<ph id="ph2">`str`</ph>。</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>If such a string exists, its reference in the intern pool is returned.</source>
          <target state="translated">如果此類字串存在，則會傳回它在保留集區的參考。</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>If the string does not exist, a reference to <ph id="ph1">`str`</ph> is added to the intern pool, then that reference is returned.</source>
          <target state="translated">如果字串不存在，參考<ph id="ph1">`str`</ph>保留集區，則會傳回該參考加入。</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program.</source>
          <target state="translated">在下列範例中，字串 s1 有"MyTest"的值，是已被保留，因為它是在程式中的常值。</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.StringBuilder?displayProperty=nameWithType&gt;</ph> class generates a new string object that has the same value as s1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.StringBuilder?displayProperty=nameWithType&gt;</ph>類別會產生具有相同的值為 s1 的新字串物件。</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>A reference to that string is assigned to s2.</source>
          <target state="translated">該字串的參考，則指派給 s2。</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method searches for a string that has the same value as s2.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph>方法會搜尋具有相同的值為 s2 的字串。</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Because such a string exists, the method returns the same reference that is assigned to s1.</source>
          <target state="translated">因為此類字串存在，則方法會傳回相同的參考指派給 s1。</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>That reference is then assigned to s3.</source>
          <target state="translated">接著，該參考會指派給 s3。</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.</source>
          <target state="translated">參考 s1 和 s2 比較不相等因為兩者參考不同的物件。參考 s1 和 s3 比較相等，因為兩者參考相同的字串。</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Compare this method to the <ph id="ph1">&lt;xref:System.String.IsInterned%2A&gt;</ph> method.</source>
          <target state="translated">比較這個方法，以<ph id="ph1">&lt;xref:System.String.IsInterned%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Version Considerations</source>
          <target state="translated">版本的考量</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]</ph>、<ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph>方法還原成其行為在.NET Framework 1.0 和 1.1 中的關於實習空字串。</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the following example, the variable <ph id="ph1">`str1`</ph> is assigned a reference to <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>, and the variable <ph id="ph3">`str2`</ph> is assigned the reference to <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph> that is returned by calling the <ph id="ph5">&lt;xref:System.String.Intern%2A&gt;</ph> method after converting a <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph> object whose value is <ph id="ph7">&lt;xref:System.String.Empty&gt;</ph> to a string.</source>
          <target state="translated">在下列範例中，變數<ph id="ph1">`str1`</ph>參考會指派給<ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>，和變數<ph id="ph3">`str2`</ph>指派參考<ph id="ph4">&lt;xref:System.String.Empty&gt;</ph>藉由呼叫傳回<ph id="ph5">&lt;xref:System.String.Intern%2A&gt;</ph>方法轉換之後<ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph>物件，其值為<ph id="ph7">&lt;xref:System.String.Empty&gt;</ph>為字串。</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Then the references contained in <ph id="ph1">`str1`</ph> and <ph id="ph2">`str2`</ph> are compared for equality.</source>
          <target state="translated">然後中包含的參考<ph id="ph1">`str1`</ph>和<ph id="ph2">`str2`</ph>會比較是否相等。</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]</ph>, <ph id="ph2">[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>, <ph id="ph4">`str1`</ph> and <ph id="ph5">`str2`</ph> are equal.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]</ph>， <ph id="ph2">[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]</ph>，和<ph id="ph3">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>，<ph id="ph4">`str1`</ph>和<ph id="ph5">`str2`</ph>相等。</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph> and <ph id="ph2">[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]</ph>, <ph id="ph3">`str1`</ph> and <ph id="ph4">`str2`</ph> are not equal.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>和<ph id="ph2">[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]</ph>，<ph id="ph3">`str1`</ph>和<ph id="ph4">`str2`</ph>不相等。</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Performance Considerations</source>
          <target state="translated">效能考量</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects.</source>
          <target state="translated">如果您嘗試減少記憶體總數量會配置您的應用程式，請記住，實習字串有兩個不必要的副作用。</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>First, the memory allocated for interned <ph id="ph1">&lt;xref:System.String&gt;</ph> objects is not likely be released until the common language runtime (CLR) terminates.</source>
          <target state="translated">首先，記憶體配置給實習<ph id="ph1">&lt;xref:System.String&gt;</ph>物件不可能會釋出 common language runtime (CLR) 終止為止。</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The reason is that the CLR's reference to the interned <ph id="ph1">&lt;xref:System.String&gt;</ph> object can persist after your application, or even your application domain, terminates.</source>
          <target state="translated">原因在於實習的 CLR 參考<ph id="ph1">&lt;xref:System.String&gt;</ph>物件可以保存您的應用程式或甚至是您應用程式定義域之後，會終止。</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Second, to intern a string, you must first create the string.</source>
          <target state="translated">其次，若 intern 字串，您必須先建立字串。</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The memory used by the <ph id="ph1">&lt;xref:System.String&gt;</ph> object must still be allocated, even though the memory will eventually be garbage collected.</source>
          <target state="translated">所使用的記憶體<ph id="ph1">&lt;xref:System.String&gt;</ph>必須仍然即將配置給物件，即使記憶體會最後被記憶體回收。</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The .NET Framework version 2.0 introduces the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType&gt;</ph> enumeration member.</source>
          <target state="translated">.NET Framework 2.0 版導入了<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType&gt;</ph>列舉成員。</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> member marks an assembly as not requiring string-literal interning.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph>成員標記為不需要字串常值實習組件。</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>You can apply <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> to an assembly using the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute&gt;</ph> attribute.</source>
          <target state="translated">您可以套用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph>使用組件<ph id="ph2">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Also, when you use the <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> to compile an assembly in advance of run time, strings are not interned across modules.</source>
          <target state="translated">此外，當您使用<bpt id="p1">[</bpt>Ngen.exe （原生映像產生器）<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept>編譯組件之前 執行階段，字串不實習跨模組。</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The following example uses three strings that are equal in value to determine whether a newly created string and an interned string are equal.</source>
          <target state="translated">下列範例會使用三個值來判斷新建立的字串是否相等的字串，並已經保留的字串相等。</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source>The string to search for in the intern pool.</source>
          <target state="translated">要在保留集區中搜尋的字串。</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source>Retrieves a reference to a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">擷取對指定 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的參考。</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source>A reference to <ph id="ph1">&lt;paramref name="str" /&gt;</ph> if it is in the common language runtime intern pool; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果是在 Common Language Runtime 保留集區中，則為 <ph id="ph1">&lt;paramref name="str" /&gt;</ph> 的參考，否則為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <ph id="ph1">&lt;xref:System.String&gt;</ph> you add programmatically by calling the <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> method.</source>
          <target state="translated">Common language runtime 會自動維護的資料表，稱為保留集區，其中包含宣告中的程式，以及任何唯一的執行個體的每個唯一的常值字串常數的單一執行個體<ph id="ph1">&lt;xref:System.String&gt;</ph>以程式設計方式將藉由呼叫<ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>The intern pool conserves string storage.</source>
          <target state="translated">保留集區可以節省字串儲存體。</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <ph id="ph1">&lt;xref:System.String&gt;</ph> that have identical values.</source>
          <target state="translated">如果您將常值的字串常數指派給數個變數時，每個變數會設定為參考相同的常數在保留集區，而不是參考的數個不同的執行個體<ph id="ph1">&lt;xref:System.String&gt;</ph>具有相同的值。</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>This method looks up <ph id="ph1">`str`</ph> in the intern pool.</source>
          <target state="translated">這個方法會查詢<ph id="ph1">`str`</ph>在保留集區。</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>If <ph id="ph1">`str`</ph> has already been interned, a reference to that instance is returned; otherwise, <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">如果<ph id="ph1">`str`</ph>已經過實習，該執行個體的參考會傳回，否則<ph id="ph2">`null`</ph>傳回。</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>Compare this method to the <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method.</source>
          <target state="translated">比較這個方法，以<ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>This method does not return a Boolean value.</source>
          <target state="translated">這個方法不會傳回布林值。</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.</source>
          <target state="translated">如果您呼叫的方法，因為您想要的布林值，指出是否要實習的特定字串，您可以使用下列程式碼。</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> to install an assembly to the native image cache on a local computer.</source>
          <target state="translated">從.NET Framework 2.0 版開始，您可以覆寫的保留集區使用當您使用<bpt id="p1">[</bpt>Ngen.exe （原生映像產生器）<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept>組件安裝至本機電腦上的原生映像快取。</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>For more information, see Performance Considerations in the Remarks section for the <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> property.</source>
          <target state="translated">如需詳細資訊，請參閱 &lt; 備註 &gt; 一節中的效能考量<ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>The following example demonstrates that literal strings are interned automatically by the compiler.</source>
          <target state="translated">下列範例會示範常值字串由編譯器自動實習。</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Indicates whether this string is in a particular Unicode normalization form.</source>
          <target state="translated">指出這個字串是否為特定的 Unicode 正規化格式。</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized">
          <source>Indicates whether this string is in Unicode normalization form C.</source>
          <target state="translated">指出這個字串是否為 Unicode 正規化格式 C。</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this string is in normalization form C; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果這個字串為正規化格式 C，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">某些 Unicode 字元有組成組結合多個對等二進位表示法和/或複合的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">有多種表示的單一字元得搜尋、 排序、 比對，和其他作業。</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">Unicode 標準會定義稱為會傳回一個二進位表示法時指定任何字元的對等二進位表示的正規化的程序。</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">可以使用數種演算法，稱為正規化表單，會遵循不同的規則，執行正規化。</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The .NET Framework currently supports normalization forms C, D, KC, and KD.</source>
          <target state="translated">.NET Framework 目前支援的正規化表單 C、 D、 KC 和 KD。</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需支援的 Unicode 正規化表單的說明，請參閱<ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The following example determines whether a string is successfully normalized to various normalization forms.</source>
          <target state="translated">下列範例會判斷字串是否成功正規化成各種正規化格式。</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">目前的執行個體包含無效的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph>方法會傳回<ph id="ph2">&lt;see langword="false" /&gt;</ph>當它遇到第一個非標準化字元在字串中的。</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method will throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">因此，如果字串包含非標準化的字元無效的 Unicode 字元後, 接<ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph>方法會擲回<ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph>雖然<ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph>傳回<ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>A Unicode normalization form.</source>
          <target state="translated">Unicode 正規化格式。</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Indicates whether this string is in the specified Unicode normalization form.</source>
          <target state="translated">指出這個字串是否為指定的 Unicode 正規化格式。</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this string is in the normalization form specified by the <ph id="ph2">&lt;paramref name="normalizationForm" /&gt;</ph> parameter; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果這個字串為 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 參數指定的正規化格式，則為 <ph id="ph2">&lt;paramref name="normalizationForm" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">某些 Unicode 字元有組成組結合多個對等二進位表示法和/或複合的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">有多種表示的單一字元得搜尋、 排序、 比對，和其他作業。</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">Unicode 標準會定義稱為會傳回一個二進位表示法時指定任何字元的對等二進位表示的正規化的程序。</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">可以使用數種演算法，稱為正規化表單，會遵循不同的規則，執行正規化。</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The .NET Framework currently supports normalization forms C, D, KC, and KD.</source>
          <target state="translated">.NET Framework 目前支援的正規化表單 C、 D、 KC 和 KD。</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需支援的 Unicode 正規化表單的說明，請參閱<ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.IsNormalized%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Normalize%2A&gt;</ph> methods.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.IsNormalized%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.String.Normalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">目前的執行個體包含無效的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph>方法會傳回<ph id="ph2">&lt;see langword="false" /&gt;</ph>當它遇到第一個非標準化字元在字串中的。</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method will throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">因此，如果字串包含非標準化的字元無效的 Unicode 字元後, 接<ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph>方法會擲回<ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph>雖然<ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph>傳回<ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>The string to test.</source>
          <target state="translated">要測試的字串。</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>Indicates whether the specified string is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> string.</source>
          <target state="translated">表示指定的字串是否為 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 或 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> 字串。</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty string (""); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 參數為 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 或空字串 ("")，則為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> is a convenience method that enables you to simultaneously test whether a <ph id="ph2">&lt;xref:System.String&gt;</ph> is <ph id="ph3">`null`</ph> or its value is <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> 是便利的方法，可讓您以同時測試您是否<ph id="ph2">&lt;xref:System.String&gt;</ph>是<ph id="ph3">`null`</ph>或其值為<ph id="ph4">&lt;xref:System.String.Empty&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">相當於下列程式碼：</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method to test whether a string is <ph id="ph2">`null`</ph>, its value is <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>,  or it consists only of white-space characters.</source>
          <target state="translated">您可以使用<ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph>方法來測試字串是否<ph id="ph2">`null`</ph>，其值是<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>，或它只包含空白字元。</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>What is a null string?</source>
          <target state="translated">什麼是 null 字串？</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>A string is <ph id="ph1">`null`</ph> if it has not been assigned a value (in C++ and Visual Basic) or if has explicitly been assigned a value of <ph id="ph2">`null`</ph>.</source>
          <target state="translated">字串是<ph id="ph1">`null`</ph>如果它尚未指派的值 （以 c + + 和 Visual Basic），或如果已明確指派值為<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>Although the <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</source>
          <target state="translated">雖然<bpt id="p1">[</bpt>複合格式化<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>功能可以依正常程序處理 null 的字串，如下列範例所示，如果其成員擲回，嘗試呼叫其中<ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>What is an empty string?</source>
          <target state="translated">什麼是空字串？</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>A string is empty if it  is explicitly assigned an empty string ("") or <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">字串為空白，如果它被明確指派為空字串 ("") 或<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>An empty string has a <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> of 0.</source>
          <target state="translated">空字串具有<ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph>為 0。</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>The following example creates an empty string and displays its value and its length.</source>
          <target state="translated">下列範例會建立空的字串，並顯示其值和它的長度。</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>The following example examines three strings and determines whether each string has a value, is an empty string, or is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">下列範例會檢查三個字串，並判斷每個字串的值、 空字串，還是<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>The string to test.</source>
          <target state="translated">要測試的字串。</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>Indicates whether a specified string is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, empty, or consists only of white-space characters.</source>
          <target state="translated">表示指定的字串是否為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>、空白，或只由空白字元組成的字串。</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or <ph id="ph4">&lt;see cref="F:System.String.Empty" /&gt;</ph>, or if <ph id="ph5">&lt;paramref name="value" /&gt;</ph> consists exclusively of white-space characters.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 參數是 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 或 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，或者 <ph id="ph4">&lt;see cref="F:System.String.Empty" /&gt;</ph> 完全由空白字元組成，則為 <ph id="ph5">&lt;paramref name="value" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> is a convenience method that is similar to the following  code, except that it offers superior performance:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> 是便利的方法，不同之處在於它提供更優異的效能會類似下列程式碼：</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>White-space characters are defined by the Unicode standard.</source>
          <target state="translated">泛空白字元是由 Unicode 標準定義。</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method interprets any character that returns a value of <ph id="ph2">`true`</ph> when it is passed to the <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method as a white-space character.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph>方法會傳回值的任何字元將解譯<ph id="ph2">`true`</ph>傳遞至時<ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph>方法以做為泛空白字元。</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>The following example creates a string array, and then passes each element of the array to the <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會建立字串陣列，並接著會將傳遞至陣列的每個項目<ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Concatenates the elements of a specified array or the members of a collection, using the specified separator between each element or member.</source>
          <target state="translated">串連指定之陣列的項目或集合的成員，並在每個項目或成員之間使用指定的分隔符號。</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The string to use as a separator.<bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated">要當做分隔符號的字串。只有在 <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> 有一個以上元素時，<bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> 才會包含在傳回的字串中。</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>A collection that contains the strings to concatenate.</source>
          <target state="translated">包含要串連之字串的集合。</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>Concatenates the members of a constructed <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> collection of type <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>, using the specified separator between each member.</source>
          <target state="translated">串連類型 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> 之已建構的 <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> 集合的成員，並在每個成員之間使用指定的分隔符號。</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>A string that consists of the members of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">字串，由 <ph id="ph1">&lt;paramref name="values" /&gt;</ph> 中的成員組成，且每個成員之間都會以 <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> 字串分隔。</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">&lt;paramref name="values" /&gt;</ph> has no members, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="values" /&gt;</ph> 沒有成員，方法會傳回 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">如果<ph id="ph1">`separator`</ph>是<ph id="ph2">`null`</ph>，空字串 (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) 改為使用。</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>If any member of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">如果任何成員<ph id="ph1">`values`</ph>是<ph id="ph2">`null`</ph>，改為使用空字串。</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">`IEnumerable(Of String)`</ph> collection without first converting the elements to a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> 是便利的方法，可讓您在串連每個項目<ph id="ph2">`IEnumerable(Of String)`</ph>集合，而不先將項目轉換成字串陣列。</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions.</source>
          <target state="translated">它特別適合使用 Language-Integrated Query (LINQ) 查詢運算式。</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example passes a <ph id="ph1">`List(Of String)`</ph> object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</source>
          <target state="translated">下列範例會傳遞<ph id="ph1">`List(Of String)`</ph>物件，其中包含英文字母給 lambda 運算式會選取等於或大於特定的字母 （即，在範例中，"M"） 的字母大寫或小寫字母。</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The <ph id="ph1">`IEnumerable(Of String)`</ph> collection returned by the <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> method is passed to the <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method to display the result as a single string.</source>
          <target state="translated"><ph id="ph1">`IEnumerable(Of String)`</ph>所傳回集合<ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph>方法傳遞至<ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph>方法來顯示以單一字串結果。</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>It assigns the result to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object of type <ph id="ph2">&lt;xref:System.String&gt;</ph>, which it then passes to the <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method.</source>
          <target state="translated">它會將結果指派<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>型別的物件<ph id="ph2">&lt;xref:System.String&gt;</ph>，這會接著傳遞給<ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The string to use as a separator.</source>
          <target state="translated">要當做分隔符號的字串。</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated">只有在 <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> 的元素有一個以上時，<bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> 才會包含在傳回的字串中。</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>An array that contains the elements to concatenate.</source>
          <target state="translated">含有要串連之項目的陣列。</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>Concatenates the elements of an object array, using the specified separator between each element.</source>
          <target state="translated">串連物件陣列的項目，並在每個項目之間使用指定的分隔符號。</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>A string that consists of the elements of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">字串，由 <ph id="ph1">&lt;paramref name="values" /&gt;</ph> 的項目組成，且每個項目之間都會以 <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> 字串分隔。</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>If <ph id="ph1">&lt;paramref name="values" /&gt;</ph> is an empty array, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="values" /&gt;</ph> 為空陣列，則方法會傳回 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph> or if any element of <ph id="ph3">`values`</ph> other than the first element is <ph id="ph4">`null`</ph>, an empty string (<ph id="ph5">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">如果<ph id="ph1">`separator`</ph>是<ph id="ph2">`null`</ph>或的任何項目<ph id="ph3">`values`</ph>第一個項目，則除了<ph id="ph4">`null`</ph>，空字串 (<ph id="ph5">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) 改為使用。</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>See the Notes for Callers section if the first element of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果，請參閱 &lt; 呼叫者 &gt; 一節的附註的第一個元素<ph id="ph1">`values`</ph>是<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> 是便利的方法，可讓您沒有明確將其項目轉換為字串串連物件陣列中的每個項目。</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The string representation of each object in the array is derived by calling that object's <ph id="ph1">`ToString`</ph> method.</source>
          <target state="translated">藉由呼叫該物件的陣列中的每個物件的字串表示衍生<ph id="ph1">`ToString`</ph>方法。</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>It assigns the result to a integer array, which it then passes to the <ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">將結果指派到的整數陣列，然後將傳遞給<ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>If the first element of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the <ph id="ph3">&lt;see cref="M:System.String.Join(System.String,System.Object[])" /&gt;</ph> method does not concatenate the elements in <ph id="ph4">&lt;paramref name="values" /&gt;</ph> but instead returns <ph id="ph5">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">如果第一個項目<ph id="ph1">&lt;paramref name="values" /&gt;</ph>是<ph id="ph2">&lt;see langword="null" /&gt;</ph>、<ph id="ph3">&lt;see cref="M:System.String.Join(System.String,System.Object[])" /&gt;</ph>方法不會串連中的項目<ph id="ph4">&lt;paramref name="values" /&gt;</ph>而是傳回<ph id="ph5">&lt;see cref="F:System.String.Empty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>A number of workarounds for this issue are available.</source>
          <target state="translated">使用此問題的因應措施的數目。</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The easiest is to assign a value of <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> to the first element of the array, as the following example shows.</source>
          <target state="translated">若要指派的值的最簡單方法是<ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>陣列的第一個元素，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>The string to use as a separator.</source>
          <target state="translated">要當做分隔符號的字串。</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated">只有在 <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> 的元素有一個以上時，<bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> 才會包含在傳回的字串中。</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>An array that contains the elements to concatenate.</source>
          <target state="translated">含有要串連之項目的陣列。</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>Concatenates all the elements of a string array, using the specified separator between each element.</source>
          <target state="translated">串連字串陣列的所有項目，並在每個項目之間使用指定的分隔符號。</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>A string that consists of the elements in <ph id="ph1">&lt;paramref name="value" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">字串，由 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 中的項目組成，且每個項目之間都會以 <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> 字串分隔。</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is an empty array, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為空陣列，則方法會傳回 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>For example, if <ph id="ph1">`separator`</ph> is ", " and the elements of <ph id="ph2">`value`</ph> are "apple", "orange", "grape", and "pear", <ph id="ph3">`Join(separator, value)`</ph> returns "apple, orange, grape, pear".</source>
          <target state="translated">例如，如果<ph id="ph1">`separator`</ph>是"，"的項目和<ph id="ph2">`value`</ph>為"apple"、 「 橙色 」、 「 grape 」 和 「 西洋梨"<ph id="ph3">`Join(separator, value)`</ph>會傳回 「 apple、 橙色、 grape、 西洋梨"。</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">如果<ph id="ph1">`separator`</ph>是<ph id="ph2">`null`</ph>，空字串 (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) 改為使用。</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>If any element in <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">如果在任何項目<ph id="ph1">`value`</ph>是<ph id="ph2">`null`</ph>，改為使用空字串。</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The string to use as a separator.</source>
          <target state="translated">要當做分隔符號的字串。</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated">只有在 <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> 的元素有一個以上時，<bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> 才會包含在傳回的字串中。</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>An array that contains the elements to concatenate.</source>
          <target state="translated">含有要串連之項目的陣列。</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The first element in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 中要使用的第一個元素。</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The number of elements of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">要使用的 <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 元素數目。</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>Concatenates the specified elements of a string array, using the specified separator between each element.</source>
          <target state="translated">串連字串陣列的指定項目，並在每個項目之間使用指定的分隔符號。</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>A string that consists of the strings in <ph id="ph1">&lt;paramref name="value" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">由 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 中之字串組成的字串，每個字串之間都以 <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> 字串隔開。</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is zero, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> has no elements, or <ph id="ph4">&lt;paramref name="separator" /&gt;</ph> and all the elements of <ph id="ph5">&lt;paramref name="value" /&gt;</ph> are <ph id="ph6">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> 為零、<ph id="ph2">&lt;paramref name="count" /&gt;</ph> 沒有任何項目，或 <ph id="ph3">&lt;paramref name="value" /&gt;</ph> 和 <ph id="ph4">&lt;paramref name="separator" /&gt;</ph> 的所有項目都是 <ph id="ph5">&lt;paramref name="value" /&gt;</ph>，則為 <ph id="ph6">&lt;see cref="F:System.String.Empty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>For example, if <ph id="ph1">`separator`</ph> is ", " and the elements of <ph id="ph2">`value`</ph> are "apple", "orange", "grape", and "pear", <ph id="ph3">`Join(separator, value, 1, 2)`</ph> returns "orange, grape".</source>
          <target state="translated">例如，如果<ph id="ph1">`separator`</ph>是"，"的項目和<ph id="ph2">`value`</ph>為"apple"、 「 橙色 」、 「 grape 」 和 「 西洋梨"<ph id="ph3">`Join(separator, value, 1, 2)`</ph>傳回"橙色，grape"。</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">如果<ph id="ph1">`separator`</ph>是<ph id="ph2">`null`</ph>，空字串 (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) 改為使用。</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>If any element in <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">如果在任何項目<ph id="ph1">`value`</ph>是<ph id="ph2">`null`</ph>，改為使用空字串。</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The following example concatenates two elements from an array of names of fruit.</source>
          <target state="translated">下列範例會串連兩個項目從水果名稱的陣列。</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 小於 0。</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is greater than the number of elements in <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 加上 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 大於 <ph id="ph3">&lt;paramref name="value" /&gt;</ph> 中的元素數目。</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>Out of memory.</source>
          <target state="translated">記憶體不足。</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The type of the members of <bpt id="p1">&lt;c&gt;</bpt>values<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">之成員的型別<bpt id="p1">&lt;c&gt;</bpt>值<ept id="p1">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The string to use as a separator.<bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated">要當做分隔符號的字串。只有在 <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> 有一個以上元素時，<bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> 才會包含在傳回的字串中。</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>A collection that contains the objects to concatenate.</source>
          <target state="translated">包含要串連之物件的集合。</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>Concatenates the members of a collection, using the specified separator between each member.</source>
          <target state="translated">串連集合的成員，並在每個成員之間使用指定的分隔符號。</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>A string that consists of the members of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">字串，由 <ph id="ph1">&lt;paramref name="values" /&gt;</ph> 中的成員組成，且每個成員之間都會以 <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> 字串分隔。</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>If <ph id="ph1">&lt;paramref name="values" /&gt;</ph> has no members, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="values" /&gt;</ph> 沒有成員，方法會傳回 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">如果<ph id="ph1">`separator`</ph>是<ph id="ph2">`null`</ph>，空字串 (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) 改為使用。</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>If any member of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">如果任何成員<ph id="ph1">`values`</ph>是<ph id="ph2">`null`</ph>，改為使用空字串。</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> is a convenience method that lets you concatenate each member of an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection without first converting them to strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> 是便利的方法，可讓您在串連的每個成員<ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>而不先將它們轉換成字串的集合。</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The string representation of each object in the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection is derived by calling that object's <ph id="ph2">`ToString`</ph> method.</source>
          <target state="translated">在每個物件的字串表示<ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>集合藉由呼叫該物件衍生<ph id="ph2">`ToString`</ph>方法。</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>This method is particular useful with Language-Integrated Query (LINQ) query expressions.</source>
          <target state="translated">這個方法是在特定使用 Language-Integrated Query (LINQ) 查詢運算式很有用。</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>For example, the following code defines a very simple <ph id="ph1">`Animal`</ph> class that contains the name of an animal and the order to which it belongs.</source>
          <target state="translated">例如，下列程式碼會定義非常簡單<ph id="ph1">`Animal`</ph>類別，其中包含代表動物以及其所屬的順序的名稱。</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>It then defines a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object that contains a number of <ph id="ph2">`Animal`</ph> objects.</source>
          <target state="translated">然後它會定義<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>物件，其中包含一些<ph id="ph2">`Animal`</ph>物件。</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> extension method is called to extract the <ph id="ph2">`Animal`</ph> objects whose <ph id="ph3">`Order`</ph> property equals "Rodent".</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph>擴充方法呼叫以擷取<ph id="ph2">`Animal`</ph>物件<ph id="ph3">`Order`</ph>屬性等於"齧齒動物"。</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The result is passed to the <ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> method.</source>
          <target state="translated">結果會傳遞至<ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>It assigns the result to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object of type integer, which it then passes to the <ph id="ph2">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> method.</source>
          <target state="translated">它會將結果指派<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>物件型別整數，然後將傳遞給<ph id="ph2">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character or string within this instance.</source>
          <target state="translated">報告這個執行個體中指定之 Unicode 字元或字串最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the character or string is not found in this instance.</source>
          <target state="translated">如果在此執行個體中找不到該字元或字串，此方法會傳回 -1。</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The Unicode character to seek.</source>
          <target state="translated">要搜尋的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char)">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</source>
          <target state="translated">報告這個執行個體中指定之 Unicode 字元最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not.</source>
          <target state="translated">如果找到該字元，則為 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 以零為起始的索引位置，如果找不到為 -1。</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph>-1。</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">這個方法會在這個執行個體的最後一個字元位置開始搜尋，然後反向朝直到開始進行<ph id="ph1">`value`</ph>找到或已經檢查的第一個字元位置。</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The search is case-sensitive.</source>
          <target state="translated">搜尋不區分大小寫。</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">若要執行區分文化特性的搜尋，請使用<ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The following example defines an <ph id="ph1">`ExtractFilename`</ph> method that uses the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.Char%29&gt;</ph> method to find the last directory separator character in a string and to extract the string's file name.</source>
          <target state="translated">下列範例會定義<ph id="ph1">`ExtractFilename`</ph>方法使用<ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.Char%29&gt;</ph>方法來尋找字串中的最後一個目錄分隔符號字元和擷取字串的檔案名稱。</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>If the file exists, the method returns the file name without its path.</source>
          <target state="translated">如果檔案存在，則方法會傳回不包含其路徑的檔案名稱。</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>The string to seek.</source>
          <target state="translated">要搜尋的字串。</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>The zero-based starting index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not.</source>
          <target state="translated">如果找到該字串，則為 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 以零為起始的起始索引位置，如未找到，則為 -1。</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the last index position in this instance.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則傳回值為這個執行個體中的最後一個索引位置。</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph>-1。</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>The search begins at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">搜尋會從這個執行個體，最後一個字元位置開始，然後反向朝直到開始進行<ph id="ph1">`value`</ph>找到或已經檢查的第一個字元位置。</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">執行區分文化特性的搜尋時，如果 <ph id="ph1">`value`</ph> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> method always returns <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph> – 1, which represents the last index position in the current instance.</source>
          <target state="translated">如果<ph id="ph1">`value`</ph>只包含一個或多個可忽略的字元，<ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph>方法一律會傳回<ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph>– 1，代表在目前執行個體之最後索引位置。</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">在下列範例中，<ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph>方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)、"n"，後面接著選擇性連字號和選擇性的連字號後面接著"m"）。</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">只有其中一個字串包含選擇性連字號。</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in <ph id="ph2">`value`</ph>.</source>
          <target state="translated">如果執行範例<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，在每個案例中，因為選擇性連字號是可忽略的字元，結果會與相同選擇性連字號不包含在<ph id="ph2">`value`</ph>。</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>When searching for a soft hyphen only, the method returns 6 and 5.</source>
          <target state="translated">搜尋的選擇性連字號只時，這個方法會傳回 6 和 5。</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>These values correspond to the index of the last character in the two strings.</source>
          <target state="translated">這些值對應到兩個字串中的最後一個字元索引。</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>The following example removes opening and closing HTML tags from a string if the tags begin and end the string.</source>
          <target state="translated">下列範例會移除開頭和結尾的字串，如果標記開始與結尾字串的 HTML 標記。</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>If a string ends with a closing bracket character ("&gt;"), the example uses the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method to locate the start of the end tag.</source>
          <target state="translated">如果字串的結尾的右括號字元 ("&gt;")，此範例會使用<ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>方法來找出的結束標記開頭。</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">中所述<bpt id="p1">[</bpt>使用字串的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>To find the last index of a substring within a string instance by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">若要尋找的字串執行個體的子字串的最後一個索引，使用目前文化特性的比較規則，請呼叫<ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph>方法多載，其值為<ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph>針對其<ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The Unicode character to seek.</source>
          <target state="translated">要搜尋的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The starting position of the search.</source>
          <target state="translated">搜尋的開始位置。</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">搜尋會從 <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> 朝這個執行個體的開頭進行。</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</source>
          <target state="translated">報告這個執行個體中指定之 Unicode 字元最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">如果找到該字元，則為 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 的以零為起始索引位置，如果找不到該字元或者目前的執行個體等於 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則為 -1。</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.This method begins searching at the <ph id="ph2">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning of the current instance until either <ph id="ph3">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph>-1.這個方法會在開始搜尋<ph id="ph2">`startIndex`</ph>字元位置，這個執行個體與回溯到目前的執行個體的開頭之前會繼續進行<ph id="ph3">`value`</ph>找到或已經檢查的第一個字元位置。</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
          <target state="translated">例如，如果<ph id="ph1">`startIndex`</ph>是<ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph>-1，方法會搜尋每個字元從最後一個字元字串中要開始。</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">搜尋不區分大小寫。</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">若要執行區分文化特性的搜尋，請使用<ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The following example finds the index of all occurrences of a character in a string, working from the end of the string to the start of the string.</source>
          <target state="translated">下列範例會尋找所有出現的字元的索引，在字串中，使用從字串的結尾字串的開頭。</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than or equal to the length of this instance.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 小於零，或者大於或等於這個執行個體的長度。</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">要搜尋的字串。</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">搜尋會從 <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> 朝這個執行個體的開頭進行。</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The zero-based starting index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">如果找到該字串，則為 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 的以零為起始索引位置，如果找不到該字串或者目前的執行個體等於 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則為 -1。</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則傳回值是 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 或這個執行個體之最後索引位置，取兩者中較小者。</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph>-1。</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either <ph id="ph2">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">搜尋開始於<ph id="ph1">`startIndex`</ph>字元位置，此執行個體，會繼續執行直到朝回溯<ph id="ph2">`value`</ph>找到或已經檢查的第一個字元位置。</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
          <target state="translated">例如，如果<ph id="ph1">`startIndex`</ph>是<ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph>-1，方法會搜尋每個字元從最後一個字元字串中要開始。</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">執行區分文化特性的搜尋時，如果 <ph id="ph1">`value`</ph> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">如果<ph id="ph1">`value`</ph>只包含一個或多個可忽略的字元，<ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph>方法一律會傳回<ph id="ph3">`startIndex`</ph>，即開始搜尋的字元位置。</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string.</source>
          <target state="translated">在下列範例中，<ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph>方法用來尋找包含選擇性連字號 (U + 00AD)，而且之前或是在字串中包括最後的"m"的子字串。</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n".</source>
          <target state="translated">如果執行範例<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，搜尋字串中的選擇性連字號會被忽略，因為呼叫以尋找子字串包含選擇性連字號和"m"在字串中，傳回"m"的位置而呼叫它來尋找 substrin 方法g 包含選擇性連字號和"n"會傳回"n"的位置。</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of <ph id="ph1">`startIndex`</ph>.</source>
          <target state="translated">當搜尋字串不包含只選擇性連字號時，方法會傳回"m"，其代表的值索引<ph id="ph1">`startIndex`</ph>。</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The following example finds the index of all occurrences of a string in target string, working from the end of the target string to the start of the target string.</source>
          <target state="translated">下列範例會尋找所有出現的字串索引在目標字串中，從目標字串的結尾工作目標字串的開頭。</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than the length of the current instance.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 小於零或大於目前執行個體的長度。</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">目前的執行個體等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 小於 -1 或大於零。</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">中所述<bpt id="p1">[</bpt>使用字串的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>To find the index of a substring that precedes a particular character position by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">若要尋找特定的字元位置之前使用目前文化特性的比較規則的子字串的索引，請呼叫<ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph>方法多載，其值為<ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph>針對其<ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">要搜尋的字串。</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">其中一個列舉值，指定搜尋規則。</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Reports the zero-based index of the last occurrence of a specified string within the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">報告目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件中指定之字串最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>A parameter specifies the type of search to use for the specified string.</source>
          <target state="translated">參數會指定要用於指定字串的搜尋類型。</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The zero-based starting index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not.</source>
          <target state="translated">如果找到該字串，則為 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 參數的以零為起始的起始索引位置，否則為 -1。</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the last index position in this instance.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則傳回值為這個執行個體中的最後一個索引位置。</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph>-1。</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph>參數會指定要搜尋<ph id="ph2">`value`</ph>參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用文字或序數比較規則。</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The search begins at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">搜尋會從這個執行個體，最後一個字元位置開始，然後反向朝直到開始進行<ph id="ph1">`value`</ph>找到或已經檢查的第一個字元位置。</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method that find the last occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">下列 exampledemonstrates 三個多載的<ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>尋找使用的不同值的另一個字串中之字串最後一次出現的方法<ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是有效的 <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">執行區分文化特性的搜尋 (也就是說，如果 <ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> 或 <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>) 時，如果 <ph id="ph4">&lt;paramref name="value" /&gt;</ph> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph> – 1, which represents the last index position in the current instance.</source>
          <target state="translated">如果<ph id="ph1">&lt;paramref name="value" /&gt;</ph>只包含一個或多個可忽略的字元，<ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph>方法一律會傳回<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>– 1，代表在目前執行個體之最後索引位置。</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">在下列範例中，<ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph>方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)、"n"，後面接著選擇性連字號和選擇性的連字號後面接著"m"）。</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">只有其中一個字串包含選擇性連字號。</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</source>
          <target state="translated">如果執行範例<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，因為選擇性連字號是可忽略的字元，區分文化特性的搜尋傳回相同的值，它就會傳回如果搜尋字串中未包含選擇性連字號。</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</source>
          <target state="translated">序數搜尋，不過，順利在一個字串中尋找選擇性連字號，並報告它不存在從第二個字串。</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The Unicode character to seek.</source>
          <target state="translated">要搜尋的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The starting position of the search.</source>
          <target state="translated">搜尋的開始位置。</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">搜尋會從 <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> 朝這個執行個體的開頭進行。</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">要檢視的字元位置數目。</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance.</source>
          <target state="translated">報告這個執行個體的子字串中，指定的 Unicode 字元最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
          <target state="translated">搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">如果找到該字元，則為 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 的以零為起始索引位置，如果找不到該字元或者目前的執行個體等於 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則為 -1。</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph>-1。</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward toward the beginning of this instance until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">這個方法會在開始搜尋<ph id="ph1">`startIndex`</ph>字元位置和繼續回溯朝這個執行個體的開頭，直到<ph id="ph2">`value`</ph>找到或<ph id="ph3">`count`</ph>字元位置已檢查。</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
          <target state="translated">例如，如果<ph id="ph1">`startIndex`</ph>是<ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph>-1，此方法會向後搜尋<ph id="ph3">`count`</ph>從字串中的最後一個字元的字元。</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">搜尋不區分大小寫。</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
          <target state="translated">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有當 Unicode 純量值都相同，字元會視為等於另一個字元。</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">若要執行區分文化特性的搜尋，請使用<ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The following example finds the index of all occurrences of a character in a substring, working from the end of the substring to the start of the substring.</source>
          <target state="translated">下列範例會尋找所有出現的字元索引的子字串，處理從子字串的結尾子字串的開頭。</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than or equal to the length of this instance.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 小於零，或者大於或等於這個執行個體的長度。</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph> + 1 is less than zero.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph> + 1 小於零。</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">要搜尋的字串。</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">搜尋會從 <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> 朝這個執行個體的開頭進行。</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">要檢視的字元位置數目。</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
          <target state="translated">搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The zero-based starting index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">如果找到該字串，則為 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 的以零為起始索引位置，如果找不到該字串或者目前的執行個體等於 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則為 -1。</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則傳回值是 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 或這個執行個體之最後索引位置，取兩者中較小者。</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph>-1。</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">搜尋開始於<ph id="ph1">`startIndex`</ph>字元位置，此執行個體，會繼續執行直到朝回溯<ph id="ph2">`value`</ph>找到或<ph id="ph3">`count`</ph>字元位置已檢查。</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
          <target state="translated">例如，如果<ph id="ph1">`startIndex`</ph>是<ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph>-1，此方法會向後搜尋<ph id="ph3">`count`</ph>從字串中的最後一個字元的字元。</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">執行區分文化特性的搜尋時，如果 <ph id="ph1">`value`</ph> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">如果<ph id="ph1">`value`</ph>只包含一個或多個可忽略的字元，<ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>方法一律會傳回<ph id="ph3">`startIndex`</ph>，即開始搜尋的字元位置。</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings.</source>
          <target state="translated">在下列範例中，<ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>方法用來尋找在前面兩個字串的最後"m"的兩個字元的選擇性連字號 (U + 00AD) 的位置。</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">只有其中一個字串包含必要的子字串。</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">如果執行範例<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The following example finds the index of all occurrences of a string in substring, working from the end of the substring to the start of the substring.</source>
          <target state="translated">下列範例會尋找所有出現的字串索引中的子字串，處理從子字串的結尾子字串的開頭。</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 大於這個執行個體的長度。</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph>+ 1 specifies a position that is not within this instance.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph>+ 1 指定的位置不在此執行個體之內。</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="start" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">目前的執行個體等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="start" /&gt;</ph> 小於 -1 或大於零。</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is greater than 1.</source>
          <target state="translated">目前的執行個體等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 大於 1。</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">中所述<bpt id="p1">[</bpt>使用字串的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>To perform this operation by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">若要使用目前文化特性的比較規則，以執行這項作業，請呼叫<ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph>方法多載，其值為<ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph>針對其<ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">要搜尋的字串。</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">搜尋會從 <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> 朝這個執行個體的開頭進行。</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">其中一個列舉值，指定搜尋規則。</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index of the last occurrence of a specified string within the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">報告目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件中指定之字串最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>A parameter specifies the type of comparison to perform when searching for the specified string.</source>
          <target state="translated">參數會指定搜尋指定字串時要執行的比較類型。</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The zero-based starting index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">如果找到該字串，則為 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 參數以零為起始的索引位置，如果找不到該字串或者目前的執行個體等於 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則為 -1。</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則傳回值是 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 或這個執行個體之最後索引位置，取兩者中較小者。</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph>-1。</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward until either <ph id="ph2">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">搜尋開始於<ph id="ph1">`startIndex`</ph>字元位置然後繼續直到回溯<ph id="ph2">`value`</ph>找到或已經檢查的第一個字元位置。</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
          <target state="translated">例如，如果<ph id="ph1">`startIndex`</ph>是<ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph>-1，方法會搜尋每個字元從最後一個字元字串中要開始。</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph>參數會指定要搜尋<ph id="ph2">`value`</ph>參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用文字或序數比較規則。</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method that find the last occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">下列 exampledemonstrates 三個多載的<ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>尋找使用的不同值的另一個字串中之字串最後一次出現的方法<ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than the length of the current instance.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 小於零或大於目前執行個體的長度。</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">目前的執行個體等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> 且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 小於 -1 或大於零。</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是有效的 <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">執行區分文化特性的搜尋 (也就是說，如果 <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> 或 <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>) 時，如果 <ph id="ph4">&lt;paramref name="value" /&gt;</ph> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">如果<ph id="ph1">&lt;paramref name="value" /&gt;</ph>只包含一個或多個可忽略的字元，<ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph>方法一律會傳回<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>，即開始搜尋的字元位置。</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m", starting with the final "m" in two strings.</source>
          <target state="translated">在下列範例中，<ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph>方法用來尋找後面接著"m"，開頭為"m"最後兩個字串中選擇性連字號 (U + 00AD) 的位置。</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">只有其中一個字串包含必要的子字串。</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">如果執行範例<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">要搜尋的字串。</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">搜尋會從 <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> 朝這個執行個體的開頭進行。</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The number of character positions to examine.</source>
          <target state="translated">要檢視的字元位置數目。</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">其中一個列舉值，指定搜尋規則。</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions.</source>
          <target state="translated">搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>A parameter specifies the type of comparison to perform when searching for the specified string.</source>
          <target state="translated">參數會指定搜尋指定字串時要執行的比較類型。</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The zero-based starting index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">如果找到該字串，則為 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 參數以零為起始的索引位置，如果找不到該字串或者目前的執行個體等於 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則為 -1。</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則傳回值是 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 或這個執行個體之最後索引位置，取兩者中較小者。</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph>-1。</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">搜尋開始於<ph id="ph1">`startIndex`</ph>字元位置然後繼續直到回溯<ph id="ph2">`value`</ph>找到或<ph id="ph3">`count`</ph>字元位置已檢查。</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
          <target state="translated">例如，如果<ph id="ph1">`startIndex`</ph>是<ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph>-1，此方法會向後搜尋<ph id="ph3">`count`</ph>從字串中的最後一個字元的字元。</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph>參數會指定要搜尋<ph id="ph2">`value`</ph>參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用文字或序數比較規則。</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method that find the last occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">下列 exampledemonstrates 三個多載的<ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>尋找使用的不同值的另一個字串中之字串最後一次出現的方法<ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 大於這個執行個體的長度。</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> + 1 - <ph id="ph3">&lt;paramref name="count" /&gt;</ph> specifies a position that is not within this instance.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> + 1 - <ph id="ph3">&lt;paramref name="count" /&gt;</ph> 指定的位置不在此執行個體之內。</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="start" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">目前的執行個體等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="start" /&gt;</ph> 小於 -1 或大於零。</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is greater than 1.</source>
          <target state="translated">目前的執行個體等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 大於 1。</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是有效的 <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">執行區分文化特性的搜尋 (也就是說，如果 <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> 或 <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>) 時，如果 <ph id="ph4">&lt;paramref name="value" /&gt;</ph> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">如果<ph id="ph1">&lt;paramref name="value" /&gt;</ph>只包含一個或多個可忽略的字元，<ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph>方法一律會傳回<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>，即開始搜尋的字元位置。</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in all but the first character position before the final "m" in two strings.</source>
          <target state="translated">在下列範例中，<ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph>方法用來尋找兩個字串中的選擇性連字號 (U + 00AD) 後面接著"m"在所有位置，但最終"m"之前的第一個字元位置。</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">只有其中一個字串包含必要的子字串。</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">如果執行範例<ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph>或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>When it performs an ordinal comparison, however, it finds the substring only in the first string.</source>
          <target state="translated">當它執行序數比較時，不過，它會尋找子字串只能在第一個字串中。</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</source>
          <target state="translated">請注意，就第一個字串，其中包含選擇性連字號後面接著"m"，此方法無法傳回選擇性連字號的索引執行區分文化特性的比較時，而是傳回"m"的索引。</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the characters in the array are not found in this instance.</source>
          <target state="translated">如果在此執行個體中找不到陣列中的字元，此方法會傳回 -1。</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Unicode 字元陣列，含有一或多個要搜尋的字元。</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>The index position of the last occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">這個執行個體中最後項目的索引位置，其中找到了 <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> 中的任何字元，如果 <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> 中沒有找到任何字元，則為 -1。</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph1">`anyOf`</ph> is found or the first character position has been examined.</source>
          <target state="translated">這個方法會在這個執行個體的最後一個字元位置開始搜尋，然後反向朝直到中字元的開頭進行<ph id="ph1">`anyOf`</ph>找到或已經檢查的第一個字元位置。</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>The search is case-sensitive.</source>
          <target state="translated">搜尋不區分大小寫。</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">若要執行區分文化特性的搜尋，請使用<ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>The following example finds the index of the last occurrence of any character in the string "is" within another string.</source>
          <target state="translated">下列範例會尋找任何字元在字串中最後一個出現的索引"is"內另一個字串。</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Unicode 字元陣列，含有一或多個要搜尋的字元。</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">搜尋會從 <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> 朝這個執行個體的開頭進行。</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The index position of the last occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found or if the current instance equals <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">所找到之 <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> 的任何字元，在這個執行個體中最後一次出現的索引位置；如果找不到 <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> 中的字元，或目前的執行個體等於 <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則為 -1。</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph2">`anyOf`</ph> is found or the first character position has been examined.</source>
          <target state="translated">這個方法會在開始搜尋<ph id="ph1">`startIndex`</ph>字元位置，這個執行個體與回溯朝直到中字元的開頭繼續<ph id="ph2">`anyOf`</ph>找到或已經檢查的第一個字元位置。</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">搜尋不區分大小寫。</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">若要執行區分文化特性的搜尋，請使用<ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The following example finds the index of the last occurrence of any character in the string "is" within a substring of another string.</source>
          <target state="translated">下列範例會尋找任何字元在字串中最後一個出現的索引"is"另一個字串的子字串內。</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> specifies a position that is not within this instance.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 指定的位置不在這個執行個體之內。</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Unicode 字元陣列，含有一或多個要搜尋的字元。</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">搜尋開始位置。</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">搜尋會從 <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> 朝這個執行個體的開頭進行。</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">要檢視的字元位置數目。</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
          <target state="translated">搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The index position of the last occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found or if the current instance equals <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">所找到之 <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> 的任何字元，在這個執行個體中最後一次出現的索引位置；如果找不到 <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> 中的字元，或目前的執行個體等於 <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>，則為 -1。</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">索引編號會從零開始。</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph2">`anyOf`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">這個方法會在開始搜尋<ph id="ph1">`startIndex`</ph>字元位置，這個執行個體與回溯朝直到中字元的開頭繼續<ph id="ph2">`anyOf`</ph>找到或<ph id="ph3">`count`</ph>字元位置已檢查。</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">搜尋不區分大小寫。</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">若要執行區分文化特性的搜尋，請使用<ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The following example finds the index of the last occurrence of any character in the string "aid" within a substring of another string.</source>
          <target state="translated">下列範例會尋找另一個字串的子字串內的任何字元在字串"輔助工具 」，最後一個出現的索引。</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> or <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> minus <ph id="ph3">&lt;paramref name="count" /&gt;</ph> + 1 is less than zero.</source>
          <target state="translated">目前的執行個體不等於 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>，且 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> - <ph id="ph3">&lt;paramref name="count" /&gt;</ph> + 1 小於零。</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" uid="P:System.String.Length">
          <source>Gets the number of characters in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件中字元的數目。</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The number of characters in the current string.</source>
          <target state="translated">目前字串中的字元數。</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property returns the number of <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects in this instance, not the number of Unicode characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph>屬性傳回的數目<ph id="ph2">&lt;xref:System.Char&gt;</ph>這個執行個體中的物件、 不是 Unicode 字元的數目。</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The reason is that a Unicode character might be represented by more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</source>
          <target state="translated">原因是，可能會將 Unicode 字元表示由多個<ph id="ph1">&lt;xref:System.Char&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> class to work with each Unicode character instead of each <ph id="ph2">&lt;xref:System.Char&gt;</ph>.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph>類別，以使用每個 Unicode 字元，而不是每個<ph id="ph2">&lt;xref:System.Char&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>In some languages, such as C and C++, a null character indicates the end of a string.</source>
          <target state="translated">在某些語言中，例如 C 與 c + +，null 字元表示字串的結尾。</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>In the .NET Framework, a null character can be embedded in a string.</source>
          <target state="translated">在.NET Framework 中，可以內嵌 null 字元在字串中。</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>When a string includes one or more null characters, they are included in the length of the total string.</source>
          <target state="translated">字串，包含一或多個 null 字元時，它們會包含總字串的長度。</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>For example, in the following string, the substrings "abc" and "def" are separated by a null character.</source>
          <target state="translated">例如，在下列字串"abc"與"def"會以 null 字元分隔的子字串。</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph>屬性會傳回 7，這表示它包含六個字母的字元，以及 null 字元。</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string whose binary representation is in a particular Unicode normalization form.</source>
          <target state="translated">傳回新的字串，其二進位表示為特定的 Unicode 正規化格式。</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" uid="M:System.String.Normalize">
          <source>Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</source>
          <target state="translated">傳回新的字串，其文字值與這個字串相同，但是其二進位表示為 Unicode 正規化格式 C。</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" uid="M:System.String.Normalize">
          <source>A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</source>
          <target state="translated">新的正規化字串，其文字值與這個字串相同，但是其二進位表示為正規化格式 C。</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">某些 Unicode 字元有組成組結合多個對等二進位表示法和/或複合的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>For example, any of the following code points can represent the letter "ắ":</source>
          <target state="translated">例如，下列字碼指標的任何可代表字母"ắ":</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>U+1EAF</source>
          <target state="translated">U + 1EAF</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>U+0103 U+0301</source>
          <target state="translated">U+0103 U+0301</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>U+0061 U+0306 U+0301</source>
          <target state="translated">U+0061 U+0306 U+0301</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">有多種表示的單一字元得搜尋、 排序、 比對，和其他作業。</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">Unicode 標準會定義稱為會傳回一個二進位表示法時指定任何字元的對等二進位表示的正規化的程序。</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">可以使用數種演算法，稱為正規化表單，會遵循不同的規則，執行正規化。</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, theycan be compared by using ordinal comparison.</source>
          <target state="translated">.NET Framework 支援的四個正規化表單 （C、 D、 KC 和 KD） 由 Unicode 標準所定義。當兩個字串相同的正規化格式表示時，使用序數比較來比較 theycan。</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>To normalize and compare two strings, do the following:</source>
          <target state="translated">若要正常化，並比較兩個字串，執行下列作業：</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Obtain the strings to be compared from an input source, such as a file or a user input device.</source>
          <target state="translated">取得從輸入來源，例如檔案或使用者的輸入的裝置要比較的字串。</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Call the <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> method to normalize the strings to normalization form C.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph>方法，以將字串標準化為正規化格式 c。</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>To compare two strings, call a method that supports ordinal string comparison, such as the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, and supply a value of <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> as the <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> argument.</source>
          <target state="translated">若要比較兩個字串，呼叫的方法，支援的序數字串比較，例如<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph>方法，並提供值<ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>或<ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>做為<ph id="ph4">&lt;xref:System.StringComparison&gt;</ph>引數。</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>To sort an array of normalized strings, pass a <ph id="ph1">`comparer`</ph> value of <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> to an appropriate overload of <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">若要排序的正規化的字串陣列，傳遞<ph id="ph1">`comparer`</ph>值<ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph>或<ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph>適當多載<ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Emit the strings in the sorted output based on the order indicated by the previous step.</source>
          <target state="translated">發出根據上一個步驟所指定的順序排序的輸出中的字串。</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需支援的 Unicode 正規化表單的說明，請參閱<ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</source>
          <target state="translated">下列範例會將字串標準化為每四個正規化格式，確認字串已標準化為指定的正規化表單，然後列出正規化的字串中的字碼指標。</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" uid="M:System.String.Normalize">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">目前的執行個體包含無效的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph>方法會傳回<ph id="ph2">&lt;see langword="false" /&gt;</ph>當它遇到第一個非標準化字元在字串中的。</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method will throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">因此，如果字串包含非標準化的字元無效的 Unicode 字元後, 接<ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph>方法會擲回<ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph>雖然<ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph>傳回<ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>A Unicode normalization form.</source>
          <target state="translated">Unicode 正規化格式。</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</source>
          <target state="translated">傳回新的字串，其文字值與這個字串相同，但是其二進位表示為特定的 Unicode 正規化格式。</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <ph id="ph1">&lt;paramref name="normalizationForm" /&gt;</ph> parameter.</source>
          <target state="translated">新的字串，其文字值與這個字串相同，但是其二進位表示為 <ph id="ph1">&lt;paramref name="normalizationForm" /&gt;</ph> 參數指定的正規化格式。</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">某些 Unicode 字元有組成組結合多個對等二進位表示法和/或複合的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">有多種表示的單一字元得搜尋、 排序、 比對，和其他作業。</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">Unicode 標準會定義稱為會傳回一個二進位表示法時指定任何字元的對等二進位表示的正規化的程序。</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">可以使用數種演算法，稱為正規化表單，會遵循不同的規則，執行正規化。</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</source>
          <target state="translated">.NET Framework 支援的四個正規化表單 （C、 D、 KC 和 KD） 由 Unicode 標準所定義。當兩個字串都表示相同的正規化格式時，它們可以使用序數比較來比較。</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>To normalize and compare two strings, do the following:</source>
          <target state="translated">若要正常化，並比較兩個字串，執行下列作業：</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Obtain the strings to be compared from an input source, such as a file or a user input device.</source>
          <target state="translated">取得從輸入來源，例如檔案或使用者的輸入的裝置要比較的字串。</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Call the <ph id="ph1">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> method to normalize the strings to a specified normalization form.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph>方法，以將字串標準化為指定的正規化格式。</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>To compare two strings, call a method that supports ordinal string comparison, such as the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, and supply a value of <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> as the <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> argument.</source>
          <target state="translated">若要比較兩個字串，呼叫的方法，支援的序數字串比較，例如<ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph>方法，並提供值<ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>或<ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>做為<ph id="ph4">&lt;xref:System.StringComparison&gt;</ph>引數。</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>To sort an array of normalized strings, pass a <ph id="ph1">`comparer`</ph> value of <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> to an appropriate overload of <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">若要排序的正規化的字串陣列，傳遞<ph id="ph1">`comparer`</ph>值<ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph>或<ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph>適當多載<ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Emit the strings in the sorted output based on the order indicated by the previous step.</source>
          <target state="translated">發出根據上一個步驟所指定的順序排序的輸出中的字串。</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需支援的 Unicode 正規化表單的說明，請參閱<ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</source>
          <target state="translated">下列範例會將字串標準化為每四個正規化格式，確認字串已標準化為指定的正規化表單，然後列出正規化的字串中的字碼指標。</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">目前的執行個體包含無效的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph>方法會傳回<ph id="ph2">&lt;see langword="false" /&gt;</ph>當它遇到第一個非標準化字元在字串中的。</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method may throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">因此，如果字串包含非標準化的字元無效的 Unicode 字元後, 接<ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph>方法可能會擲回<ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph>雖然<ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph>傳回<ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">要比較的第一個字串，或是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">要比較的第二個字串，或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>Determines whether two specified strings have the same value.</source>
          <target state="translated">判斷兩個指定的字串是否具有相同的值。</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of <ph id="ph2">&lt;paramref name="a" /&gt;</ph> is the same as the value of <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 的值與 <ph id="ph2">&lt;paramref name="a" /&gt;</ph> 的值相同，則為 <ph id="ph3">&lt;paramref name="b" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> method defines the operation of the equality operator for the <ph id="ph2">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph>方法定義的等號比較運算子的作業<ph id="ph2">&lt;xref:System.String&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>It enables code such as that shown in the Example section.</source>
          <target state="translated">它可讓程式碼，例如顯示的範例 &gt; 一節。</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The operator, in turn, calls the static <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">運算子，又會呼叫靜態<ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph>執行序數 （區分大小寫且區分文化特性） 比較方法。</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The Visual Basic compiler does not resolve the equality operator as a call to the <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> method.</source>
          <target state="translated">Visual Basic 編譯器不會解析與呼叫的等號比較運算子<ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>Instead, the equality operator wraps a call to the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">相反地，等號比較運算子會呼叫包裝<ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The following example demonstrates the equality operator.</source>
          <target state="translated">下列範例會示範等號比較運算子。</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">要比較的第一個字串，或是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">要比較的第二個字串，或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>Determines whether two specified strings have different values.</source>
          <target state="translated">判斷兩個指定的字串是否具有不同的值。</target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of <ph id="ph2">&lt;paramref name="a" /&gt;</ph> is different from the value of <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 的值與 <ph id="ph2">&lt;paramref name="a" /&gt;</ph> 的值不同，則為 <ph id="ph3">&lt;paramref name="b" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for the <ph id="ph2">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph>方法會定義作業的不等比較運算子的<ph id="ph2">&lt;xref:System.String&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>It enables code such as that shown in the Examples section.</source>
          <target state="translated">它可讓程式碼，例如顯示的範例 &gt; 一節。</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> operator in turn calls the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph>運算子會呼叫靜態<ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph>執行序數 （區分大小寫且區分文化特性） 比較方法。</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The Visual Basic compiler does not resolve the inequality operator as a call to the <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> method.</source>
          <target state="translated">Visual Basic 編譯器不會解析不等比較運算子，與呼叫<ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>Instead, the inequality operator wraps a call to the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">相反地，不等比較運算子會呼叫包裝<ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The following example demonstrates the inequality operator.</source>
          <target state="translated">下列範例會示範不等比較運算子。</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string of a specified length in which the beginning of the current string is padded with spaces or with a specified Unicode character.</source>
          <target state="translated">傳回指定之長度的新字串，其中目前字串的開頭將以空白和或指定的 Unicode 字元填補。</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</source>
          <target state="translated">傳回新字串，此字串會以空格填補左側至指定的總長度，靠右對齊這個執行個體中的字元。</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">與這個執行個體相等的新字串，但為靠右對齊，並在左側視需要填補若干空間來建立 <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">但是，如果 <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>A Unicode space is defined as hexadecimal 0x0020.</source>
          <target state="translated">Unicode 空間會定義為十六進位 0x0020。</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%29&gt;</ph> method pads the beginning of the returned string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%29&gt;</ph>方法填補傳回之字串的開頭。</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>This means that, when used with right-to-left languages, it pads the right portion of the string.</source>
          <target state="translated">這表示，由右至左語言搭配使用時，它會填補字串的右側部分。</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph>方法填補空白字元目前的執行個體，這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>Instead, it returns a new string that is padded with leading white space so that its total length is <ph id="ph1">`totalWidth`</ph> characters.</source>
          <target state="translated">相反地，它會傳回新字串，使其總長度前置空白字元填補<ph id="ph1">`totalWidth`</ph>字元。</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 小於零。</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>A Unicode padding character.</source>
          <target state="translated">Unicode 填補字元。</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</source>
          <target state="translated">傳回新字串，此字串會以指定的 Unicode 字元填補左側至指定的總長度，靠右對齊這個執行個體中的字元。</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph> characters as needed to create a length of <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">與這個執行個體相等的新字串，但為靠右對齊，並在左側視需要填補若干 <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph> 字元來建立 <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">但是，如果 <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29&gt;</ph> method pads the beginning of the returned string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29&gt;</ph>方法填補傳回之字串的開頭。</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>This means that, when used with right-to-left languages, it pads the right portion of the string.</source>
          <target state="translated">這表示，由右至左語言搭配使用時，它會填補字串的右側部分。</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph>方法填補空白字元目前的執行個體，這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>Instead, it returns a new string that is padded with leading <ph id="ph1">`paddingChar`</ph> characters so that its total length is <ph id="ph2">`totalWidth`</ph> characters.</source>
          <target state="translated">相反地，它會傳回新字串，以前置填補<ph id="ph1">`paddingChar`</ph>個字元，使其總長度<ph id="ph2">`totalWidth`</ph>字元。</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 小於零。</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string of a specified length in which the end of the current string is padded with spaces or with a specified Unicode character.</source>
          <target state="translated">傳回指定之長度的新字串，其中目前字串的結尾將以空白和或指定的 Unicode 字元填補。</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</source>
          <target state="translated">傳回新字串，此字串會以空格填補右側至指定的總長度，靠左對齊這個字串中的字元。</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">與這個執行個體相等的新字串，但為靠左對齊，並在右側視需要填補若干空間來建立 <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">但是，如果 <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>A Unicode space is defined as hexadecimal 0x0020.</source>
          <target state="translated">Unicode 空間會定義為十六進位 0x0020。</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%29&gt;</ph> method pads the end of the returned string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%29&gt;</ph>方法填補傳回之字串的結尾。</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>This means that, when used with right-to-left languages, it pads the left portion of the string.</source>
          <target state="translated">這表示，由右至左語言搭配使用時，它會填補字串的左側的部分。</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph>方法填補空白字元目前的執行個體，這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>Instead, it returns a new string that is padded with trailing white space so that its total length is <ph id="ph1">`totalWidth`</ph> characters.</source>
          <target state="translated">相反地，它會傳回新字串，使其總長度塞滿尾端空白字元<ph id="ph1">`totalWidth`</ph>字元。</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 小於零。</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>A Unicode padding character.</source>
          <target state="translated">Unicode 填補字元。</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</source>
          <target state="translated">傳回新字串，此字串會以指定的 Unicode 字元填補右側至指定的總長度，靠左對齊這個字串中的字元。</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph> characters as needed to create a length of <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">與這個執行個體相等的新字串，但為靠左對齊，並在右側視需要填補若干 <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph> 字元來建立 <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">但是，如果 <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%2CSystem.Char%29&gt;</ph> method pads the end of the returned string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%2CSystem.Char%29&gt;</ph>方法填補傳回之字串的結尾。</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>This means that, when used with right-to-left languages, it pads the left portion of the string.</source>
          <target state="translated">這表示，由右至左語言搭配使用時，它會填補字串的左側的部分。</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph>方法填補空白字元目前的執行個體，這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>Instead, it returns a new string that is padded with trailing <ph id="ph1">`paddingChar`</ph> characters so that its total length is <ph id="ph2">`totalWidth`</ph> characters.</source>
          <target state="translated">相反地，它會傳回新字串，會以尾端填補<ph id="ph1">`paddingChar`</ph>個字元，使其總長度<ph id="ph2">`totalWidth`</ph>字元。</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> 小於零。</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string in which a specified number of characters from the current string are deleted.</source>
          <target state="translated">傳回新字串，其中刪除了目前字串中指定的字元數目。</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>The zero-based position to begin deleting characters.</source>
          <target state="translated">要開始刪除字元之以零為起始的位置。</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</source>
          <target state="translated">傳回新字串，其中已刪除目前執行個體中的所有字元 (從指定位置開始到最後一個位置為止)。</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>A new string that is equivalent to this string except for the removed characters.</source>
          <target state="translated">新字串，除了已移除的字元以外，其餘部分都與這個字串相等。</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, strings are zero-based.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>，字串都是以零為起始。</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The value of the <ph id="ph1">`startIndex`</ph> parameter can range from zero to one less than the length of the string instance.</source>
          <target state="translated">值<ph id="ph1">`startIndex`</ph>參數的範圍可以從零到字串執行個體的長度大於或等於一。</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>Instead, it returns a new string in which all characters from position <ph id="ph1">`startIndex`</ph> to the end of the original string have been removed.</source>
          <target state="translated">相反地，它會傳回新字串中的所有字元從位置<ph id="ph1">`startIndex`</ph>原始字串的結尾已移除。</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The next-to-last case removes all text starting from the specified index through the end of the string.</source>
          <target state="translated">下一步 到最後一個案例會移除從指定之索引到結尾的字串開始的所有文字。</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The last case removes three characters starting from the specified index.</source>
          <target state="translated">最後一種情況會移除從指定索引開始的三個字元。</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 小於零。</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> specifies a position that is not within this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 指定了不在這個字串中的位置。</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The zero-based position to begin deleting characters.</source>
          <target state="translated">要開始刪除字元之以零為起始的位置。</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The number of characters to delete.</source>
          <target state="translated">要刪除的字元數。</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</source>
          <target state="translated">傳回新字串，其中已刪除在目前執行個體中指定位置開始之指定數目的字元。</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>A new string that is equivalent to this instance except for the removed characters.</source>
          <target state="translated">新字串，除了已移除的字元以外，其餘部分都與這個執行個體相等。</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, strings are zero-based.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>，字串都是以零為起始。</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The value of the <ph id="ph1">`startIndex`</ph> parameter can range from zero to one less than the length of the string instance.</source>
          <target state="translated">值<ph id="ph1">`startIndex`</ph>參數的範圍可以從零到字串執行個體的長度大於或等於一。</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>Instead, it returns a new string in which the number of characters specified by the <ph id="ph1">`count`</ph> parameter have been removed.</source>
          <target state="translated">相反地，它會傳回新字串的字元數所指定<ph id="ph1">`count`</ph>已移除參數。</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The characters are removed at the position specified by <ph id="ph1">`startIndex`</ph>.</source>
          <target state="translated">字元會在所指定的位置移除<ph id="ph1">`startIndex`</ph>。</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The following example demonstrates how you can remove the middle name from a complete name.</source>
          <target state="translated">下列範例會示範如何移除中間名是完整的名稱從。</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 小於零。</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="count" /&gt;</ph> specify a position outside this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 加上 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 可指定不在這個執行個體中的位置。</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string in which all occurrences of a specified Unicode character or <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> in the current string are replaced with another specified Unicode character or <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">傳回新字串，其中目前字串中指定之 Unicode 字元或 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的所有項目，全都會被取代成另一個指定的 Unicode 字元或 <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The Unicode character to be replaced.</source>
          <target state="translated">要被取代的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The Unicode character to replace all occurrences of <bpt id="p1">&lt;c&gt;</bpt>oldChar<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">要用來取代所有出現之 <bpt id="p1">&lt;c&gt;</bpt>oldChar<ept id="p1">&lt;/c&gt;</ept> 的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</source>
          <target state="translated">傳回新字串，其中這個執行個體中所有出現的指定 Unicode 字元都取代成其他指定的 Unicode 字元。</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>A string that is equivalent to this instance except that all instances of <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> are replaced with <ph id="ph2">&lt;paramref name="newChar" /&gt;</ph>.</source>
          <target state="translated">相當於這個執行個體的字串，只是 <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> 的所有執行個體都會取代成 <ph id="ph2">&lt;paramref name="newChar" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>If <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> is not found in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果在目前的執行個體中找不到 <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph>，則方法傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) search to find <ph id="ph1">`oldChar`</ph>.</source>
          <target state="translated">這個方法會執行序數 （區分大小寫且區分文化特性） 搜尋來尋找<ph id="ph1">`oldChar`</ph>。</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Instead, it returns a new string in which all occurrences of <ph id="ph1">`oldChar`</ph> are replaced by <ph id="ph2">`newChar`</ph>.</source>
          <target state="translated">相反地，它會傳回新字串中的所有項目<ph id="ph1">`oldChar`</ph>來取代<ph id="ph2">`newChar`</ph>。</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Because this method returns the modified string, you can chain together successive calls to the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to perform multiple replacements on the original string.</source>
          <target state="translated">因為這個方法會傳回已修改的字串，您可以鏈結在一起後續呼叫<ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph>原始字串上執行多個替代方法。</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Method calls are executed from left to right.</source>
          <target state="translated">方法會呼叫執行從左到右。</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The following example provides an illustration.</source>
          <target state="translated">下列範例提供一個實例。</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The following example creates a comma separated value list by substituting commas for the blanks between a series of numbers.</source>
          <target state="translated">下列範例會建立以逗號分隔值清單所得到的一連串數字之間的空白。</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>The string to be replaced.</source>
          <target state="translated">要被取代的字串。</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>The string to replace all occurrences of <bpt id="p1">&lt;c&gt;</bpt>oldValue<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">用來取代所有出現之 <bpt id="p1">&lt;c&gt;</bpt>oldValue<ept id="p1">&lt;/c&gt;</ept> 的字串。</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</source>
          <target state="translated">傳回新字串，其中目前執行個體中所有出現的指定字串，都取代成其他指定的字串。</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>A string that is equivalent to the current string except that all instances of <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> are replaced with <ph id="ph2">&lt;paramref name="newValue" /&gt;</ph>.</source>
          <target state="translated">相當於目前字串的字串，只是 <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> 的所有執行個體都會取代成 <ph id="ph2">&lt;paramref name="newValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> is not found in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果在目前的執行個體中找不到 <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph>，則方法傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>If <ph id="ph1">`newValue`</ph> is <ph id="ph2">`null`</ph>, all occurrences of <ph id="ph3">`oldValue`</ph> are removed.</source>
          <target state="translated">如果<ph id="ph1">`newValue`</ph>是<ph id="ph2">`null`</ph>的所有項目<ph id="ph3">`oldValue`</ph>會移除。</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>Instead, it returns a new string in which all occurrences of <ph id="ph1">`oldValue`</ph> are replaced by <ph id="ph2">`newValue`</ph>.</source>
          <target state="translated">相反地，它會傳回新字串中的所有項目<ph id="ph1">`oldValue`</ph>來取代<ph id="ph2">`newValue`</ph>。</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) search to find <ph id="ph1">`oldValue`</ph>.</source>
          <target state="translated">這個方法會執行序數 （區分大小寫且區分文化特性） 搜尋來尋找<ph id="ph1">`oldValue`</ph>。</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>Because this method returns the modified string, you can chain together successive calls to the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to perform multiple replacements on the original string.</source>
          <target state="translated">因為這個方法會傳回已修改的字串，您可以鏈結在一起後續呼叫<ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph>原始字串上執行多個替代方法。</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>Method calls are executed from left to right.</source>
          <target state="translated">方法會呼叫執行從左到右。</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>The following example provides an illustration.</source>
          <target state="translated">下列範例提供一個實例。</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>The following example demonstrates how you can use the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to correct a spelling error.</source>
          <target state="translated">下列範例示範如何使用<ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph>更正拼字錯誤的方法。</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> 為空字串 ("")。</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a string array that contains the substrings in this instance that are delimited by elements of a specified string or Unicode character array.</source>
          <target state="translated">傳回字串陣列，這個陣列包含這個執行個體中，由指定的字串或 Unicode 字元陣列之項目所分隔的子字串。</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> is used to break a delimited string into substrings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> 用來分隔的字串分割成子字串。</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can use either a character array to specify zero, one, or multiple delimiting characters (the <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method), or you can use a character array to specify zero, one, or multiple delimiting strings.</source>
          <target state="translated">您可用來指定零個、 一個或多個分隔字元的字元陣列 (<ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>方法)，或者您可以使用的字元陣列，指定零個、 一個或多個分隔的字串。</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Overloads of the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method allow you to limit the number of substrings returned by the method (the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29&gt;</ph> method), to determine whether empty strings are included in the returned substrings (the <ph id="ph3">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> and <ph id="ph4">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> methods, or to do both (the <ph id="ph5">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> and <ph id="ph6">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> methods).</source>
          <target state="translated">多載<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法可讓您限制的方法所傳回的子字串數目 (<ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29&gt;</ph>方法)，以決定中傳回的子字串是否包含空字串 (<ph id="ph3">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph>和<ph id="ph4">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph>方法，或以這兩種 (<ph id="ph5">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph>和<ph id="ph6">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph>方法)。</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more detailed information on the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method, as well as for examples that call each overload, see the documentation for the individual overloads of <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</source>
          <target state="translated">如需詳細資訊在<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法，以及呼叫的範例中，每個多載，請參閱個別的多載的文件<ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method is not always the best way to break a delimited string into substrings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法不一定要分隔的字串分割成子字串的最佳方式。</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</source>
          <target state="translated">如果您不想要擷取所有的子字串的分隔的字串，或如果您想要根據的模式，而不是一組字元的分隔符號將字串剖析，請考慮下列的替代方案。</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Regular expressions</source>
          <target state="translated">規則運算式</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</source>
          <target state="translated">如果字串符合固定模式，您可以使用規則運算式來擷取並處理其項目。</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if strings take the form "<bpt id="p1">*</bpt>number<ept id="p1">*</ept> <bpt id="p2">*</bpt>operand<ept id="p2">*</ept> <bpt id="p3">*</bpt>number<ept id="p3">*</ept>" you can use a <bpt id="p4">[</bpt>regular expression<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> to extract and handle the string's elements.</source>
          <target state="translated">比方說，如果字串的形式"<bpt id="p1">*</bpt>數目<ept id="p1">*</ept><bpt id="p2">*</bpt>運算元<ept id="p2">*</ept><bpt id="p3">*</bpt>數目<ept id="p3">*</ept>」 可以使用<bpt id="p4">[</bpt>規則運算式<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept>擷取及處理字串的項目。</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's an example:</source>
          <target state="translated">以下為範例：</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The regular expression pattern <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> is defined like this:</source>
          <target state="translated">規則運算式模式<ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph>定義如下：</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more decimal digits.</source>
          <target state="translated">比對一個或多個十進位數字。</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the first capturing group.</source>
          <target state="translated">這是第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">比對一個或多個空格字元。</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match an arithmetic operator sign (+, -, *, or /).</source>
          <target state="translated">符合號算術運算子 (+、-、 *、 或 /)。</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the second capturing group.</source>
          <target state="translated">這是第二個擷取群組。</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">比對一個或多個空格字元。</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more decimal digits.</source>
          <target state="translated">比對一個或多個十進位數字。</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the third capturing group.</source>
          <target state="translated">這是第三個擷取群組。</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</source>
          <target state="translated">您也可以使用規則運算式從根據的模式，而不是固定的一組字元的字串擷取子字串。</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is a common scenario when either of these conditions occurs:</source>
          <target state="translated">當任一條件發生時，這是常見的案例：</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>One or more of the delimiter characters does not always serve as a delimiter in the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated">一或多個分隔符號字元不一定服務中的分隔符號<ph id="ph1">&lt;xref:System.String&gt;</ph>執行個體。</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sequence and number of delimiter characters is variable or unknown.</source>
          <target state="translated">順序及分隔符號字元數是區域變數或未知。</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method cannot be used to split the following string, because the number of <ph id="ph2">`\n`</ph> (in C#) or <ph id="ph3">`vbCrLf`</ph> (in Visual Basic) characters is variable, and they don't always serve as delimiters.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法無法用來分割下列字串，因為數目<ph id="ph2">`\n`</ph>（C# 中） 或<ph id="ph3">`vbCrLf`</ph>（在 Visual Basic) 字元是變數，而且它們不一定會做為分隔符號。</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A regular expression can split this string easily, as the following example shows.</source>
          <target state="translated">規則運算式可以輕鬆，如下列範例所示分割此字串。</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The regular expression pattern <ph id="ph1">`\[([^\[\]]+)\]`</ph> is defined like this:</source>
          <target state="translated">規則運算式模式<ph id="ph1">`\[([^\[\]]+)\]`</ph>定義如下：</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match an opening bracket.</source>
          <target state="translated">比對左括號。</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match any character that is not an opening or a closing bracket one or more times.</source>
          <target state="translated">比對不是左或右括弧一或多次的任何字元。</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the first capturing group.</source>
          <target state="translated">這是第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match a closing bracket.</source>
          <target state="translated">比對右括號。</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method is almost identical to <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>方法是幾乎完全相同<ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>，只不過它會將分割根據規則運算式模式，而不是固定的字元集的字串。</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</source>
          <target state="translated">例如，下列範例會使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>方法包含以各種連字號和其他字元的組合分隔的子字串將字串分隔。</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The regular expression pattern <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> is defined like this:</source>
          <target state="translated">規則運算式模式<ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph>定義如下：</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match a whitespace character followed by a hyphen.</source>
          <target state="translated">比對空白字元後面接著連字號。</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">比對零個或一個空白字元。</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match zero or one occurrence of either the + or * character.</source>
          <target state="translated">比對零個或一個任一個的 + 或 * 字元。</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">比對零個或一個空白字元。</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match a hyphen followed by a whitespace character.</source>
          <target state="translated">比對後面接著空白字元的字元是連字號。</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Search methods and the Substring method</source>
          <target state="translated">搜尋方法和 Substring 方法</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</source>
          <target state="translated">如果您不想要在字串中子字串的所有項目，您可能想要使用其中一個會傳回的索引開始比對的字串比較方法。</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can then call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract the substring that you want.</source>
          <target state="translated">您可以接著呼叫<ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph>方法，可擷取您想要的子字串。</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The string comparison methods include:</source>
          <target state="translated">字串比較方法包括：</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>它會傳回字元或字串第一次出現的以零為起始的索引中的字串執行個體。</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>它會傳回目前的字串執行個體中，字元陣列中的任何字元第一次出現的以零為起始的索引。</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>它會傳回字元或字串最後一次出現的以零為起始的索引中的字串執行個體。</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>它會傳回以零為起始的索引中目前的最後一個出現的字元陣列中的任何字元的字串執行個體。</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to find the periods in a string.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法來尋找字串中的句點。</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It then uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to return full sentences.</source>
          <target state="translated">然後它會使用<ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph>方法以傳回完整的句子。</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>Splits a string into substrings that are based on the characters in an array.</source>
          <target state="translated">根據陣列中的字元分割字串成子字串。</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>An array whose elements contain the substrings from this instance that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">陣列，其項目中包含了這個執行個體中的子字串，由 <ph id="ph1">&lt;paramref name="separator" /&gt;</ph> 內的一或多個字元分隔。</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">如需詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>When a string is delimited by a known set of characters, you can use the <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method to separate it into substrings.</source>
          <target state="translated">當已知的一組字元所分隔的字串時，您可以使用<ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>分隔成子字串的方法。</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For other ways to extract substrings from a string, see the <bpt id="p1">[</bpt>Alternatives to String.Split<ept id="p1">](#Alternatives)</ept> section.</source>
          <target state="translated">從字串擷取子字串的其他方式，請參閱<bpt id="p1">[</bpt>String.Split 的替代方案<ept id="p1">](#Alternatives)</ept>&gt; 一節。</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Return value details</source>
          <target state="translated">傳回值的詳細資料</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
          <target state="translated">傳回陣列的項目中不包含分隔符號字元。</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, if the separator array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
          <target state="translated">例如，如果分隔符號陣列包含字元"-"，目前的字串執行個體的值是"aa 位 bb-cc"方法會傳回陣列，其中包含三個項目:"aa"、"bb"和"cc"。</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">如果這個執行個體不包含任何字元<ph id="ph1">`separator`</ph>，傳回的陣列包含這個執行個體的單一項目所組成。</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
          <target state="translated">每個項目<ph id="ph1">`separator`</ph>定義不同的分隔符號字元。</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">如果兩個分隔符號是相鄰的或是位於分隔符號的開頭或結尾的這個執行個體，傳回陣列中對應的項目包含<ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Here are some examples:</source>
          <target state="translated">以下是一些範例：</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>String value</source>
          <target state="translated">字串值</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Separator</source>
          <target state="translated">Separator</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Returned array</source>
          <target state="translated">傳回的陣列</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"42, 12, 19"</source>
          <target state="translated">"42, 12, 19"</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {',', ' '} (C#)</source>
          <target state="translated">新 Char [] {'，' ' '} (C#)</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {","c, " "c}) (Visual Basic)</source>
          <target state="translated">Char() = {","c, " "c}) (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"42", "", "12", "", "19"}</source>
          <target state="translated">{"42", "", "12", "", "19"}</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"42..12..19"</source>
          <target state="translated">"42..12..19"</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {'.'}</source>
          <target state="translated">新 Char [] {'。 '}</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char （) = {"。"c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"42", "", "12", "", "19"}</source>
          <target state="translated">{"42", "", "12", "", "19"}</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Banana"</source>
          <target state="translated">「 Banana"</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {'.'}</source>
          <target state="translated">新 Char [] {'。 '}</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char （) = {"。"c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"Banana"}</source>
          <target state="translated">{"Banana"}</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (C#)</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {} (C#)</source>
          <target state="translated">新的 Char [] {} (C#)</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {} (Visual Basic)</source>
          <target state="translated">Char （) = {} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{"Darb", "Smarba"}</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (C#)</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>null (C#)</source>
          <target state="translated">null (C#)</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Nothing (Visual Basic)</source>
          <target state="translated">Nothing (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{"Darb", "Smarba"}</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The separator array</source>
          <target state="translated">分隔陣列</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Each element of separator defines a separate delimiter that consists of a single character.</source>
          <target state="translated">每個項目分隔符號的定義不同的分隔符號包含單一字元。</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If the <ph id="ph1">`separator`</ph> argument is <ph id="ph2">`null`</ph> or contains no characters, the method treats white-space characters as the delimiters.</source>
          <target state="translated">如果<ph id="ph1">`separator`</ph>引數是<ph id="ph2">`null`</ph>或未包含任何字元，方法會將空白字元視為分隔符號。</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>White-space characters are defined by the Unicode standard; they return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">泛空白字元是由 Unicode 標準; 定義它們會傳回<ph id="ph1">`true`</ph>如果傳遞至<ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>String.Split(Char[]) and compiler overload resolution</source>
          <target state="translated">String.Split(Char[]) 和編譯器多載解析</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Although the single parameter for this overload of <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> is a character array, you can call it with a single character, as the following example shows.</source>
          <target state="translated">雖然的這個多載的單一參數<ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>是字元陣列中，呼叫以單一字元，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Because the <ph id="ph1">`separator`</ph> parameter is decorated  with the <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> attribute, compilers will interpret a single character as a single-element character array.</source>
          <target state="translated">因為<ph id="ph1">`separator`</ph>參數以裝飾<ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph>屬性，編譯器會解譯為單一字元做為單一元素字元陣列。</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is not the case for other <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> overloads that include a <ph id="ph2">`separator`</ph> parameter; you must explicitly pass these overloads a character array as the <ph id="ph3">`separator`</ph> argument.</source>
          <target state="translated">這不是為其他案例<ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>包含的多載<ph id="ph2">`separator`</ph>參數，您必須明確傳遞這些多載字元陣列，做為<ph id="ph3">`separator`</ph>引數。</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Comparison details</source>
          <target state="translated">比較詳細資料</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the characters in the <ph id="ph2">`separator`</ph> array, and returns those substrings as elements of an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>方法還會擷取一或多個中的字元會分隔這個字串中子字串<ph id="ph2">`separator`</ph>陣列，並將傳回的子字串做為陣列的項目。</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>方法會尋找分隔符號執行比較使用區分大小寫的序數排序規則。</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Alternatives to String.Split</source>
          <target state="translated">String.Split 的替代方案</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method is not always the best way to break a delimited string into substrings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法不一定要分隔的字串分割成子字串的最佳方式。</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</source>
          <target state="translated">如果您不想要擷取所有的子字串的分隔的字串，或如果您想要根據的模式，而不是一組字元的分隔符號將字串剖析，請考慮下列的替代方案。</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Regular expressions</source>
          <target state="translated">規則運算式</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</source>
          <target state="translated">如果字串符合固定模式，您可以使用規則運算式來擷取並處理其項目。</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, if strings take the form "<bpt id="p1">*</bpt>number<ept id="p1">*</ept> <bpt id="p2">*</bpt>operand<ept id="p2">*</ept> <bpt id="p3">*</bpt>number<ept id="p3">*</ept>" you can use a <bpt id="p4">[</bpt>regular expression<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> to extract and handle the string's elements.</source>
          <target state="translated">比方說，如果字串的形式"<bpt id="p1">*</bpt>數目<ept id="p1">*</ept><bpt id="p2">*</bpt>運算元<ept id="p2">*</ept><bpt id="p3">*</bpt>數目<ept id="p3">*</ept>」 可以使用<bpt id="p4">[</bpt>規則運算式<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept>擷取及處理字串的項目。</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Here's an example:</source>
          <target state="translated">以下為範例：</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The regular expression pattern <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> is defined like this:</source>
          <target state="translated">規則運算式模式<ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph>定義如下：</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more decimal digits.</source>
          <target state="translated">比對一個或多個十進位數字。</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the first capturing group.</source>
          <target state="translated">這是第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">比對一個或多個空格字元。</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match an arithmetic operator sign (+, -, *, or /).</source>
          <target state="translated">符合號算術運算子 (+、-、 *、 或 /)。</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the second capturing group.</source>
          <target state="translated">這是第二個擷取群組。</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">比對一個或多個空格字元。</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more decimal digits.</source>
          <target state="translated">比對一個或多個十進位數字。</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the third capturing group.</source>
          <target state="translated">這是第三個擷取群組。</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</source>
          <target state="translated">您也可以使用規則運算式從根據的模式，而不是固定的一組字元的字串擷取子字串。</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is a common scenario when either of these conditions occurs:</source>
          <target state="translated">當任一條件發生時，這是常見的案例：</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>One or more of the delimiter characters does not always serve as a delimiter in the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated">一或多個分隔符號字元不一定服務中的分隔符號<ph id="ph1">&lt;xref:System.String&gt;</ph>執行個體。</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The sequence and number of delimiter characters is variable or unknown.</source>
          <target state="translated">順序及分隔符號字元數是區域變數或未知。</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method cannot be used to split the following string, because the number of <ph id="ph2">`\n`</ph> (in C#) or <ph id="ph3">`vbCrLf`</ph> (in Visual Basic) characters is variable, and they don't always serve as delimiters.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法無法用來分割下列字串，因為數目<ph id="ph2">`\n`</ph>（C# 中） 或<ph id="ph3">`vbCrLf`</ph>（在 Visual Basic) 字元是變數，而且它們不一定會做為分隔符號。</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>A regular expression can split this string easily, as the following example shows.</source>
          <target state="translated">規則運算式可以輕鬆，如下列範例所示分割此字串。</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The regular expression pattern <ph id="ph1">`\[([^\[\]]+)\]`</ph> is defined like this:</source>
          <target state="translated">規則運算式模式<ph id="ph1">`\[([^\[\]]+)\]`</ph>定義如下：</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match an opening bracket.</source>
          <target state="translated">比對左括號。</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match any character that is not an opening or a closing bracket one or more times.</source>
          <target state="translated">比對不是左或右括弧一或多次的任何字元。</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the first capturing group.</source>
          <target state="translated">這是第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match a closing bracket.</source>
          <target state="translated">比對右括號。</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method is almost identical to <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>方法是幾乎完全相同<ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>，只不過它會將分割根據規則運算式模式，而不是固定的字元集的字串。</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, the following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</source>
          <target state="translated">例如，下列範例會使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>方法包含以各種連字號和其他字元的組合分隔的子字串將字串分隔。</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The regular expression pattern <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> is defined like this:</source>
          <target state="translated">規則運算式模式<ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph>定義如下：</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match a whitespace character followed by a hyphen.</source>
          <target state="translated">比對空白字元後面接著連字號。</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">比對零個或一個空白字元。</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match zero or one occurrence of either the + or * character.</source>
          <target state="translated">比對零個或一個任一個的 + 或 * 字元。</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">比對零個或一個空白字元。</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match a hyphen followed by a whitespace character.</source>
          <target state="translated">比對後面接著空白字元的字元是連字號。</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Search methods and the Substring method</source>
          <target state="translated">搜尋方法和 Substring 方法</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</source>
          <target state="translated">如果您不想要在字串中子字串的所有項目，您可能想要使用其中一個會傳回的索引開始比對的字串比較方法。</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>You can then call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract the substring that you want.</source>
          <target state="translated">您可以接著呼叫<ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph>方法，可擷取您想要的子字串。</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The string comparison methods include:</source>
          <target state="translated">字串比較方法包括：</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>它會傳回字元或字串第一次出現的以零為起始的索引中的字串執行個體。</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>它會傳回目前的字串執行個體中，字元陣列中的任何字元第一次出現的以零為起始的索引。</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>它會傳回字元或字串最後一次出現的以零為起始的索引中的字串執行個體。</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>它會傳回以零為起始的索引中目前的最後一個出現的字元陣列中的任何字元的字串執行個體。</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to find the periods in a string.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法來尋找字串中的句點。</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>It then uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to return full sentences.</source>
          <target state="translated">然後它會使用<ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph>方法以傳回完整的句子。</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Performance Considerations</source>
          <target state="translated">效能考量</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法傳回的陣列物件配置記憶體和<ph id="ph2">&lt;xref:System.String&gt;</ph>每個陣列元素的物件。</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method.</source>
          <target state="translated">如果您的應用程式需要最佳效能，或管理記憶體配置是關鍵應用程式中，請考慮使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>You also have the option of using the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to locate a substring within a string.</source>
          <target state="translated">您也可以選擇使用<ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>方法來找出在字串內子字串。</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>To split a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">若要分割位於分隔字元字串，請使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法來找出字串中的分隔字元。</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>To split a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">若要分割的分隔符號字串的字串，請使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法來找出第一個字元的分隔符號字串。</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">然後使用<ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>方法，以判斷是否相等的分隔符號字串的其餘字元之後的第一個字元的字元。</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">此外，如果相同設定的字元用來分割在多個字串<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">這會大幅降低每個方法呼叫的額外負擔。</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The following example demonstrates how to extract individual words from a block of text by treating white space and punctuation marks as delimiters.</source>
          <target state="translated">下列範例示範如何從一個區塊的文字擷取個別文字，藉由將做為分隔符號的泛空白字元和標點符號。</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The character array passed to the <ph id="ph1">`separator`</ph> parameter of the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method consists of a space character and a tab character, together with some common punctuation symbols.</source>
          <target state="translated">字元陣列傳遞至<ph id="ph1">`separator`</ph>參數<ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph>方法包含空格字元和定位字元，以及一些常見的標點符號。</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>和舊版中，如果<ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph>方法傳遞<ph id="ph3">&lt;paramref name="separator" /&gt;</ph>也就是<ph id="ph4">&lt;see langword="null" /&gt;</ph>或未包含任何字元，方法會使用稍有不同的一組字元分割字串比<ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph>方法會以修剪該字串。</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，這兩種方法使用一組完全相同的 Unicode 空白字元。</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The maximum number of substrings to return.</source>
          <target state="translated">要傳回的子字串之最大數目。</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Splits a string into a maximum number of substrings based on the characters in an array.</source>
          <target state="translated">根據陣列中的字元分割字串成最大數目的子字串。</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>You also specify the maximum number of substrings to return.</source>
          <target state="translated">您也要指定傳回的子字串之最大數目。</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>An array whose elements contain the substrings in this instance that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">陣列，其項目中包含了這個執行個體中的子字串，由 <ph id="ph1">&lt;paramref name="separator" /&gt;</ph> 內的一或多個字元分隔。</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">如需詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
          <target state="translated">傳回陣列的項目中不包含分隔符號字元。</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">如果這個執行個體不包含任何字元<ph id="ph1">`separator`</ph>，傳回的陣列包含這個執行個體的單一項目所組成。</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is zero, an empty array is returned.</source>
          <target state="translated">如果<ph id="ph1">`count`</ph>為零，則傳回空陣列。</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">如果<ph id="ph1">`separator`</ph>參數是<ph id="ph2">`null`</ph>未包含任何字元，或空格字元會假設為分隔符號。</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">空白字元會由 Unicode 標準和傳回<ph id="ph1">`true`</ph>如果傳遞至<ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
          <target state="translated">每個項目<ph id="ph1">`separator`</ph>定義不同的分隔符號字元。</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">如果兩個分隔符號是相鄰的或是位於分隔符號的開頭或結尾的這個執行個體，對應的陣列元素包含<ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
          <target state="translated">如果有多個<ph id="ph1">`count`</ph>子字串，在本例中，第一個<ph id="ph2">`count`</ph>減 1 的子字串會傳回在第一個<ph id="ph3">`count`</ph>減 1 的傳回值，而其餘字元在這個執行個體中的項目會傳回在過去傳回值的項目。</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
          <target state="translated">如果<ph id="ph1">`count`</ph>數目大於可用的子字串所傳回的子字串，並擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The following table provides examples.</source>
          <target state="translated">下表提供範例。</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>String value</source>
          <target state="translated">字串值</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Separator</source>
          <target state="translated">Separator</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Count</source>
          <target state="translated">計數</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Returned array</source>
          <target state="translated">傳回的陣列</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"42, 12, 19"</source>
          <target state="translated">"42, 12, 19"</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {',', ' '} (C#)</source>
          <target state="translated">新 Char [] {'，' ' '} (C#)</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {","c, " "c} (Visual Basic)</source>
          <target state="translated">Char() = {","c, " "c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"42", " 12, 19"}</source>
          <target state="translated">{"42", " 12, 19"}</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"42..12..19"</source>
          <target state="translated">"42..12..19"</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {'.'}</source>
          <target state="translated">新 Char [] {'。 '}</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char （) = {"。"c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"42", "", "12", ".19"}</source>
          <target state="translated">{"42", "", "12", ".19"}</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Banana"</source>
          <target state="translated">「 Banana"</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {'.'}</source>
          <target state="translated">新 Char [] {'。 '}</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char （) = {"。"c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Banana"}</source>
          <target state="translated">{"Banana"}</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (C#)</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {} (C#)</source>
          <target state="translated">新的 Char [] {} (C#)</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {} (Visual Basic)</source>
          <target state="translated">Char （) = {} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Darb\nSmarba"} (C#)</source>
          <target state="translated">{"Darb\nSmarba"} (C#)</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (C#)</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] null (C#)</source>
          <target state="translated">新 Char [] null (C#)</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = Nothing</source>
          <target state="translated">Char （) = Nothing</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{"Darb", "Smarba"}</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (C#)</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] null (C#)</source>
          <target state="translated">新 Char [] null (C#)</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = Nothing</source>
          <target state="translated">Char （) = Nothing</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>100</source>
          <target state="translated">100</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{"Darb", "Smarba"}</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Performance Considerations</source>
          <target state="translated">效能考量</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法傳回的陣列物件配置記憶體和<ph id="ph2">&lt;xref:System.String&gt;</ph>每個陣列元素的物件。</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">如果您的應用程式需要最佳效能，或管理記憶體配置是關鍵應用程式中，請考慮使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法，並選擇性地<ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph>方法，來找出在字串內子字串。</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">如果您要分割位於分隔字元字串，使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法來找出字串中的分隔字元。</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">如果您要分割的分隔符號字串的字串，使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法來找出第一個字元的分隔符號字串。</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">然後使用<ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>方法，以判斷是否相等的分隔符號字串的其餘字元之後的第一個字元的字元。</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">此外，如果相同設定的字元用來分割在多個字串<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">這會大幅降低每個方法呼叫的額外負擔。</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The following example demonstrates how <ph id="ph1">`count`</ph> affects the number of strings returned by <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</source>
          <target state="translated">下列範例會示範如何<ph id="ph1">`count`</ph>影響字串所傳回的數字<ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>和舊版中，如果<ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph>方法傳遞<ph id="ph3">&lt;paramref name="separator" /&gt;</ph>也就是<ph id="ph4">&lt;see langword="null" /&gt;</ph>或未包含任何字元，方法會使用稍有不同的一組字元分割字串比<ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph>方法會以修剪該字串。</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，這兩種方法使用一組完全相同的 Unicode 空白字元。</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> 表示要省略傳回陣列中的空陣列項目，否則 <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> 表示要包含傳回陣列中的空陣列項目。</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Splits a string into substrings based on the characters in an array.</source>
          <target state="translated">根據陣列中的字元分割字串成子字串。</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>You can specify whether the substrings include empty array elements.</source>
          <target state="translated">您可以指定子字串是否包含空的陣列元素。</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">陣列，其項目包含了這個字串中由 <ph id="ph1">&lt;paramref name="separator" /&gt;</ph> 內的一或多個字元所分隔的子字串。</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">如需詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Return value details</source>
          <target state="translated">傳回值的詳細資料</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Delimiter characters (the characters in the <ph id="ph1">`separator`</ph> array) are not included in the elements of the returned array.</source>
          <target state="translated">分隔符號字元 (中的字元<ph id="ph1">`separator`</ph>陣列) 不包含在傳回陣列中的項目。</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For example, if the <ph id="ph1">`separator`</ph> array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
          <target state="translated">例如，如果<ph id="ph1">`separator`</ph>陣列包含字元"-"，目前的字串執行個體的值是"aa 位 bb-cc"方法會傳回陣列，其中包含三個項目:"aa"、"bb"和"cc"。</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">如果這個執行個體不包含任何字元<ph id="ph1">`separator`</ph>，傳回的陣列包含這個執行個體的單一項目所組成。</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, the method returns an empty array.</source>
          <target state="translated">如果<ph id="ph1">`options`</ph>參數是<ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph>和這個執行個體的長度為零，方法會傳回空陣列。</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of a single character.</source>
          <target state="translated">每個項目<ph id="ph1">`separator`</ph>定義不同的分隔符號包含單一字元。</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> argument is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`options`</ph>引數是<ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>，和兩個分隔符號相鄰或分隔符號位於開頭或結尾的這個執行個體，對應的陣列元素包含<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For example, if <ph id="ph1">`separator`</ph> includes  two elements, "-" and "<ph id="ph2">\_</ph>", the value of the string instance is "-<ph id="ph3">\_</ph>aa-<ph id="ph4">\_</ph>", and the value of   the <ph id="ph5">`options`</ph> argument is <ph id="ph6">&lt;xref:System.StringSplitOptions.None&gt;</ph>, the method returns a string array with the following five elements:</source>
          <target state="translated">比方說，如果<ph id="ph1">`separator`</ph>包含兩個項目，"-"和"<ph id="ph2">\_</ph>"，字串執行個體的值是"-<ph id="ph3">\_</ph>aa 位<ph id="ph4">\_</ph>」，和值<ph id="ph5">`options`</ph>引數是<ph id="ph6">&lt;xref:System.StringSplitOptions.None&gt;</ph>，方法會傳回字串陣列下列五個項目：</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that precedes the "-" character at index 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>表示之前的空字串"-"字元位於索引 0。</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>表示之間的空白字串"-"字元在索引 0 和位於索引 1 的"_"字元。</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>"aa",</source>
          <target state="translated">"aa"，</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "_" character at index 4.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>代表索引 4 上的"_"字元後面接著的空字串。</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "-" character at index 5.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>表示後面之空字串"-"5 索引處的字元。</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The separator array</source>
          <target state="translated">分隔陣列</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">如果<ph id="ph1">`separator`</ph>參數是<ph id="ph2">`null`</ph>未包含任何字元，或空格字元會假設為分隔符號。</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">空白字元會由 Unicode 標準和傳回<ph id="ph1">`true`</ph>如果傳遞至<ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">如果<ph id="ph1">`separator`</ph>參數在呼叫這個方法多載是<ph id="ph2">`null`</ph>，編譯器多載解析失敗時。</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
          <target state="translated">若要明確地識別所呼叫的方法，您的程式碼必須指出的型別<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">下列範例顯示數種方式可明確識別這個多載。</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Comparison details</source>
          <target state="translated">比較詳細資料</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the characters in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法還會擷取一或多個中的字元會分隔這個字串中子字串<ph id="ph2">`separator`</ph>參數，並傳回這些子字串做為陣列的項目。</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法會尋找分隔符號執行比較使用區分大小寫的序數排序規則。</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Performance Considerations</source>
          <target state="translated">效能考量</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法傳回的陣列物件配置記憶體和<ph id="ph2">&lt;xref:System.String&gt;</ph>每個陣列元素的物件。</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">如果您的應用程式需要最佳效能，或管理記憶體配置是關鍵應用程式中，請考慮使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法，並選擇性地<ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph>方法，來找出在字串內子字串。</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">如果您要分割位於分隔字元字串，使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法來找出字串中的分隔字元。</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">如果您要分割的分隔符號字串的字串，使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法來找出第一個字元的分隔符號字串。</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">然後使用<ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>方法，以判斷是否相等的分隔符號字串的其餘字元之後的第一個字元的字元。</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">此外，如果相同設定的字元用來分割在多個字串<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">這會大幅降低每個方法呼叫的額外負擔。</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumeration to include or exclude substrings generated by the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph>列舉来包含或排除所產生的子字串<ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是其中一個 <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>和舊版中，如果<ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph>方法傳遞<ph id="ph3">&lt;paramref name="separator" /&gt;</ph>也就是<ph id="ph4">&lt;see langword="null" /&gt;</ph>或未包含任何字元，方法會使用稍有不同的一組字元分割字串比<ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph>方法會以修剪該字串。</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，這兩種方法使用一組完全相同的 Unicode 空白字元。</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> 表示要省略傳回陣列中的空陣列項目，否則 <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> 表示要包含傳回陣列中的空陣列項目。</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Splits a string into substrings based on the strings in an array.</source>
          <target state="translated">根據陣列中的字串分割字串成子字串。</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>You can specify whether the substrings include empty array elements.</source>
          <target state="translated">您可以指定子字串是否包含空的陣列元素。</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more strings in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">陣列，其項目包含了這個字串中由 <ph id="ph1">&lt;paramref name="separator" /&gt;</ph> 內的一或多個字串所分隔的子字串。</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">如需詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>When a string is delimited by a known set of strings, you can use the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method to separate it into substrings.</source>
          <target state="translated">當一組已知的字串所分隔的字串時，您可以使用<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>分隔成子字串的方法。</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Return value details</source>
          <target state="translated">傳回值的詳細資料</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Delimiter strings are not included in the elements of the returned array.</source>
          <target state="translated">傳回陣列的項目中不包含分隔符號字串。</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, if the <ph id="ph1">`separator`</ph> array includes the string "--" and the value of the current string instance is "aa--bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
          <target state="translated">例如，如果<ph id="ph1">`separator`</ph>陣列包含字串"-"，目前的字串執行個體的值是"aa-bb cc"方法會傳回陣列，其中包含三個項目:"aa"、"bb"和"cc"。</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If this instance does not contain any of the strings in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">如果這個執行個體不包含任何的字串中<ph id="ph1">`separator`</ph>，傳回的陣列包含這個執行個體的單一項目所組成。</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, the method returns an empty array.</source>
          <target state="translated">如果<ph id="ph1">`options`</ph>參數是<ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph>和這個執行個體的長度為零，方法會傳回空陣列。</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of one or more characters.</source>
          <target state="translated">每個項目<ph id="ph1">`separator`</ph>定義不同的分隔符號所組成的一或多個字元。</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> argument is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`options`</ph>引數是<ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>，和兩個分隔符號相鄰或分隔符號位於開頭或結尾的這個執行個體，對應的陣列元素包含<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, if <ph id="ph1">`separator`</ph> includes  two elements, "-" and "_", the value of the string instance is "-_aa-<ph id="ph2">\_</ph>", and the value of   the <ph id="ph3">`options`</ph> argument is <ph id="ph4">&lt;xref:System.StringSplitOptions.None&gt;</ph>, the method returns a sting array with the following five elements:</source>
          <target state="translated">比方說，如果<ph id="ph1">`separator`</ph>包含兩個項目，"-"和"_"、 字串執行個體的值是"-_aa-<ph id="ph2">\_</ph>」，和值<ph id="ph3">`options`</ph>引數是<ph id="ph4">&lt;xref:System.StringSplitOptions.None&gt;</ph>，方法會傳回字串陣列，包含下列五個元素：</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that precedes the "-" substring at index 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>表示之前的空字串"-"位於索引 0 的子字串。</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string between the "-" substring at index 0 and the "_" substring at index 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>表示之間的空白字串"-"在索引 0 和"_"子字串，位於索引 1 的子字串。</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>"aa",</source>
          <target state="translated">"aa"，</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "_" substring at index 4.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>表示後面"_"上的子字串索引 4 之空字串。</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "-" substring at index 5.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>表示後面之空字串"-"5 索引處的子字串。</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The separator array</source>
          <target state="translated">分隔陣列</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If any of the elements in <ph id="ph1">`separator`</ph> consists of multiple characters, the entire substring is considered a delimiter.</source>
          <target state="translated">如果有任何項目中<ph id="ph1">`separator`</ph>包含多個字元，將整個子字串會被視為分隔符號。</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, if one of the elements in <ph id="ph1">`separator`</ph> is "10", attempting to split the string "This10is10a10string."</source>
          <target state="translated">例如，如果一個中的項目<ph id="ph1">`separator`</ph>為"10"，請嘗試分割字串"This10is10a10string。 」</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>returns the following four-element array: { "This", "is", "a", "string."</source>
          <target state="translated">會傳回下列四個元素陣列: {"This"、"is"，"a"、"string"。</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>}.</source>
          <target state="translated">}.</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">如果<ph id="ph1">`separator`</ph>參數是<ph id="ph2">`null`</ph>未包含任何字元，或空格字元會假設為分隔符號。</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">空白字元會由 Unicode 標準和傳回<ph id="ph1">`true`</ph>如果傳遞至<ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">如果<ph id="ph1">`separator`</ph>參數在呼叫這個方法多載是<ph id="ph2">`null`</ph>，編譯器多載解析失敗時。</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
          <target state="translated">若要明確地識別所呼叫的方法，您的程式碼必須指出的型別<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">下列範例顯示數種方式可明確識別這個多載。</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Comparison details</source>
          <target state="translated">比較詳細資料</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the strings in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法還會擷取由一個或多個字串中分隔這個字串中的子字串<ph id="ph2">`separator`</ph>參數，並傳回這些子字串做為陣列的項目。</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法會尋找分隔符號執行比較使用區分大小寫的序數排序規則。</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method ignores any element of <ph id="ph2">`separator`</ph> whose value is <ph id="ph3">`null`</ph> or the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法就會忽略任何項目<ph id="ph2">`separator`</ph>其實<ph id="ph3">`null`</ph>或空字串 ("")。</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>To avoid ambiguous results when strings in <ph id="ph1">`separator`</ph> have characters in common, the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in <ph id="ph3">`separator`</ph> that is equal to a delimiter in the instance.</source>
          <target state="translated">若要避免模稜兩可的結果時中的字串<ph id="ph1">`separator`</ph>共通字元<ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>作業從開頭到結尾的執行個體的值，並且在符合中的第一個項目<ph id="ph3">`separator`</ph>等於中的分隔符號執行個體。</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The order in which substrings are encountered in the instance takes precedence over the order of elements in <ph id="ph1">`separator`</ph>.</source>
          <target state="translated">基元執行個體中的子字串順序的優先順序高於中項目的順序<ph id="ph1">`separator`</ph>。</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, consider an instance whose value is "abcdef".</source>
          <target state="translated">例如，假設其值為"abcdef"執行個體。</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the first element in <ph id="ph1">`separator`</ph> was "ef" and the second element was "bcde", the result of the split operation would be a string array that contains two elements, "a" and "f".</source>
          <target state="translated">如果中的第一個項目<ph id="ph1">`separator`</ph>"ef"，而第二個元素是"bcde"、 split 作業的結果會是字串陣列，其中包含兩個項目，"a"和"f"。</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This is because the substring in the instance, "bcde", is encountered and matches an element in <ph id="ph1">`separator`</ph> before the substring "f" is encountered.</source>
          <target state="translated">這是因為發生的子字串中的執行個體，"bcde"，且會符合中的項目<ph id="ph1">`separator`</ph>之前遇到"f"的子字串。</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>However, if the first element of <ph id="ph1">`separator`</ph> was "bcd" and the second element was "bc", the result of the split operation would be a string array that contains two elements, "a" and "ef".</source>
          <target state="translated">不過，如果第一個項目<ph id="ph1">`separator`</ph>"bcd"，而第二個元素是"bc"、 split 作業的結果會是字串陣列，其中包含兩個項目，"a"和"ef"。</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This is because "bcd" is the first delimiter in <ph id="ph1">`separator`</ph> that matches a delimiter in the instance.</source>
          <target state="translated">這是因為"bcd"中的第一個分隔符號<ph id="ph1">`separator`</ph>符合執行個體中的分隔符號。</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be a string array that contains two elements,  "a" and "def".</source>
          <target state="translated">如果分隔符號的順序相反，因此第一個項目為"bc"，而第二個項目已"bcd"，結果會是字串陣列，其中包含兩個項目，"a"和"def"。</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Performance considerations</source>
          <target state="translated">效能考量</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法傳回的陣列物件配置記憶體和<ph id="ph2">&lt;xref:System.String&gt;</ph>每個陣列元素的物件。</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">如果您的應用程式需要最佳效能，或管理記憶體配置是關鍵應用程式中，請考慮使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法，並選擇性地<ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph>方法，來找出在字串內子字串。</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">如果您要分割位於分隔字元字串，使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法來找出字串中的分隔字元。</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">如果您要分割的分隔符號字串的字串，使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法來找出第一個字元的分隔符號字串。</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">然後使用<ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>方法，以判斷是否相等的分隔符號字串的其餘字元之後的第一個字元的字元。</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">此外，如果相同設定的字元用來分割在多個字串<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">這會大幅降低每個方法呼叫的額外負擔。</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The following example illustrates the difference in the arrays returned by calling a string's <ph id="ph1">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType&gt;</ph> method with its <ph id="ph2">`options`</ph> parameter equal to <ph id="ph3">&lt;xref:System.StringSplitOptions.None?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">下列範例說明透過呼叫的字串所傳回陣列中的差異<ph id="ph1">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType&gt;</ph>方法及其<ph id="ph2">`options`</ph>參數等於<ph id="ph3">&lt;xref:System.StringSplitOptions.None?displayProperty=nameWithType&gt;</ph>和<ph id="ph4">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The following example defines an array of separators that include punctuation and white-space characters.</source>
          <target state="translated">下列範例會定義包含標點符號和空格字元的分隔符號的陣列。</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Passing this array along with a value of <ph id="ph1">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph> to the <ph id="ph2">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> method returns an array that consists of the individual words from the string.</source>
          <target state="translated">傳遞的值以及此陣列<ph id="ph1">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>至<ph id="ph2">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph>方法會傳回從字串的個別字所組成的陣列。</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Note that the method is called with the <ph id="ph1">`options`</ph> argument set to <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">請注意，方法以呼叫<ph id="ph1">`options`</ph>引數設定為<ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This prevents the returned array from including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> values that represent empty substring matches between punctuation marks and white-space characters.</source>
          <target state="translated">這可防止在傳回的陣列包括<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>代表標點符號和空格字元之間的空白子字串相符的值。</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是其中一個 <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>和舊版中，如果<ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph>方法傳遞<ph id="ph3">&lt;paramref name="separator" /&gt;</ph>也就是<ph id="ph4">&lt;see langword="null" /&gt;</ph>或未包含任何字元，方法會使用稍有不同的一組字元分割字串比<ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph>方法會以修剪該字串。</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，這兩種方法使用一組完全相同的 Unicode 空白字元。</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The maximum number of substrings to return.</source>
          <target state="translated">要傳回的子字串之最大數目。</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> 表示要省略傳回陣列中的空陣列項目，否則 <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> 表示要包含傳回陣列中的空陣列項目。</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Splits a string into a maximum number of substrings based on the characters in an array.</source>
          <target state="translated">根據陣列中的字元分割字串成最大數目的子字串。</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">陣列，其項目包含了這個字串中由 <ph id="ph1">&lt;paramref name="separator" /&gt;</ph> 內的一或多個字元所分隔的子字串。</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">如需詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
          <target state="translated">傳回陣列的項目中不包含分隔符號字元。</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, or the <ph id="ph2">`count`</ph> parameter is 1, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">如果這個執行個體不包含任何字元<ph id="ph1">`separator`</ph>，或<ph id="ph2">`count`</ph>參數為 1，傳回的陣列包含這個執行個體的單一項目所組成。</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">如果<ph id="ph1">`separator`</ph>參數是<ph id="ph2">`null`</ph>未包含任何字元，或空格字元會假設為分隔符號。</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">空白字元會由 Unicode 標準和傳回<ph id="ph1">`true`</ph>如果傳遞至<ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>However, if the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">不過，如果<ph id="ph1">`separator`</ph>參數在呼叫這個方法多載是<ph id="ph2">`null`</ph>，編譯器多載解析失敗時。</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the null.</source>
          <target state="translated">若要明確地識別所呼叫的方法，您的程式碼必須指出 null 的類型。</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">下列範例顯示數種方式可明確識別這個多載。</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`count`</ph> parameter is zero, or the <ph id="ph2">`options`</ph> parameter is <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, an empty array is returned.</source>
          <target state="translated">如果<ph id="ph1">`count`</ph>參數為零，或<ph id="ph2">`options`</ph>參數是<ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph>和這個執行個體的長度為零，則傳回空陣列。</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
          <target state="translated">每個項目<ph id="ph1">`separator`</ph>定義不同的分隔符號字元。</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`options`</ph>參數是<ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>，和兩個分隔符號相鄰或分隔符號位於開頭或結尾的這個執行個體，對應的陣列元素包含<ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
          <target state="translated">如果有多個<ph id="ph1">`count`</ph>子字串，在本例中，第一個<ph id="ph2">`count`</ph>減 1 的子字串會傳回在第一個<ph id="ph3">`count`</ph>減 1 的傳回值，而其餘字元在這個執行個體中的項目會傳回在過去傳回值的項目。</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
          <target state="translated">如果<ph id="ph1">`count`</ph>數目大於可用的子字串所傳回的子字串，並擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Performance Considerations</source>
          <target state="translated">效能考量</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法傳回的陣列物件配置記憶體和<ph id="ph2">&lt;xref:System.String&gt;</ph>每個陣列元素的物件。</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">如果您的應用程式需要最佳效能，或管理記憶體配置是關鍵應用程式中，請考慮使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法，並選擇性地<ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph>方法，來找出在字串內子字串。</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">如果您要分割位於分隔字元字串，使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法來找出字串中的分隔字元。</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">如果您要分割的分隔符號字串的字串，使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法來找出第一個字元的分隔符號字串。</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">然後使用<ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>方法，以判斷是否相等的分隔符號字串的其餘字元之後的第一個字元的字元。</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">此外，如果相同設定的字元用來分割在多個字串<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">這會大幅降低每個方法呼叫的額外負擔。</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumeration to include or exclude substrings generated by the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph>列舉来包含或排除所產生的子字串<ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是其中一個 <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>和舊版中，如果<ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph>方法傳遞<ph id="ph3">&lt;paramref name="separator" /&gt;</ph>也就是<ph id="ph4">&lt;see langword="null" /&gt;</ph>或未包含任何字元，方法會使用稍有不同的一組字元分割字串比<ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph>方法會以修剪該字串。</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，這兩種方法使用一組完全相同的 Unicode 空白字元。</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The maximum number of substrings to return.</source>
          <target state="translated">要傳回的子字串之最大數目。</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> 表示要省略傳回陣列中的空陣列項目，否則 <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> 表示要包含傳回陣列中的空陣列項目。</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Splits a string into a maximum number of substrings based on the strings in an array.</source>
          <target state="translated">根據陣列中的字串分割字串成最大數目的子字串。</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>You can specify whether the substrings include empty array elements.</source>
          <target state="translated">您可以指定子字串是否包含空的陣列元素。</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more strings in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">陣列，其項目包含了這個字串中由 <ph id="ph1">&lt;paramref name="separator" /&gt;</ph> 內的一或多個字串所分隔的子字串。</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">如需詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Return value details</source>
          <target state="translated">傳回值的詳細資料</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Delimiter strings are not included in the elements of the returned array.</source>
          <target state="translated">傳回陣列的項目中不包含分隔符號字串。</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If this instance does not contain any of the strings in <ph id="ph1">`separator`</ph>, or the <ph id="ph2">`count`</ph> parameter is 1, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">如果這個執行個體不包含任何的字串中<ph id="ph1">`separator`</ph>，或<ph id="ph2">`count`</ph>參數為 1，傳回的陣列包含這個執行個體的單一項目所組成。</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">如果<ph id="ph1">`separator`</ph>參數是<ph id="ph2">`null`</ph>未包含任何字元，或空格字元會假設為分隔符號。</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">空白字元會由 Unicode 標準和傳回<ph id="ph1">`true`</ph>如果傳遞至<ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>However, if the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">不過，如果<ph id="ph1">`separator`</ph>參數在呼叫這個方法多載是<ph id="ph2">`null`</ph>，編譯器多載解析失敗時。</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
          <target state="translated">若要明確地識別所呼叫的方法，您的程式碼必須指出的型別<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">下列範例顯示數種方式可明確識別這個多載。</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`count`</ph> parameter is zero, or the <ph id="ph2">`options`</ph> parameter is <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, an empty array is returned.</source>
          <target state="translated">如果<ph id="ph1">`count`</ph>參數為零，或<ph id="ph2">`options`</ph>參數是<ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph>和這個執行個體的長度為零，則傳回空陣列。</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of one or more characters.</source>
          <target state="translated">每個項目<ph id="ph1">`separator`</ph>定義不同的分隔符號所組成的一或多個字元。</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`options`</ph>參數是<ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>，和兩個分隔符號相鄰或分隔符號位於開頭或結尾的這個執行個體，對應的陣列元素包含<ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
          <target state="translated">如果有多個<ph id="ph1">`count`</ph>子字串，在本例中，第一個<ph id="ph2">`count`</ph>減 1 的子字串會傳回在第一個<ph id="ph3">`count`</ph>減 1 的傳回值，而其餘字元在這個執行個體中的項目會傳回在過去傳回值的項目。</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
          <target state="translated">如果<ph id="ph1">`count`</ph>數目大於可用的子字串所傳回的子字串，並擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The separator array</source>
          <target state="translated">分隔陣列</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If any of the elements in <ph id="ph1">`separator`</ph> consists of multiple characters, the entire substring is considered a delimiter.</source>
          <target state="translated">如果有任何項目中<ph id="ph1">`separator`</ph>包含多個字元，將整個子字串會被視為分隔符號。</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For example, if one of the elements in <ph id="ph1">`separator`</ph> is "10", attempting to split the string "This10is10a10string."</source>
          <target state="translated">例如，如果一個中的項目<ph id="ph1">`separator`</ph>為"10"，請嘗試分割字串"This10is10a10string。 」</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>returns this four-element array: { "This", "is", "a", "string."</source>
          <target state="translated">傳回這個四個元素陣列: {"This"、"is"，"a"、"string"。</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>}.</source>
          <target state="translated">}.</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Comparison details</source>
          <target state="translated">比較詳細資料</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the strings in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法還會擷取由一個或多個字串中分隔這個字串中的子字串<ph id="ph2">`separator`</ph>參數，並傳回這些子字串做為陣列的項目。</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法會尋找分隔符號執行比較使用區分大小寫的序數排序規則。</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">如需 word、 字串和序數排序的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method ignores any element of <ph id="ph2">`separator`</ph> whose value is <ph id="ph3">`null`</ph> or the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法就會忽略任何項目<ph id="ph2">`separator`</ph>其實<ph id="ph3">`null`</ph>或空字串 ("")。</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>To avoid ambiguous results when strings in <ph id="ph1">`separator`</ph> have characters in common, the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method proceeds from the beginning to the end of the value of the instance, and matches the first element in <ph id="ph3">`separator`</ph> that is equal to a delimiter in the instance.</source>
          <target state="translated">若要避免模稜兩可的結果時中的字串<ph id="ph1">`separator`</ph>共通字元<ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>方法從開頭到結尾的執行個體的值，並且在符合中的第一個項目<ph id="ph3">`separator`</ph>等於中的分隔符號執行個體。</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The order in which substrings are encountered in the instance takes precedence over the order of elements in <ph id="ph1">`separator`</ph>.</source>
          <target state="translated">基元執行個體中的子字串順序的優先順序高於中項目的順序<ph id="ph1">`separator`</ph>。</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For example, consider an instance whose value is "abcdef".</source>
          <target state="translated">例如，假設其值為"abcdef"執行個體。</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the first element in <ph id="ph1">`separator`</ph> was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f".</source>
          <target state="translated">如果中的第一個項目<ph id="ph1">`separator`</ph>"ef"，而第二個元素是"bcde"、 split 作業的結果會是"a"和"f"。</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>This is because the substring in the instance, "bcde", is encountered and matches an element in <ph id="ph1">`separator`</ph> before the substring "f" is encountered.</source>
          <target state="translated">這是因為發生的子字串中的執行個體，"bcde"，且會符合中的項目<ph id="ph1">`separator`</ph>之前遇到"f"的子字串。</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>However, if the first element of <ph id="ph1">`separator`</ph> was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef".</source>
          <target state="translated">不過，如果第一個項目<ph id="ph1">`separator`</ph>"bcd"，而第二個元素是"bc"、 split 作業的結果會是"a"和"ef"。</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>This is because "bcd" is the first delimiter in <ph id="ph1">`separator`</ph> that matches a delimiter in the instance.</source>
          <target state="translated">這是因為"bcd"中的第一個分隔符號<ph id="ph1">`separator`</ph>符合執行個體中的分隔符號。</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def".</source>
          <target state="translated">如果分隔符號的順序相反，因此第一個項目為"bc"，而第二個項目已"bcd"，結果會是"a"和"def"。</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Performance considerations</source>
          <target state="translated">效能考量</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法傳回的陣列物件配置記憶體和<ph id="ph2">&lt;xref:System.String&gt;</ph>每個陣列元素的物件。</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">如果您的應用程式需要最佳效能，或管理記憶體配置是關鍵應用程式中，請考慮使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法，並選擇性地<ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph>方法，來找出在字串內子字串。</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">如果您要分割位於分隔字元字串，使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法來找出字串中的分隔字元。</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">如果您要分割的分隔符號字串的字串，使用<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>方法來找出第一個字元的分隔符號字串。</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">然後使用<ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>方法，以判斷是否相等的分隔符號字串的其餘字元之後的第一個字元的字元。</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">此外，如果相同設定的字元用來分割在多個字串<ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">這會大幅降低每個方法呼叫的額外負擔。</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumeration to include or exclude substrings generated by the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph>列舉来包含或排除所產生的子字串<ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> 為負。</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是其中一個 <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>和舊版中，如果<ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph>方法傳遞<ph id="ph3">&lt;paramref name="separator" /&gt;</ph>也就是<ph id="ph4">&lt;see langword="null" /&gt;</ph>或未包含任何字元，方法會使用稍有不同的一組字元分割字串比<ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph>方法會以修剪該字串。</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，這兩種方法使用一組完全相同的 Unicode 空白字元。</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Determines whether the beginning of this string instance matches a specified string.</source>
          <target state="translated">判斷這個字串執行個體的開頭是否符合指定的字串。</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source>The string to compare.</source>
          <target state="translated">要比較的字串。</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source>Determines whether the beginning of this string instance matches the specified string.</source>
          <target state="translated">判斷這個字串執行個體的開頭是否符合指定的字串。</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> matches the beginning of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 符合這個字串的開頭，則為 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>This method compares <ph id="ph1">`value`</ph> to the substring at the beginning of this instance that is the same length as <ph id="ph2">`value`</ph>, and returns an indication whether they are equal.</source>
          <target state="translated">這個方法會比較<ph id="ph1">`value`</ph>是相同的長度做為這個執行個體的開頭的子字串<ph id="ph2">`value`</ph>，並傳回表示是否相等。</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be an empty string (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), must be a reference to this same instance, or must match the beginning of this instance.</source>
          <target state="translated">若要視為相等，<ph id="ph1">`value`</ph>必須是空字串 (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>)，必須是這個相同的執行個體的參考，或是必須符合這個執行個體的開頭。</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>The following example defines a <ph id="ph1">`StripStartTags`</ph> method that uses the <ph id="ph2">&lt;xref:System.String.StartsWith%28System.String%29&gt;</ph> method to remove HTML start tags from the beginning of a string.</source>
          <target state="translated">下列範例會定義<ph id="ph1">`StripStartTags`</ph>方法使用<ph id="ph2">&lt;xref:System.String.StartsWith%28System.String%29&gt;</ph>移除 HTML 方法從字串開頭開始標記。</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>Note that the <ph id="ph1">`StripStartTags`</ph> method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed.</source>
          <target state="translated">請注意，<ph id="ph1">`StripStartTags`</ph>方法稱為遞迴運作，以確保要移除的多個 HTML 開始標記，在一行的開頭。</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>The example does not remove HTML tags embedded in a string.</source>
          <target state="translated">此範例不會移除內嵌在字串中的 HTML 標記。</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">中所述<bpt id="p1">[</bpt>使用字串的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>To determine whether a string begins with a particular substring by using the string comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">若要判斷是否字串開頭為特定的子字串使用目前文化特性的字串比較規則，請呼叫<ph id="ph1">&lt;see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /&gt;</ph>方法多載，其值為<ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph>針對其<ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The string to compare.</source>
          <target state="translated">要比較的字串。</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>One of the enumeration values that determines how this string and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">列舉值之一，指定這個字串和 <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 的比較方式。</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</source>
          <target state="translated">判斷當使用指定之比較選項進行比較時，這個字串執行個體的開頭是否符合指定的字串。</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this instance begins with <ph id="ph2">&lt;paramref name="value" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果這個執行個體以 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 為開頭，則為 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method compares the <ph id="ph2">`value`</ph> parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph>方法會比較<ph id="ph2">`value`</ph>在這個字串的開頭的子字串的參數和傳回值，指出它們是否相等。</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same string, must be the empty string (""), or must match the beginning of this string.</source>
          <target state="translated">若要視為相等，<ph id="ph1">`value`</ph>必須是相同的字串的參考，必須是空字串 ("")，或必須符合這個字串的開頭。</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The type of comparison performed by the <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method depends on the value of the <ph id="ph2">`comparisonType`</ph> parameter.</source>
          <target state="translated">所執行的比較類型<ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph>方法取決於值<ph id="ph2">`comparisonType`</ph>參數。</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The comparison can use the conventions of the current culture (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>) or the invariant culture (<ph id="ph3">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>), or it can consist of a character-by-character comparison of code points (<ph id="ph5">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">比較可以使用目前文化特性的慣例 (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>) 或文化特性而異 (<ph id="ph3">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph>和<ph id="ph4">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>)，或者也可以包含字碼指標的逐字元比較 (<ph id="ph5">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>或<ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The comparison can also be case-sensitive (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>), or it can ignore case (<ph id="ph4">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">比較也可以是區分大小寫 (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>， <ph id="ph2">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph>，或<ph id="ph3">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>)，或它可以忽略大小寫 (<ph id="ph4">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>， <ph id="ph5">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>， <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The following example searches for the string "the" at the beginning of a longer string that begins with the word "The".</source>
          <target state="translated">下列範例會搜尋字串"the"開頭字較長字串的開頭"The"。</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>As the output from the example shows, a call to the <ph id="ph1">&lt;xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29&gt;</ph> method that performs a culture-insensitive but case-sensitive comparison fails to match the string, while a call that performs a culture- and case-insensitive comparison matches the string.</source>
          <target state="translated">從範例所示，呼叫輸出<ph id="ph1">&lt;xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29&gt;</ph>方法，執行區分大小寫，但不區分文化特性的比較時，無法比對字串中，而執行的文化特性和 case insensitive 比較的呼叫會比對字串。</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The following example determines whether a string starts with a particular substring.</source>
          <target state="translated">下列範例會判斷字串是否以特定的子字串開始。</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>It initializes a two-dimensional string array.</source>
          <target state="translated">它會初始化二維的字串陣列。</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The first element in the second dimension contains a string, and the second element contains the string to search for at the start of the first string.</source>
          <target state="translated">第二個維度中的第一個項目包含字串，而第二個元素包含要搜尋的第一個字串的開頭的字串。</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</source>
          <target state="translated">文化特性、 是否忽略大小寫，以及是否執行序數比較的選擇會影響結果。</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>Note that when the string instance contains a ligature, culture-sensitive comparisons with its consecutive characters successfully match.</source>
          <target state="translated">請注意，當字串執行個體包含連字，其連續字元的區分文化特性的比較成功比對。</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The string to compare.</source>
          <target state="translated">要比較的字串。</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示在比較時忽略大小寫，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Cultural information that determines how this string and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">判斷如何比較此字串和 <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> 的文化特性資訊。</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current culture is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> 是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，則會使用目前的文化特性。</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</source>
          <target state="translated">判斷當使用指定之文化特性進行比較時，這個字串執行個體的開頭是否符合指定的字串。</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter matches the beginning of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 參數符合這個字串的開頭，則為 <ph id="ph2">&lt;paramref name="value" /&gt;</ph>，否則為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method compares the <ph id="ph1">`value`</ph> parameter to the substring at the beginning of this string that is the same length as <ph id="ph2">`value`</ph>, and returns a value that indicates whether they are equal.</source>
          <target state="translated">這個方法會比較<ph id="ph1">`value`</ph>參數在此與相同長度的字串開頭的子字串<ph id="ph2">`value`</ph>，並傳回值，指出它們是否相等。</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be an empty string (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), must be a reference to this same instance, or must match the beginning of this instance.</source>
          <target state="translated">若要視為相等，<ph id="ph1">`value`</ph>必須是空字串 (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>)，必須是這個相同的執行個體的參考，或是必須符合這個執行個體的開頭。</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method performs a comparison using the specified casing and culture.</source>
          <target state="translated">這個方法會執行使用指定的大小寫和文化特性的比較。</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example determines whether a string occurs at the beginning of another string.</source>
          <target state="translated">下列範例會判斷字串是否會在另一個字串的開頭發生。</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph>幾次使用區分大小寫、 不區分大小寫和不同的文化特性會影響搜尋的結果呼叫方法。</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Retrieves a substring from this instance.</source>
          <target state="translated">從這個執行個體擷取子字串。</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>This member is overloaded.</source>
          <target state="translated">這個成員是多載的。</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>For complete information about this member, including syntax, usage, and examples, click a name in the overload list.</source>
          <target state="translated">如需這個成員的完整資訊，包含語法、使用方式和範例，請按一下多載清單中的名稱。</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>The zero-based starting character position of a substring in this instance.</source>
          <target state="translated">這個執行個體中子字串之以零為起始的起始字元位置。</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>Retrieves a substring from this instance.</source>
          <target state="translated">從這個執行個體擷取子字串。</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>The substring starts at a specified character position and continues to the end of the string.</source>
          <target state="translated">子字串會在指定的字元位置開始並繼續到字串的結尾。</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>A string that is equivalent to the substring that begins at <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> in this instance, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is equal to the length of this instance.</source>
          <target state="translated">與這個執行個體中從 <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 開始之子字串相等的字串；如果 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> 等於這個執行個體的長度，則為 <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract a substring from a string that begins at a specified character position and ends at the end of the string.</source>
          <target state="translated">您呼叫<ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph>方法，以從指定的字元位置開始，且字串的結尾當做結尾的字串擷取子字串。</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</source>
          <target state="translated">起始字元的位置以零為起始。換句話說，在字串中的第一個字元是在索引 0，索引 1。</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>To extract a substring that begins at a specified character position and ends before to the end of the string, call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method.</source>
          <target state="translated">若要擷取的子字串，指定的字元位置開始並以字串的結尾結束之前，請呼叫<ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>Instead, it returns a new string that begins at the <ph id="ph1">`startIndex`</ph> position in the current string.</source>
          <target state="translated">相反地，它會傳回新字串，起點<ph id="ph1">`startIndex`</ph>目前字串中的位置。</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>To extract a substring that begins with a particular character or character sequence, call a method such as  <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> to get the value of <ph id="ph3">`startIndex`</ph>.</source>
          <target state="translated">若要擷取特定字元或字元序列的開頭的子字串，呼叫的方法如<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph>取得的值<ph id="ph3">`startIndex`</ph>。</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The second example illustrates this; it extracts a key value that begins one character position after the "=" character.</source>
          <target state="translated">第二個範例將說明這點。它會擷取一個字元位置開始"="字元後面的金鑰值。</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to zero, the method returns the original string unchanged.</source>
          <target state="translated">如果<ph id="ph1">`startIndex`</ph>等於零，則方法會傳回原始字串不變。</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The following example demonstrates obtaining a substring from a string.</source>
          <target state="translated">下列範例會示範從字串取得子字串。</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to separate key/value pairs that are delimited by an equals ("=") character.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph>方法，以不同的以等號分隔的索引鍵/值配對 （"="） 字元。</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method is used to get the position of the equals character in the string..</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法用來取得等字元的字串中的位置...</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">若要呼叫<ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph>方法還會擷取索引鍵名稱。，它會從字串中的第一個字元開始，並延伸來呼叫所傳回的字元數個<ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> method then extracts the value assigned to the key.</source>
          <target state="translated">若要呼叫<ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph>方法接著會擷取指定的索引鍵的值。</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>It starts at one character position beyond the equals character and extends to the end of the string.</source>
          <target state="translated">它會從一個等號字元後面的字元位置，並延伸到字串的結尾。</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than the length of this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 小於零或大於此執行個體的長度。</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The zero-based starting character position of a substring in this instance.</source>
          <target state="translated">這個執行個體中子字串之以零為起始的起始字元位置。</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The number of characters in the substring.</source>
          <target state="translated">子字串中的字元數。</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>Retrieves a substring from this instance.</source>
          <target state="translated">從這個執行個體擷取子字串。</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The substring starts at a specified character position and has a specified length.</source>
          <target state="translated">子字串起始於指定的字元位置，並且具有指定的長度。</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>A string that is equivalent to the substring of length <ph id="ph1">&lt;paramref name="length" /&gt;</ph> that begins at <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> in this instance, or <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> is equal to the length of this instance and <ph id="ph5">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated">與長度為 <ph id="ph1">&lt;paramref name="length" /&gt;</ph> 且在這個執行個體中從 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 開始之子字串相等的字串；如果 <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph> 等於這個執行個體的長度且 <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> 為零，則為 <ph id="ph5">&lt;paramref name="length" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method to extract a substring from a string that begins at a specified character position and ends before the end of the string.</source>
          <target state="translated">您呼叫<ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph>方法，以從指定的字元位置開始，且字串的結尾之前結束的字串擷取子字串。</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</source>
          <target state="translated">起始字元的位置以零為起始。換句話說，在字串中的第一個字元是在索引 0，索引 1。</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>To extract a substring that begins at a specified character position and continues to the end of the string, call the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> method.</source>
          <target state="translated">若要擷取的子字串，指定的字元位置開始並繼續到字串的結尾，呼叫<ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>Instead, it returns a new string with <ph id="ph1">`length`</ph> characters starting from the <ph id="ph2">`startIndex`</ph> position in the current string.</source>
          <target state="translated">相反地，它會傳回新字串，<ph id="ph1">`length`</ph>起的字元<ph id="ph2">`startIndex`</ph>目前字串中的位置。</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`length`</ph> parameter represents the total number of characters to extract from the current string instance.</source>
          <target state="translated"><ph id="ph1">`length`</ph>參數代表要從目前的字串執行個體中擷取的字元總數。</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This includes the starting character found at index  <ph id="ph1">`startIndex`</ph>.</source>
          <target state="translated">這包括起始字元的索引，請參閱<ph id="ph1">`startIndex`</ph>。</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>In other words, the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method attempts to extract characters from index <ph id="ph2">`startIndex`</ph> to index <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph> - 1.</source>
          <target state="translated">換句話說，<ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph>方法會嘗試從索引擷取字元<ph id="ph2">`startIndex`</ph>索引<ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph> -1。</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>To extract a substring that begins with a particular character or character sequence, call a method such as  <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> to get the value of <ph id="ph3">`startIndex`</ph>.</source>
          <target state="translated">若要擷取特定字元或字元序列的開頭的子字串，呼叫的方法如<ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>取得的值<ph id="ph3">`startIndex`</ph>。</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If the substring extends from <ph id="ph1">`startIndex`</ph> to a specified character sequence, you can call a method such as  <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> to get the index of the ending character or character sequence.</source>
          <target state="translated">如果從子字串開始<ph id="ph1">`startIndex`</ph>在指定的字元順序，您可以呼叫方法例如<ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>取得結束的字元或字元序列的索引。</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>You can then convert that value to an index position in the string as follows:</source>
          <target state="translated">您可以再將該值轉換成字串中的索引位置，如下所示：</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If you've searched for a single character that is to mark the end of the substring, the <ph id="ph1">`length`</ph> parameter equals  <ph id="ph2">`endIndex`</ph><ph id="ph3"> - </ph><ph id="ph4">`startIndex`</ph> + 1, where <ph id="ph5">`endIndex`</ph> is the return value of the <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">如果您要標記的子字串結尾的單一字元搜尋過<ph id="ph1">`length`</ph>參數等於<ph id="ph2">`endIndex`</ph> <ph id="ph3"> - </ph> <ph id="ph4">`startIndex`</ph> + 1，其中<ph id="ph5">`endIndex`</ph>是傳回值的<ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example extracts a continuous block of "b" characters from a string.</source>
          <target state="translated">下列範例會從字串擷取"b"字元的連續的區塊。</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If you've searched for multiple characters that are to mark the end of the substring, the <ph id="ph1">`length`</ph> parameter equals  <ph id="ph2">`endIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`endMatchLength`</ph><ph id="ph5"> - </ph><ph id="ph6">`startIndex`</ph>, where <ph id="ph7">`endIndex`</ph> is the return value of the <ph id="ph8">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph9">&lt;xref:System.String.IndexOf%2A&gt;</ph> method., and <ph id="ph10">`endMatchLength`</ph> is the length of the character sequence that marks the end of the substring.</source>
          <target state="translated">如果您要標記的子字串結尾的多個字元的搜尋過<ph id="ph1">`length`</ph>參數等於<ph id="ph2">`endIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`endMatchLength`</ph> <ph id="ph5"> - </ph> <ph id="ph6">`startIndex`</ph>，其中<ph id="ph7">`endIndex`</ph>的傳回值<ph id="ph8">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph9">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法。 和<ph id="ph10">`endMatchLength`</ph>標記結尾的子字串的字元序列的長度。</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example extracts a block of text that contains an XML <ph id="ph1">`&lt;definition&gt;`</ph> element.</source>
          <target state="translated">下列範例會擷取包含 XML 的文字區塊<ph id="ph1">`&lt;definition&gt;`</ph>項目。</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If the character or character sequence is not included in the end of the substring, the <ph id="ph1">`length`</ph> parameter equals <ph id="ph2">`endIndex`</ph><ph id="ph3"> - </ph><ph id="ph4">`startIndex`</ph>, where <ph id="ph5">`endIndex`</ph> is the return value of the <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">如果字元或字元序列未包含在子字串的結尾<ph id="ph1">`length`</ph>參數等於<ph id="ph2">`endIndex`</ph> <ph id="ph3"> - </ph> <ph id="ph4">`startIndex`</ph>，其中<ph id="ph5">`endIndex`</ph>是傳回值的<ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph>或<ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to zero and  equals the length of the current string, the method returns the original string unchanged.</source>
          <target state="translated">如果<ph id="ph1">`startIndex`</ph>等於零和字串的長度目前，此方法傳回未變更的原始字串的等號。</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example illustrates a simple call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method that extracts two characters from a string starting at the sixth character position (that is, at index five).</source>
          <target state="translated">下列範例說明簡單呼叫<ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph>從字串的第六個的字元位置開始擷取兩個字元的方法 （也就是在索引 5）。</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method in the following three cases to isolate substrings within a string.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph>在下列三個情況下，若要找出在字串內子字串的方法。</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>In two cases the substrings are used in comparisons, and in the third case an exception is thrown because invalid parameters are specified.</source>
          <target state="translated">在兩個情況下之子字串會用來比較，並在第三個情況下擲回例外狀況因為指定的參數無效。</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It extracts the single character and the third position in the string (at index 2) and compares it with a "c".</source>
          <target state="translated">它會擷取單一字元和字串 （位於索引 2） 中的第三個位置，並比較它與"c"。</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This comparison returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">這項比較會傳回<ph id="ph1">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It extracts zero characters starting at the fourth position in the string (at index 3) and passes it to the <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method.</source>
          <target state="translated">它會擷取的第四個位置中 （位於索引 3） 的字串開頭的零個字元，並將其傳遞給<ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This returns true because the call to the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method returns <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">這個傳回 true，因為呼叫<ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph>方法會傳回<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It attempts to extract one character starting at the fourth position in the string.</source>
          <target state="translated">它會嘗試擷取一個字元字串中第四個位置開始。</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>Because there is no character at that position, the method call throws an <ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> exception.</source>
          <target state="translated">因為沒有在該位置的字元，方法呼叫會擲回<ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to separate key/value pairs that are delimited by an equals ("=") character.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph>方法，以不同的以等號分隔的索引鍵/值配對 （"="） 字元。</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method is used to get the position of the equals character in the string..</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法用來取得等字元的字串中的位置...</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">若要呼叫<ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph>方法還會擷取索引鍵名稱。，它會從字串中的第一個字元開始，並延伸來呼叫所傳回的字元數個<ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> method then extracts the value assigned to the key.</source>
          <target state="translated">若要呼叫<ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph>方法接著會擷取指定的索引鍵的值。</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It starts at one character position beyond the equals character and extends to the end of the string.</source>
          <target state="translated">它會從一個等號字元後面的字元位置，並延伸到字串的結尾。</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="length" /&gt;</ph> indicates a position not within this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 加上 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 表示不在此執行個體中的位置。</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 小於零。</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>Returns an enumerator that iterates through the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">傳回列舉值，可逐一查看目前的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>A strongly-typed enumerator that can be used to iterate through the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">強型別列舉值，可用來逐一查看目前的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface object.</source>
          <target state="translated">它可用時，才<ph id="ph1">&lt;xref:System.String&gt;</ph>執行個體轉換成<ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>介面物件。</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>Returns an enumerator that iterates through the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">傳回列舉值，可逐一查看目前的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>An enumerator that can be used to iterate through the current string.</source>
          <target state="translated">可用來逐一查看目前字串的列舉程式。</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">這個參數已忽略。</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the current string is <ph id="ph2">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph>; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the value of the current string is <ph id="ph4">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>.</source>
          <target state="translated">如果目前字串的值為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，則為 <ph id="ph2">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph>；如果目前字串的值為 <ph id="ph3">&lt;see langword="false" /&gt;</ph>，則為 <ph id="ph4">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>The value of the current string is not <ph id="ph1">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>.</source>
          <target state="translated">目前字串的值不是 <ph id="ph1">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph> 或 <ph id="ph2">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的轉換值。</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">無法剖析目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值。</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.Byte.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.Byte.MinValue" /&gt;</ph>.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值為大於 <ph id="ph2">&lt;see cref="F:System.Byte.MaxValue" /&gt;</ph> 或小於 <ph id="ph3">&lt;see cref="F:System.Byte.MinValue" /&gt;</ph> 的數字。</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>The character at index 0 in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件中位於索引 0 的字元。</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的轉換值。</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的轉換值。</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">無法剖析目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值。</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number less than <ph id="ph2">&lt;see cref="F:System.Decimal.MinValue" /&gt;</ph> or than <ph id="ph3">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph> greater.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值為小於 <ph id="ph2">&lt;see cref="F:System.Decimal.MinValue" /&gt;</ph> 或大於 <ph id="ph3">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph> 的數字。</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的轉換值。</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">無法剖析目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值。</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number less than <ph id="ph2">&lt;see cref="F:System.Double.MinValue" /&gt;</ph> or greater than <ph id="ph3">&lt;see cref="F:System.Double.MaxValue" /&gt;</ph>.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值為小於 <ph id="ph2">&lt;see cref="F:System.Double.MinValue" /&gt;</ph> 或大於 <ph id="ph3">&lt;see cref="F:System.Double.MaxValue" /&gt;</ph> 的數字。</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的轉換值。</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">無法剖析目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值。</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph>.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值為大於 <ph id="ph2">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph> 或小於 <ph id="ph3">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph> 的數字。</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的轉換值。</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的轉換值。</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的轉換值。</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">無法剖析目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值。</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph>.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值為大於 <ph id="ph2">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph> 或小於 <ph id="ph3">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph> 的數字。</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的轉換值。</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The type of the returned object.</source>
          <target state="translated">傳回的物件之類型。</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的轉換值。</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ChangeType%2A&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ChangeType%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be converted to the type specified by the <ph id="ph2">&lt;paramref name="type" /&gt;</ph> parameter.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值不能轉換為 <ph id="ph2">&lt;paramref name="type" /&gt;</ph> 參數指定的型別。</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的轉換值。</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">無法剖析目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值。</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.UInt16.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.UInt16.MinValue" /&gt;</ph>.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值為大於 <ph id="ph2">&lt;see cref="F:System.UInt16.MaxValue" /&gt;</ph> 或小於 <ph id="ph3">&lt;see cref="F:System.UInt16.MinValue" /&gt;</ph> 的數字。</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的轉換值。</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">無法剖析目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值。</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater <ph id="ph2">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.UInt32.MinValue" /&gt;</ph></source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的值為大於 <ph id="ph2">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph> 或小於 <ph id="ph3">&lt;see cref="F:System.UInt32.MinValue" /&gt;</ph> 的數字。</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">如需這個成員的說明，請參閱 <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件的轉換值。</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">這個成員是明確介面成員實作，</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">只有在 <ph id="ph1">&lt;xref:System.String&gt;</ph> 執行個體轉換成 <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> 介面時，才能使用這個成員。</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">建議的替代方式是呼叫<ph id="ph1">&lt;xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Copies the characters in this instance to a Unicode character array.</source>
          <target state="translated">將這個執行個體中的字元複製到 Unicode 字元陣列中。</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray">
          <source>Copies the characters in this instance to a Unicode character array.</source>
          <target state="translated">將這個執行個體中的字元複製到 Unicode 字元陣列中。</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray">
          <source>A Unicode character array whose elements are the individual characters of this instance.</source>
          <target state="translated">Unicode 字元陣列，其項目是這個執行個體的個別字元。</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray">
          <source>If this instance is an empty string, the returned array is empty and has a zero length.</source>
          <target state="translated">如果這個執行個體是空字串，則傳回的陣列會是空的且長度為零。</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>This method copies each character (that is, each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object) in a string to a character array.</source>
          <target state="translated">這個方法會複製每個字元 (亦即，每個<ph id="ph1">&lt;xref:System.Char&gt;</ph>物件) 中的字元陣列的字串。</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>The first character copied is at index zero of the returned character array; the last character copied is at index <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> – 1.</source>
          <target state="translated">複製的第一個字元是索引位置為零的傳回的字元陣列。複製的最後一個字元是在索引<ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>– 1。</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>To create a string from the characters in a character array, call the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> constructor.</source>
          <target state="translated">若要建立字元陣列中的字元字串，呼叫<ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>To create a byte array that contains the encoded characters in a string, instantiate the appropriate <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object and call its <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">若要建立包含編碼的字元在字串中的位元組陣列，產生適當<ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph>物件並呼叫其<ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>Some of the standard encodings available in the .NET Framework include the following:</source>
          <target state="translated">.NET Framework 中可用之標準編碼包括下列：</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>Encoding</source>
          <target state="translated">編碼</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>Object</source>
          <target state="translated">Object</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>ASCII</source>
          <target state="translated">ASCII</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>For more information, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>字元編碼方式在.NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> method to extract the characters in a string to a character array.</source>
          <target state="translated">下列範例會呼叫<ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph>方法來擷取字元的字元陣列的字串中。</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>It then displays the original string and the elements in the array.</source>
          <target state="translated">接著會顯示原始的字串和項目陣列中。</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>The following example defines a string containing the characters that serve as delimiters in a delimited string.</source>
          <target state="translated">下列範例會定義包含做為分隔符號分隔的字串中字元的字串。</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> method to create a character array that can be passed to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method to separate the delimited string into its individual substrings.</source>
          <target state="translated">然後它會呼叫<ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph>方法來建立可以傳遞至字元陣列<ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>來分隔的字串分隔成其個別的子字串的方法。</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The starting position of a substring in this instance.</source>
          <target state="translated">這個執行個體中的子字串開始位置。</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The length of the substring in this instance.</source>
          <target state="translated">這個執行個體中的子字串長度。</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Copies the characters in a specified substring in this instance to a Unicode character array.</source>
          <target state="translated">將這個執行個體的指定子字串字元複製到 Unicode 字元陣列。</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>A Unicode character array whose elements are the <ph id="ph1">&lt;paramref name="length" /&gt;</ph> number of characters in this instance starting from character position <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Unicode 字元陣列，其項目是從 <ph id="ph1">&lt;paramref name="length" /&gt;</ph> 字元位置起始的這個執行個體中的 <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> 字元數。</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>This method copies the characters in a portion of a string to a character array.</source>
          <target state="translated">這個方法將部份字串字元複製的字元陣列。</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>To create a string from a range of characters in a character array, call the  <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">若要建立一個範圍的字元陣列中的字元字串，呼叫<ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter is zero-based.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph>參數以零為起始。</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>That is, the index of the first character in the string instance is zero.</source>
          <target state="translated">也就是索引的第一個字元的字串執行個體是零。</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`length`</ph> is zero, the returned array is empty and has a zero length.</source>
          <target state="translated">如果<ph id="ph1">`length`</ph>為零，傳回的陣列是空的且長度為零。</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>If this instance is <ph id="ph1">`null`</ph> or an empty string (""), the returned array is empty and has a zero length.</source>
          <target state="translated">如果這個執行個體<ph id="ph1">`null`</ph>或空字串 ("")，則傳回的陣列是空的且長度為零。</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object and call its <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">若要建立包含編碼的字元字串的部分位元組陣列，產生適當<ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph>物件並呼叫其<ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Some of the standard encodings available in the .NET Framework include the following:</source>
          <target state="translated">.NET Framework 中可用之標準編碼包括下列：</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Encoding</source>
          <target state="translated">編碼</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Object</source>
          <target state="translated">Object</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>ASCII</source>
          <target state="translated">ASCII</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>字元編碼方式在.NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The following example converts a substring within a string to an array of characters, then enumerates and displays the elements of the array.</source>
          <target state="translated">下列範例將字串內子字串轉換成陣列的字元，則列舉，並顯示陣列的項目。</target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 小於零。</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 加上 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 大於這個執行個體的長度。</target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a copy of this string converted to lowercase.</source>
          <target state="translated">傳回此字串轉換為小寫的版本。</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" uid="M:System.String.ToLower">
          <source>Returns a copy of this string converted to lowercase.</source>
          <target state="translated">傳回此字串轉換為小寫的版本。</target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" uid="M:System.String.ToLower">
          <source>A string in lowercase.</source>
          <target state="translated">小寫的字串。</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>This method takes into account the casing rules of the current culture.</source>
          <target state="translated">這個方法會考量目前的文化特性的大小寫規則。</target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
          <target state="translated">相反地，它會傳回新的目前執行個體中的所有字元都轉換成小寫的字串。</target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>Security Considerations</source>
          <target state="translated">安全性考量</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>The casing operation that results from calling the <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> method takes the casing conventions of the current culture into account.</source>
          <target state="translated">呼叫結果大小寫作業<ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph>方法會考量目前的文化特性的大小寫慣例。</target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
          <target state="translated">如果您需要的作業系統識別碼，例如檔案名稱、 大寫或小寫版本具名管道或登錄機碼，使用<ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>This produces the same result in every culture (unlike the <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> method) and performs more efficiently.</source>
          <target state="translated">這會產生相同的結果中每個文化特性 (不同於<ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph>方法)，並且更有效率地執行。</target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>The following example converts several mixed case strings to lowercase.</source>
          <target state="translated">下列範例會將數個混合大小寫的字串轉換成小寫。</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">中所述<bpt id="p1">[</bpt>使用字串的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>，我們建議您避免呼叫字串大小寫的方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>To convert a character to lowercase by using the casing conventions of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> parameter.</source>
          <target state="translated">若要使用目前文化特性的大小寫慣例小寫字元轉換，呼叫<ph id="ph1">&lt;see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /&gt;</ph>方法多載，其值為<ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph>針對其<ph id="ph3">&lt;paramref name="culture" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific casing rules.</source>
          <target state="translated">提供文化特性大小寫規則的物件。</target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</source>
          <target state="translated">使用指定之文化特性的大小寫規則，傳回這個字串轉換成小寫的複本。</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The lowercase equivalent of the current string.</source>
          <target state="translated">目前字串的小寫對應項。</target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The casing rules of the culture specified by the <ph id="ph1">`culture`</ph> parameter determine the way the case of the string is changed.</source>
          <target state="translated">所指定的文化特性的大小寫規則<ph id="ph1">`culture`</ph>參數可讓您判斷變更字串的大小寫的方式。</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
          <target state="translated">相反地，它會傳回新的目前執行個體中的所有字元都轉換成小寫的字串。</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>Security Considerations</source>
          <target state="translated">安全性考量</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>If you pass the <ph id="ph1">&lt;xref:System.String.ToLower%28System.Globalization.CultureInfo%29&gt;</ph> method a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object other than <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, the casing operation will take culture-specific rules into account.</source>
          <target state="translated">如果您要傳入<ph id="ph1">&lt;xref:System.String.ToLower%28System.Globalization.CultureInfo%29&gt;</ph>方法<ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph>物件以外<ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>，大小寫作業會列入考量的特定文化特性的規則。</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">如果您需要的作業系統識別碼，例如檔案名稱、 大寫或小寫版本具名管道或登錄機碼，使用<ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>This produces the same result in every culture and performs more efficiently.</source>
          <target state="translated">這會產生相同的結果，每個文化特性中，且更有效率地執行。</target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The following example converts two strings of uppercase characters to lowercase characters using the English-United States and Turkish-Turkey cultures, then compares the lowercase strings.</source>
          <target state="translated">下列範例會將轉換成小寫字元使用美國和土耳其文的文化特性，大寫字元的兩個字串，然後比較小寫的字串。</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</source>
          <target state="translated">大寫的字串完全相同，不同之處在於 Unicode LATIN CAPITAL LETTER 我在一個字串中的每個相符項目，另一個字串包含 LATIN CAPITAL LETTER 我與點上方。</target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" uid="M:System.String.ToLowerInvariant">
          <source>Returns a copy of this <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object converted to lowercase using the casing rules of the invariant culture.</source>
          <target state="translated">使用不因文化特性而異的大小寫規則，傳回轉換成小寫的這個 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件之複本。</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" uid="M:System.String.ToLowerInvariant">
          <source>The lowercase equivalent of the current string.</source>
          <target state="translated">目前字串的小寫對應項。</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The invariant culture represents a culture that is culture-insensitive.</source>
          <target state="translated">文化特性而異表示不區分文化特性的文化特性。</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>It is associated with the English language but not with a specific country or region.</source>
          <target state="translated">相關聯，所以與英文，但不是能搭配特定國家或地區。</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> 屬性 (Property)。</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method.</source>
          <target state="translated">如果您的應用程式而定的字串，並不會受到目前文化特性使用的可預測的方式變更大小寫<ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method is equivalent to <ph id="ph2">`ToLower(CultureInfo.InvariantCulture)`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph>方法相當於<ph id="ph2">`ToLower(CultureInfo.InvariantCulture)`</ph>。</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</source>
          <target state="translated">字串的集合必須出現在使用者介面控制項中可預測的順序時，建議的方法。</target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
          <target state="translated">相反地，它會傳回新的目前執行個體中的所有字元都轉換成小寫的字串。</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>Security Considerations</source>
          <target state="translated">安全性考量</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
          <target state="translated">如果您需要的作業系統識別碼，例如檔案名稱、 大寫或小寫版本具名管道或登錄機碼，使用<ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The following example defines a string array that contains a single word in a number of languages.</source>
          <target state="translated">下列範例會定義包含有多種語言中的一個字的字串陣列。</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph>方法用來填入平行陣列的項目與每個字不區分大小寫版本。</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method is used to sort the case-sensitive array based on the order of elements in the lowercase array to ensure that elements appear in the same order regardless of language.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph>方法用來排序依據以確保項目，會出現在相同的順序，不論語言為何小寫的陣列中項目順序區分大小寫的陣列。</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Converts the value of this instance to a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">將這個執行個體的值轉換為 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" uid="M:System.String.ToString">
          <source>Returns this instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>; no actual conversion is performed.</source>
          <target state="translated">傳回這個 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 執行個體；不會實際執行轉換。</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" uid="M:System.String.ToString">
          <source>The current string.</source>
          <target state="translated">目前的字串。</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>Because this method simply returns the current string unchanged, there is no need to call it directly.</source>
          <target state="translated">因為這個方法只會傳回目前的字串不變，所以不需要直接呼叫它。</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>It is usually called implicitly in a composite formatting operation, as the example shows.</source>
          <target state="translated">它通常隱含地呼叫中的複合格式的作業，如範例所示。</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.ToString%2A&gt;</ph> method.Note that the example does not explicitly call the <ph id="ph2">&lt;xref:System.String.ToString%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會示範<ph id="ph1">&lt;xref:System.String.ToString%2A&gt;</ph>方法。請注意，此範例不會明確呼叫<ph id="ph2">&lt;xref:System.String.ToString%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>Instead, the method is called implicitly by the <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature.</source>
          <target state="translated">相反地，此方法會隱含地呼叫<bpt id="p1">[</bpt>複合格式化<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>功能。</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>(Reserved) An object that supplies culture-specific formatting information.</source>
          <target state="translated">(保留) 物件，提供特定文化特性格式資訊。</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>Returns this instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>; no actual conversion is performed.</source>
          <target state="translated">傳回這個 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 執行個體；不會實際執行轉換。</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>The current string.</source>
          <target state="translated">目前的字串。</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString(System.IFormatProvider)">
          <source><ph id="ph1">`provider`</ph> is reserved, and does not currently participate in this operation.</source>
          <target state="translated"><ph id="ph1">`provider`</ph> 已保留，以及目前參與這項作業。</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>Because this method simply returns the current string unchanged, there is no need to call it directly.</source>
          <target state="translated">因為這個方法只會傳回目前的字串不變，所以不需要直接呼叫它。</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a copy of this string converted to uppercase.</source>
          <target state="translated">傳回此字串轉換為大寫的版本。</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper">
          <source>Returns a copy of this string converted to uppercase.</source>
          <target state="translated">傳回此字串轉換為大寫的版本。</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper">
          <source>The uppercase equivalent of the current string.</source>
          <target state="translated">目前字串的大寫對應項。</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent.</source>
          <target state="translated">這個方法會使用目前文化特性的大小寫規則，將目前的執行個體中的每個字元轉換成其對等大寫。</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>If a character does not have an uppercase equivalent, it is included unchanged in the returned string.</source>
          <target state="translated">如果字元沒有對等大寫，它會包含傳回的字串中保持不變。</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
          <target state="translated">相反地，它會傳回新的目前執行個體中的所有字元都轉換成大寫的字串。</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph>方法通常用來將字串轉換成大寫，使其可以用於在不區分大小寫的比較。</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>A better method to perform case-insensitive comparison is to call a string comparison method that has a <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> parameter whose value you set to <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph> for a culture-sensitive, case-insensitive comparison.</source>
          <target state="translated">更好的方法，以執行不區分大小寫的比較是呼叫有字串比較方法<ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>參數值設為<ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>進行區分文化特性、 不區分大小寫的比較。</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>Security Considerations</source>
          <target state="translated">安全性考量</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>The casing operation that results from calling the <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> method takes the casing conventions of the current culture into account.</source>
          <target state="translated">呼叫結果大小寫作業<ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph>方法會考量目前的文化特性的大小寫慣例。</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">如果您需要的作業系統識別碼，例如檔案名稱、 大寫或小寫版本具名管道或登錄機碼，使用<ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>This produces the same result in every culture (unlike the <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> method) and performs more efficiently.</source>
          <target state="translated">這會產生相同的結果中每個文化特性 (不同於<ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph>方法)，並且更有效率地執行。</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> method to convert a series of one-character strings that contain each character in the Basic Latin, Latin-1 Supplement, and Latin Extended-A character sets.</source>
          <target state="translated">下列範例會呼叫<ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph>方法，將一系列的單字元字串包含基本拉丁、 拉丁文 1 補充和拉丁文擴充-A 字元集中的每個字元的轉換。</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>It then displays each string whose uppercase character is different from its lowercase character.</source>
          <target state="translated">然後，它會顯示每個字串的大寫字元是不同於其小寫的字元。</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">中所述<bpt id="p1">[</bpt>使用字串的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>，我們建議您避免呼叫字串大小寫的方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>To convert a string to uppercase by using the casing conventions of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> parameter.</source>
          <target state="translated">若要將字串轉換為大寫使用目前文化特性的大小寫慣例，呼叫<ph id="ph1">&lt;see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /&gt;</ph>方法多載，其值為<ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph>針對其<ph id="ph3">&lt;paramref name="culture" /&gt;</ph>參數。</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific casing rules.</source>
          <target state="translated">提供文化特性大小寫規則的物件。</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</source>
          <target state="translated">使用指定之文化特性的大小寫規則，傳回這個字串轉換成大寫的複本。</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The uppercase equivalent of the current string.</source>
          <target state="translated">目前字串的大寫對應項。</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The casing rules of the culture specified by the <ph id="ph1">`culture`</ph> parameter determine the way the case of a string is changed.</source>
          <target state="translated">所指定的文化特性的大小寫規則<ph id="ph1">`culture`</ph>參數可讓您判斷變更字串的大小寫的方式。</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
          <target state="translated">相反地，它會傳回新的目前執行個體中的所有字元都轉換成大寫的字串。</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>Security Considerations</source>
          <target state="translated">安全性考量</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>If you pass the <ph id="ph1">&lt;xref:System.String.ToUpper%28System.Globalization.CultureInfo%29&gt;</ph> method a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object other than <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, the casing operation will take culture-specific rules into account.</source>
          <target state="translated">如果您要傳入<ph id="ph1">&lt;xref:System.String.ToUpper%28System.Globalization.CultureInfo%29&gt;</ph>方法<ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph>物件以外<ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>，大小寫作業會列入考量的特定文化特性的規則。</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">如果您需要的作業系統識別碼，例如檔案名稱、 大寫或小寫版本具名管道或登錄機碼，使用<ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>This produces the same result in every culture and performs more efficiently.</source>
          <target state="translated">這會產生相同的結果，每個文化特性中，且更有效率地執行。</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The following example converts a string of lowercase characters to two strings of uppercase characters using the English-United States and Turkish-Turkey cultures, then compares the uppercase strings.</source>
          <target state="translated">下列範例會將小寫字元的字串轉換成大寫字元使用美國和土耳其文的文化特性的兩個字串，然後比較大寫的字串。</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</source>
          <target state="translated">大寫的字串完全相同，不同之處在於 Unicode LATIN CAPITAL LETTER 我在一個字串中的每個相符項目，另一個字串包含 LATIN CAPITAL LETTER 我與點上方。</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" uid="M:System.String.ToUpperInvariant">
          <source>Returns a copy of this <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object converted to uppercase using the casing rules of the invariant culture.</source>
          <target state="translated">使用不因文化特性而異的大小寫規則，傳回轉換成大寫的這個 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件之複本。</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" uid="M:System.String.ToUpperInvariant">
          <source>The uppercase equivalent of the current string.</source>
          <target state="translated">目前字串的大寫對應項。</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The invariant culture represents a culture that is culture-insensitive.</source>
          <target state="translated">文化特性而異表示不區分文化特性的文化特性。</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>It is associated with the English language but not with a specific country or region.</source>
          <target state="translated">相關聯，所以與英文，但不是能搭配特定國家或地區。</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">如需詳細資訊，請參閱 <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> 屬性 (Property)。</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">如果您的應用程式而定的字串，並不會受到目前文化特性使用的可預測的方式變更大小寫<ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method is equivalent to <ph id="ph2">`ToUpper(CultureInfo.InvariantCulture)`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph>方法相當於<ph id="ph2">`ToUpper(CultureInfo.InvariantCulture)`</ph>。</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</source>
          <target state="translated">字串的集合必須出現在使用者介面控制項中可預測的順序時，建議的方法。</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
          <target state="translated">相反地，它會傳回新的目前執行個體中的所有字元都轉換成大寫的字串。</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>Security Considerations</source>
          <target state="translated">安全性考量</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
          <target state="translated">如果您需要的作業系統識別碼，例如檔案名稱、 大寫或小寫版本具名管道或登錄機碼，使用<ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The following example defines a string array that contains a single word in a number of languages.</source>
          <target state="translated">下列範例會定義包含有多種語言中的一個字的字串陣列。</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph>方法用來填入平行陣列的項目與每個字不區分大小寫版本。</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method is used to sort the case-sensitive array based on the order of elements in the uppercase array to ensure that elements appear in the same order regardless of language.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph>方法用來排序依據以確保項目，會出現在相同的順序，不論語言為何大寫的陣列中項目順序區分大小寫的陣列。</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string in which all leading and trailing occurrences of a set of specified characters from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object are removed.</source>
          <target state="translated">傳回新字串，其中已經移除出現在目前 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件中之所有開頭與結尾的一組指定的字元。</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" uid="M:System.String.Trim">
          <source>Removes all leading and trailing white-space characters from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">從目前的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件中移除所有的開頭和結尾空白字元。</target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" uid="M:System.String.Trim">
          <source>The string that remains after all white-space characters are removed from the start and end of the current string.</source>
          <target state="translated">從目前字串的開頭和結尾移除所有空白字元後，所保留下來的字串。</target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" uid="M:System.String.Trim">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果在目前的執行個體中無法修剪任何字元，則方法傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes from the current string all leading and trailing white-space characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph>方法從目前字串中移除所有開頭和尾端空白字元。</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Each leading and trailing trim operation stops when a non-white-space character is encountered.</source>
          <target state="translated">每個前置和尾端的修剪作業停止時遇到非空格字元。</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>For example, if the current string is "   abc   xyz   ", the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method returns "abc   xyz".</source>
          <target state="translated">例如，如果目前的字串為"abc xyz"，<ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph>方法會傳回"abc xyz"。</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>To remove white-space characters between words in a string, use a <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
          <target state="translated">若要移除字串中的文字之間的空格字元，請使用<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>If the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.</source>
          <target state="translated">相反地，它會傳回新字串，目前的執行個體中之所有開頭和尾端的空格字元都會被移除。</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>If the current string equals <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> or all the characters in the current instance consist of white-space characters, the method returns <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">如果目前字串等於<ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>或目前的執行個體中的所有字元都包含空白字元，則方法會傳回<ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>White-space characters are defined by the Unicode standard.</source>
          <target state="translated">泛空白字元是由 Unicode 標準定義。</target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim&gt;</ph> method removes any leading and trailing characters that produce a return value of <ph id="ph2">`true`</ph> when they are passed to the <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Trim&gt;</ph>方法中移除傳回值會產生任何開頭和尾端字元<ph id="ph2">`true`</ph>傳遞至時<ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Trim?displayProperty=nameWithType&gt;</ph> method to remove any extra white space from strings entered by the user before concatenating them.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.Trim?displayProperty=nameWithType&gt;</ph>方法，以從使用者輸入之前它們串連的字串中移除任何額外的空白字元。</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintain an internal list of white-space characters that this method trims.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>和舊版維護的內部清單，這個方法會修剪的空格字元。</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph2">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph3">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，方法會修剪所有 Unicode 空格字元 (也就是字元產生<ph id="ph2">&lt;see langword="true" /&gt;</ph>傳回值時傳遞至<ph id="ph3">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph>方法)。</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>and later versions does not remove.</source>
          <target state="translated">這項變更，因為<ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph>方法中的<ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>和更早版本中移除兩個字元，零寬度空格 (U + 200B) 和零寬度的不中斷空格 (U + FEFF)，<ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph>方法中的<ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>更新版本，並無法移除。</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">此外，<ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph>方法中的<ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>和更早版本不會修剪三種 Unicode 空白字元： 蒙古母音分隔符號 (U + 180E)、 窄不中斷空格 (U + 202F) 及中型數學空格 (U + 205F)。</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>An array of Unicode characters to remove, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">要移除的 Unicode 字元陣列或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>Removes all leading and trailing occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">從目前的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件中移除陣列中指定之一組字元的所有開頭和結尾指定項目。</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>The string that remains after all occurrences of the characters in the <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> parameter are removed from the start and end of the current string.</source>
          <target state="translated">從目前的字串開頭和結尾處移除 <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> 參數中所有出現的字元後，所保留下來的字串。</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>If <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty array, white-space characters are removed instead.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或空陣列，則反而會移除空白字元。</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果在目前的執行個體中無法修剪任何字元，則方法傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes from the current string all leading and trailing characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph>方法會移除目前字串中的所有開頭和尾端字元<ph id="ph2">`trimChars`</ph>參數。</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Each leading and trailing trim operation stops when a character that is not in <ph id="ph1">`trimChars`</ph> is encountered.</source>
          <target state="translated">每一個開頭和尾端空白位置修剪作業停止時未出現在字元<ph id="ph1">`trimChars`</ph>為止。</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.Trim%2A&gt;</ph> method returns "abc456xyz".</source>
          <target state="translated">例如，如果目前的字串為"123abc456xyz789 」 和<ph id="ph1">`trimChars`</ph>包含數字"1"到"9"，從<ph id="ph2">&lt;xref:System.String.Trim%2A&gt;</ph>方法會傳回"abc456xyz"。</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>If the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Instead, it returns a new string in which all leading and trailing <ph id="ph1">`trimChars`</ph> characters found in the current instance are removed.</source>
          <target state="translated">相反地，它會傳回新字串中所有開頭和尾端<ph id="ph1">`trimChars`</ph>移除目前的執行個體中的字元。</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>If the current string equals <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> or all the characters in the current instance consist of characters in the <ph id="ph2">`trimChars`</ph> array, the method returns <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">如果目前字串等於<ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>或中的字元，包含目前執行個體中的所有字元<ph id="ph2">`trimChars`</ph>陣列，此方法會傳回<ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>If <ph id="ph1">`trimChars`</ph> is <ph id="ph2">`null`</ph> or an empty array, this method removes any leading or trailing characters that result in the method returning <ph id="ph3">`true`</ph> when they are passed to the <ph id="ph4">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method,</source>
          <target state="translated">如果<ph id="ph1">`trimChars`</ph>是<ph id="ph2">`null`</ph>或空陣列，這個方法會移除任何開頭或結尾字元，導致方法傳回<ph id="ph3">`true`</ph>傳遞至時<ph id="ph4">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph>方法</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method to remove space, asterisk (*), and apostrophe (') characters from a string.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph>方法從字串中移除空間、 星號 （*），以及單引號 （'） 字元。</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintains an internal list of white-space characters that this method trims if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>及更早版本維護的內部清單，如果這個方法會修剪的空格字元<ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph>是<ph id="ph3">&lt;see langword="null" /&gt;</ph>或空陣列。</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph4">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，如果<ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph>是<ph id="ph3">&lt;see langword="null" /&gt;</ph>或空陣列，此方法會修剪所有 Unicode 空格字元 (也就是字元產生<ph id="ph4">&lt;see langword="true" /&gt;</ph>傳回值時傳遞至<ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph>方法)。</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>and later versions does not remove.</source>
          <target state="translated">這項變更，因為<ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph>方法中的<ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>和更早版本中移除兩個字元，零寬度空格 (U + 200B) 和零寬度的不中斷空格 (U + FEFF)，<ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph>方法中的<ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>更新版本，並無法移除。</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">此外，<ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph>方法中的<ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>和更早版本不會修剪三種 Unicode 空白字元： 蒙古母音分隔符號 (U + 180E)、 窄不中斷空格 (U + 202F) 及中型數學空格 (U + 205F)。</target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>An array of Unicode characters to remove, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">要移除的 Unicode 字元陣列或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Removes all trailing occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">從目前的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件中移除陣列中指定之一組字元的所有結尾指定項目。</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The string that remains after all occurrences of the characters in the <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> parameter are removed from the end of the current string.</source>
          <target state="translated">從目前的字串結尾處移除 <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> 參數中所有出現的字元後，所保留下來的字串。</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>If <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty array, Unicode white-space characters are removed instead.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或空陣列，則反而會移除 Unicode 空白字元。</target>       </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果在目前的執行個體中無法修剪任何字元，則方法傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method removes from the current string all trailing characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph>方法會移除目前字串中的所有行尾字元<ph id="ph2">`trimChars`</ph>參數。</target>       </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The trim operation stops when the first character that is not in <ph id="ph1">`trimChars`</ph> is encountered at the end of the string.</source>
          <target state="translated">修剪作業停止時的第一個字元不在<ph id="ph1">`trimChars`</ph>發生在字串結尾處。</target>       </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method returns "123abc456xyz".</source>
          <target state="translated">例如，如果目前的字串為"123abc456xyz789 」 和<ph id="ph1">`trimChars`</ph>包含數字"1"到"9"，從<ph id="ph2">&lt;xref:System.String.TrimEnd%2A&gt;</ph>方法會傳回"123abc456xyz"。</target>       </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>If the <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Instead, it returns a new string in which all trailing characters found in <ph id="ph1">`trimChars`</ph> are removed from the current string.</source>
          <target state="translated">相反地，它會傳回新字串中哪些中找到的所有尾端字元<ph id="ph1">`trimChars`</ph>會從目前的字串。</target>       </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The following example demonstrates how you can use the <ph id="ph1">&lt;xref:System.String.TrimEnd%28System.Char%5B%5D%29&gt;</ph> method to trim white space or punctuation marks from the end of a string.</source>
          <target state="translated">下列範例示範如何使用<ph id="ph1">&lt;xref:System.String.TrimEnd%28System.Char%5B%5D%29&gt;</ph>方法来修剪空白字元或標點符號從字串的結尾。</target>       </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintains an internal list of white-space characters that this method trims if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>及更早版本維護的內部清單，如果這個方法會修剪的空格字元<ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph>是<ph id="ph3">&lt;see langword="null" /&gt;</ph>或空陣列。</target>       </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph4">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，如果<ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph>是<ph id="ph3">&lt;see langword="null" /&gt;</ph>或空陣列，此方法會修剪所有 Unicode 空格字元 (也就是字元產生<ph id="ph4">&lt;see langword="true" /&gt;</ph>傳回值時傳遞至<ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph>方法)。</target>       </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> and later versions does not remove.</source>
          <target state="translated">這項變更，因為<ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph>方法中的<ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>和更早版本中移除兩個字元，零寬度空格 (U + 200B) 和零寬度的不中斷空格 (U + FEFF)，<ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph>方法中的<ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>更新版本，並無法移除。</target>       </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">此外，<ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph>方法中的<ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>和更早版本不會修剪三種 Unicode 空白字元： 蒙古母音分隔符號 (U + 180E)、 窄不中斷空格 (U + 202F) 及中型數學空格 (U + 205F)。</target>       </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>An array of Unicode characters to remove, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">要移除的 Unicode 字元陣列或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>Removes all leading occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">從目前的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 物件中移除陣列中指定之一組字元的所有開頭指定項目。</target>       </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>The string that remains after all occurrences of characters in the <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> parameter are removed from the start of the current string.</source>
          <target state="translated">從目前的字串開頭處移除 <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> 參數中所有出現的字元後，所保留下來的字串。</target>       </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>If <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty array, white-space characters are removed instead.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或空陣列，則反而會移除空白字元。</target>       </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method removes from the current string all leading characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph>方法會移除目前字串中的所有前置字元<ph id="ph2">`trimChars`</ph>參數。</target>       </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The trim operation stops when a character that is not in <ph id="ph1">`trimChars`</ph> is encountered.</source>
          <target state="translated">不是一個字元時，就會停止修剪作業<ph id="ph1">`trimChars`</ph>為止。</target>       </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> method returns "abc456xyz789".</source>
          <target state="translated">例如，如果目前的字串為"123abc456xyz789 」 和<ph id="ph1">`trimChars`</ph>包含數字"1"到"9"，從<ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph>方法會傳回"abc456xyz789"。</target>       </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>If the <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。</target>       </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>Instead, it returns a new string in which all leading white space characters found in the current instance are removed.</source>
          <target state="translated">相反地，它會傳回新字串，目前的執行個體中的所有前置空格字元會被移除。</target>       </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method to trim white space and comment characters from lines of source code.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph>修剪泛空白字元和註解字元從原始程式碼的方法。</target>       </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">`StripComments`</ph> method wraps a call to <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> and passes it a character array that contains a space and the comment character, which is an apostrophe ( ' ) in Visual Basic and a slash ( / ) in C#.</source>
          <target state="translated"><ph id="ph1">`StripComments`</ph>方法會包裝呼叫<ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph>並將其傳遞字元陣列，其中包含一個空格和註解字元，也就是單引號 （'） 在 Visual Basic 和 C# 中的斜線 （/）。</target>       </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method is also called to remove leading white space when evaluating whether a string is a comment.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph>也會呼叫方法來評估字串是否為註解時，移除前置空白字元。</target>       </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The following example then illustrates a call to the <ph id="ph1">`StripComments`</ph> method.</source>
          <target state="translated">下列範例說明如何呼叫 <ph id="ph1">`StripComments`</ph> 方法。</target>       </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintains an internal list of white-space characters that this method trims if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>及更早版本維護的內部清單，如果這個方法會修剪的空格字元<ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph>是<ph id="ph3">&lt;see langword="null" /&gt;</ph>或空陣列。</target>       </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph4">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，如果<ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph>是<ph id="ph3">&lt;see langword="null" /&gt;</ph>或空陣列，此方法會修剪所有 Unicode 空格字元 (也就是字元產生<ph id="ph4">&lt;see langword="true" /&gt;</ph>傳回值時傳遞至<ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph>方法)。</target>       </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> and later versions does not remove.</source>
          <target state="translated">這項變更，因為<ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph>方法中的<ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>和更早版本中移除兩個字元，零寬度空格 (U + 200B) 和零寬度的不中斷空格 (U + FEFF)，<ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph>方法中的<ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>更新版本，並無法移除。</target>       </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">此外，<ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph>方法中的<ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>和更早版本不會修剪三種 Unicode 空白字元： 蒙古母音分隔符號 (U + 180E)、 窄不中斷空格 (U + 202F) 及中型數學空格 (U + 205F)。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>