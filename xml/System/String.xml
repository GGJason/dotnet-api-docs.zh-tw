<Type Name="String" FullName="System.String">
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="5f51e-101">以一連串的 UTF-16 字碼單位表示文字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-101">Represents text as a sequence of UTF-16 code units.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="5f51e-102">字串是用來代表文字的字元的循序集合。</span><span class="sxs-lookup"><span data-stu-id="5f51e-102">A string is a sequential collection of characters that is used to represent text.</span></span> <span data-ttu-id="5f51e-103">A<xref:System.String>物件是循序集合<xref:System.Char?displayProperty=nameWithType>物件來代表字串;<xref:System.Char?displayProperty=nameWithType>物件會對應至的 utf-16 字碼單位。</span><span class="sxs-lookup"><span data-stu-id="5f51e-103">A <xref:System.String> object is a sequential collection of <xref:System.Char?displayProperty=nameWithType> objects that represent a string; a <xref:System.Char?displayProperty=nameWithType> object corresponds to a UTF-16 code unit.</span></span> <span data-ttu-id="5f51e-104">值<xref:System.String>物件的循序集合的內容<xref:System.Char?displayProperty=nameWithType>物件和值是不變 （也就是說，它位於唯讀）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-104">The value of the <xref:System.String> object is the content of the sequential collection of <xref:System.Char?displayProperty=nameWithType> objects, and that value is immutable (that is, it is read-only).</span></span> <span data-ttu-id="5f51e-105">字串的不變性的相關資訊，請參閱[不變性和 StringBuilder 類別](#Immutability)本主題稍後的章節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-105">For more information about the immutability of strings, see the [Immutability and the StringBuilder class](#Immutability) section later in this topic.</span></span> <span data-ttu-id="5f51e-106">大小上限<xref:System.String>在記憶體中的物件是 2 GB 或大約 1 億個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-106">The maximum size of a <xref:System.String> object in memory is 2GB, or about 1 billion characters.</span></span>  
  
 <span data-ttu-id="5f51e-107">本節內容：</span><span class="sxs-lookup"><span data-stu-id="5f51e-107">In this section:</span></span>  
  
 <span data-ttu-id="5f51e-108">[具現化字串物件](#Instantiation) </span><span class="sxs-lookup"><span data-stu-id="5f51e-108">[Instantiating a String object](#Instantiation) </span></span>  
 <span data-ttu-id="5f51e-109">[Char 物件和 Unicode 字元](#Characters) </span><span class="sxs-lookup"><span data-stu-id="5f51e-109">[Char objects and Unicode characters](#Characters) </span></span>  
 <span data-ttu-id="5f51e-110">[字串和 Unicode 標準](#Unicode) </span><span class="sxs-lookup"><span data-stu-id="5f51e-110">[Strings and The Unicode Standard](#Unicode) </span></span>  
 <span data-ttu-id="5f51e-111">[字串和內嵌的 null 字元](#EmbeddedNulls) </span><span class="sxs-lookup"><span data-stu-id="5f51e-111">[Strings and embedded null characters](#EmbeddedNulls) </span></span>  
 <span data-ttu-id="5f51e-112">[字串與索引](#Indexes) </span><span class="sxs-lookup"><span data-stu-id="5f51e-112">[Strings and indexes](#Indexes) </span></span>  
 <span data-ttu-id="5f51e-113">[Null 字串值和空白字串](#Nulls) </span><span class="sxs-lookup"><span data-stu-id="5f51e-113">[Null strings and empty strings](#Nulls) </span></span>  
 <span data-ttu-id="5f51e-114">[不變性和 StringBuilder 類別](#Immutability) </span><span class="sxs-lookup"><span data-stu-id="5f51e-114">[Immutability and the StringBuilder class](#Immutability) </span></span>  
 <span data-ttu-id="5f51e-115">[序數和區分文化特性的作業](#CultureSensitive) </span><span class="sxs-lookup"><span data-stu-id="5f51e-115">[Ordinal vs. culture-sensitive operations](#CultureSensitive) </span></span>  
 <span data-ttu-id="5f51e-116">[正規化](#Normalization) </span><span class="sxs-lookup"><span data-stu-id="5f51e-116">[Normalization](#Normalization) </span></span>  
 [<span data-ttu-id="5f51e-117">依類別目錄的字串作業</span><span class="sxs-lookup"><span data-stu-id="5f51e-117">String operations by category</span></span>](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a><span data-ttu-id="5f51e-118">具現化字串物件</span><span class="sxs-lookup"><span data-stu-id="5f51e-118">Instantiating a String object</span></span>  
 <span data-ttu-id="5f51e-119">您可以具現化<xref:System.String>物件如下：</span><span class="sxs-lookup"><span data-stu-id="5f51e-119">You can instantiate a <xref:System.String> object in the following ways:</span></span>  
  
-   <span data-ttu-id="5f51e-120">將字串常值指定<xref:System.String>變數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-120">By assigning a string literal to a <xref:System.String> variable.</span></span> <span data-ttu-id="5f51e-121">這是最常使用的方法來建立字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-121">This is the most commonly used method for creating a string.</span></span> <span data-ttu-id="5f51e-122">下列範例會使用指派，建立數個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-122">The following example uses assignment to create several strings.</span></span> <span data-ttu-id="5f51e-123">請注意，在 C# 中，因為反斜線 (\\) 逸出字元，必須逸出字串中的常值反斜線或整個字串必須@-quoted。</span><span class="sxs-lookup"><span data-stu-id="5f51e-123">Note that in C#, because the backslash (\\) is an escape character, literal backslashes in a string must be escaped or the entire string must be @-quoted.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   <span data-ttu-id="5f51e-124">藉由呼叫<xref:System.String>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-124">By calling a <xref:System.String> class constructor.</span></span> <span data-ttu-id="5f51e-125">下列範例會產生字串，藉由呼叫數個類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-125">The following example instantiates strings by calling several class constructors.</span></span> <span data-ttu-id="5f51e-126">請注意，有些建構函式會包含字元陣列或做為參數的帶正負號的位元組陣列的指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-126">Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters.</span></span> <span data-ttu-id="5f51e-127">Visual Basic 不支援這些建構函式的呼叫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-127">Visual Basic does not support calls to these constructors.</span></span> <span data-ttu-id="5f51e-128">如需詳細資訊<xref:System.String>建構函式，請參閱<xref:System.String.%23ctor%2A>建構函式的摘要。</span><span class="sxs-lookup"><span data-stu-id="5f51e-128">For detailed information about <xref:System.String> constructors, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   <span data-ttu-id="5f51e-129">使用字串串連運算子 (+ 在 C# 和 （& c) 或 + 在 Visual Basic 中) 從的任何組合建立單一字串<xref:System.String>執行個體和字串常值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-129">By using the string concatenation operator (+ in C# and & or + in Visual Basic) to create a single string from any combination of <xref:System.String> instances and string literals.</span></span> <span data-ttu-id="5f51e-130">下列範例說明如何使用字串串連運算子。</span><span class="sxs-lookup"><span data-stu-id="5f51e-130">The following example illustrates the use of the string concatenation operator.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   <span data-ttu-id="5f51e-131">擷取屬性，或呼叫的方法，傳回的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-131">By retrieving a property or calling a method that returns a string.</span></span> <span data-ttu-id="5f51e-132">下列範例會使用的方法<xref:System.String>類別，以從較大的字串擷取子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-132">The following example uses the methods of the <xref:System.String> class to extract a substring from a larger string.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   <span data-ttu-id="5f51e-133">藉由呼叫格式化方法要為其字串表示轉換的值或物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-133">By calling a formatting method to convert a value or object to its string representation.</span></span> <span data-ttu-id="5f51e-134">下列範例會使用[複合格式化](~/docs/standard/base-types/composite-formatting.md)內嵌兩個物件的字串表示，轉換為字串的功能。</span><span class="sxs-lookup"><span data-stu-id="5f51e-134">The following example uses the                [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature to embed the string representation of two objects into a string.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a><span data-ttu-id="5f51e-135">Char 物件和 Unicode 字元</span><span class="sxs-lookup"><span data-stu-id="5f51e-135">Char objects and Unicode characters</span></span>  
 <span data-ttu-id="5f51e-136">在字串中的每一個字元是由 Unicode 純量值，也稱為 Unicode 字碼指標或 Unicode 字元的序數 （數值） 定義。</span><span class="sxs-lookup"><span data-stu-id="5f51e-136">Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character.</span></span> <span data-ttu-id="5f51e-137">每個字碼指標使用 utf-16 編碼，進行編碼，而每個項目編碼方式的數字值由<xref:System.Char>物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-137">Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <xref:System.Char> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-138">請注意，因為<xref:System.String>循序集合的 utf-16 字碼單位執行個體所組成，您可以建立<xref:System.String>不是語式正確的 Unicode 字串的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-138">Note that, because a <xref:System.String> instance consists of a sequential collection of UTF-16 code units, it is possible to create a <xref:System.String> object that is not a well-formed Unicode string.</span></span> <span data-ttu-id="5f51e-139">比方說，就可以建立沒有對應的高 surrogate 的低 surrogate 的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-139">For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate.</span></span> <span data-ttu-id="5f51e-140">雖然某些方法，例如使用的編碼和解碼物件方法<xref:System.Text>命名空間，可能會執行檢查以確定字串為格式正確，<xref:System.String>類別成員不確定該字串會是語式正確。</span><span class="sxs-lookup"><span data-stu-id="5f51e-140">Although some methods, such as the methods of encoding and decoding objects in the <xref:System.Text> namespace, may performs checks to ensure that strings are well-formed, <xref:System.String> class members don't ensure that a string is well-formed.</span></span>  
  
 <span data-ttu-id="5f51e-141">單一<xref:System.Char>物件通常代表單一字碼指標，也就是數字值<xref:System.Char>等於字碼指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-141">A single <xref:System.Char> object usually represents a single code point; that is, the numeric value of the <xref:System.Char> equals the code point.</span></span> <span data-ttu-id="5f51e-142">例如，字碼指標"的字元 a"是 U + 0061。</span><span class="sxs-lookup"><span data-stu-id="5f51e-142">For example, the code point for the character "a" is U+0061.</span></span> <span data-ttu-id="5f51e-143">不過，字碼指標可能會需要多個編碼項目 (一個以上<xref:System.Char>物件)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-143">However, a code point might require more than one encoded element (more than one <xref:System.Char> object).</span></span> <span data-ttu-id="5f51e-144">Unicode 標準會定義兩種類型的字元會對應至多個<xref:System.Char>物件： graphemes，並對應至 Unicode 補充平面中的字元的 Unicode 補充字碼指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-144">The Unicode standard defines two types of characters that correspond to multiple <xref:System.Char> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.</span></span>  
  
-   <span data-ttu-id="5f51e-145">字母是由基底的字元，後面接著一個或多個組合字元表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-145">A grapheme is represented by a base character followed by one or more combining characters.</span></span> <span data-ttu-id="5f51e-146">例如，ä 的字元由 a<xref:System.Char>物件，其字碼指標為 U + 0061 後面接著 a<xref:System.Char>物件，其字碼指標為 U + 0308年。</span><span class="sxs-lookup"><span data-stu-id="5f51e-146">For example, the character ä is represented by a <xref:System.Char> object whose code point is U+0061 followed by a <xref:System.Char> object whose code point is U+0308.</span></span> <span data-ttu-id="5f51e-147">這個字元也可以定義由單一<xref:System.Char>具有的字碼指標 U + 00E4 物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-147">This character can also be defined by a single <xref:System.Char> object that has a code point of U+00E4.</span></span> <span data-ttu-id="5f51e-148">如下列範例所示，區分文化特性的比較相等表示這些兩種表示法相等，雖然一般的序數比較並不會。</span><span class="sxs-lookup"><span data-stu-id="5f51e-148">As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not.</span></span> <span data-ttu-id="5f51e-149">不過，如果兩個字串正規化，序數比較也會指出它們是否相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-149">However, if the two strings are normalized, an ordinal comparison also indicates that they are equal.</span></span> <span data-ttu-id="5f51e-150">(如需有關正規化字串的詳細資訊，請參閱[正規化](#Normalization)> 一節。)</span><span class="sxs-lookup"><span data-stu-id="5f51e-150">(For more information on normalizing strings, see the [Normalization](#Normalization) section.)</span></span>  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   <span data-ttu-id="5f51e-151">增補的字碼指標 （surrogate 字組） 由 Unicode<xref:System.Char>其字碼指標是否為高 surrogate 的物件後面<xref:System.Char>其字碼指標是否為低 surrogate 的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-151">A Unicode supplementary code point (a surrogate pair) is represented by a <xref:System.Char> object whose code point is a high surrogate followed by a <xref:System.Char> object whose code point is a low surrogate.</span></span> <span data-ttu-id="5f51e-152">高 surrogate 範圍從 U + D800 到 U + DBFF 的程式碼單元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-152">The code units of high surrogates range from U+D800 to U+DBFF.</span></span> <span data-ttu-id="5f51e-153">低 surrogate 範圍是從 U + DC00 到 U + dfff 範圍內的程式碼單元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-153">The code units of low surrogates range from U+DC00 to U+DFFF.</span></span> <span data-ttu-id="5f51e-154">Surrogate 字組用來代表 16 的 Unicode 補充平面中的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-154">Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes.</span></span> <span data-ttu-id="5f51e-155">下列範例會建立 surrogate 字元，並將其傳遞給<xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType>方法，以判斷其是否為 surrogate 字組。</span><span class="sxs-lookup"><span data-stu-id="5f51e-155">The following example creates a surrogate character and passes it to the <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> method to determine whether it is a surrogate pair.</span></span>  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a><span data-ttu-id="5f51e-156">字串和 Unicode 標準</span><span class="sxs-lookup"><span data-stu-id="5f51e-156">Strings and The Unicode Standard</span></span>  
 <span data-ttu-id="5f51e-157">字串中的字元都由這對應於 utf-16 編碼字碼單位<xref:System.Char>值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-157">Characters in a string are represented by UTF-16 encoded code units, which correspond to <xref:System.Char> values.</span></span>  
  
 <span data-ttu-id="5f51e-158">在字串中的每個字元的相關聯的 Unicode 字元類別，表示由.NET Framework 中<xref:System.Globalization.UnicodeCategory>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-158">Each character in a string has an associated Unicode character category, which is represented in the .NET Framework by the <xref:System.Globalization.UnicodeCategory> enumeration.</span></span> <span data-ttu-id="5f51e-159">字元或 surrogate 字組的類別目錄由呼叫<xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-159">The category of a character or a surrogate pair can be determined by calling the <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="5f51e-160">.NET 會維護其資料表的字元和其對應的類別，可確保在不同平台上執行的.NET 實作的特定版本，會傳回相同的字元類別目錄資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-160">.NET maintains its own table of characters and their corresponding categories, which ensures that a specific version of a .NET implementation running on different platforms returns identical character category information.</span></span> <span data-ttu-id="5f51e-161">下表列出.NET 版本和 Unicode 標準所根據的字元類別的版本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-161">The following table lists .NET versions and the versions of the Unicode Standard on which their character categories are based.</span></span>  
  
|<span data-ttu-id="5f51e-162">.NET Framework 版本</span><span class="sxs-lookup"><span data-stu-id="5f51e-162">.NET Framework version</span></span>|<span data-ttu-id="5f51e-163">Unicode 標準版本</span><span class="sxs-lookup"><span data-stu-id="5f51e-163">Version of the Unicode Standard</span></span>|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[<span data-ttu-id="5f51e-164">Unicode Standard 4.0.0 版</span><span class="sxs-lookup"><span data-stu-id="5f51e-164">The Unicode Standard, Version 4.0.0</span></span>](https://www.unicode.org/versions/Unicode4.0.0/)|  
|<span data-ttu-id="5f51e-165">.NET Framework 2.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-165">The .NET Framework 2.0</span></span>|[<span data-ttu-id="5f51e-166">Unicode Standard 版本 5.0.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-166">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[<span data-ttu-id="5f51e-167">Unicode Standard 版本 5.0.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-167">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[<span data-ttu-id="5f51e-168">Unicode Standard 版本 5.0.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-168">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]|[<span data-ttu-id="5f51e-169">Unicode Standard 版本 6.3.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-169">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v451](~/includes/net-v451-md.md)]|[<span data-ttu-id="5f51e-170">Unicode Standard 版本 6.3.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-170">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v452](~/includes/net-v452-md.md)]|[<span data-ttu-id="5f51e-171">Unicode Standard 版本 6.3.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-171">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v46](~/includes/net-v46-md.md)]|[<span data-ttu-id="5f51e-172">Unicode Standard 版本 6.3.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-172">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v461](~/includes/net-v461-md.md)]|[<span data-ttu-id="5f51e-173">Unicode Standard 版本 6.3.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-173">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v462](~/includes/net-v462-md.md)]|[<span data-ttu-id="5f51e-174">Unicode Standard 版本 8.0.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-174">The Unicode Standard, Version 8.0.0</span></span>](https://www.unicode.org/versions/Unicode8.0.0/)|  
|<span data-ttu-id="5f51e-175">.NET core （所有版本）</span><span class="sxs-lookup"><span data-stu-id="5f51e-175">.NET Core (all versions)</span></span>|[<span data-ttu-id="5f51e-176">Unicode Standard 版本 8.0.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-176">The Unicode Standard, Version 8.0.0</span></span>](https://www.unicode.org/versions/Unicode8.0.0/)|
  
 <span data-ttu-id="5f51e-177">此外，.NET Framework 支援字串比較和排序 Unicode 標準為基礎。</span><span class="sxs-lookup"><span data-stu-id="5f51e-177">In addition, the .NET Framework supports string comparison and sorting based on the Unicode standard.</span></span> <span data-ttu-id="5f51e-178">透過.NET Framework 版本中[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，.NET Framework 會維護自己的字串資料的資料表。</span><span class="sxs-lookup"><span data-stu-id="5f51e-178">In versions of the .NET Framework through the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the .NET Framework maintains its own table of string data.</span></span> <span data-ttu-id="5f51e-179">這也是如此開頭的.NET framework 版本[!INCLUDE[net_v45](~/includes/net-v45-md.md)]在 Windows 7 上執行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-179">This is also true of versions of the .NET Framework starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Windows 7.</span></span> <span data-ttu-id="5f51e-180">從開始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]Window 8 和更新版本的 Windows 作業系統上執行，執行階段委派字串比較和排序作業的作業系統。</span><span class="sxs-lookup"><span data-stu-id="5f51e-180">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system.</span></span> <span data-ttu-id="5f51e-181">下表列出.NET framework 版本和 Unicode 標準字元的比較和排序所依據的版本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-181">The following table lists the versions of the .NET Framework and the versions of the Unicode Standard on which character comparison and sorting are based.</span></span>  
  
|<span data-ttu-id="5f51e-182">.NET Framework 版本</span><span class="sxs-lookup"><span data-stu-id="5f51e-182">.NET Framework version</span></span>|<span data-ttu-id="5f51e-183">Unicode 標準版本</span><span class="sxs-lookup"><span data-stu-id="5f51e-183">Version of the Unicode Standard</span></span>|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[<span data-ttu-id="5f51e-184">Unicode Standard 4.0.0 版</span><span class="sxs-lookup"><span data-stu-id="5f51e-184">The Unicode Standard, Version 4.0.0</span></span>](https://www.unicode.org/versions/Unicode4.0.0/)|  
|<span data-ttu-id="5f51e-185">.NET Framework 2.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-185">The .NET Framework 2.0</span></span>|[<span data-ttu-id="5f51e-186">Unicode Standard 版本 5.0.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-186">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[<span data-ttu-id="5f51e-187">Unicode Standard 版本 5.0.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-187">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[<span data-ttu-id="5f51e-188">Unicode Standard 版本 5.0.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-188">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]<span data-ttu-id="5f51e-189"> 及更新版本，在 Windows 7 上</span><span class="sxs-lookup"><span data-stu-id="5f51e-189"> and later on Windows 7</span></span>|[<span data-ttu-id="5f51e-190">Unicode Standard 版本 5.0.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-190">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]<span data-ttu-id="5f51e-191"> 及更新 Windows 8 和更新版本的 Windows 作業系統版本</span><span class="sxs-lookup"><span data-stu-id="5f51e-191"> and later on Windows 8 and later Windows operating systems</span></span>|[<span data-ttu-id="5f51e-192">Unicode Standard 版本 6.3.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-192">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  

<span data-ttu-id="5f51e-193">.NET Core 中排序及比較作業會根據[Unicode 標準版本 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-193">In .NET Core, sorting and comparison operations are based on [Version 8.0.0 of the Unicode Standard](https://www.unicode.org/versions/Unicode8.0.0/).</span></span>

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a><span data-ttu-id="5f51e-194">字串和內嵌的 null 字元</span><span class="sxs-lookup"><span data-stu-id="5f51e-194">Strings and embedded null characters</span></span>  
 <span data-ttu-id="5f51e-195">在.NET Framework 中，<xref:System.String>物件可以包含內嵌的 null 字元，計算字串長度的一部分。</span><span class="sxs-lookup"><span data-stu-id="5f51e-195">In the .NET Framework, a <xref:System.String> object can include embedded null characters, which count as a part of the string's length.</span></span> <span data-ttu-id="5f51e-196">不過，在某些語言如 C 和 c + + 中，null 字元表示字串的結尾，它不被視為字串的一部分，而且不會計入為字串的長度的一部分。</span><span class="sxs-lookup"><span data-stu-id="5f51e-196">However, in some languages such as C and C++, a null character indicates the end of a string;it is not considered a part of the string and is not counted as part of the string's length.</span></span> <span data-ttu-id="5f51e-197">這表示不一定有效時套用到 C 和 c + + 程式設計人員 」 或 「 撰寫 C 或 c + + 程式庫可能會對字串相關的下列一般假設<xref:System.String>物件：</span><span class="sxs-lookup"><span data-stu-id="5f51e-197">This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to <xref:System.String> objects:</span></span>  
  
-   <span data-ttu-id="5f51e-198">所傳回的值`strlen`或`wcslen`函式不一定等於<xref:System.String.Length%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-198">The value returned by the `strlen` or `wcslen` functions does not necessarily equal <xref:System.String.Length%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="5f51e-199">建立的字串`strcpy_s`或`wcscpy_s`函式不一定等於建立的字串<xref:System.String.Copy%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-199">The string created by the `strcpy_s` or `wcscpy_s` functions is not necessarily identical to the string created by the <xref:System.String.Copy%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="5f51e-200">您應該確定具現化該原生 C 和 c + + 程式碼<xref:System.String>物件和程式碼傳遞<xref:System.String>物件可透過平台叫用，請勿假設內嵌的 null 字元標示字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-200">You should ensure that native C and C++ code that instantiates <xref:System.String> objects, and code that is passed <xref:System.String> objects through platform invoke, don't assume that an embedded null character marks the end of the string.</span></span>  
  
 <span data-ttu-id="5f51e-201">字串是排序 （或比較） 時，會搜尋字串時，也會以不同方式處理內嵌的 null 字元在字串中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-201">Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched.</span></span> <span data-ttu-id="5f51e-202">執行區分文化特性的比較兩個字串，包括使用文化特性而異的比較時，會忽略 null 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-202">Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture.</span></span> <span data-ttu-id="5f51e-203">將它們視為只是針對序數或不區分大小寫的序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-203">They are considered only for ordinal or case-insensitive ordinal comparisons.</span></span> <span data-ttu-id="5f51e-204">相反地，內嵌的 null 字元時，會永遠考慮這類方法搜尋字串<xref:System.String.Contains%2A>， <xref:System.String.StartsWith%2A>，和<xref:System.String.IndexOf%2A>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-204">On the other hand, embedded null characters are always considered when searching a string with methods such as <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.IndexOf%2A>.</span></span>  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a><span data-ttu-id="5f51e-205">字串與索引</span><span class="sxs-lookup"><span data-stu-id="5f51e-205">Strings and indexes</span></span>  
 <span data-ttu-id="5f51e-206">索引是位置<xref:System.Char>中的物件 （不屬於 Unicode 字元） <xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-206">An index is the position of a <xref:System.Char> object (not a Unicode character) in a <xref:System.String>.</span></span> <span data-ttu-id="5f51e-207">索引是負值，以零為起始的數字，以從索引位置為零的字串中的第一個位置開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-207">An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero.</span></span> <span data-ttu-id="5f51e-208">一個數字的搜尋方法，例如<xref:System.String.IndexOf%2A>和<xref:System.String.LastIndexOf%2A>、 傳回字元的索引或子字串的字串執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-208">A number of search methods, such as <xref:System.String.IndexOf%2A> and <xref:System.String.LastIndexOf%2A>, return the index of a character or substring in the string instance.</span></span>  
  
 <span data-ttu-id="5f51e-209"><xref:System.String.Chars%2A>屬性可讓您存取個別<xref:System.Char>依字串中的索引位置的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-209">The <xref:System.String.Chars%2A> property lets you access individual <xref:System.Char> objects by their index position in the string.</span></span> <span data-ttu-id="5f51e-210">因為<xref:System.String.Chars%2A>屬性為預設屬性 （在 Visual Basic) 或索引子 （在 C# 中)，您可以存取個別<xref:System.Char>字串使用下列程式碼中的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-210">Because the <xref:System.String.Chars%2A> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <xref:System.Char> objects in a string by using code such as the following.</span></span> <span data-ttu-id="5f51e-211">此程式碼會尋找泛空白字元或標點符號字元，以判斷字串包含幾個文字字串中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-211">This code looks for white space or punctuation characters in a string to determine how many words the string contains.</span></span>  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 <span data-ttu-id="5f51e-212">因為<xref:System.String>類別會實作<xref:System.Collections.IEnumerable>介面，您可以也逐一<xref:System.Char>中使用的字串物件`foreach`建構，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-212">Because the <xref:System.String> class implements the <xref:System.Collections.IEnumerable> interface, you can also iterate through the <xref:System.Char> objects in a string by using a `foreach` construct, as the following example shows.</span></span>  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 <span data-ttu-id="5f51e-213">連續索引值可能不會對應至連續的 Unicode 字元，因為的 Unicode 字元可能會編碼為多個<xref:System.Char>物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-213">Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <xref:System.Char> object.</span></span> <span data-ttu-id="5f51e-214">特別是，字串可能包含多字元由基底字元後面的一或多個組合字元或 surrogate 字組所組成的文字單元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-214">In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs.</span></span> <span data-ttu-id="5f51e-215">若要使用 Unicode 字元，而不是<xref:System.Char>物件，使用<xref:System.Globalization.StringInfo?displayProperty=nameWithType>和<xref:System.Globalization.TextElementEnumerator>類別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-215">To work with Unicode characters instead of <xref:System.Char> objects, use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> and <xref:System.Globalization.TextElementEnumerator> classes.</span></span> <span data-ttu-id="5f51e-216">下列範例說明可搭配程式碼之間的差異<xref:System.Char>物件與處理 Unicode 字元碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-216">The following example illustrates the difference between code that works with <xref:System.Char> objects and code that works with Unicode characters.</span></span> <span data-ttu-id="5f51e-217">它會比較字元或在每個字的句子中的文字項目的數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-217">It compares the number of characters or text elements in each word of a sentence.</span></span> <span data-ttu-id="5f51e-218">字串包含兩個基底的字元，後面接著組合字元的序列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-218">The string includes two sequences of a base character followed by a combining character.</span></span>  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 <span data-ttu-id="5f51e-219">使用這個範例適用於文字項目與<xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType>方法和<xref:System.Globalization.TextElementEnumerator>列舉字串中的所有文字元素的類別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-219">This example works with text elements by using the <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> method and the <xref:System.Globalization.TextElementEnumerator> class to enumerate all the text elements in a string.</span></span> <span data-ttu-id="5f51e-220">您也可以擷取陣列，其中包含每個文字項目的起始的索引，藉由呼叫<xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-220">You can also retrieve an array that contains the starting index of each text element by calling the <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="5f51e-221">如需有關使用的文字，而非個別單位<xref:System.Char>值，請參閱<xref:System.Globalization.StringInfo>類別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-221">For more information about working with units of text rather than individual <xref:System.Char> values, see the <xref:System.Globalization.StringInfo> class.</span></span>  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a><span data-ttu-id="5f51e-222">Null 字串值和空白字串</span><span class="sxs-lookup"><span data-stu-id="5f51e-222">Null strings and empty strings</span></span>  
 <span data-ttu-id="5f51e-223">已宣告但尚未指派值的字串是`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-223">A string that has been declared but has not been assigned a value is `null`.</span></span> <span data-ttu-id="5f51e-224">嘗試在該字串上呼叫方法會擲回<xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-224">Attempting to call methods on that string throws a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="5f51e-225">Null 字串是不同的是的字串，其值是空字串""或<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-225">A null string is different from an empty string, which is a string whose value is "" or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-226">在某些情況下，傳遞 null 字串或空字串做為引數的方法呼叫會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="5f51e-226">In some cases, passing either a null string or an empty string as an argument in a method call throws an exception.</span></span> <span data-ttu-id="5f51e-227">例如，傳遞 null 字串給<xref:System.Int32.Parse%2A?displayProperty=nameWithType>方法會擲回<xref:System.ArgumentNullException>，並傳遞空字串會擲回<xref:System.FormatException>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-227">For example, passing a null string to the <xref:System.Int32.Parse%2A?displayProperty=nameWithType> method throws an <xref:System.ArgumentNullException>, and passing an empty string throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="5f51e-228">在其他情況下，為方法引數可以是 null 字串或是空字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-228">In other cases, a method argument can be either a null string or an empty string.</span></span> <span data-ttu-id="5f51e-229">例如，如果您要提供<xref:System.IFormattable>類別實作，您想要使用一般 ("G") 格式規範等同 null 字串和空字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-229">For example, if you are providing an <xref:System.IFormattable> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.</span></span>  
  
 <span data-ttu-id="5f51e-230"><xref:System.String>類別包含下列兩個便利的方法可讓您可測試字串是否`null`或空白：</span><span class="sxs-lookup"><span data-stu-id="5f51e-230">The <xref:System.String> class includes the following two convenience methods that enable you to test whether a string is `null` or empty:</span></span>  
  
-   <span data-ttu-id="5f51e-231"><xref:System.String.IsNullOrEmpty%2A>指出字串是否為`null`或等於<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-231"><xref:System.String.IsNullOrEmpty%2A>, which indicates whether a string is either `null` or is equal to  <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-232">這個方法就不需要使用程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="5f51e-232">This method eliminates the need to use code such as the following:</span></span>  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <span data-ttu-id="5f51e-233"><xref:System.String.IsNullOrWhiteSpace%2A>指出字串是否`null`，等於<xref:System.String.Empty?displayProperty=nameWithType>，或只包含空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-233"><xref:System.String.IsNullOrWhiteSpace%2A>, which indicates whether a string is `null`, equals <xref:System.String.Empty?displayProperty=nameWithType>, or consists exclusively of white-space characters.</span></span> <span data-ttu-id="5f51e-234">這個方法就不需要使用程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="5f51e-234">This method eliminates the need to use code such as the following:</span></span>  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 <span data-ttu-id="5f51e-235">下列範例會使用<xref:System.String.IsNullOrEmpty%2A>方法中的<xref:System.IFormattable.ToString%2A?displayProperty=nameWithType>的自訂實作`Temperature`類別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-235">The following example uses the <xref:System.String.IsNullOrEmpty%2A> method in the <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation of a custom `Temperature` class.</span></span> <span data-ttu-id="5f51e-236">此方法支援"G"、"C"、"F"和"K"格式字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-236">The method supports the "G", "C", "F", and "K" format strings.</span></span> <span data-ttu-id="5f51e-237">如果是空的格式字串或格式字串的值是`null`會傳遞至方法，其值變更為"G"格式字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-237">If an empty format string or a format string whose value is `null` is passed to the method, its value is changed to the "G" format string.</span></span>  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a><span data-ttu-id="5f51e-238">不變性和 StringBuilder 類別</span><span class="sxs-lookup"><span data-stu-id="5f51e-238">Immutability and the StringBuilder class</span></span>  
 <span data-ttu-id="5f51e-239">A<xref:System.String>物件稱為不可變 （唯讀），因為它建立之後便無法修改其值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-239">A <xref:System.String> object is called immutable (read-only), because its value cannot be modified after it has been created.</span></span> <span data-ttu-id="5f51e-240">方法會將修改<xref:System.String>物件實際上會傳回新<xref:System.String>包含修改物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-240">Methods that appear to modify a <xref:System.String> object actually return a new <xref:System.String> object that contains the modification.</span></span>  
  
 <span data-ttu-id="5f51e-241">字串是不可變的因為執行的字串操作常式重複新增或刪除來顯示為單一的字串可以精確顯著的效能負面影響。</span><span class="sxs-lookup"><span data-stu-id="5f51e-241">Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty.</span></span> <span data-ttu-id="5f51e-242">例如，下列程式碼會使用隨機號碼產生器建立具有在範圍內要 0x052F 0x0001 1000 個字元的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-242">For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F.</span></span> <span data-ttu-id="5f51e-243">雖然程式碼會顯示使用字串串連來將新字元附加至現有的字串，名為`str`，它會建立新<xref:System.String>每個串連作業的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-243">Although the code appears to use string concatenation to append a new character to the existing string named `str`, it actually creates a new <xref:System.String> object for each concatenation operation.</span></span>  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 <span data-ttu-id="5f51e-244">您可以使用<xref:System.Text.StringBuilder>類別而不是<xref:System.String>變更多個字串值的作業類別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-244">You can use the <xref:System.Text.StringBuilder> class instead of the <xref:System.String> class for operations that make multiple changes to the value of a string.</span></span> <span data-ttu-id="5f51e-245">不同的執行個體於<xref:System.String>類別<xref:System.Text.StringBuilder>是可變動的物件; 當您串連、 附加、 或刪除從字串的子字串時，作業將會在單一字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-245">Unlike instances of the <xref:System.String> class, <xref:System.Text.StringBuilder> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string.</span></span> <span data-ttu-id="5f51e-246">當您完成修改的值<xref:System.Text.StringBuilder>物件，您可以呼叫其<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法，以將它轉換為字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-246">When you have finished modifying the value of a <xref:System.Text.StringBuilder> object, you can call its <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> method to convert it to a string.</span></span> <span data-ttu-id="5f51e-247">下列範例會取代<xref:System.String>前一個範例中用來串連來與 0x052F 0x0001 範圍中的 1000 個隨機字元<xref:System.Text.StringBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-247">The following example replaces the <xref:System.String> used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <xref:System.Text.StringBuilder> object.</span></span>  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a><span data-ttu-id="5f51e-248">序數和區分文化特性的作業</span><span class="sxs-lookup"><span data-stu-id="5f51e-248">Ordinal vs. culture-sensitive operations</span></span>  
 <span data-ttu-id="5f51e-249">成員<xref:System.String>類別上執行序數或區分文化特性 （語言） 作業<xref:System.String>物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-249">Members of the <xref:System.String> class perform either ordinal or culture-sensitive (linguistic) operations on a <xref:System.String> object.</span></span> <span data-ttu-id="5f51e-250">序數的作業處理程式碼的每個數值<xref:System.Char>物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-250">An ordinal operation acts on the numeric value of each <xref:System.Char> object.</span></span> <span data-ttu-id="5f51e-251">區分文化特性的作業處理程式碼的值<xref:System.String>物件，並採用特定文化特性大小寫、 排序、 格式和剖析規則納入考量。</span><span class="sxs-lookup"><span data-stu-id="5f51e-251">A culture-sensitive operation acts on the value of the <xref:System.String> object, and takes culture-specific casing, sorting, formatting, and parsing rules into account.</span></span> <span data-ttu-id="5f51e-252">明確宣告的文化特性或目前的文化特性隱含的內容中，執行區分文化特性的作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-252">Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture.</span></span> <span data-ttu-id="5f51e-253">它們在相同的字串上執行時，兩種運算會產生非常不同的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-253">The two kinds of operations can produce very different results when they are performed on the same string.</span></span>  
  
 <span data-ttu-id="5f51e-254">.NET Framework 也支援不區分文化特性的語言字串作業所使用的文化特性而異 (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>)，這鬆散根據英文語言的地區無關的文化特性設定。</span><span class="sxs-lookup"><span data-stu-id="5f51e-254">The .NET Framework also supports culture-insensitive linguistic string operations by using the invariant culture (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), which is loosely based on the culture settings of the English language independent of region.</span></span> <span data-ttu-id="5f51e-255">不同於其他<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>保證設定、 文化特性而異的設定都維持一致的單一電腦上，從系統的系統，以及.NET Framework 的版本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-255">Unlike other <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of the .NET Framework.</span></span> <span data-ttu-id="5f51e-256">跨所有文化特性而異的文化特性可以是所見，做為一種黑色方塊，以確保穩定性的字串比較和排序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-256">The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5f51e-257">如果應用程式決定安全性的相關符號的識別項，例如檔案名稱或具名管道，或保存的資料，例如 XML 檔案中以文字為基礎的資料相關作業應該使用序數比較，而不是區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-257">If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-258">這是因為區分文化特性比較可以作用中，產生不同的結果，根據文化特性而取決於二進位值的比較字元的序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-258">This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5f51e-259">大部分執行字串作業的方法包括參數類型的多載<xref:System.StringComparison>，可讓您指定方法是否執行的序數或區分文化特性的作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-259">Most methods that perform string operations include an overload that has a parameter of type <xref:System.StringComparison>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation.</span></span> <span data-ttu-id="5f51e-260">一般情況下，您應該呼叫此多載，以讓您的方法呼叫更清晰。</span><span class="sxs-lookup"><span data-stu-id="5f51e-260">In general, you should call this overload to make the intent of your method call clear.</span></span> <span data-ttu-id="5f51e-261">最佳作法及使用序數和區分文化特性的字串作業的指引，請參閱[使用字串的最佳作法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-261">For best practices and guidance for using ordinal and culture-sensitive operations on strings, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="5f51e-262">作業[大小寫](#casing)，[格式化和剖析](#parsing)，[比較和排序](#comparison)，和[測試是否相等](#equality)可以是序數或區分文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-262">Operations for [casing](#casing), [parsing and formatting](#parsing), [comparison and sorting](#comparison), and [testing for equality](#equality) can be either ordinal or culture-sensitive.</span></span> <span data-ttu-id="5f51e-263">下列章節會討論每個作業類別目錄。</span><span class="sxs-lookup"><span data-stu-id="5f51e-263">The following sections discuss each category of operation.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="5f51e-264">您應該一律呼叫的方法多載，可在方法呼叫更清晰。</span><span class="sxs-lookup"><span data-stu-id="5f51e-264">You should always call a method overload that makes the intent of your method call clear.</span></span> <span data-ttu-id="5f51e-265">比方說，而不是呼叫<xref:System.String.Compare%28System.String%2CSystem.String%29>方法來執行區分文化特性比較的兩個字串，使用目前的文化特性的慣例，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，其值為<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>如`comparisonType`引數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-265">For example, instead of calling the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with a value of <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> for the `comparisonType` argument.</span></span> <span data-ttu-id="5f51e-266">如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-266">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
<a name="casing"></a>   
### <a name="casing"></a><span data-ttu-id="5f51e-267">大小寫</span><span class="sxs-lookup"><span data-stu-id="5f51e-267">Casing</span></span>  
 <span data-ttu-id="5f51e-268">大小寫規則會決定如何變更大小寫的 Unicode 字元;例如，從小寫為大寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-268">Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase.</span></span> <span data-ttu-id="5f51e-269">通常，大小寫進行字串比較之前。</span><span class="sxs-lookup"><span data-stu-id="5f51e-269">Often, a casing operation is performed before a string comparison.</span></span> <span data-ttu-id="5f51e-270">例如，字串可能會轉換成大寫，以便與另一個大寫的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-270">For example, a string might be converted to uppercase so that it can be compared with another uppercase string.</span></span> <span data-ttu-id="5f51e-271">您可以將轉換成小寫藉由呼叫字串中的字元<xref:System.String.ToLower%2A>或<xref:System.String.ToLowerInvariant%2A>方法，而且您可以將它們轉換成大寫藉由呼叫<xref:System.String.ToUpper%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-271">You can convert the characters in a string to lowercase by calling the <xref:System.String.ToLower%2A> or <xref:System.String.ToLowerInvariant%2A> method, and you can convert them to uppercase by calling the <xref:System.String.ToUpper%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="5f51e-272">此外，您可以使用<xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType>方法，將字串轉換為字首大寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-272">In addition, you can use the <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> method to convert a string to title case.</span></span>  
  
 <span data-ttu-id="5f51e-273">大小寫作業可以根據目前文化特性、 指定的文化特性或文化特性而異的規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-273">Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture.</span></span> <span data-ttu-id="5f51e-274">大小寫對應可以使用的文化特性而有所不同，因為大小寫作業的結果可以根據而異的文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-274">Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture.</span></span> <span data-ttu-id="5f51e-275">實際大小寫的差異有三種：</span><span class="sxs-lookup"><span data-stu-id="5f51e-275">The actual differences in casing are of three kinds:</span></span>  
  
-   <span data-ttu-id="5f51e-276">大小寫的 LATIN CAPITAL LETTER I 對應的差異 (U + 0049)，拉丁小字母 I (U + 0069)，LATIN CAPITAL LETTER 我使用點 (U + 0130)，高於和拉丁小字母無點 I (U + 0131)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-276">Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131).</span></span> <span data-ttu-id="5f51e-277">TR-TR （土耳其文 （土耳其）） 和 az-Latn-AZ （亞塞拜然，拉丁） 文化特性中，在 tr，az，az Latn 中性文化特性，拉丁文大寫字母 1 的小寫對應項拉丁文小字母無點 1，且拉丁文小字母 1 的大寫對應項高於 LATIN CAPITAL LETTER 我與點。</span><span class="sxs-lookup"><span data-stu-id="5f51e-277">In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span> <span data-ttu-id="5f51e-278">在其他文化特性，包括 文化特性而異，拉丁小字母 I 與 LATIN CAPITAL LETTER 進行小寫和大寫對等項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-278">In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.</span></span>  
  
     <span data-ttu-id="5f51e-279">下列範例示範如何設計的字串比較，以避免檔案系統存取權可能會失敗它依賴區分文化特性大小寫比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-279">The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison.</span></span> <span data-ttu-id="5f51e-280">（文化特性而異的大小寫慣例應該已使用。）</span><span class="sxs-lookup"><span data-stu-id="5f51e-280">(The casing conventions of the invariant culture should have been used.)</span></span>  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   <span data-ttu-id="5f51e-281">大小寫對應中所有其他文化特性而異的文化特性之間的差異。</span><span class="sxs-lookup"><span data-stu-id="5f51e-281">Differences in case mappings between the invariant culture and all other cultures.</span></span> <span data-ttu-id="5f51e-282">在這些情況下，使用文化特性而異的大小寫規則變更為大寫或小寫的字元會傳回相同的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-282">In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character.</span></span> <span data-ttu-id="5f51e-283">針對其他文化特性，它會傳回不同的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-283">For all other cultures, it returns a different character.</span></span> <span data-ttu-id="5f51e-284">某些受影響的字元會在下表中列出。</span><span class="sxs-lookup"><span data-stu-id="5f51e-284">Some of the affected characters are listed in the following table.</span></span>  
  
    |<span data-ttu-id="5f51e-285">字元</span><span class="sxs-lookup"><span data-stu-id="5f51e-285">Character</span></span>|<span data-ttu-id="5f51e-286">如果變更為</span><span class="sxs-lookup"><span data-stu-id="5f51e-286">If changed to</span></span>|<span data-ttu-id="5f51e-287">Returns</span><span class="sxs-lookup"><span data-stu-id="5f51e-287">Returns</span></span>|  
    |---------------|-------------------|-------------|  
    |<span data-ttu-id="5f51e-288">MICRON 登 (U + 00B5)</span><span class="sxs-lookup"><span data-stu-id="5f51e-288">MICRON SIGN (U+00B5)</span></span>|<span data-ttu-id="5f51e-289">大寫</span><span class="sxs-lookup"><span data-stu-id="5f51e-289">Uppercase</span></span>|<span data-ttu-id="5f51e-290">希臘文的大寫字母 MU (U +-39 C)</span><span class="sxs-lookup"><span data-stu-id="5f51e-290">GREEK CAPITAL LETTER MU (U+-39C)</span></span>|  
    |<span data-ttu-id="5f51e-291">拉丁文大寫字母 I 點上方 (U + 0130)</span><span class="sxs-lookup"><span data-stu-id="5f51e-291">LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</span></span>|<span data-ttu-id="5f51e-292">小寫</span><span class="sxs-lookup"><span data-stu-id="5f51e-292">Lowercase</span></span>|<span data-ttu-id="5f51e-293">拉丁文小字母 I (U + 0069)</span><span class="sxs-lookup"><span data-stu-id="5f51e-293">LATIN SMALL LETTER I (U+0069)</span></span>|  
    |<span data-ttu-id="5f51e-294">無點拉丁小寫字母 I (U + 0131)</span><span class="sxs-lookup"><span data-stu-id="5f51e-294">LATIN SMALL LETTER DOTLESS I (U+0131)</span></span>|<span data-ttu-id="5f51e-295">大寫</span><span class="sxs-lookup"><span data-stu-id="5f51e-295">Uppercase</span></span>|<span data-ttu-id="5f51e-296">拉丁文大寫字母 I (U + 0049)</span><span class="sxs-lookup"><span data-stu-id="5f51e-296">LATIN CAPITAL LETTER I (U+0049)</span></span>|  
    |<span data-ttu-id="5f51e-297">拉丁文小寫字母長 S (U + 017F)</span><span class="sxs-lookup"><span data-stu-id="5f51e-297">LATIN SMALL LETTER LONG S (U+017F)</span></span>|<span data-ttu-id="5f51e-298">大寫</span><span class="sxs-lookup"><span data-stu-id="5f51e-298">Uppercase</span></span>|<span data-ttu-id="5f51e-299">LATIN CAPITAL LETTER S (U + 0053)</span><span class="sxs-lookup"><span data-stu-id="5f51e-299">LATIN CAPITAL LETTER S (U+0053)</span></span>|  
    |<span data-ttu-id="5f51e-300">上方有勾的小寫字母 Z LATIN CAPITAL LETTER A (U + 01C 5)</span><span class="sxs-lookup"><span data-stu-id="5f51e-300">LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)</span></span>|<span data-ttu-id="5f51e-301">小寫</span><span class="sxs-lookup"><span data-stu-id="5f51e-301">Lowercase</span></span>|<span data-ttu-id="5f51e-302">上方有勾的拉丁小寫字母 DZ (U + 01C 6)</span><span class="sxs-lookup"><span data-stu-id="5f51e-302">LATIN SMALL LETTER DZ WITH CARON (U+01C6)</span></span>|  
    |<span data-ttu-id="5f51e-303">結合希臘 YPOGEGRAMMENI (U + 0345)</span><span class="sxs-lookup"><span data-stu-id="5f51e-303">COMBINING GREEK YPOGEGRAMMENI (U+0345)</span></span>|<span data-ttu-id="5f51e-304">大寫</span><span class="sxs-lookup"><span data-stu-id="5f51e-304">Uppercase</span></span>|<span data-ttu-id="5f51e-305">希臘文的大寫字母 IOTA (U + 0399)</span><span class="sxs-lookup"><span data-stu-id="5f51e-305">GREEK CAPITAL LETTER IOTA (U+0399)</span></span>|  
  
-   <span data-ttu-id="5f51e-306">ASCII 字元範圍內的兩個字母大小字母混合的組的大小寫對應的差異。</span><span class="sxs-lookup"><span data-stu-id="5f51e-306">Differences in case mappings of two-letter mixed-case pairs in the ASCII character range.</span></span> <span data-ttu-id="5f51e-307">大部分的文化特性中的兩個字母大小字母混合的組等於的對等的兩個字母大寫或小寫組。</span><span class="sxs-lookup"><span data-stu-id="5f51e-307">In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair.</span></span> <span data-ttu-id="5f51e-308">這是不在下列的文化特性中，下列兩個字母組，則為 true，因為它們會在每個案例進行比較雙拼詞：</span><span class="sxs-lookup"><span data-stu-id="5f51e-308">This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:</span></span>  
  
    -   <span data-ttu-id="5f51e-309">「 lJ"和"nJ"HR-HR （克羅埃西亞文 （克羅埃西亞）） 文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-309">"lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture.</span></span>  
  
    -   <span data-ttu-id="5f51e-310">「 cH"CS-CZ （捷克文 （捷克共和國）） 和 sk SK （斯洛伐克文 （斯洛伐克）） 文化特性而有所不同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-310">"cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.</span></span>  
  
    -   <span data-ttu-id="5f51e-311">"aA"DA-DK （丹麥文 （丹麥）） 文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-311">"aA" in the da-DK (Danish (Denmark)) culture.</span></span>  
  
    -   <span data-ttu-id="5f51e-312">"cS"、"dZ"、"dZS"、"nY"、"sZ"、"置入"和"zs"表示 HU-HU （匈牙利文 （匈牙利）） 文化特性中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-312">"cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture.</span></span>  
  
    -   <span data-ttu-id="5f51e-313">「 cH"和"lL"es ES_tradnl （西班牙文 （西班牙，傳統排序）） 文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-313">"cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.</span></span>  
  
    -   <span data-ttu-id="5f51e-314">「 cH"、"gI"、"kH"、"nG""nH"、"pH"，"qU'，「 日 」 和 「 tR"vi VN （越南文 （越南）） 文化特性中的。</span><span class="sxs-lookup"><span data-stu-id="5f51e-314">"cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture.</span></span>  
  
     <span data-ttu-id="5f51e-315">不過，很少會發生區分文化特性的比較這些字組的建立問題，這種情況，因為這些配對是固定的字串或識別項中不常發生。</span><span class="sxs-lookup"><span data-stu-id="5f51e-315">However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.</span></span>  
  
 <span data-ttu-id="5f51e-316">下列範例會說明一些在大小寫規則時將字串轉換成大寫的文化特性之間的差異。</span><span class="sxs-lookup"><span data-stu-id="5f51e-316">The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.</span></span>  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a><span data-ttu-id="5f51e-317">格式化和剖析</span><span class="sxs-lookup"><span data-stu-id="5f51e-317">Parsing and formatting</span></span>  
 <span data-ttu-id="5f51e-318">格式化和剖析都是反向作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-318">Formatting and parsing are inverse operations.</span></span> <span data-ttu-id="5f51e-319">格式化規則會決定如何將一個值，例如日期和時間或數字，轉換為其字串表示，而剖析規則會決定如何將字串表示轉換成一個值，例如日期和時間。</span><span class="sxs-lookup"><span data-stu-id="5f51e-319">Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time.</span></span> <span data-ttu-id="5f51e-320">格式化和剖析規則均依存於文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="5f51e-320">Both formatting and parsing rules are dependent on cultural conventions.</span></span> <span data-ttu-id="5f51e-321">下列範例說明如何解譯特定文化特性的日期字串時，可能會發生模稜兩可。</span><span class="sxs-lookup"><span data-stu-id="5f51e-321">The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string.</span></span> <span data-ttu-id="5f51e-322">而不需要知道用來產生日期字串文化特性的慣例，不可能知道 03/01/2011年，3/1/2011，01/03/2011年代表 2011 年 1 月 3 日或 2011 年 3 月 1 日。</span><span class="sxs-lookup"><span data-stu-id="5f51e-322">Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.</span></span>  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 <span data-ttu-id="5f51e-323">同樣地，如下列範例所示，單一字串可能會產生不同的日期，根據在剖析作業中會使用其慣例的文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-323">Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.</span></span>  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a><span data-ttu-id="5f51e-324">字串比較和排序</span><span class="sxs-lookup"><span data-stu-id="5f51e-324">String comparison and sorting</span></span>  
 <span data-ttu-id="5f51e-325">比較和排序字串的慣例改變文化。</span><span class="sxs-lookup"><span data-stu-id="5f51e-325">Conventions for comparing and sorting strings vary from culture to culture.</span></span> <span data-ttu-id="5f51e-326">例如，排序次序可能會根據語音或字元的視覺表示法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-326">For example, the sort order may be based on phonetics or on the visual representation of characters.</span></span> <span data-ttu-id="5f51e-327">在東亞語言中，字元都是依據筆劃來排序和文字字根進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-327">In East Asian languages, characters are sorted by the stroke and radical of ideographs.</span></span> <span data-ttu-id="5f51e-328">排序也取決於順序語言和文化特性使用的字母。</span><span class="sxs-lookup"><span data-stu-id="5f51e-328">Sorting also depends on the order languages and cultures use for the alphabet.</span></span> <span data-ttu-id="5f51e-329">例如，丹麥文的 "Æ" 字元在字母順序中排列在 "Z" 之後。</span><span class="sxs-lookup"><span data-stu-id="5f51e-329">For example, the Danish language has an "Æ" character that it sorts after "Z" in the alphabet.</span></span> <span data-ttu-id="5f51e-330">此外，比較可以是區分大小寫或區分大小寫，並且在某些情況下的大小寫規則也因文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-330">In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture.</span></span> <span data-ttu-id="5f51e-331">序數比較，相反地，使用時比較和排序字串的字串中的個別字元的 Unicode 字碼指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-331">Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.</span></span>  
  
 <span data-ttu-id="5f51e-332">排序規則決定彼此的 Unicode 字元的字母順序和兩個字串比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-332">Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other.</span></span> <span data-ttu-id="5f51e-333">例如，<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>方法比較為基礎的兩個字串<xref:System.StringComparison>參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-333">For example, the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method compares two strings based on the <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="5f51e-334">如果參數值為<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>，此方法會執行會使用目前文化特性; 慣例語言比較，如果參數值為<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>，此方法會執行序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-334">If the parameter value is <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, the method performs an ordinal comparison.</span></span> <span data-ttu-id="5f51e-335">因此，如下列範例所示，如果目前的文化特性是美國英文、 第一次呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>方法 （使用區分文化特性的比較） 會考慮"a"小於"A"，但相同的方法 （使用序數比較） 的第二個呼叫會考慮"a"大於"A"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-335">Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".</span></span>  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 <span data-ttu-id="5f51e-336">.NET Framework 支援 word、 字串和序數排序規則：</span><span class="sxs-lookup"><span data-stu-id="5f51e-336">The .NET Framework supports word, string, and ordinal sort rules:</span></span>  
  
-   <span data-ttu-id="5f51e-337">文字排序執行區分文化特性比較的字串，其中某些非英數字元的 Unicode 字元可能會有特殊的權重。</span><span class="sxs-lookup"><span data-stu-id="5f51e-337">A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them.</span></span> <span data-ttu-id="5f51e-338">例如，連字號 （-） 可能會有非常小的加權指派給它，以便 「 coop 」 和 「 聯合"會相互並排顯示已排序的清單中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-338">For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list.</span></span> <span data-ttu-id="5f51e-339">取得一份<xref:System.String>方法來比較兩個字串使用字組的排序規則，請參閱[依類別目錄字串運算](#ByCategory)> 一節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-339">For a list of the <xref:System.String> methods that compare two strings using word sort rules, see the [String operations by category](#ByCategory) section.</span></span>  
  
-   <span data-ttu-id="5f51e-340">字串排序也會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-340">A string sort also performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-341">很類似於 word 排序，但是沒有特殊案例，而所有的非英數符號前面所有英數字元的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-341">It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters.</span></span> <span data-ttu-id="5f51e-342">可以藉由呼叫使用字串的排序規則比較兩個字串<xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType>方法的多載`options`參數所提供的值<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-342">Two strings can be compared using string sort rules by calling the <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> method overloads that have an `options` parameter that is supplied a value of <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-343">請注意，這是.NET Framework 提供比較兩個字串，使用字串的排序規則的唯一方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-343">Note that this is the only method that the .NET Framework provides to compare two strings using string sort rules.</span></span>  
  
-   <span data-ttu-id="5f51e-344">序數排序比較根據每個數值的字串<xref:System.Char>字串中的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-344">An ordinal sort compares strings based on the numeric value of each <xref:System.Char> object in the string.</span></span> <span data-ttu-id="5f51e-345">序數比較是自動區分大小寫，因為小寫和大寫字元的版本具有不同的字碼指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-345">An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points.</span></span> <span data-ttu-id="5f51e-346">不過，如果案例並不重要，您可以指定會忽略大小寫的序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-346">However, if case is not important, you can specify an ordinal comparison that ignores case.</span></span> <span data-ttu-id="5f51e-347">這就相當於將轉換為大寫，使用文化特性而異，然後在結果上執行序數比較字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-347">This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result.</span></span> <span data-ttu-id="5f51e-348">取得一份<xref:System.String>方法來比較兩個字串，使用序數排序規則，請參閱[依類別目錄字串運算](#ByCategory)> 一節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-348">For a list of the <xref:System.String> methods that compare two strings using ordinal sort rules, see the [String operations by category](#ByCategory) section.</span></span>  
  
 <span data-ttu-id="5f51e-349">區分文化特性的比較是明確或隱含使用任何比較<xref:System.Globalization.CultureInfo>物件，包括異的文化特性所指定<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-349">A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <xref:System.Globalization.CultureInfo> object, including the invariant culture that is specified by the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="5f51e-350">隱含的文化特性是所指定的目前文化特性<xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>和<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-350">The implicit culture is the current culture, which is specified by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="5f51e-351">沒有相當大的變化，字母字元的排序順序 (也就是字元的<xref:System.Char.IsLetter%2A?displayProperty=nameWithType>屬性會傳回`true`) 跨文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-351">There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> property returns `true`) across cultures.</span></span> <span data-ttu-id="5f51e-352">您可以指定使用藉由提供特定文化特性的慣例的文化特性比較<xref:System.Globalization.CultureInfo>這類物件的字串比較方法<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-352">You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <xref:System.Globalization.CultureInfo> object to a string comparison method such as <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>.</span></span> <span data-ttu-id="5f51e-353">您可以指定使用目前文化特性的慣例，藉由提供文化特性比較<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>， <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>，或任何成員<xref:System.Globalization.CompareOptions>以外的列舉<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>適當多載<xref:System.String.Compare%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-353">You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, or any member of the <xref:System.Globalization.CompareOptions> enumeration other than <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> or <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> to an appropriate overload of the <xref:System.String.Compare%2A> method.</span></span> <span data-ttu-id="5f51e-354">通常適合進行排序而序數比較不是區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-354">A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not.</span></span> <span data-ttu-id="5f51e-355">序數比較是通常適用於判斷兩個字串是否相等 (也就是判斷識別) 而不是區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-355">An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.</span></span>  
  
 <span data-ttu-id="5f51e-356">下列範例說明區分文化特性和序數比較之間的差異。</span><span class="sxs-lookup"><span data-stu-id="5f51e-356">The following example illustrates the difference between culture-sensitive and ordinal comparison.</span></span> <span data-ttu-id="5f51e-357">此範例會評估三個字串、"Apple"、"Æble，"和"AEble"，使用序數比較和 DA-DK 和 EN-US 文化特性的慣例 (其中每一個都是預設文化特性時<xref:System.String.Compare%2A>方法呼叫)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-357">The example evaluates three strings, "Apple", "Æble", and "AEble", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <xref:System.String.Compare%2A> method is called).</span></span> <span data-ttu-id="5f51e-358">由於丹麥文"Æ"字元視為單一字母，而且字母表中將它排列在"Z"之後，字串"Æble"大於"Apple"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-358">Because the Danish language treats the character "Æ" as an individual letter and sorts it after "Z" in the alphabet, the string "Æble" is greater than "Apple".</span></span> <span data-ttu-id="5f51e-359">不過，"Æble"是不被視為相等於"AEble"，因此也是"AEble 「 大於 」 Æble"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-359">However, "Æble" is not considered equivalent to "AEble", so "Æble" is also greater than "AEble".</span></span> <span data-ttu-id="5f51e-360">EN-US 文化特性並不包含字母"Æ"，但會將它視為相當於"AE"，其中說明為什麼"Æble"小於"Apple"但為等於"AEble"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-360">The en-US culture doesn't include the letter"Æ" but treats it as equivalent to "AE", which explains why  "Æble" is less than "Apple" but equal to "AEble".</span></span> <span data-ttu-id="5f51e-361">序數比較，相反地，會視為必須小於"Æble 」 和"Æble"必須是大於"AEble"的"Apple"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-361">Ordinal comparison, on the other hand, considers "Apple" to be less than "Æble", and "Æble" to be greater than "AEble".</span></span>  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 <span data-ttu-id="5f51e-362">您可以使用下列一般指導方針來選擇適當的排序或字串比較方法：</span><span class="sxs-lookup"><span data-stu-id="5f51e-362">Use the following general guidelines to choose an appropriate sorting or string comparison method:</span></span>  
  
-   <span data-ttu-id="5f51e-363">如果您想根據使用者的文化特性來排序字串，您應該將目前的文化特性的慣例為基礎進行排序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-363">If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture.</span></span> <span data-ttu-id="5f51e-364">如果使用者的文化特性變更，排序字串的順序將也會據此變更。</span><span class="sxs-lookup"><span data-stu-id="5f51e-364">If the user's culture changes, the order of sorted strings will also change accordingly.</span></span> <span data-ttu-id="5f51e-365">例如，同義字應用程式應該永遠排序根據使用者的文化特性的字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-365">For example, a thesaurus application should always sort words based on the user's culture.</span></span>  
  
-   <span data-ttu-id="5f51e-366">如果您想根據特定的文化特性的慣例來排序字串，您應該排列這些資料行藉由提供<xref:System.Globalization.CultureInfo>物件，代表該文化特性的比較方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-366">If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <xref:System.Globalization.CultureInfo> object that represents that culture to a comparison method.</span></span> <span data-ttu-id="5f51e-367">比方說，教導學生特定語言設計的應用程式，在您想要排序的字串根據其中一個說出該語言的文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="5f51e-367">For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.</span></span>  
  
-   <span data-ttu-id="5f51e-368">如果您要維持不變，跨文化特性的字串順序，您應該排列這些而異的文化特性的慣例為基礎，或使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-368">If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison.</span></span> <span data-ttu-id="5f51e-369">例如，您會使用序數排序來組織檔案、 處理程序、 mutex 的名稱或具名管道。</span><span class="sxs-lookup"><span data-stu-id="5f51e-369">For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.</span></span>  
  
-   <span data-ttu-id="5f51e-370">如需牽涉到安全性決策 （例如使用者名稱是否有效） 的比較，您應該一律執行相等序數測試藉由呼叫的多載<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-370">For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <xref:System.String.Equals%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-371">區分文化特性的排序和大小寫字串比較中使用規則取決於.NET Framework 版本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-371">The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET Framework.</span></span> <span data-ttu-id="5f51e-372">在.NET Framework[!INCLUDE[net_v45](~/includes/net-v45-md.md)]上執行[!INCLUDE[win8](~/includes/win8-md.md)]作業系統、 排序、 大小寫、 正規化和 Unicode 的字元資訊符合 Unicode 6.0 標準。</span><span class="sxs-lookup"><span data-stu-id="5f51e-372">In the .NET Framework [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on the [!INCLUDE[win8](~/includes/win8-md.md)] operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard.</span></span> <span data-ttu-id="5f51e-373">在其他作業系統，其符合 Unicode 5.0 標準。</span><span class="sxs-lookup"><span data-stu-id="5f51e-373">On other operating systems, it conforms to the Unicode 5.0 standard.</span></span>  
  
 <span data-ttu-id="5f51e-374">如需 word、 字串和序數排序規則的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>主題。</span><span class="sxs-lookup"><span data-stu-id="5f51e-374">For more information about word, string, and ordinal sort rules, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> topic.</span></span> <span data-ttu-id="5f51e-375">如需其他建議何時使用每個規則，請參閱[使用字串的最佳作法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-375">For additional recommendations on when to use each rule, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="5f51e-376">通常，在未呼叫字串比較方法，例如<xref:System.String.Compare%2A>直接以決定字串的排序次序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-376">Ordinarily, you don't call string comparison methods such as <xref:System.String.Compare%2A> directly to determine the sort order of strings.</span></span> <span data-ttu-id="5f51e-377">相反地，比較方法會呼叫這類排序方法<xref:System.Array.Sort%2A?displayProperty=nameWithType>或<xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-377">Instead, comparison methods are called by sorting methods such as <xref:System.Array.Sort%2A?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-378">下列範例會執行四個不同排序作業 （使用目前文化特性、 使用文化特性而異的文字排序、 序數排序，以及使用而異的文化特性的字串排序文字排序） 而不需要明確地呼叫字串比較方法，雖然這些字元會指定要使用的比較類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-378">The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use.</span></span> <span data-ttu-id="5f51e-379">請注意，每種類型的排序會產生唯一的字串陣列中所用的排序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-379">Note that each type of sort produces a unique ordering of strings in its array.</span></span>  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  <span data-ttu-id="5f51e-380">就內部而言，.net Framework 會使用排序索引鍵，以支援 culturallysensitive 字串比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-380">Internally, the.NET Framework uses sort keys to support culturallysensitive string comparison.</span></span> <span data-ttu-id="5f51e-381">每個字元的字串中指定排序權重，包括字母、 大小寫和變音符號的數種類別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-381">Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic.</span></span> <span data-ttu-id="5f51e-382">排序索引鍵，由<xref:System.Globalization.SortKey>類別，這些加權的儲存機制，提供特定的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-382">A sort key, represented by the <xref:System.Globalization.SortKey> class, provides a repository of these weights for a particular string.</span></span> <span data-ttu-id="5f51e-383">如果您的應用程式執行大量搜尋或排序作業，在同一組字串時，您就可以改善其效能所產生並儲存它所使用的所有字串的排序索引鍵。</span><span class="sxs-lookup"><span data-stu-id="5f51e-383">If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses.</span></span> <span data-ttu-id="5f51e-384">需要排序或比較作業時，您可以使用的排序索引鍵而不要使用字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-384">When a sort or comparison operation is required, you use the sort keys instead of the strings.</span></span> <span data-ttu-id="5f51e-385">如需詳細資訊，請參閱 <xref:System.Globalization.SortKey> 類別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-385">For more information, see the <xref:System.Globalization.SortKey> class.</span></span>  
  
 <span data-ttu-id="5f51e-386">如果您未指定字串比較慣例，排序方法例如<xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>執行字串區分文化特性，區分大小寫排序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-386">If you don't specify a string comparison convention, sorting methods such as <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> perform a culture-sensitive, case-sensitive sort on strings.</span></span> <span data-ttu-id="5f51e-387">下列範例說明如何變更目前的文化特性會影響排序字串陣列中的順序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-387">The following example illustrates how changing the current culture affects the order of sorted strings in an array.</span></span> <span data-ttu-id="5f51e-388">它會建立三個字串的陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-388">It creates an array of three strings.</span></span> <span data-ttu-id="5f51e-389">首先，它會設定`System.Threading.Thread.CurrentThread.CurrentCulture`屬性設為 EN-US 並呼叫<xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-389">First, it sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to en-US and calls the <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5f51e-390">產生的排序次序為基礎的排序英文 （美國） 文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="5f51e-390">The resulting sort order is based on sorting conventions for the English (United States) culture.</span></span> <span data-ttu-id="5f51e-391">接下來，範例會將設定`System.Threading.Thread.CurrentThread.CurrentCulture`屬性 DA-DK 和呼叫<xref:System.Array.Sort%2A?displayProperty=nameWithType>方法一次。</span><span class="sxs-lookup"><span data-stu-id="5f51e-391">Next, the example sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to da-DK and calls the <xref:System.Array.Sort%2A?displayProperty=nameWithType> method again.</span></span> <span data-ttu-id="5f51e-392">請注意如何產生的排序次序與不同 EN-US 結果因為排序慣例用於丹麥文 （丹麥）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-392">Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).</span></span>  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  <span data-ttu-id="5f51e-393">如果您在比較字串的主要目的是要判斷是否相等，您應該呼叫<xref:System.String.Equals%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-393">If your primary purpose in comparing strings is to determine whether they are equal, you should call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5f51e-394">一般而言，您應該使用<xref:System.String.Equals%2A>来執行序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-394">Typically, you should use <xref:System.String.Equals%2A> to perform an ordinal comparison.</span></span> <span data-ttu-id="5f51e-395"><xref:System.String.Compare%2A?displayProperty=nameWithType>方法主要為了排序字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-395">The <xref:System.String.Compare%2A?displayProperty=nameWithType> method is intended primarily to sort strings.</span></span>  
  
 <span data-ttu-id="5f51e-396">字串搜尋方法，例如<xref:System.String.StartsWith%2A?displayProperty=nameWithType>和<xref:System.String.IndexOf%2A?displayProperty=nameWithType>，也可以執行區分文化特性或序數字串比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-396">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons.</span></span> <span data-ttu-id="5f51e-397">下列範例說明使用序數和區分文化特性比較的差異<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-397">The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="5f51e-398">區分文化特性的搜尋目前的文化特性是英文 （美國） 會視為 「 oe"符合"œ"連字的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-398">A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "œ".</span></span> <span data-ttu-id="5f51e-399">因為選擇性連字號 (U + 00AD) 是零寬度的字元，所以搜尋視為選擇性連字號相當於<xref:System.String.Empty>和字串的開頭處找到符合項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-399">Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <xref:System.String.Empty> and finds a match at the beginning of the string.</span></span> <span data-ttu-id="5f51e-400">序數搜尋，相反地，找不到相符項目在任一情況下。</span><span class="sxs-lookup"><span data-stu-id="5f51e-400">An ordinal search, on the other hand, does not find a match in either case.</span></span>  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a><span data-ttu-id="5f51e-401">搜尋字串</span><span class="sxs-lookup"><span data-stu-id="5f51e-401">Searching Strings</span></span>  
 <span data-ttu-id="5f51e-402">字串搜尋方法，例如<xref:System.String.StartsWith%2A?displayProperty=nameWithType>和<xref:System.String.IndexOf%2A?displayProperty=nameWithType>，也可以執行區分文化特性或指定之字串中找到的序數字串比較，以判斷是否字元或子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-402">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.</span></span>  
  
 <span data-ttu-id="5f51e-403">中的搜尋方法<xref:System.String>類別搜尋個別的字元，例如<xref:System.String.IndexOf%2A>方法，或其中一個的一組字元，例如<xref:System.String.IndexOfAny%2A>方法，所有執行的序數搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-403">The search methods in the <xref:System.String> class that search for an individual character, such as the <xref:System.String.IndexOf%2A> method, or one of a set of characters,   such as the <xref:System.String.IndexOfAny%2A> method, all perform an ordinal search.</span></span> <span data-ttu-id="5f51e-404">若要執行區分文化特性的搜尋的字元，您必須呼叫<xref:System.Globalization.CompareInfo>方法，例如<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>或<xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-404">To perform a culture-sensitive search for a character, you must call a <xref:System.Globalization.CompareInfo> method such as <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> or <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-405">請注意，搜尋字元，使用序數和區分文化特性的比較的結果可以是非常不同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-405">Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different.</span></span> <span data-ttu-id="5f51e-406">比方說，搜尋預先組成的 Unicode 字元，例如"Æ"連字 (U + 00 C 6) 可能符合正確的順序，例如"AE 」 及其元件的任何項目 （U + 041U + 0045），根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-406">For example, a search for a precomposed Unicode character such as the ligature "Æ" (U+00C6) might match any occurrence of its components in the correct sequence, such as "AE" (U+041U+0045), depending on the culture.</span></span> <span data-ttu-id="5f51e-407">下列範例說明之間的差異<xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType>和<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>方法搜尋的個別字元時。</span><span class="sxs-lookup"><span data-stu-id="5f51e-407">The following example illustrates the difference between the <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> and <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> methods when searching for an individual character.</span></span> <span data-ttu-id="5f51e-408">連字的"æ"(U + 00E6) 中找到字串"空照圖 」 時使用 EN-US 文化特性的慣例，但不是使用 DA-DK 文化特性的慣例或時執行序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-408">The ligature "æ" (U+00E6) is found in the string "aerial" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 <span data-ttu-id="5f51e-409">相反地，<xref:System.String>類別方法的搜尋字串，而不是字元執行區分文化特性的搜尋如果搜尋選項未明確指定型別參數所<xref:System.StringComparison>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-409">On the other hand, <xref:System.String> class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <xref:System.StringComparison>.</span></span> <span data-ttu-id="5f51e-410">唯一的例外狀況是<xref:System.String.Contains%2A>，它會執行序數搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-410">The sole exception is <xref:System.String.Contains%2A>, which performs an ordinal search.</span></span>  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a><span data-ttu-id="5f51e-411">測試相等</span><span class="sxs-lookup"><span data-stu-id="5f51e-411">Testing for equality</span></span>  
 <span data-ttu-id="5f51e-412">使用<xref:System.String.Compare%2A?displayProperty=nameWithType>方法，以判斷兩個字串在排序次序的關聯性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-412">Use the <xref:System.String.Compare%2A?displayProperty=nameWithType> method to determine the relationship of two strings in the sort order.</span></span> <span data-ttu-id="5f51e-413">一般而言，這是區分文化特性的作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-413">Typically, this is a culture-sensitive operation.</span></span> <span data-ttu-id="5f51e-414">相較之下，呼叫<xref:System.String.Equals%2A?displayProperty=nameWithType>方法來測試是否相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-414">In contrast, call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method to test for equality.</span></span> <span data-ttu-id="5f51e-415">因為相等測試通常會比較使用者輸入的一些已知的字串，例如有效的使用者名稱、 密碼或檔案系統路徑，通常是序數的作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-415">Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="5f51e-416">可以藉由呼叫測試是否相等<xref:System.String.Compare%2A?displayProperty=nameWithType>方法，並判斷傳回的值是否為零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-416">It is possible to test for equality by calling the <xref:System.String.Compare%2A?displayProperty=nameWithType> method and determining whether the return value is zero.</span></span> <span data-ttu-id="5f51e-417">不過，不建議這種做法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-417">However, this practice is not recommended.</span></span> <span data-ttu-id="5f51e-418">若要判斷兩個字串是否相等，您應該呼叫其中一個多載的<xref:System.String.Equals%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-418">To determine whether two strings are equal, you should call one of the overloads of the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5f51e-419">慣用的多載來呼叫是任一個執行個體<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>方法或靜態<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，因為這兩種方法包含<xref:System.StringComparison?displayProperty=nameWithType>明確指定的比較類型的參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-419">The preferred overload to call is either the instance <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method or the static <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, because both methods include a <xref:System.StringComparison?displayProperty=nameWithType> parameter that explicitly specifies the type of comparison.</span></span>  
  
 <span data-ttu-id="5f51e-420">下列範例會說明執行區分文化特性的比較相等時應改為使用其中一種為序數的危險。</span><span class="sxs-lookup"><span data-stu-id="5f51e-420">The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead.</span></span> <span data-ttu-id="5f51e-421">在此情況下，程式碼的意圖是要禁止檔案系統存取所執行的 URL 與字串"FILE:// 開頭的不區分大小寫的比較，以"FILE:// 或"file:// 開頭的 Url。</span><span class="sxs-lookup"><span data-stu-id="5f51e-421">In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://".</span></span> <span data-ttu-id="5f51e-422">不過，如果以"file:// 開頭的 URL 上使用土耳其文 （土耳其） 文化特性執行區分文化特性的比較時，相等的比較會失敗，因為土耳其文的大寫對應項的小寫字母"i"是"İ"而不是"I"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-422">However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "İ" instead of "I".</span></span> <span data-ttu-id="5f51e-423">如此一來，不小心允許檔案系統存取權。</span><span class="sxs-lookup"><span data-stu-id="5f51e-423">As a result, file system access is inadvertently permitted.</span></span> <span data-ttu-id="5f51e-424">相反地，如果執行序數比較，則成功的相等比較，並會拒絕檔案系統存取。</span><span class="sxs-lookup"><span data-stu-id="5f51e-424">On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.</span></span>  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a><span data-ttu-id="5f51e-425">正規化</span><span class="sxs-lookup"><span data-stu-id="5f51e-425">Normalization</span></span>  
 <span data-ttu-id="5f51e-426">某些 Unicode 字元有多個表示方式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-426">Some Unicode characters have multiple representations.</span></span> <span data-ttu-id="5f51e-427">例如，下列字碼指標的任何可代表字母"ắ":</span><span class="sxs-lookup"><span data-stu-id="5f51e-427">For example, any of the following code points can represent the letter "ắ":</span></span>  
  
-   <span data-ttu-id="5f51e-428">U + 1EAF</span><span class="sxs-lookup"><span data-stu-id="5f51e-428">U+1EAF</span></span>  
  
-   <span data-ttu-id="5f51e-429">U+0103 U+0301</span><span class="sxs-lookup"><span data-stu-id="5f51e-429">U+0103 U+0301</span></span>  
  
-   <span data-ttu-id="5f51e-430">U+0061 U+0306 U+0301</span><span class="sxs-lookup"><span data-stu-id="5f51e-430">U+0061 U+0306 U+0301</span></span>  
  
 <span data-ttu-id="5f51e-431">搜尋、 排序、 比對，及其他字串作業，讓更加複雜的單一字元的多種表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-431">Multiple representations for a single character complicate searching, sorting, matching, and other string operations.</span></span>  
  
 <span data-ttu-id="5f51e-432">Unicode 標準會定義稱為會傳回一個為其相等的二進位表示法的任何 Unicode 字元的二進位表示法的正規化的程序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-432">The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations.</span></span> <span data-ttu-id="5f51e-433">正規化可以使用數種演算法，稱為正規化表單，可遵循的規則不同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-433">Normalization can use several algorithms, called normalization forms, that follow different rules.</span></span> <span data-ttu-id="5f51e-434">.NET Framework 支援的 Unicode 正規化表單 C、 D、 KC 和 KD。</span><span class="sxs-lookup"><span data-stu-id="5f51e-434">The .NET Framework supports Unicode normalization forms C, D, KC, and KD.</span></span> <span data-ttu-id="5f51e-435">當字串已經正規化成相同的正規化格式時，它們可以使用序數比較來比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-435">When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="5f51e-436">序數比較是 Unicode 的對應純量值的二進位比較<xref:System.Char>每個字串中的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-436">An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <xref:System.Char> objects in each string.</span></span> <span data-ttu-id="5f51e-437"><xref:System.String>類別包含數個方法可以執行序數比較，包括下列：</span><span class="sxs-lookup"><span data-stu-id="5f51e-437">The <xref:System.String> class includes a number of methods that can perform an ordinal comparison, including the following:</span></span>  
  
-   <span data-ttu-id="5f51e-438">任何多載<xref:System.String.Compare%2A>， <xref:System.String.Equals%2A>， <xref:System.String.StartsWith%2A>， <xref:System.String.EndsWith%2A>， <xref:System.String.IndexOf%2A>，和<xref:System.String.LastIndexOf%2A>方法包含<xref:System.StringComparison>參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-438">Any overload of the <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>,  <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, and <xref:System.String.LastIndexOf%2A> methods that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="5f51e-439">如果您提供的值，這個方法會執行序數比較<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase>這個參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-439">The method performs an ordinal comparison if you supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase> for this parameter.</span></span>  
  
-   <span data-ttu-id="5f51e-440">多載<xref:System.String.CompareOrdinal%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-440">The overloads of the <xref:System.String.CompareOrdinal%2A> method.</span></span>  
  
-   <span data-ttu-id="5f51e-441">根據預設，使用序數比較，例如方法<xref:System.String.Contains%2A>， <xref:System.String.Replace%2A>，和<xref:System.String.Split%2A>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-441">Methods that use ordinal comparison by default, such as <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, and <xref:System.String.Split%2A>.</span></span>  
  
-   <span data-ttu-id="5f51e-442">方法會搜尋<xref:System.Char>值或中的項目<xref:System.Char>陣列的字串執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-442">Methods that search for a <xref:System.Char> value or for the elements in a <xref:System.Char> array in a string instance.</span></span> <span data-ttu-id="5f51e-443">這類方法包括<xref:System.String.IndexOf%28System.Char%29>和<xref:System.String.Split%28System.Char%5B%5D%29>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-443">Such methods include <xref:System.String.IndexOf%28System.Char%29> and <xref:System.String.Split%28System.Char%5B%5D%29>.</span></span>  
  
 <span data-ttu-id="5f51e-444">您可以判斷字串是否會正規化為正規化格式 C 藉由呼叫<xref:System.String.IsNormalized?displayProperty=nameWithType>方法，或者您可以呼叫<xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType>方法，以判斷字串是否會正規化為指定的正規化格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-444">You can determine whether a string is normalized to normalization form C by calling the <xref:System.String.IsNormalized?displayProperty=nameWithType> method, or you can call the <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to determine whether a string is normalized to a specified normalization form.</span></span> <span data-ttu-id="5f51e-445">您也可以呼叫<xref:System.String.Normalize?displayProperty=nameWithType>方法，以將字串轉換為正規化格式 C，或您可以呼叫<xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType>方法，將字串轉換為指定的正規化格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-445">You can also call the <xref:System.String.Normalize?displayProperty=nameWithType> method to convert a string to normalization form C, or you can call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to convert a string to a specified normalization form.</span></span> <span data-ttu-id="5f51e-446">逐步解說正規化和比較字串的詳細資訊，請參閱<xref:System.String.Normalize>和<xref:System.String.Normalize%28System.Text.NormalizationForm%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-446">For step-by-step information about normalizing and comparing strings, see the <xref:System.String.Normalize> and <xref:System.String.Normalize%28System.Text.NormalizationForm%29> methods.</span></span>  
  
 <span data-ttu-id="5f51e-447">下列簡易範例說明字串正規化。</span><span class="sxs-lookup"><span data-stu-id="5f51e-447">The following simple example illustrates string normalization.</span></span> <span data-ttu-id="5f51e-448">它以三個不同的方式在三個不同的字串，定義的字母"ố 」，並使用以判斷每個字串，不同於其他兩個字串的序數比較相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-448">It defines the letter "ố" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings.</span></span> <span data-ttu-id="5f51e-449">它然後將每個字串轉換成支援的正規化格式，並再次執行序數比較每個字串中指定的正規化格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-449">It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form.</span></span> <span data-ttu-id="5f51e-450">在每個案例中，第二個等號比較測試會顯示字串相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-450">In each case, the second test for equality shows that the strings are equal.</span></span>  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 <span data-ttu-id="5f51e-451">多個正規化和正規化表單的詳細資訊，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>，以及[Unicode 標準附錄 #15: Unicode 正規化表單](https://unicode.org/reports/tr15/)和[正規化常見問題集](https://www.unicode.org/faq/normalization.html)上unicode.org 網站。</span><span class="sxs-lookup"><span data-stu-id="5f51e-451">For more information about normalization and normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, as well as [Unicode Standard Annex #15: Unicode Normalization Forms](https://unicode.org/reports/tr15/) and the [Normalization FAQ](https://www.unicode.org/faq/normalization.html) on the unicode.org website.</span></span>  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a><span data-ttu-id="5f51e-452">依類別目錄的字串作業</span><span class="sxs-lookup"><span data-stu-id="5f51e-452">String operations by category</span></span>  
 <span data-ttu-id="5f51e-453"><xref:System.String>類別會提供比較字串、 測試字串是否相等、 尋找字元的成員，或在字串中，修改字串，擷取組合字串，格式化值、 複製字串，及正規化字串的字串中的子字串的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-453">The <xref:System.String> class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.</span></span>  
  
### <a name="comparing-strings"></a><span data-ttu-id="5f51e-454">比較字串</span><span class="sxs-lookup"><span data-stu-id="5f51e-454">Comparing strings</span></span>  
 <span data-ttu-id="5f51e-455">您可以比較字串，以判斷兩者在排序次序的相對位置，使用下列<xref:System.String>方法：</span><span class="sxs-lookup"><span data-stu-id="5f51e-455">You can compare strings to determine their relative position in the sort order by using the following <xref:System.String> methods:</span></span>  
  
-   <span data-ttu-id="5f51e-456"><xref:System.String.Compare%2A> 傳回一個整數，表示一個字串在排序次序為第二個字串的關聯性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-456"><xref:System.String.Compare%2A> returns an integer that indicates the relationship of one string to a second string in the sort order.</span></span>  
  
-   <span data-ttu-id="5f51e-457"><xref:System.String.CompareOrdinal%2A> 傳回一個整數，指出要根據其字碼指標比較的第二個字串的一個字串的關聯性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-457"><xref:System.String.CompareOrdinal%2A> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.</span></span>  
  
-   <span data-ttu-id="5f51e-458"><xref:System.String.CompareTo%2A> 傳回一個整數，指出目前的字串執行個體在排序次序為第二個字串的關聯性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-458"><xref:System.String.CompareTo%2A> returns an integer that indicates the relationship of the current string instance to a second string in the sort order.</span></span> <span data-ttu-id="5f51e-459"><xref:System.String.CompareTo%28System.String%29>方法提供<xref:System.IComparable>和<xref:System.IComparable%601>實作<xref:System.String>類別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-459">The <xref:System.String.CompareTo%28System.String%29> method provides the <xref:System.IComparable> and <xref:System.IComparable%601> implementations for the <xref:System.String> class.</span></span>  
  
### <a name="testing-strings-for-equality"></a><span data-ttu-id="5f51e-460">測試字串相等</span><span class="sxs-lookup"><span data-stu-id="5f51e-460">Testing strings for equality</span></span>  
 <span data-ttu-id="5f51e-461">您呼叫<xref:System.String.Equals%2A>方法，以判斷兩個字串是否相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-461">You call the <xref:System.String.Equals%2A> method to determine whether two strings are equal.</span></span> <span data-ttu-id="5f51e-462">執行個體<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>和靜態<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>多載可讓您指定比較是否區分文化特性或序數，以及是否會被視為或是忽略大小寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-462">The instance <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> and the static <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored.</span></span> <span data-ttu-id="5f51e-463">大部分測試相等為序數，且應一律序數決定可以存取系統資源 （例如檔案系統物件） 的比較相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-463">Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.</span></span>  
  
### <a name="finding-characters-in-a-string"></a><span data-ttu-id="5f51e-464">尋找字串中的字元</span><span class="sxs-lookup"><span data-stu-id="5f51e-464">Finding characters in a string</span></span>  
 <span data-ttu-id="5f51e-465"><xref:System.String>類別包含兩種搜尋方法：</span><span class="sxs-lookup"><span data-stu-id="5f51e-465">The <xref:System.String> class includes two kinds of search methods:</span></span>  
  
-   <span data-ttu-id="5f51e-466">方法會傳回<xref:System.Boolean>可指出特定的子字串是否出現在字串執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-466">Methods that return a <xref:System.Boolean> value to indicate whether a particular substring is present in a string instance.</span></span> <span data-ttu-id="5f51e-467">這些包括<xref:System.String.Contains%2A>， <xref:System.String.EndsWith%2A>，和<xref:System.String.StartsWith%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-467">These include the <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, and <xref:System.String.StartsWith%2A> methods.</span></span>  
  
-   <span data-ttu-id="5f51e-468">表示子字串的字串執行個體的開始位置的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-468">Methods that indicate the starting position of a substring in a string instance.</span></span> <span data-ttu-id="5f51e-469">這些包括<xref:System.String.IndexOf%2A>， <xref:System.String.IndexOfAny%2A>， <xref:System.String.LastIndexOf%2A>，和<xref:System.String.LastIndexOfAny%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-469">These include the <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, and <xref:System.String.LastIndexOfAny%2A> methods.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="5f51e-470">如果您想要搜尋特定的模式，而不是特定的子字串的字串，您應該使用規則運算式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-470">If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions.</span></span> <span data-ttu-id="5f51e-471">如需詳細資訊，請參閱 [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-471">For more information, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>  
  
### <a name="modifying-a-string"></a><span data-ttu-id="5f51e-472">修改的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-472">Modifying a string</span></span>  
 <span data-ttu-id="5f51e-473"><xref:System.String>類別包含下列方法會將修改字串的值：</span><span class="sxs-lookup"><span data-stu-id="5f51e-473">The <xref:System.String> class includes the following methods that appear to modify the value of a string:</span></span>  
  
-   <span data-ttu-id="5f51e-474"><xref:System.String.Insert%2A> 將字串插入至目前<xref:System.String>執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-474"><xref:System.String.Insert%2A> inserts a string into the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="5f51e-475"><xref:System.String.PadLeft%2A> 將指定之字元的一個或多個插入字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-475"><xref:System.String.PadLeft%2A> inserts one or more occurrences of a specified character at the beginning of a string.</span></span>  
  
-   <span data-ttu-id="5f51e-476"><xref:System.String.PadRight%2A> 將指定之字元的一個或多個插入字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-476"><xref:System.String.PadRight%2A> inserts one or more occurrences of a specified character at the end of a string.</span></span>  
  
-   <span data-ttu-id="5f51e-477"><xref:System.String.Remove%2A> 刪除從目前的子字串<xref:System.String>執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-477"><xref:System.String.Remove%2A> deletes a substring from the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="5f51e-478"><xref:System.String.Replace%2A> 在目前的另一個子字串，取代子字串<xref:System.String>執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-478"><xref:System.String.Replace%2A> replaces a substring with another substring in the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="5f51e-479"><xref:System.String.ToLower%2A> 和<xref:System.String.ToLowerInvariant%2A>字串中的所有字元都轉換成小寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-479"><xref:System.String.ToLower%2A> and <xref:System.String.ToLowerInvariant%2A> convert all the characters in a string to lowercase.</span></span>  
  
-   <span data-ttu-id="5f51e-480"><xref:System.String.ToUpper%2A> 和<xref:System.String.ToUpperInvariant%2A>字串中的所有字元都轉換成大寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-480"><xref:System.String.ToUpper%2A> and <xref:System.String.ToUpperInvariant%2A> convert all the characters in a string to uppercase.</span></span>  
  
-   <span data-ttu-id="5f51e-481"><xref:System.String.Trim%2A> 移除開頭和結尾字串的所有出現的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-481"><xref:System.String.Trim%2A> removes all occurrences of a character from the beginning and end of a string.</span></span>  
  
-   <span data-ttu-id="5f51e-482"><xref:System.String.TrimEnd%2A> 從字串的結尾移除所有出現的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-482"><xref:System.String.TrimEnd%2A> removes all occurrences of a character from the end of a string.</span></span>  
  
-   <span data-ttu-id="5f51e-483"><xref:System.String.TrimStart%2A> 從字串開頭中移除所有出現的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-483"><xref:System.String.TrimStart%2A> removes all occurrences of a character from the beginning of a string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5f51e-484">所有字串修改方法都會都傳回新<xref:System.String>物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-484">All string modification methods return a new <xref:System.String> object.</span></span> <span data-ttu-id="5f51e-485">它們就不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-485">They don't modify the value of the current instance.</span></span>  
  
### <a name="extracting-substrings-from-a-string"></a><span data-ttu-id="5f51e-486">從字串擷取子字串</span><span class="sxs-lookup"><span data-stu-id="5f51e-486">Extracting substrings from a string</span></span>  
 <span data-ttu-id="5f51e-487"><xref:System.String.Split%2A?displayProperty=nameWithType>方法會將單一字串分隔成多個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-487">The <xref:System.String.Split%2A?displayProperty=nameWithType> method separates a single string into multiple strings.</span></span> <span data-ttu-id="5f51e-488">方法的多載可讓您指定多個分隔符號，來判斷最大數目的子字串，它會擷取方法，並判斷是否包含在所傳回的字串之間空字串 （分隔符號相鄰時，會發生問題）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-488">Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.</span></span>  
  
### <a name="combining-strings"></a><span data-ttu-id="5f51e-489">結合字串</span><span class="sxs-lookup"><span data-stu-id="5f51e-489">Combining strings</span></span>  
 <span data-ttu-id="5f51e-490">下列<xref:System.String>方法可用於字串串連：</span><span class="sxs-lookup"><span data-stu-id="5f51e-490">The following <xref:System.String> methods can be used for string concatenation:</span></span>  
  
-   <span data-ttu-id="5f51e-491"><xref:System.String.Concat%2A> 結合成單一字串的一個或多個子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-491"><xref:System.String.Concat%2A> combines one or more substrings into a single string.</span></span>  
  
-   <span data-ttu-id="5f51e-492"><xref:System.String.Join%2A> 串連一或多個成單一元素的子字串，並將每一個子字串之間的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-492"><xref:System.String.Join%2A> concatenates one or more substrings into a single element and adds a separator between each substring.</span></span>  
  
### <a name="formatting-values"></a><span data-ttu-id="5f51e-493">格式化值</span><span class="sxs-lookup"><span data-stu-id="5f51e-493">Formatting values</span></span>  
 <span data-ttu-id="5f51e-494"><xref:System.String.Format%2A?displayProperty=nameWithType>方法使用複合格式功能的某些物件或值的字串表示法取代字串中的一個或多個預留位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-494">The <xref:System.String.Format%2A?displayProperty=nameWithType> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value.</span></span> <span data-ttu-id="5f51e-495"><xref:System.String.Format%2A>方法通常用來執行下列動作：</span><span class="sxs-lookup"><span data-stu-id="5f51e-495">The <xref:System.String.Format%2A> method is often used to do the following:</span></span>  
  
-   <span data-ttu-id="5f51e-496">若要在字串中內嵌之數值的字串表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-496">To embed the string representation of a numeric value in a string.</span></span>  
  
-   <span data-ttu-id="5f51e-497">若要將日期和時間值的字串表示嵌入字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-497">To embed the string representation of a date and time value in a string.</span></span>  
  
-   <span data-ttu-id="5f51e-498">若要在字串中嵌入的列舉值的字串表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-498">To embed the string representation of an enumeration value in a string.</span></span>  
  
-   <span data-ttu-id="5f51e-499">若要內嵌支援某些物件的字串表示<xref:System.IFormattable>字串中的介面。</span><span class="sxs-lookup"><span data-stu-id="5f51e-499">To embed the string representation of some object that supports the <xref:System.IFormattable> interface in a string.</span></span>  
  
-   <span data-ttu-id="5f51e-500">若要靠右對齊或靠左對齊的較大的字串內的欄位中的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-500">To right-justify or left-justify a substring in a field within a larger string.</span></span>  
  
 <span data-ttu-id="5f51e-501">如需格式化作業和範例的詳細資訊，請參閱<xref:System.String.Format%2A>多載摘要。</span><span class="sxs-lookup"><span data-stu-id="5f51e-501">For detailed information about formatting operations and examples, see the <xref:System.String.Format%2A> overload summary.</span></span>  
  
### <a name="copying-a-string"></a><span data-ttu-id="5f51e-502">複製字串</span><span class="sxs-lookup"><span data-stu-id="5f51e-502">Copying a string</span></span>  
 <span data-ttu-id="5f51e-503">您可以呼叫下列<xref:System.String>方法來進行字串的複本：</span><span class="sxs-lookup"><span data-stu-id="5f51e-503">You can call the following <xref:System.String> methods to make a copy of a string:</span></span>  
  
-   <span data-ttu-id="5f51e-504"><xref:System.String.Clone%2A> 將參考傳回給現有<xref:System.String>物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-504"><xref:System.String.Clone%2A> returns a reference to an existing <xref:System.String> object.</span></span>  
  
-   <span data-ttu-id="5f51e-505"><xref:System.String.Copy%2A> 建立現有字串的複本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-505"><xref:System.String.Copy%2A> creates a copy of an existing string.</span></span>  
  
-   <span data-ttu-id="5f51e-506"><xref:System.String.CopyTo%2A> 將字串的部分複製到字元陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-506"><xref:System.String.CopyTo%2A> copies a portion of a string to a character array.</span></span>  
  
### <a name="normalizing-a-string"></a><span data-ttu-id="5f51e-507">正規化字串</span><span class="sxs-lookup"><span data-stu-id="5f51e-507">Normalizing a string</span></span>  
 <span data-ttu-id="5f51e-508">在 Unicode 中，單一字元可以有多個字碼指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-508">In Unicode, a single character can have multiple code points.</span></span> <span data-ttu-id="5f51e-509">正規化會將這些對等的字元轉換成相同的二進位表示法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-509">Normalization converts these equivalent characters into the same binary representation.</span></span> <span data-ttu-id="5f51e-510"><xref:System.String.Normalize%2A?displayProperty=nameWithType>方法會執行正規化，而<xref:System.String.IsNormalized%2A?displayProperty=nameWithType>方法會判斷字串是否都正規化。</span><span class="sxs-lookup"><span data-stu-id="5f51e-510">The <xref:System.String.Normalize%2A?displayProperty=nameWithType> method performs the normalization, and the <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> method determines whether a string is normalized.</span></span>  
  
 <span data-ttu-id="5f51e-511">如需詳細資訊和範例，請參閱[正規化](#Normalization)稍早在本主題中的區段。</span><span class="sxs-lookup"><span data-stu-id="5f51e-511">For more information and an example, see the [Normalization](#Normalization) section earlier in this topic.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="5f51e-512">此型別具備執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="5f51e-512">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-513">初始化 <see cref="T:System.String" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-513">Initializes a new instance of the <see cref="T:System.String" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-514">本節內容：</span><span class="sxs-lookup"><span data-stu-id="5f51e-514">In this section:</span></span>  
  
 <span data-ttu-id="5f51e-515">[多載建構函式語法](#Syntax) </span><span class="sxs-lookup"><span data-stu-id="5f51e-515">[Overloaded constructor syntax](#Syntax) </span></span>  
 <span data-ttu-id="5f51e-516">[參數](#Params) </span><span class="sxs-lookup"><span data-stu-id="5f51e-516">[Parameters](#Params) </span></span>  
 <span data-ttu-id="5f51e-517">[例外狀況](#Exceptions) </span><span class="sxs-lookup"><span data-stu-id="5f51e-517">[Exceptions](#Exceptions) </span></span>  
 <span data-ttu-id="5f51e-518">[沒有呼叫的方法？](#Tasks) </span><span class="sxs-lookup"><span data-stu-id="5f51e-518">[Which method do I call?](#Tasks) </span></span>  
 <span data-ttu-id="5f51e-519">[建立字串](#Creating_Strings) </span><span class="sxs-lookup"><span data-stu-id="5f51e-519">[Creating strings](#Creating_Strings) </span></span>  
 <span data-ttu-id="5f51e-520">[處理重複字串](#Repetitive) </span><span class="sxs-lookup"><span data-stu-id="5f51e-520">[Handling repetitive strings](#Repetitive) </span></span>  
 <span data-ttu-id="5f51e-521">具現化字串的範例：</span><span class="sxs-lookup"><span data-stu-id="5f51e-521">Examples of instantiating strings:</span></span>   
 [<span data-ttu-id="5f51e-522">使用字串指派</span><span class="sxs-lookup"><span data-stu-id="5f51e-522">Using string assignment</span></span>](#Ctor1_Example)  
 [<span data-ttu-id="5f51e-523">使用的字元陣列</span><span class="sxs-lookup"><span data-stu-id="5f51e-523">Using a character array</span></span>](#Ctor2_Example)  
 [<span data-ttu-id="5f51e-524">使用字元陣列的一部分，並重複單一字元</span><span class="sxs-lookup"><span data-stu-id="5f51e-524">Using a portion of a character array and repeating a single character</span></span>](#Ctor3_Example)  
 [<span data-ttu-id="5f51e-525">使用的字元陣列的指標</span><span class="sxs-lookup"><span data-stu-id="5f51e-525">Using a pointer to a character array</span></span>](#Ctor4_Example)  
 [<span data-ttu-id="5f51e-526">使用指標以及陣列的範圍</span><span class="sxs-lookup"><span data-stu-id="5f51e-526">Using  a pointer and a range of an array</span></span>](#Ctor5_Example)  
 [<span data-ttu-id="5f51e-527">使用帶正負號的位元組陣列的指標</span><span class="sxs-lookup"><span data-stu-id="5f51e-527">Using a pointer to a signed byte array</span></span>](#Ctor6_Example)  
[<span data-ttu-id="5f51e-528">版本資訊</span><span class="sxs-lookup"><span data-stu-id="5f51e-528">Version information</span></span>](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a><span data-ttu-id="5f51e-529">多載建構函式語法</span><span class="sxs-lookup"><span data-stu-id="5f51e-529">Overloaded constructor syntax</span></span>  
 <span data-ttu-id="5f51e-530">字串建構函式分為兩類： 不使用指標參數，以及使用指標的參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-530">String constructors fall into two categories: those without pointer parameters, and those with pointer parameters.</span></span> <span data-ttu-id="5f51e-531">使用指標的建構函式不符合 CLS 標準。</span><span class="sxs-lookup"><span data-stu-id="5f51e-531">The constructors that use pointers are not CLS-compliant.</span></span> <span data-ttu-id="5f51e-532">此外，Visual Basic 不支援使用指標，以及 C# 需要使用指標 unsafe 內容中執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-532">In addition, Visual Basic does not support the use of pointers, and C# requires code that uses pointers to run in an unsafe context.</span></span> <span data-ttu-id="5f51e-533">如需詳細資訊，請參閱 [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-533">For more information, see [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).</span></span>  
  
 <span data-ttu-id="5f51e-534">如需有關選擇最多載的其他指引，請參閱[沒有呼叫的方法？](#Tasks)</span><span class="sxs-lookup"><span data-stu-id="5f51e-534">For additional guidance on choosing an overload, see [Which method do I call?](#Tasks)</span></span>  
  
 `String(Char[] value)`  
 <span data-ttu-id="5f51e-535">初始化新的執行個體的 Unicode 字元陣列所指示的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-535">Initializes the new instance to the value indicated by an array of Unicode characters.</span></span> <span data-ttu-id="5f51e-536">這個建構函式會將 Unicode 字元的複製 ([範例](#Ctor2_Example))。</span><span class="sxs-lookup"><span data-stu-id="5f51e-536">This constructor copies Unicode characters([example](#Ctor2_Example)).</span></span>  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="5f51e-537">初始化新的執行個體的 Unicode 字元，該陣列，且長度內起始字元位置陣列所指示的值 ([範例](#Ctor3_Example))。</span><span class="sxs-lookup"><span data-stu-id="5f51e-537">Initializes the new instance to the value indicated by an array of Unicode characters, a starting character position within that array, and a length ([example](#Ctor3_Example)).</span></span>  
  
 `String(Char c, Int32 count)`  
 <span data-ttu-id="5f51e-538">初始化指定的 Unicode 字元所指示的新執行個體的值重複指定的次數 ([範例](#Ctor3_Example))。</span><span class="sxs-lookup"><span data-stu-id="5f51e-538">Initializes the new instance to the value indicated by a specified Unicode character repeated a specified number of times ([example](#Ctor3_Example)).</span></span>  
  
 `String(char* value)`  
 <span data-ttu-id="5f51e-539">**（不符合 CLS 標準）** 初始化新的執行個體終止的 null 字元的 Unicode 字元陣列的指標所指示的值 (U + 0000 或 '\0')。</span><span class="sxs-lookup"><span data-stu-id="5f51e-539">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters that is terminated by a null character (U+0000 or '\0').</span></span> <span data-ttu-id="5f51e-540">([範例](#Ctor4_Example))。</span><span class="sxs-lookup"><span data-stu-id="5f51e-540">([example](#Ctor4_Example)).</span></span>  
  
 <span data-ttu-id="5f51e-541">權限： <xref:System.Security.SecurityCriticalAttribute>，需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-541">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="5f51e-542">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-542">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="5f51e-543">**（不符合 CLS 標準）** 初始化新的執行個體的 Unicode 字元，該陣列，且長度內起始字元位置陣列的指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-543">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters, a starting character position within that array, and a length.</span></span> <span data-ttu-id="5f51e-544">建構函式的字元複製到 Unicode 從`value`索引處開始`startIndex`和結束索引`startIndex`  +  `length` – 1 ([範例](#Ctor5_Example))。</span><span class="sxs-lookup"><span data-stu-id="5f51e-544">The constructor copies the Unicode characters from `value` starting at index `startIndex` and ending at index `startIndex` + `length` – 1 ([example](#Ctor5_Example)).</span></span>  
  
 <span data-ttu-id="5f51e-545">權限： <xref:System.Security.SecurityCriticalAttribute>，需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-545">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="5f51e-546">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-546">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value)`  
 <span data-ttu-id="5f51e-547">**（不符合 CLS 標準）** 初始化新的執行個體的 8 位元帶正負號的整數陣列的指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-547">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers.</span></span> <span data-ttu-id="5f51e-548">陣列會假設為表示使用目前的系統字碼頁編碼的字串 (也就指定的編碼方式<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-548">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="5f51e-549">建構函式會處理從字元`value`從 null 字元 (0x00) 為止，指標所指定的位置開始 ([範例](#Ctor6_Example))。</span><span class="sxs-lookup"><span data-stu-id="5f51e-549">The constructor processes characters from `value` starting from the location specified by the pointer until a null character (0x00) is reached ([example](#Ctor6_Example)).</span></span>  
  
 <span data-ttu-id="5f51e-550">權限： <xref:System.Security.SecurityCriticalAttribute>，需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-550">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="5f51e-551">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-551">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="5f51e-552">**（不符合 CLS 標準）** 初始化新的執行個體的 8 位元帶正負號的整數，該陣列，且長度內開始位置陣列的指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-552">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span></span>  <span data-ttu-id="5f51e-553">陣列會假設為表示使用目前的系統字碼頁編碼的字串 (也就指定的編碼方式<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-553">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="5f51e-554">建構函式會處理從開始值的字元`startIndex`結束為`startIndex`  +  `length` – 1 ([範例](#Ctor6_Example))。</span><span class="sxs-lookup"><span data-stu-id="5f51e-554">The constructor processes characters from value starting at `startIndex` and ending at `startIndex` + `length` – 1 ([example](#Ctor6_Example)).</span></span>  
  
 <span data-ttu-id="5f51e-555">權限： <xref:System.Security.SecurityCriticalAttribute>，需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-555">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="5f51e-556">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-556">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 <span data-ttu-id="5f51e-557">**（不符合 CLS 標準）** 初始化新的執行個體的 8 位元帶正負號的整數，長度，該陣列內開始位置陣列的指標所指示的值和<xref:System.Text.Encoding>物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-557">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <xref:System.Text.Encoding> object.</span></span>  
  
 <span data-ttu-id="5f51e-558">權限： <xref:System.Security.SecurityCriticalAttribute>，需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-558">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="5f51e-559">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-559">This member cannot be used by partially trusted or transparent code.</span></span>  
  
<a name="Params"></a>   
## <a name="parameters"></a><span data-ttu-id="5f51e-560">參數</span><span class="sxs-lookup"><span data-stu-id="5f51e-560">Parameters</span></span>  
 <span data-ttu-id="5f51e-561">以下是完整的清單所使用的參數<xref:System.String>不包括指標參數的建構函式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-561">Here is a complete list of parameters used by <xref:System.String> constructors that don't include a pointer parameter.</span></span> <span data-ttu-id="5f51e-562">每個多載所使用的參數，請參閱上述的多載語法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-562">For the parameters used by each overload, see the overload syntax above.</span></span>  
  
|<span data-ttu-id="5f51e-563">參數</span><span class="sxs-lookup"><span data-stu-id="5f51e-563">Parameter</span></span>|<span data-ttu-id="5f51e-564">類型</span><span class="sxs-lookup"><span data-stu-id="5f51e-564">Type</span></span>|<span data-ttu-id="5f51e-565">描述</span><span class="sxs-lookup"><span data-stu-id="5f51e-565">Description</span></span>|  
|---------------|----------|-----------------|  
|`value`|<span data-ttu-id="5f51e-566"><xref:System.Char>[]</span><span class="sxs-lookup"><span data-stu-id="5f51e-566"><xref:System.Char>[]</span></span>|<span data-ttu-id="5f51e-567">Unicode 字元陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-567">An array of Unicode characters.</span></span>|  
|`c`|<xref:System.Char>|<span data-ttu-id="5f51e-568">Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-568">A Unicode character.</span></span>|  
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="5f51e-569">中的開始位置`value`新的字串中的第一個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-569">The starting position in `value` of the first character in the new string.</span></span><br /><br /> <span data-ttu-id="5f51e-570">預設值： 0</span><span class="sxs-lookup"><span data-stu-id="5f51e-570">Default value: 0</span></span>|  
|`length`|<xref:System.Int32>|<span data-ttu-id="5f51e-571">中的字元數`value`包含在新的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-571">The number of characters in `value` to include in the new string.</span></span><br /><br /> <span data-ttu-id="5f51e-572">預設值： <xref:System.Array.Length%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="5f51e-572">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|  
|`count`|<xref:System.Int32>|<span data-ttu-id="5f51e-573">次數字元`c`會在新的字串中重複。</span><span class="sxs-lookup"><span data-stu-id="5f51e-573">The number of times the character `c` is repeated in the new string.</span></span> <span data-ttu-id="5f51e-574">如果`count`為零，新物件的值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-574">If `count` is zero, the value of the new object is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="5f51e-575">以下是完整的清單所使用的參數<xref:System.String>包含指標參數的建構函式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-575">Here is a complete list of parameters used by <xref:System.String> constructors that include a pointer parameter.</span></span> <span data-ttu-id="5f51e-576">每個多載所使用的參數，請參閱上述的多載語法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-576">For the parameters used by each overload, see the overload syntax above.</span></span>  
  
|<span data-ttu-id="5f51e-577">參數</span><span class="sxs-lookup"><span data-stu-id="5f51e-577">Parameter</span></span>|<span data-ttu-id="5f51e-578">類型</span><span class="sxs-lookup"><span data-stu-id="5f51e-578">Type</span></span>|<span data-ttu-id="5f51e-579">描述</span><span class="sxs-lookup"><span data-stu-id="5f51e-579">Description</span></span>|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> <span data-ttu-id="5f51e-580">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-580">-or-</span></span><br /><br /> <xref:System.SByte>\*|<span data-ttu-id="5f51e-581">以 null 結束的 Unicode 字元陣列或 8 位元帶正負號的整數陣列的指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-581">A pointer to a null-terminated array of Unicode characters or an array of 8-bit signed integers.</span></span> <span data-ttu-id="5f51e-582">如果`value`是`null`或空陣列，而新字串的值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-582">If `value` is `null` or an empty array, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="5f51e-583">定義新的字串中的第一個字元之陣列項目的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-583">The index of the array element that defines the first character in the new string.</span></span><br /><br /> <span data-ttu-id="5f51e-584">預設值： 0</span><span class="sxs-lookup"><span data-stu-id="5f51e-584">Default value: 0</span></span>|  
|`length`|<xref:System.Int32>|<span data-ttu-id="5f51e-585">要用來建立新的字串陣列元素數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-585">The number of array elements to use to create the new string.</span></span> <span data-ttu-id="5f51e-586">如果長度為零，建構函式會建立的字串，其值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-586">If length is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span><br /><br /> <span data-ttu-id="5f51e-587">預設值： <xref:System.Array.Length%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="5f51e-587">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|  
|`enc`|<xref:System.Text.Encoding>|<span data-ttu-id="5f51e-588">物件，指定如何`value`編碼陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-588">An object that specifies how the `value` array is encoded.</span></span><br /><br /> <span data-ttu-id="5f51e-589">預設值： <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>，或系統的目前 ANSI 字碼頁</span><span class="sxs-lookup"><span data-stu-id="5f51e-589">Default value: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, or the system's current ANSI code page</span></span>|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a><span data-ttu-id="5f51e-590">例外狀況</span><span class="sxs-lookup"><span data-stu-id="5f51e-590">Exceptions</span></span>  
 <span data-ttu-id="5f51e-591">以下是不包含指標參數的建構函式所擲回的例外狀況的清單。</span><span class="sxs-lookup"><span data-stu-id="5f51e-591">Here's a list of exceptions thrown by constructors that don't include pointer parameters.</span></span>  
  
|<span data-ttu-id="5f51e-592">例外</span><span class="sxs-lookup"><span data-stu-id="5f51e-592">Exception</span></span>|<span data-ttu-id="5f51e-593">條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-593">Condition</span></span>|<span data-ttu-id="5f51e-594">所擲回</span><span class="sxs-lookup"><span data-stu-id="5f51e-594">Thrown by</span></span>|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|<span data-ttu-id="5f51e-595">`value` 為 `null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-595">`value` is `null`.</span></span>|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="5f51e-596">`startIndex``length`，或`count`小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-596">`startIndex`,`length`, or `count` is less than zero.</span></span><br /><br /> <span data-ttu-id="5f51e-597">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-597">-or-</span></span><br /><br /> <span data-ttu-id="5f51e-598">`startIndex` 和 `length` 的總和大於 `value` 中的元素數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-598">The sum of `startIndex` and `length` is greater than the number of elements in `value`.</span></span><br /><br /> <span data-ttu-id="5f51e-599">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-599">-or-</span></span><br /><br /> <span data-ttu-id="5f51e-600">`count` 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-600">`count` is less than zero.</span></span>|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 <span data-ttu-id="5f51e-601">以下是包含指標參數的建構函式所擲回的例外狀況的清單。</span><span class="sxs-lookup"><span data-stu-id="5f51e-601">Here's a list of exceptions thrown by constructors that include pointer parameters.</span></span>  
  
|<span data-ttu-id="5f51e-602">例外</span><span class="sxs-lookup"><span data-stu-id="5f51e-602">Exception</span></span>|<span data-ttu-id="5f51e-603">條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-603">Condition</span></span>|<span data-ttu-id="5f51e-604">所擲回</span><span class="sxs-lookup"><span data-stu-id="5f51e-604">Thrown by</span></span>|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|<span data-ttu-id="5f51e-605">`value` 指定的陣列，包含無效的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-605">`value` specifies an array that contains an invalid Unicode character.</span></span><br /><br /> <span data-ttu-id="5f51e-606">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-606">-or-</span></span><br /><br /> <span data-ttu-id="5f51e-607">`value` 或`value`  +  `startIndex`指定的位址小於 64k。</span><span class="sxs-lookup"><span data-stu-id="5f51e-607">`value` or `value` + `startIndex` specifies an address that is less than 64K.</span></span><br /><br /> <span data-ttu-id="5f51e-608">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-608">-or-</span></span><br /><br /> <span data-ttu-id="5f51e-609">新<xref:System.String>無法初始化執行個體，從`value`位元組陣列，因為`value`不會使用預設字碼頁編碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-609">A new <xref:System.String> instance could not be initialized from the `value` byte array because `value` does not use the default code page encoding.</span></span>|<span data-ttu-id="5f51e-610">使用指標的所有建構函式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-610">All constructors with pointers.</span></span>|  
|<xref:System.ArgumentNullException>|<span data-ttu-id="5f51e-611">`value` 為 null。</span><span class="sxs-lookup"><span data-stu-id="5f51e-611">`value` is null.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="5f51e-612">目前的處理序沒有讀取所有定址字元的權限。</span><span class="sxs-lookup"><span data-stu-id="5f51e-612">The current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="5f51e-613">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-613">-or-</span></span><br /><br /> <span data-ttu-id="5f51e-614">`startIndex` 或 `length` 小於零、`value` + `startIndex` 導致指標溢位，或目前的處理序沒有所有定址字元的讀取權限。</span><span class="sxs-lookup"><span data-stu-id="5f51e-614">`startIndex` or `length` is less than zero, `value` + `startIndex` cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="5f51e-615">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-615">-or-</span></span><br /><br /> <span data-ttu-id="5f51e-616">新字串長度太大而無法配置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-616">The length of the new string is too large to allocate.</span></span>|<span data-ttu-id="5f51e-617">使用指標的所有建構函式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-617">All constructors with pointers.</span></span>|  
|<xref:System.AccessViolationException>|<span data-ttu-id="5f51e-618">`value`或`value`  +  `startIndex`  +  `length` – 1，指定了無效的位址。</span><span class="sxs-lookup"><span data-stu-id="5f51e-618">`value`, or `value` + `startIndex` + `length` – 1, specifies an invalid address.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a><span data-ttu-id="5f51e-619">沒有呼叫的方法？</span><span class="sxs-lookup"><span data-stu-id="5f51e-619">Which method do I call?</span></span>  
  
|<span data-ttu-id="5f51e-620">以</span><span class="sxs-lookup"><span data-stu-id="5f51e-620">To</span></span>|<span data-ttu-id="5f51e-621">呼叫或使用</span><span class="sxs-lookup"><span data-stu-id="5f51e-621">Call or use</span></span>|  
|--------|-----------------|  
|<span data-ttu-id="5f51e-622">建立字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-622">Create a string.</span></span>|<span data-ttu-id="5f51e-623">從字串常值或現有的字串指派 ([範例](#Ctor1_Example))</span><span class="sxs-lookup"><span data-stu-id="5f51e-623">Assignment from a string literal or an existing string ([example](#Ctor1_Example))</span></span>|  
|<span data-ttu-id="5f51e-624">從整個字元陣列建立字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-624">Create a string from an entire character array.</span></span>|<span data-ttu-id="5f51e-625"><xref:System.String.%23ctor%28System.Char%5B%5D%29> ([範例](#Ctor2_Example))</span><span class="sxs-lookup"><span data-stu-id="5f51e-625"><xref:System.String.%23ctor%28System.Char%5B%5D%29> ([example](#Ctor2_Example))</span></span>|  
|<span data-ttu-id="5f51e-626">建立字串，從字元陣列的一部分。</span><span class="sxs-lookup"><span data-stu-id="5f51e-626">Createa string from a portion of a character array.</span></span>|<span data-ttu-id="5f51e-627"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([範例](#Ctor3_Example))</span><span class="sxs-lookup"><span data-stu-id="5f51e-627"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|  
|<span data-ttu-id="5f51e-628">建立重複多次的相同字元的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-628">Create a string that repeats the same character multiple times.</span></span>|<span data-ttu-id="5f51e-629"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([範例](#Ctor3_Example))</span><span class="sxs-lookup"><span data-stu-id="5f51e-629"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|  
|<span data-ttu-id="5f51e-630">從指標建立字串，以 Unicode 或寬字元陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-630">Create a string from a pointer to a Unicode or wide character array.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|<span data-ttu-id="5f51e-631">使用它的指標，從 Unicode 或寬字元陣列的一部分建立字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-631">Create a string from a portion of a Unicode or wide character array by using its pointer.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|<span data-ttu-id="5f51e-632">從 c + + 建立字串`char`陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-632">Create a string from a C++ `char` array.</span></span>|<span data-ttu-id="5f51e-633"><xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span><span class="sxs-lookup"><span data-stu-id="5f51e-633"><xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span></span><br /><br /> <span data-ttu-id="5f51e-634">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-634">-or-</span></span><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<span data-ttu-id="5f51e-635">建立從 ASCII 字元的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-635">Create a string from ASCII characters.</span></span>|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a><span data-ttu-id="5f51e-636">建立字串</span><span class="sxs-lookup"><span data-stu-id="5f51e-636">Creating strings</span></span>  
 <span data-ttu-id="5f51e-637">最常使用的技術以程式設計方式建立字串是簡單指派，如所示[本例](#Ctor1_Example)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-637">The most commonly used technique for creating strings programmatically is simple assignment, as illustrated in [this example](#Ctor1_Example).</span></span> <span data-ttu-id="5f51e-638"><xref:System.String>類別也包含四種類型的建構函式多載可讓您從下列值建立字串：</span><span class="sxs-lookup"><span data-stu-id="5f51e-638">The <xref:System.String> class also includes four types of constructor overloads that let you create strings from the following values:</span></span>  
  
-   <span data-ttu-id="5f51e-639">從字元陣列 （UTF 16 編碼的字元陣列）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-639">From a character array (an array of UTF-16-encoded characters).</span></span> <span data-ttu-id="5f51e-640">您可以建立新<xref:System.String>整個陣列或其一部分之字元的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-640">You can create a new <xref:System.String> object from the characters in the entire array or a portion of it.</span></span> <span data-ttu-id="5f51e-641"><xref:System.String.%23ctor%28System.Char%5B%5D%29>建構函式所有的字元複製到陣列中的新字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-641">The <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor copies all the characters in the array to the new string.</span></span> <span data-ttu-id="5f51e-642"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>建構函式的字元複製到從索引`startIndex`索引`startIndex`  +  `length` – 1，以新的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-642">The <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor copies the characters from index `startIndex` to index `startIndex` + `length` – 1 to the new string.</span></span> <span data-ttu-id="5f51e-643">如果`length`為零，而新字串的值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-643">If `length` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
     <span data-ttu-id="5f51e-644">如果您的程式碼重複具現化具有相同的值的字串，您可以藉由建立字串的其他方式來改善應用程式的效能。</span><span class="sxs-lookup"><span data-stu-id="5f51e-644">If your code repeatedly instantiates strings that have the same value, you can improve application performance by using an alternate means of creating strings.</span></span> <span data-ttu-id="5f51e-645">如需詳細資訊，請參閱[處理重複字串](#Repetitive)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-645">For more information, see [Handling repetitive strings](#Repetitive).</span></span>  
  
-   <span data-ttu-id="5f51e-646">從單一字元也就是重複的零，一次或多次使用<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-646">From a single character that is duplicated zero, one, or more times, by using the <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="5f51e-647">如果`count`為零，而新字串的值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-647">If `count` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="5f51e-648">以 null 結束的字元陣列的指標，從使用<xref:System.String.%23ctor%28System.Char%2A%29>或<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-648">From a pointer to a null-terminated character array, by using the <xref:System.String.%23ctor%28System.Char%2A%29> or <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="5f51e-649">整個陣列或指定的範圍，都可以用來初始化字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-649">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="5f51e-650">建構函式會複製啟動從指定的指標或加上的指定指標的 Unicode 字元序列`startIndex`繼續執行到結尾的陣列或`length`字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-650">The constructor copies a sequence of Unicode characters starting from the specified pointer or from the specified pointer plus `startIndex` and continuing to the end of the array or for `length` characters.</span></span> <span data-ttu-id="5f51e-651">如果`value`為 null 指標或`length`為零，建構函式會建立的字串，其值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-651">If `value` is a null pointer or `length` is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-652">如果複製作業繼續進行陣列的結尾，而且陣列不是以 null 結束，則建構函式行為是系統而定。</span><span class="sxs-lookup"><span data-stu-id="5f51e-652">If the copy operation proceeds to the end of the array and the array is not null-terminated, the constructor behavior is system-dependent.</span></span> <span data-ttu-id="5f51e-653">這種情況可能會造成存取違規。</span><span class="sxs-lookup"><span data-stu-id="5f51e-653">Such a condition might cause an access violation.</span></span>  
  
     <span data-ttu-id="5f51e-654">如果陣列包含任何內嵌的 null 字元 (U + 0000 或 '\0') 和<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>呼叫的多載，就會包含字串執行個體`length`字元，包括任何內嵌的 null。</span><span class="sxs-lookup"><span data-stu-id="5f51e-654">If the array contains any embedded null characters (U+0000 or '\0') and the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="5f51e-655">下列範例會顯示 10 個元素的陣列，其中包含兩個 null 字元的指標傳遞至時，會發生什麼事<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-655">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="5f51e-656">因為位址是陣列的開頭，而且若要加入至字串陣列中的所有項目，建構函式具現化具有 10 個字元，包括兩個內嵌的 null 的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-656">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="5f51e-657">另一方面，如果相同的陣列傳遞至<xref:System.String.%23ctor%28System.Char%2A%29>建構函式，結果是不包含第一個 null 字元的四個字元字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-657">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.Char%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     <span data-ttu-id="5f51e-658">陣列必須包含 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-658">The array must contain Unicode characters.</span></span> <span data-ttu-id="5f51e-659">在 c + +，這表示的字元陣列必須是定義為 managed <xref:System.Char>[] 型別或未受`wchar_t`[] 型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-659">In C++, this means that the character array must be defined either as the managed <xref:System.Char>[] type or the unmanaged`wchar_t`[] type.</span></span>  
  
     <span data-ttu-id="5f51e-660">如果<xref:System.String.%23ctor%28System.Char%2A%29>呼叫的多載和陣列不是以 null 結尾，或如果<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>呼叫的多載和`startIndex`  +  `length`-1 包含順序的字元，而它之外的記憶體配置的範圍建構函式的行為是系統而定，並可能會發生存取違規。</span><span class="sxs-lookup"><span data-stu-id="5f51e-660">If the <xref:System.String.%23ctor%28System.Char%2A%29> overload is called and the array is not null-terminated, or if the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called and `startIndex` + `length`-1 includes a range that it outside the memory allocated for the sequence of characters, the behavior of the constructor is system-dependent, and an access violation may occur.</span></span> <span data-ttu-id="5f51e-661">此外，Intel Itanium 處理器上呼叫<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>建構函式可能會擲回<xref:System.DataMisalignedException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="5f51e-661">In addition, on the Intel Itanium processor, calls to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor may throw a <xref:System.DataMisalignedException> exception.</span></span> <span data-ttu-id="5f51e-662">如果發生這種情況，呼叫<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>改為。</span><span class="sxs-lookup"><span data-stu-id="5f51e-662">If this occurs, call the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> instead.</span></span>  
  
-   <span data-ttu-id="5f51e-663">從帶正負號的位元組陣列的指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-663">From a pointer to a signed byte array.</span></span> <span data-ttu-id="5f51e-664">整個陣列或指定的範圍，都可以用來初始化字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-664">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="5f51e-665">可以使用預設字碼頁編碼方式，來解譯的位元組序列，或可以指定建構函式呼叫中的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-665">The sequence of bytes can be interpreted by using the default code page encoding, or an encoding can be specified in the constructor call.</span></span> <span data-ttu-id="5f51e-666">如果建構函式會嘗試具現化不是以 null 結束的整個陣列的字串，或是如果從陣列範圍`value`  +  `startIndex`至`value`  +  `startIndex`  +  `length` -1 的記憶體配置的陣列，這個建構函式的行為是系統而定，而且發生存取違規，可能會發生。</span><span class="sxs-lookup"><span data-stu-id="5f51e-666">If the constructor tries to instantiate a string from an entire array that is not null-terminated, or if the range of the array from `value` + `startIndex` to `value` + `startIndex` + `length` -1 is outside of the memory allocated for the array, the behavior of this constructor is system-dependent, and an access violation may occur.</span></span>  
  
     <span data-ttu-id="5f51e-667">包含帶正負號的位元組陣列做為參數的三個建構函式主要設計來轉換 c + +`char`陣列為字串，此範例中所示：</span><span class="sxs-lookup"><span data-stu-id="5f51e-667">The three constructors that include a signed byte array as a parameter are designed primarily to convert a C++ `char` array to a string, as shown in this example:</span></span>  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     <span data-ttu-id="5f51e-668">如果其值為 0 的任何 null 字元 ('\0') 或位元組陣列和<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>呼叫的多載，就會包含字串執行個體`length`字元，包括任何內嵌的 null。</span><span class="sxs-lookup"><span data-stu-id="5f51e-668">If the array contains any null characters ('\0') or bytes whose value is 0 and the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="5f51e-669">下列範例會顯示 10 個元素的陣列，其中包含兩個 null 字元的指標傳遞至時，會發生什麼事<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-669">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="5f51e-670">因為位址是陣列的開頭，而且若要加入至字串陣列中的所有項目，建構函式具現化具有 10 個字元，包括兩個內嵌的 null 的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-670">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="5f51e-671">另一方面，如果相同的陣列傳遞至<xref:System.String.%23ctor%28System.SByte%2A%29>建構函式，結果是不包含第一個 null 字元的四個字元字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-671">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     <span data-ttu-id="5f51e-672">因為<xref:System.String.%23ctor%28System.SByte%2A%29>和<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>建構函式解譯`value`藉由使用預設 ANSI 字碼頁，在呼叫這些建構函式具有相同的位元組陣列可能會建立不同的系統有不同的值的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-672">Because the <xref:System.String.%23ctor%28System.SByte%2A%29> and <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> constructors interpret `value` by using the default ANSI code page, calling these constructors with identical byte arrays may create strings that have different values on different systems.</span></span>  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a><span data-ttu-id="5f51e-673">處理重複字串</span><span class="sxs-lookup"><span data-stu-id="5f51e-673">Handling repetitive strings</span></span>  
 <span data-ttu-id="5f51e-674">剖析或通常解碼的文字資料流的應用程式使用<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>建構函式或<xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法，以將字元序列轉換成字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-674">Apps that parse or decode streams of text often use the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor or the <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to convert sequences of characters into a string.</span></span> <span data-ttu-id="5f51e-675">重複使用相同的值，而不是建立及重複使用一個字串中建立新的字串會浪費記憶體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-675">Repeatedly creating new strings with the same value instead of creating and reusing one string wastes memory.</span></span> <span data-ttu-id="5f51e-676">如果您可能會重複呼叫來建立相同的字串值<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>建構函式，即使您不知道中前進這些相同的字串值可能是，您可以改為使用查閱資料表。</span><span class="sxs-lookup"><span data-stu-id="5f51e-676">If you are likely to create the same string value repeatedly by calling the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor, even if you don't know in advance what those identical string values may be, you can use a lookup table instead.</span></span>  
  
 <span data-ttu-id="5f51e-677">例如，假設您已閱讀並剖析 XML 標記和屬性包含的檔案，從字元資料流。</span><span class="sxs-lookup"><span data-stu-id="5f51e-677">For example, suppose you read and parse a stream of characters from a file that contains XML tags and attributes.</span></span> <span data-ttu-id="5f51e-678">當您剖析資料流時，您重複遇到特定權杖 （也就是具有符號的意義的字元序列）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-678">When you parse the stream, you repeatedly encounter certain tokens (that is, sequences of characters that have a symbolic meaning).</span></span> <span data-ttu-id="5f51e-679">相當於"0"，"1"，"true"和"false"字串的語彙基元是可能會在經常出現在 XML 資料流。</span><span class="sxs-lookup"><span data-stu-id="5f51e-679">Tokens equivalent to the strings "0", "1", "true", and "false" are likely to occur frequently in an XML stream.</span></span>  
  
 <span data-ttu-id="5f51e-680">而不是將每個語彙基元轉換成新的字串，您可以建立<xref:System.Xml.NameTable?displayProperty=nameWithType>物件來保存經常出現的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-680">Instead of converting each token into a new string, you can create a <xref:System.Xml.NameTable?displayProperty=nameWithType> object to hold commonly occurring strings.</span></span> <span data-ttu-id="5f51e-681"><xref:System.Xml.NameTable>物件可改進效能，因為它會擷取儲存的字串，而不需配置的暫存記憶體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-681">The <xref:System.Xml.NameTable> object improves performance, because it retrieves stored strings without allocating temporary memory.</span></span> <span data-ttu-id="5f51e-682">當您遇到語彙基元時，使用<xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法來擷取資料表中的語彙基元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-682">When you encounter a token, use the <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to retrieve the token from the table.</span></span> <span data-ttu-id="5f51e-683">如果權杖存在，則方法會傳回對應的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-683">If the token exists, the method returns the corresponding string.</span></span> <span data-ttu-id="5f51e-684">如果語彙基元不存在，使用<xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法插入資料表中的語彙基元，並取得對應的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-684">If the token does not exist, use the <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to insert the token into the table and to get the corresponding string.</span></span>  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a><span data-ttu-id="5f51e-685">範例 1： 使用字串指派</span><span class="sxs-lookup"><span data-stu-id="5f51e-685">Example 1: Using string assignment</span></span>  
 <span data-ttu-id="5f51e-686">下列範例會藉由指定字串常值建立新的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-686">The following example creates a new string by assigning it a string literal.</span></span> <span data-ttu-id="5f51e-687">它會建立第二個字串指派給它的第一個字串的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-687">It creates a second string by assigning the value of the first string to it.</span></span> <span data-ttu-id="5f51e-688">這些是兩個最常見方式，並具現化新<xref:System.String>物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-688">These are the two most common ways to instantiate a new <xref:System.String> object.</span></span>  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a><span data-ttu-id="5f51e-689">範例 2： 使用的字元陣列</span><span class="sxs-lookup"><span data-stu-id="5f51e-689">Example 2: Using a character array</span></span>  
 <span data-ttu-id="5f51e-690">下列範例示範如何建立新<xref:System.String>字元陣列中的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-690">The following example demonstrates how to create a new <xref:System.String> object from a character array.</span></span>  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a><span data-ttu-id="5f51e-691">範例 3： 使用字元陣列的一部分，並重複單一字元</span><span class="sxs-lookup"><span data-stu-id="5f51e-691">Example 3: Using a portion of a character array and repeating a single character</span></span>  
 <span data-ttu-id="5f51e-692">下列範例示範如何建立新<xref:System.String>部份字元陣列，以及如何建立新物件<xref:System.String>物件，其中包含單一字元的多個項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-692">The following example demonstrates how to create a new <xref:System.String> object from a portion of a character array, and how to create a new <xref:System.String> object that contains multiple occurrences of a single character.</span></span>  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a><span data-ttu-id="5f51e-693">範例 4： 使用的字元陣列的指標</span><span class="sxs-lookup"><span data-stu-id="5f51e-693">Example 4: Using a pointer to a character array</span></span>  
 <span data-ttu-id="5f51e-694">下列範例示範如何建立新<xref:System.String>指標的字元陣列的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-694">The following example demonstrates how to create a new <xref:System.String> object from a pointer to an array of characters.</span></span> <span data-ttu-id="5f51e-695">必須編譯 C# 範例使用`/unsafe`編譯器參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-695">The C# example must be compiled by using the `/unsafe` compiler switch.</span></span>  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a><span data-ttu-id="5f51e-696">範例 5： 具現化的字串指標，而且陣列的範圍</span><span class="sxs-lookup"><span data-stu-id="5f51e-696">Example 5: Instantiating a string from a pointer and a range of an array</span></span>  
 <span data-ttu-id="5f51e-697">下列範例會將字元陣列的項目檢查句號或驚嘆號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-697">The following example examines the elements of a character array for either a period or an exclamation point.</span></span> <span data-ttu-id="5f51e-698">如果找到一個物件，它會具現化前面標點符號的字元陣列中的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-698">If one is found, it instantiates a string from the characters in the array that precede the punctuation symbol.</span></span> <span data-ttu-id="5f51e-699">如果沒有，它會具現化的字串陣列的整個內容。</span><span class="sxs-lookup"><span data-stu-id="5f51e-699">If not, it instantiates a string with the entire contents of the array.</span></span> <span data-ttu-id="5f51e-700">必須編譯 C# 範例，使用`/unsafe`編譯器參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-700">The C# example must be compiled using the `/unsafe` compiler switch.</span></span>  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a><span data-ttu-id="5f51e-701">範例 6： 具現化的字串指標的帶正負號的位元組陣列</span><span class="sxs-lookup"><span data-stu-id="5f51e-701">Example 6: Instantiating a string from a pointer to a signed byte array</span></span>  
 <span data-ttu-id="5f51e-702">下列範例會示範如何建立執行個體<xref:System.String>類別<xref:System.String.%23ctor%28System.SByte%2A%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-702">The following example demonstrates how you can create an instance of the <xref:System.String> class with the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor.</span></span>  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a><span data-ttu-id="5f51e-703">版本資訊</span><span class="sxs-lookup"><span data-stu-id="5f51e-703">Version information</span></span>  
 <span data-ttu-id="5f51e-704">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="5f51e-704">.NET Framework</span></span>  
 <span data-ttu-id="5f51e-705">所有多載支援： 4.5、 4、 3.5、 3.0、 2.0、 1.1、 1.0</span><span class="sxs-lookup"><span data-stu-id="5f51e-705">All overloads are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span></span>  
  
 <span data-ttu-id="5f51e-706">.NET Framework Client Profile</span><span class="sxs-lookup"><span data-stu-id="5f51e-706">.NET Framework Client Profile</span></span>  
 <span data-ttu-id="5f51e-707">所有多載支援： 4、 3.5 SP1</span><span class="sxs-lookup"><span data-stu-id="5f51e-707">All overloads are supported in: 4, 3.5 SP1</span></span>  
  
 <span data-ttu-id="5f51e-708">可攜式類別庫</span><span class="sxs-lookup"><span data-stu-id="5f51e-708">Portable Class Library</span></span>  
 <span data-ttu-id="5f51e-709">所有多載，而不<xref:System.SByte>`*`參數支援</span><span class="sxs-lookup"><span data-stu-id="5f51e-709">All overloads without an <xref:System.SByte>`*` parameter are supported</span></span>  
  
 <span data-ttu-id="5f51e-710">適用於 Windows 市集應用程式的 .NET</span><span class="sxs-lookup"><span data-stu-id="5f51e-710">.NET for Windows Store apps</span></span>  
 <span data-ttu-id="5f51e-711">所有多載，而不<xref:System.SByte>`*`支援參數： Windows 8</span><span class="sxs-lookup"><span data-stu-id="5f51e-711">All overloads without an <xref:System.SByte>`*` parameter are supported in: Windows 8</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-712">Unicode 字元之 Null 終端陣列的指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-712">A pointer to a null-terminated array of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="5f51e-713">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 Unicode 字元陣列的指定指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-713">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-714">如範例和完整的使用方式資訊有關這個主題以及其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>建構函式的摘要。</span><span class="sxs-lookup"><span data-stu-id="5f51e-714">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f51e-715">目前的處理序沒有讀取所有定址字元的權限。</span><span class="sxs-lookup"><span data-stu-id="5f51e-715">The current process does not have read access to all the addressed characters.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-716"><paramref name="value" /> 指定了包含無效 Unicode 字元的陣列，或 <paramref name="value" /> 指定了小於 64000 的位址。</span><span class="sxs-lookup"><span data-stu-id="5f51e-716"><paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> specifies an address less than 64000.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5f51e-717">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-717">requires full trust for the immediate caller.</span></span> <span data-ttu-id="5f51e-718">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-718">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-719">Unicode 字元陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-719">An array of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="5f51e-720">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 Unicode 字元陣列所指示的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-720">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-721">如範例和完整的使用方式資訊有關這個主題以及其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>建構函式的摘要。</span><span class="sxs-lookup"><span data-stu-id="5f51e-721">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-722">以 null 結束之 8 位元帶正負號整數的陣列指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-722">A pointer to a null-terminated array of 8-bit signed integers.</span></span> <span data-ttu-id="5f51e-723">整數會使用目前的系統字碼頁編碼來解譯 (也就是由 <see cref="P:System.Text.Encoding.Default" /> 所指定的編碼)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-723">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span></span></param>
        <summary><span data-ttu-id="5f51e-724">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 8 位元帶正負號整數 (Signed Integer) 陣列的指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-724">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a pointer to an array of 8-bit signed integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-725">如範例和完整的使用方式資訊有關這個主題以及其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>建構函式的摘要。</span><span class="sxs-lookup"><span data-stu-id="5f51e-725">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-726"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-726"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5f51e-727">無法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新執行個體，假設 <paramref name="value" /> 是 ANSI 編碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-727">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f51e-728">要初始化的新字串長度，由 <paramref name="value" /> 之 null 結束字元所決定，該長度太長而無法配置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-728">The length of the new string to initialize, which is determined by the null termination character of <paramref name="value" />, is too large to allocate.</span></span></exception>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="5f51e-729"><paramref name="value" /> 指定了無效的位址。</span><span class="sxs-lookup"><span data-stu-id="5f51e-729"><paramref name="value" /> specifies an invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5f51e-730">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-730">requires full trust for the immediate caller.</span></span> <span data-ttu-id="5f51e-731">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-731">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="5f51e-732">Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-732">A Unicode character.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-733"><c>c</c> 發生的次數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-733">The number of times <c>c</c> occurs.</span></span></param>
        <summary><span data-ttu-id="5f51e-734">將 <see cref="T:System.String" /> 類別的新執行個體初始化為由重複指定次數的指定 Unicode 字元所指示的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-734">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified Unicode character repeated a specified number of times.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-735">如範例和完整的使用方式資訊有關這個主題以及其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>建構函式的摘要。</span><span class="sxs-lookup"><span data-stu-id="5f51e-735">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-736"><paramref name="count" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-736"><paramref name="count" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-737">Unicode 字元陣列的指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-737">A pointer to an array of Unicode characters.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-738">開始位置在 <c>value</c> 內。</span><span class="sxs-lookup"><span data-stu-id="5f51e-738">The starting position within <c>value</c>.</span></span></param>
        <param name="length"><span data-ttu-id="5f51e-739"><c>value</c> 內要使用的字元數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-739">The number of characters within <c>value</c> to use.</span></span></param>
        <summary><span data-ttu-id="5f51e-740">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 Unicode 字元陣列、在陣列內起始字元的位置以及長度等等的指定指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-740">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-741">如範例和完整的使用方式資訊有關這個主題以及其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>建構函式的摘要。</span><span class="sxs-lookup"><span data-stu-id="5f51e-741">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-742"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零、<paramref name="value" /> + <paramref name="startIndex" /> 導致指標溢位，或目前的處理序沒有所有定址字元的讀取權限。</span><span class="sxs-lookup"><span data-stu-id="5f51e-742"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero, <paramref name="value" /> + <paramref name="startIndex" /> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-743"><paramref name="value" /> 指定包含無效 Unicode 字元的陣列，或 <paramref name="value" /> + <paramref name="startIndex" /> 指定小於 64000 的位址。</span><span class="sxs-lookup"><span data-stu-id="5f51e-743"><paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> + <paramref name="startIndex" /> specifies an address less than 64000.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5f51e-744">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-744">requires full trust for the immediate caller.</span></span> <span data-ttu-id="5f51e-745">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-745">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-746">Unicode 字元陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-746">An array of Unicode characters.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-747">開始位置在 <c>value</c> 內。</span><span class="sxs-lookup"><span data-stu-id="5f51e-747">The starting position within <c>value</c>.</span></span></param>
        <param name="length"><span data-ttu-id="5f51e-748"><c>value</c> 內要使用的字元數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-748">The number of characters within <c>value</c> to use.</span></span></param>
        <summary><span data-ttu-id="5f51e-749">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 Unicode 字元陣列、在陣列內起始字元的位置和長度等等所指示的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-749">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-750">如範例和完整的使用方式資訊有關這個主題以及其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>建構函式的摘要。</span><span class="sxs-lookup"><span data-stu-id="5f51e-750">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-751"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-751"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-752"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-752"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
 <span data-ttu-id="5f51e-753">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-753">-or-</span></span>  
  
 <span data-ttu-id="5f51e-754"><paramref name="startIndex" /> 和 <paramref name="length" /> 的總和大於 <paramref name="value" /> 中的元素數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-754">The sum of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the number of elements in <paramref name="value" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-755">8 位元帶正負號整數陣列的指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-755">A pointer to an array of 8-bit signed integers.</span></span> <span data-ttu-id="5f51e-756">整數會使用目前的系統字碼頁編碼來解譯 (也就是由 <see cref="P:System.Text.Encoding.Default" /> 所指定的編碼)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-756">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-757">開始位置在 <c>value</c> 內。</span><span class="sxs-lookup"><span data-stu-id="5f51e-757">The starting position within <c>value</c>.</span></span></param>
        <param name="length"><span data-ttu-id="5f51e-758"><c>value</c> 內要使用的字元數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-758">The number of characters within <c>value</c> to use.</span></span></param>
        <summary><span data-ttu-id="5f51e-759">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 8 位元帶正負號整數的陣列、在該陣列內開始位置和長度的指定指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-759">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-760">如範例和完整的使用方式資訊有關這個主題以及其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>建構函式的摘要。</span><span class="sxs-lookup"><span data-stu-id="5f51e-760">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-761"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-761"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-762"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-762"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
 <span data-ttu-id="5f51e-763">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-763">-or-</span></span>  
  
 <span data-ttu-id="5f51e-764"><paramref name="value" /> + <paramref name="startIndex" /> 指定的位址對於目前的平台而言太大，也就是位址計算溢位。</span><span class="sxs-lookup"><span data-stu-id="5f51e-764">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span></span>  
  
 <span data-ttu-id="5f51e-765">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-765">-or-</span></span>  
  
 <span data-ttu-id="5f51e-766">要初始化的新字串長度太大而無法配置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-766">The length of the new string to initialize is too large to allocate.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5f51e-767"><paramref name="value" /> + <paramref name="startIndex" /> 指定的位址小於 64K。</span><span class="sxs-lookup"><span data-stu-id="5f51e-767">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span></span>  
  
 <span data-ttu-id="5f51e-768">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-768">-or-</span></span>  
  
 <span data-ttu-id="5f51e-769">無法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新執行個體，假設 <paramref name="value" /> 是 ANSI 編碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-769">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span></span></exception>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="5f51e-770"><paramref name="value" />、<paramref name="startIndex" /> 和 <paramref name="length" /> 共同指定了無效的位址。</span><span class="sxs-lookup"><span data-stu-id="5f51e-770"><paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5f51e-771">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-771">requires full trust for the immediate caller.</span></span> <span data-ttu-id="5f51e-772">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-772">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-773">8 位元帶正負號整數陣列的指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-773">A pointer to an array of 8-bit signed integers.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-774">開始位置在 <c>value</c> 內。</span><span class="sxs-lookup"><span data-stu-id="5f51e-774">The starting position within <c>value</c>.</span></span></param>
        <param name="length"><span data-ttu-id="5f51e-775"><c>value</c> 內要使用的字元數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-775">The number of characters within <c>value</c> to use.</span></span></param>
        <param name="enc"><span data-ttu-id="5f51e-776">物件，指定以 <c>value</c> 參考之陣列的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-776">An object that specifies how the array referenced by <c>value</c> is encoded.</span></span> <span data-ttu-id="5f51e-777">如果 <c>enc</c> 為 <see langword="null" />，則假設使用 ANSI 編碼方式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-777">If <c>enc</c> is <see langword="null" />, ANSI encoding is assumed.</span></span></param>
        <summary><span data-ttu-id="5f51e-778">將 <see cref="T:System.String" /> 類別的新執行個體初始化為 8 位元帶正負號整數的陣列、在該陣列內開始位置、長度和 <see cref="T:System.Text.Encoding" /> 物件的指定指標所指示的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-778">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-779">如範例和完整的使用方式資訊有關這個主題以及其他`String`建構函式多載，請參閱<xref:System.String.%23ctor%2A>建構函式的摘要。</span><span class="sxs-lookup"><span data-stu-id="5f51e-779">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-780"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-780"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-781"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-781"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
 <span data-ttu-id="5f51e-782">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-782">-or-</span></span>  
  
 <span data-ttu-id="5f51e-783"><paramref name="value" /> + <paramref name="startIndex" /> 指定的位址對於目前的平台而言太大，也就是位址計算溢位。</span><span class="sxs-lookup"><span data-stu-id="5f51e-783">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span></span>  
  
 <span data-ttu-id="5f51e-784">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-784">-or-</span></span>  
  
 <span data-ttu-id="5f51e-785">要初始化的新字串長度太大而無法配置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-785">The length of the new string to initialize is too large to allocate.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5f51e-786"><paramref name="value" /> + <paramref name="startIndex" /> 指定的位址小於 64K。</span><span class="sxs-lookup"><span data-stu-id="5f51e-786">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span></span>  
  
 <span data-ttu-id="5f51e-787">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-787">-or-</span></span>  
  
 <span data-ttu-id="5f51e-788">無法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新執行個體 (假設 <paramref name="value" /> 是以 <paramref name="enc" /> 指定的方式編碼)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-788">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded as specified by <paramref name="enc" />.</span></span></exception>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="5f51e-789"><paramref name="value" />、<paramref name="startIndex" /> 和 <paramref name="length" /> 共同指定了無效的位址。</span><span class="sxs-lookup"><span data-stu-id="5f51e-789"><paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5f51e-790">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-790">requires full trust for the immediate caller.</span></span> <span data-ttu-id="5f51e-791">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-791">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="5f51e-792">目前字串中的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-792">A position in the current string.</span></span></param>
        <summary><span data-ttu-id="5f51e-793">取得目前 <see cref="T:System.Char" /> 物件中指定位置的 <see cref="T:System.String" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-793">Gets the <see cref="T:System.Char" /> object at a specified position in the current <see cref="T:System.String" /> object.</span></span></summary>
        <value><span data-ttu-id="5f51e-794">在 <paramref name="index" /> 位置的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-794">The object at position <paramref name="index" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-795">`index`參數以零為起始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-795">The `index` parameter is zero-based.</span></span>  
  
 <span data-ttu-id="5f51e-796">這個屬性會傳回<xref:System.Char>物件所指定位置`index`參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-796">This property returns the <xref:System.Char> object at the position specified by the `index` parameter.</span></span> <span data-ttu-id="5f51e-797">不過，您可能會將 Unicode 字元表示由多個<xref:System.Char>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-797">However, a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="5f51e-798">使用<xref:System.Globalization.StringInfo?displayProperty=nameWithType>類別，以使用 Unicode 字元，而非<xref:System.Char>物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-798">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with Unicode characters instead of <xref:System.Char> objects.</span></span> <span data-ttu-id="5f51e-799">如需詳細資訊，請參閱 「 Char 物件和 Unicode 字元 」 一節<xref:System.String>類別概觀。</span><span class="sxs-lookup"><span data-stu-id="5f51e-799">For more information, see the "Char Objects and Unicode Characters" section in the <xref:System.String> class overview.</span></span>  
  
 <span data-ttu-id="5f51e-800">在 C# 中，<xref:System.String.Chars%2A>屬性是索引子。</span><span class="sxs-lookup"><span data-stu-id="5f51e-800">In C#, the <xref:System.String.Chars%2A> property is an indexer.</span></span> <span data-ttu-id="5f51e-801">在 Visual Basic 中，它是預設屬性<xref:System.String>類別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-801">In Visual Basic, it is the default property of the <xref:System.String> class.</span></span> <span data-ttu-id="5f51e-802">每個<xref:System.Char>可以使用下列程式碼存取字串中的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-802">Each <xref:System.Char> object in the string can be accessed by using code such as the following.</span></span>  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-803">下列範例會示範如何使用這個索引子在常式驗證字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-803">The following example demonstrates how you can use this indexer in a routine to validate a string.</span></span>  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="5f51e-804"><paramref name="index" /> 大於或等於此物件的長度或小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-804"><paramref name="index" /> is greater than or equal to the length of this object or less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-805">傳回對 <see cref="T:System.String" /> 這個執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-805">Returns a reference to this instance of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-806"><see cref="T:System.String" /> 的這個執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-806">This instance of <see cref="T:System.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-807">傳回的值不是這個執行個體的獨立複本它是只是另一個檢視相同的資料。</span><span class="sxs-lookup"><span data-stu-id="5f51e-807">The return value is not an independent copy of this instance; it is simply another view of the same data.</span></span> <span data-ttu-id="5f51e-808">使用<xref:System.String.Copy%2A>或<xref:System.String.CopyTo%2A>方法來建立個別<xref:System.String>物件具有相同的值與這個執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-808">Use the <xref:System.String.Copy%2A> or <xref:System.String.CopyTo%2A> method to create a separate <xref:System.String> object with the same value as this instance.</span></span>  
  
 <span data-ttu-id="5f51e-809">因為<xref:System.String.Clone%2A>方法只會傳回現有的字串執行個體中，沒有什麼道理直接呼叫它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-809">Because the <xref:System.String.Clone%2A> method simply returns the existing string instance, there is little reason to call it directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-810">比較兩個指定的 <see cref="T:System.String" /> 物件，並傳回一個整數，指出它們在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-810">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-811"><xref:System.String.Compare%2A> 方法的所有多載會傳回 32 位元帶正負號整數，指出兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="5f51e-811">All overloads of the <xref:System.String.Compare%2A> method return a 32-bit signed integer indicating the lexical relationship between the two comparands.</span></span>  
  
|<span data-ttu-id="5f51e-812">值</span><span class="sxs-lookup"><span data-stu-id="5f51e-812">Value</span></span>|<span data-ttu-id="5f51e-813">條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-813">Condition</span></span>|  
|-----------|---------------|  
|<span data-ttu-id="5f51e-814">小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-814">Less than zero</span></span>|<span data-ttu-id="5f51e-815">第一個子字串在排序次序中位於第二個的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-815">The first substring precedes the second substring in the sort order.</span></span>|  
|<span data-ttu-id="5f51e-816">零</span><span class="sxs-lookup"><span data-stu-id="5f51e-816">Zero</span></span>|<span data-ttu-id="5f51e-817">子字串出現在排序次序中的相同位置，或 `length` 為零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-817">The substrings occur in the same position in the sort order, or `length` is zero.</span></span>|  
|<span data-ttu-id="5f51e-818">大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-818">Greater than zero</span></span>|<span data-ttu-id="5f51e-819">第一個子字串會遵循第二個的子字串在排序次序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-819">The first substring follows the second substring in the sort order.</span></span>|  
  
> [!WARNING]
>  <span data-ttu-id="5f51e-820">可能的話，您應該呼叫的多載<xref:System.String.Compare%2A>方法包含<xref:System.StringComparison>參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-820">Whenever possible, you should call an overload of the <xref:System.String.Compare%2A> method that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="5f51e-821">如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-821">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="5f51e-822">要比較的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-822">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="5f51e-823">要比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-823">The second string to compare.</span></span></param>
        <summary><span data-ttu-id="5f51e-824">比較兩個指定的 <see cref="T:System.String" /> 物件，並傳回一個整數，指出它們在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-824">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="5f51e-825">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="5f51e-825">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="5f51e-826"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-826"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-827"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-827"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-828"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-828"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-829"></term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="5f51e-829"></term><description><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-830"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-830"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-831"></term><description><paramref name="strA" /> 出現在排序次序中的位置和 <paramref name="strB" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-831"></term><description><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-832"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-832"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-833"></term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="5f51e-833"></term><description><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-834">比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-834">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="5f51e-835">例如，某些字元的組合視為單一字元，或以特定方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元或請依照它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-835">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="5f51e-836">使用字組的排序規則來進行比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-836">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="5f51e-837">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-837">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="5f51e-838">當比較字串時，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，會要求您明確指定此方法會使用的字串比較的類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-838">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="5f51e-839">如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-839">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="5f51e-840">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-840">One or both comparands can be `null`.</span></span> <span data-ttu-id="5f51e-841">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-841">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="5f51e-842">當探索到的不等比較或這兩個字串都比較之後，則會結束比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-842">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="5f51e-843">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，然後其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="5f51e-843">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="5f51e-844">傳回值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-844">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="5f51e-845">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-845">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="5f51e-846">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="5f51e-846">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 <span data-ttu-id="5f51e-847">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-847">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="5f51e-848">若要這樣做的正確程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="5f51e-848">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-849">下列範例會呼叫<xref:System.String.Compare%28System.String%2CSystem.String%29>方法來比較三個字串集合。</span><span class="sxs-lookup"><span data-stu-id="5f51e-849">The following example calls the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to compare three sets of strings.</span></span>  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 <span data-ttu-id="5f51e-850">在下列範例中，`ReverseStringComparer`類別會示範如何評估兩個字串與<xref:System.String.Compare%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-850">In the following example, the `ReverseStringComparer` class demonstrates how you can evaluate two strings with the <xref:System.String.Compare%2A> method.</span></span>  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-851">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-851">Character sets include ignorable characters.</span></span> <span data-ttu-id="5f51e-852"><see cref="M:System.String.Compare(System.String,System.String)" />方法執行區分文化特性的比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-852">The <see cref="M:System.String.Compare(System.String,System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-853">例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，區分文化特性的比較"動物 」 與 「 ani 郵件 」 （使用選擇性連字號或 U + 00AD），表示兩個字串相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-853">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
 [!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)]
 [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]  
  
 <span data-ttu-id="5f51e-854">若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />方法並提供值的其中一個<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如`comparisonType`參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-854">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the `comparisonType` parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="5f51e-855">要比較的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-855">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="5f51e-856">要比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-856">The second string to compare.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="5f51e-857"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-857"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5f51e-858">比較兩個指定的 <see cref="T:System.String" /> 物件，忽略或區分兩者的大小寫，並傳回一個整數，表示兩者在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-858">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="5f51e-859">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="5f51e-859">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="5f51e-860"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-860"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-861"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-861"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-862"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-862"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-863"></term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="5f51e-863"></term><description><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-864"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-864"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-865"></term><description><paramref name="strA" /> 出現在排序次序中的位置和 <paramref name="strB" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-865"></term><description><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-866"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-866"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-867"></term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="5f51e-867"></term><description><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-868">比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-868">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="5f51e-869">例如，某些字元的組合視為單一字元，或以特定方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元或請依照它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-869">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="5f51e-870">使用字組的排序規則來進行比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-870">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="5f51e-871">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-871">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="5f51e-872">當比較字串時，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，會要求您明確指定此方法會使用的字串比較的類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-872">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="5f51e-873">如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-873">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="5f51e-874">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-874">One or both comparands can be `null`.</span></span> <span data-ttu-id="5f51e-875">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-875">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="5f51e-876">當探索到的不等比較或這兩個字串都比較之後，則會結束比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-876">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="5f51e-877">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，然後其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="5f51e-877">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="5f51e-878">傳回值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-878">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="5f51e-879">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-879">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="5f51e-880">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="5f51e-880">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 <span data-ttu-id="5f51e-881">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-881">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="5f51e-882">若要這樣做的正確程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="5f51e-882">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-883">下列範例會示範<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29>方法相當於使用<xref:System.String.ToUpper%2A>或<xref:System.String.ToLower%2A>比較字串時。</span><span class="sxs-lookup"><span data-stu-id="5f51e-883">The following example demonstrates that the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> method is equivalent to using <xref:System.String.ToUpper%2A> or <xref:System.String.ToLower%2A> when comparing strings.</span></span>  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-884">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-884">Character sets include ignorable characters.</span></span> <span data-ttu-id="5f51e-885"><see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" />方法執行區分文化特性的比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-885">The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-886">例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，區分文化特性、 不區分大小寫的比較"動物 」 與 「 Ani 郵件 」 （使用選擇性連字號或 U + 00AD），表示兩個字串相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-886">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive, case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
 [!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)]
 [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]  
  
 <span data-ttu-id="5f51e-887">若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />方法並提供值的其中一個<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-887">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="5f51e-888">要比較的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-888">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="5f51e-889">要比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-889">The second string to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="5f51e-890">其中一個列舉值，指定要用於比較的規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-890">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="5f51e-891">使用指定的規則比較兩個指定的 <see cref="T:System.String" /> 物件，並傳回一個整數，表示兩者在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-891">Compares two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="5f51e-892">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="5f51e-892">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="5f51e-893"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-893"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-894"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-894"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-895"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-895"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-896"></term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="5f51e-896"></term><description><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-897"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-897"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-898"></term><description><paramref name="strA" /> 在排序次序中的位置和 <paramref name="strB" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-898"></term><description><paramref name="strA" /> is in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-899"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-899"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-900"></term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="5f51e-900"></term><description><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-901">`comparisonType`參數會指出是否比較應該使用的目前或而異的文化特性、 接受或忽略大小寫的比較元，或使用 word （區分文化特性） 或序數 （不區分文化特性） 的排序規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-901">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>  
  
 <span data-ttu-id="5f51e-902">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-902">One or both comparands can be `null`.</span></span> <span data-ttu-id="5f51e-903">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-903">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="5f51e-904">當探索到的不等比較或這兩個字串都比較之後，則會結束比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-904">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="5f51e-905">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="5f51e-905">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="5f51e-906">傳回值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-906">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="5f51e-907">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-907">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="5f51e-908">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="5f51e-908">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 <span data-ttu-id="5f51e-909">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-909">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="5f51e-910">若要這樣做的正確程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="5f51e-910">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-911">下列範例會比較三個字母的版本"I"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-911">The following example compares three versions of the letter "I".</span></span> <span data-ttu-id="5f51e-912">文化特性、 是否忽略大小寫，以及是否執行序數比較的選擇會影響結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-912">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-913"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-913"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="5f51e-914">不支援 <see cref="T:System.StringComparison" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-914"><see cref="T:System.StringComparison" /> is not supported.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-915">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-915">Character sets include ignorable characters.</span></span> <span data-ttu-id="5f51e-916"><see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />方法執行區分文化特性的比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-916">The <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-917">若要識別可忽略的字元在比較中，提供的值<see cref="F:System.StringComparison.Ordinal" />或<see cref="F:System.StringComparison.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-917">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="5f51e-918">要比較的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-918">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="5f51e-919">要比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-919">The second string to compare.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="5f51e-920"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-920"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="5f51e-921">物件，提供文化特性相關的比較資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-921">An object that supplies culture-specific comparison information.</span></span></param>
        <summary><span data-ttu-id="5f51e-922">比較兩個指定的 <see cref="T:System.String" /> 物件，忽略或區分兩者的大小寫，並使用特定文化特性資訊來影響比較，然後傳回一個整數，表示兩者在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-922">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="5f51e-923">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="5f51e-923">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="5f51e-924"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-924"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-925"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-925"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-926"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-926"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-927"></term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="5f51e-927"></term><description><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-928"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-928"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-929"></term><description><paramref name="strA" /> 出現在排序次序中的位置和 <paramref name="strB" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-929"></term><description><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-930"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-930"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-931"></term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="5f51e-931"></term><description><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-932">比較會使用`culture`參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-932">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="5f51e-933">例如，某些字元的組合視為單一字元，或以特定方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元或請依照它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-933">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="5f51e-934">使用字組的排序規則來進行比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-934">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="5f51e-935">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-935">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5f51e-936">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-936">One or both comparands can be `null`.</span></span> <span data-ttu-id="5f51e-937">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-937">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="5f51e-938">當探索到的不等比較或這兩個字串都比較之後，則會結束比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-938">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="5f51e-939">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，然後其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="5f51e-939">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="5f51e-940">傳回值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-940">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="5f51e-941">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-941">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="5f51e-942">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="5f51e-942">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 <span data-ttu-id="5f51e-943">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-943">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="5f51e-944">若要這樣做的正確程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="5f51e-944">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-945">下列範例示範文化特性如何影響比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-945">The following example demonstrates how culture can affect a comparison.</span></span> <span data-ttu-id="5f51e-946">捷克文-捷克共和國文化特性，在"ch"會是單一字元，大於"d"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-946">In Czech - Czech Republic culture, "ch" is a single character that is greater than "d".</span></span> <span data-ttu-id="5f51e-947">不過，英文-美國文化特性"ch 」 包含兩個字元，而且"c"小於"d"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-947">However, in English - United States culture, "ch" consists of two characters, and "c" is less than "d".</span></span>  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-948"><paramref name="culture" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-948"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-949">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-949">Character sets include ignorable characters.</span></span> <span data-ttu-id="5f51e-950"><see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />方法執行區分文化特性的比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-950">The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-951">例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，「 動物 」 與 「 Ani 郵件 」 （使用選擇性連字號或 U + 00AD） 的不區分大小寫比較使用不變的文化特性會指出兩個字串相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-951">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) using the invariant culture indicates that the two strings are equivalent.</span></span>  
  
 [!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)]
 [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]  
  
 <span data-ttu-id="5f51e-952">若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法並提供值的其中一個<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="options" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-952">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="5f51e-953">要比較的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-953">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="5f51e-954">要比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-954">The second string to compare.</span></span></param>
        <param name="culture"><span data-ttu-id="5f51e-955">提供特定文化特性之比較資訊的文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-955">The culture that supplies culture-specific comparison information.</span></span></param>
        <param name="options"><span data-ttu-id="5f51e-956">執行比較時要使用的選項 (例如忽略大小寫或符號)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-956">Options to use when performing the comparison (such as ignoring case or symbols).</span></span></param>
        <summary><span data-ttu-id="5f51e-957">比較兩個指定的 <see cref="T:System.String" /> 物件，使用指定的比較選項及特定文化特性資訊影響比較，然後傳回整數，這個整數表示這兩個字串在排序次序中彼此的關聯性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-957">Compares two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</span></span></summary>
        <returns><span data-ttu-id="5f51e-958">32 位元帶正負號的整數，這個整數表示 <paramref name="strA" /> 和 <paramref name="strB" /> 之間的語彙關係，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-958">A 32-bit signed integer that indicates the lexical relationship between <paramref name="strA" /> and <paramref name="strB" />, as shown in the following table</span></span>  
  
 <span data-ttu-id="5f51e-959"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-959"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-960"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-960"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-961"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-961"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-962"></term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="5f51e-962"></term><description><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-963"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-963"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-964"></term><description><paramref name="strA" /> 出現在排序次序中的位置和 <paramref name="strB" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-964"></term><description><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-965"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-965"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-966"></term><description>在排序次序中，<paramref name="strA" /> 會排在 <paramref name="strB" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="5f51e-966"></term><description><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-967">比較會使用`culture`參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-967">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="5f51e-968">例如，某些字元的組合視為單一字元、 大寫和小寫字元進行比較以特定的方式，可以指定特定文化特性或字元的排序次序取決於字元，與其前面或後面。</span><span class="sxs-lookup"><span data-stu-id="5f51e-968">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5f51e-969"><xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>方法主要針對用於排序或依字母順序排列作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-969">The <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="5f51e-970">此外，它不應該使用方法呼叫的主要目的是要判斷兩個字串是否相等 （也就是當方法呼叫的目的是要測試傳回值為零） 時。</span><span class="sxs-lookup"><span data-stu-id="5f51e-970">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="5f51e-971">若要判斷兩個字串是否相等，請呼叫<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-971">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="5f51e-972">比較可以進一步指定`options`參數，其中包含一個或多個成員<xref:System.Globalization.CompareOptions>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-972">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions> enumeration.</span></span> <span data-ttu-id="5f51e-973">不過，因為此方法的目的是要進行區分文化特性的字串比較，<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>和<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>值沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="5f51e-973">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>  
  
 <span data-ttu-id="5f51e-974">可以是任一個或兩個比較元`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-974">Either or both comparands can be `null`.</span></span> <span data-ttu-id="5f51e-975">根據定義，任何字串，包括<xref:System.String.Empty?displayProperty=nameWithType>，比較彼此相等的比較大於 null 參考，且兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-975">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="5f51e-976">當探索到的不等比較或這兩個字串都比較之後，則會結束比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-976">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="5f51e-977">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="5f51e-977">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-978">下列範例會比較兩個字串以三個不同的方式： 語言比較，會使用 EN-US 文化特性;會使用 EN-US 文化特性; 語言區分大小寫的比較並使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-978">The following example compares two strings in three different ways: using linguistic comparison for the en-US culture; using linguistic case-sensitive comparison for the en-US culture; and using an ordinal comparison.</span></span> <span data-ttu-id="5f51e-979">它會說明如何比較的三種方法會產生三個不同的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-979">It illustrates how the three methods of comparison produce three different results.</span></span>  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-980"><paramref name="options" /> 不是 <see cref="T:System.Globalization.CompareOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-980"><paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-981"><paramref name="culture" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-981"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-982">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="5f51e-982">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-983"><see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法執行區分文化特性的比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-983">The <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-984">若要識別可忽略的字元在比較中，提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="options" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-984">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="5f51e-985">要用於比較中的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-985">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="5f51e-986"><c>strA</c> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-986">The position of the substring within <c>strA</c>.</span></span></param>
        <param name="strB"><span data-ttu-id="5f51e-987">要用於比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-987">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="5f51e-988"><c>strB</c> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-988">The position of the substring within <c>strB</c>.</span></span></param>
        <param name="length"><span data-ttu-id="5f51e-989">要比較之子字串的字元數上限。</span><span class="sxs-lookup"><span data-stu-id="5f51e-989">The maximum number of characters in the substrings to compare.</span></span></param>
        <summary><span data-ttu-id="5f51e-990">比較兩個指定的 <see cref="T:System.String" /> 物件子字串，並傳回一個整數，指出它們在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-990">Compares substrings of two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="5f51e-991">32 位元帶正負號整數，指出兩比較元的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="5f51e-991">A 32-bit signed integer indicating the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="5f51e-992"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-992"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-993"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-993"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-994"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-994"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-995"></term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。</span><span class="sxs-lookup"><span data-stu-id="5f51e-995"></term><description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-996"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-996"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-997"></term><description>子字串出現在排序次序中的相同位置，或 <paramref name="length" /> 為零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-997"></term><description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 <span data-ttu-id="5f51e-998"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-998"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-999"></term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。</span><span class="sxs-lookup"><span data-stu-id="5f51e-999"></term><description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1000">要比較之子字串開始`strA`在`indexA`和`strB`在`indexB`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1000">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="5f51e-1001">同時`indexA`和`indexB`都是以零為起始，也就是中的第一個字元`strA`和`strB`位在位置零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1001">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="5f51e-1002">第一個子字串的長度等於長度`strA`減去`indexA`再加 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1002">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="5f51e-1003">第二個的子字串長度的長度等於`strB`減去`indexB`再加 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1003">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="5f51e-1004">要比較的字元數為較小的兩個子字串的長度和`length`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1004">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="5f51e-1005">`indexA`， `indexB`，和`length`參數必須是非負值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1005">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="5f51e-1006">比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1006">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="5f51e-1007">例如，某些字元的組合視為單一字元，或以特定方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元或請依照它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1007">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="5f51e-1008">使用字組的排序規則來進行比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1008">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="5f51e-1009">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1009">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="5f51e-1010">當比較字串時，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>方法，會要求您明確指定此方法會使用的字串比較的類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1010">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="5f51e-1011">如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1011">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="5f51e-1012">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1012">One or both comparands can be `null`.</span></span> <span data-ttu-id="5f51e-1013">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1013">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="5f51e-1014">當探索到的不等比較，或兩個子字串有相較，則會結束比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1014">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="5f51e-1015">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，然後其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1015">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="5f51e-1016">傳回值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1016">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="5f51e-1017">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1017">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="5f51e-1018">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1018">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 <span data-ttu-id="5f51e-1019">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1019">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="5f51e-1020">若要這樣做的正確程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1020">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1021">下列範例會比較這兩個子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1021">The following example compares two substrings.</span></span>  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-1022"><paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1022"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="5f51e-1023">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1023">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1024"><paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1024"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="5f51e-1025">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1025">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1026"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1026"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-1027">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1027">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1028"><paramref name="indexA" /> 或 <paramref name="indexB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1028">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-1029">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1029">Character sets include ignorable characters.</span></span> <span data-ttu-id="5f51e-1030"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />方法在執行語言或區分文化特性的比較時不會考慮這些字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1030">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-1031">若要識別可忽略的字元在比較中，呼叫<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />方法提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1031">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="5f51e-1032">要用於比較中的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1032">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="5f51e-1033"><c>strA</c> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1033">The position of the substring within <c>strA</c>.</span></span></param>
        <param name="strB"><span data-ttu-id="5f51e-1034">要用於比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1034">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="5f51e-1035"><c>strB</c> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1035">The position of the substring within <c>strB</c>.</span></span></param>
        <param name="length"><span data-ttu-id="5f51e-1036">要比較之子字串的字元數上限。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1036">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="5f51e-1037"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1037"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="5f51e-1038">比較兩個指定之 <see cref="T:System.String" /> 物件的子字串，忽略或區分兩者的大小寫，並傳回一個整數，表示兩者在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1038">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1039">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1039">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="5f51e-1040"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-1040"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-1041"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-1041"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-1042"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1042"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-1043"></term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1043"></term><description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-1044"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1044"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-1045"></term><description>子字串出現在排序次序中的相同位置，或 <paramref name="length" /> 為零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1045"></term><description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 <span data-ttu-id="5f51e-1046"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1046"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-1047"></term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1047"></term><description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1048">要比較之子字串開始`strA`在`indexA`，然後在`strB`在`indexB`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1048">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="5f51e-1049">同時`indexA`和`indexB`都是以零為起始，也就是中的第一個字元`strA`和`strB`位在位置零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1049">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="5f51e-1050">第一個子字串的長度等於長度`strA`減去`indexA`再加 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1050">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="5f51e-1051">第二個的子字串長度的長度等於`strB`減去`indexB`再加 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1051">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="5f51e-1052">要比較的字元數為較小的兩個子字串的長度和`length`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1052">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="5f51e-1053">`indexA`， `indexB`，和`length`參數必須是非負值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1053">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="5f51e-1054">比較會使用目前文化特性，若要取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1054">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="5f51e-1055">例如，某些字元的組合視為單一字元，或以特定方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元或請依照它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1055">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="5f51e-1056">使用字組的排序規則來進行比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1056">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="5f51e-1057">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1057">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="5f51e-1058">當比較字串時，您應該呼叫<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>方法，會要求您明確指定此方法會使用的字串比較的類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1058">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="5f51e-1059">如需詳細資訊，請參閱[使用字串的最佳做法](~/docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1059">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="5f51e-1060">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1060">One or both comparands can be `null`.</span></span> <span data-ttu-id="5f51e-1061">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1061">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="5f51e-1062">當探索到的不等比較，或兩個子字串有相較，則會結束比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1062">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="5f51e-1063">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，然後其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1063">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="5f51e-1064">傳回值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1064">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="5f51e-1065">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1065">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="5f51e-1066">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1066">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 <span data-ttu-id="5f51e-1067">路徑名稱必須以而異的方式進行比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1067">The path name needs to be compared in an invariant manner.</span></span> <span data-ttu-id="5f51e-1068">若要這樣做的正確程式碼如下所示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1068">The correct code to do this is as follows.</span></span>  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1069">下列範例案例中執行兩個只有一個地方不同的子字串的兩個的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1069">The following example performs two comparisons of two substrings that only differ in case.</span></span> <span data-ttu-id="5f51e-1070">第一個比較會忽略大小寫，第二個比較會考量大小寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1070">The first comparison ignores case and the second comparison considers case.</span></span>  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-1071"><paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1071"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="5f51e-1072">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1072">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1073"><paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1073"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="5f51e-1074">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1074">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1075"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1075"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-1076">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1076">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1077"><paramref name="indexA" /> 或 <paramref name="indexB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1077">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-1078">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1078">Character sets include ignorable characters.</span></span> <span data-ttu-id="5f51e-1079"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />方法在執行語言或區分文化特性的比較時不會考慮這些字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1079">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-1080">若要識別可忽略的字元在比較中，呼叫<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />方法提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1080">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="5f51e-1081">要用於比較中的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1081">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="5f51e-1082"><c>strA</c> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1082">The position of the substring within <c>strA</c>.</span></span></param>
        <param name="strB"><span data-ttu-id="5f51e-1083">要用於比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1083">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="5f51e-1084"><c>strB</c> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1084">The position of the substring within <c>strB</c>.</span></span></param>
        <param name="length"><span data-ttu-id="5f51e-1085">要比較之子字串的字元數上限。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1085">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="5f51e-1086">其中一個列舉值，指定要用於比較的規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1086">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="5f51e-1087">使用指定的規則比較兩個指定之 <see cref="T:System.String" /> 物件的子字串，並傳回一個整數，表示兩者在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1087">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1088">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1088">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="5f51e-1089"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-1089"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-1090"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-1090"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-1091"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1091"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-1092"></term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1092"></term><description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-1093"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1093"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-1094"></term><description>子字串出現在排序次序中的相同位置，或 <paramref name="length" /> 參數為零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1094"></term><description> The substrings occur in the same position in the sort order, or the <paramref name="length" /> parameter is zero.</span></span>  
  
 <span data-ttu-id="5f51e-1095"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1095"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-1096"></term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1096"></term><description> The substring in <paramref name="strA" /> follllows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1097">要比較之子字串開始`strA`在`indexA`和`strB`在`indexB`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1097">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="5f51e-1098">同時`indexA`和`indexB`都是以零為起始，也就是中的第一個字元`strA`和`strB`是於零，並放在其中一個。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1098">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="5f51e-1099">第一個子字串的長度等於長度`strA`減去`indexA`再加 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1099">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="5f51e-1100">第二個的子字串長度的長度等於`strB`減去`indexB`再加 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1100">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="5f51e-1101">要比較的字元數為較小的兩個子字串的長度和`length`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1101">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="5f51e-1102">`indexA`， `indexB`，和`length`參數必須是非負值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1102">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="5f51e-1103">`comparisonType`參數會指出是否比較應該使用的目前或而異的文化特性、 接受或忽略大小寫的比較元，或使用 word （區分文化特性） 或序數 （不區分文化特性） 的排序規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1103">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>  
  
 <span data-ttu-id="5f51e-1104">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1104">One or both comparands can be `null`.</span></span> <span data-ttu-id="5f51e-1105">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1105">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="5f51e-1106">當探索到的不等比較，或兩個子字串有相較，則會結束比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1106">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="5f51e-1107">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1107">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="5f51e-1108">傳回值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1108">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="5f51e-1109">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1109">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="5f51e-1110">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1110">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 <span data-ttu-id="5f51e-1111">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1111">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="5f51e-1112">若要這樣做的正確程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1112">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1113">下列範例會比較這兩個子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1113">The following example compares two substrings.</span></span>  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-1114"><paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1114"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="5f51e-1115">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1115">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1116"><paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1116"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="5f51e-1117">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1117">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1118"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1118"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-1119">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1119">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1120"><paramref name="indexA" /> 或 <paramref name="indexB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1120">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-1121"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1121"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-1122">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1122">Character sets include ignorable characters.</span></span> <span data-ttu-id="5f51e-1123"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />方法在執行語言或區分文化特性的比較時不會考慮這些字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1123">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-1124">若要識別可忽略的字元在比較中，提供的值<see cref="F:System.StringComparison.Ordinal" />或<see cref="F:System.StringComparison.OrdinalIgnoreCase" />如<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1124">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="5f51e-1125">要用於比較中的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1125">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="5f51e-1126"><c>strA</c> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1126">The position of the substring within <c>strA</c>.</span></span></param>
        <param name="strB"><span data-ttu-id="5f51e-1127">要用於比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1127">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="5f51e-1128"><c>strB</c> 中子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1128">The position of the substring within <c>strB</c>.</span></span></param>
        <param name="length"><span data-ttu-id="5f51e-1129">要比較之子字串的字元數上限。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1129">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="5f51e-1130"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1130"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="5f51e-1131">物件，提供文化特性相關的比較資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1131">An object that supplies culture-specific comparison information.</span></span></param>
        <summary><span data-ttu-id="5f51e-1132">比較兩個指定之 <see cref="T:System.String" /> 物件的子字串，忽略或區分兩者的大小寫，並使用文化特性資訊來影響比較，然後傳回一個整數，表示兩者在排序順序中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1132">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1133">整數，表示兩個比較元 (Comparand) 之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1133">An integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="5f51e-1134"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-1134"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-1135"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-1135"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-1136"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1136"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-1137"></term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1137"></term><description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-1138"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1138"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-1139"></term><description>子字串出現在排序次序中的相同位置，或 <paramref name="length" /> 為零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1139"></term><description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 <span data-ttu-id="5f51e-1140"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1140"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-1141"></term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1141"></term><description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1142">要比較之子字串開始`strA`在`indexA`，然後在`strB`在`indexB`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1142">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="5f51e-1143">同時`indexA`和`indexB`都是以零為起始，也就是中的第一個字元`strA`和`strB`是於零，並放在其中一個。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1143">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="5f51e-1144">第一個子字串的長度等於長度`strA`減去`indexA`再加 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1144">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="5f51e-1145">第二個的子字串長度的長度等於`strB`減去`indexB`再加 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1145">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="5f51e-1146">要比較的字元數為較小的兩個子字串的長度和`length`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1146">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="5f51e-1147">`indexA`， `indexB`，和`length`參數必須是非負值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1147">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="5f51e-1148">比較會使用`culture`參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1148">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="5f51e-1149">例如，某些字元的組合視為單一字元，或以特定方式，比較大寫和小寫字元，可以指定文化特性或字元的排序順序取決於前面的字元或請依照它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1149">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="5f51e-1150">使用字組的排序規則來進行比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1150">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="5f51e-1151">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1151">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5f51e-1152">一或兩個比較元可以是`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1152">One or both comparands can be `null`.</span></span> <span data-ttu-id="5f51e-1153">根據定義，任何字串，包括空字串 ("")，比較大於 null 參考。並比較等於其他兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1153">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="5f51e-1154">當探索到的不等比較，或兩個子字串有相較，則會結束比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1154">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="5f51e-1155">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，然後其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1155">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="5f51e-1156">傳回值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1156">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="5f51e-1157">比較會受到特定文化特性大小寫規則，就會發生非預期的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1157">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="5f51e-1158">比方說，在土耳其文，下列範例會產生錯誤結果因為土耳其文中的檔案系統不會使用語言大小寫規則的字母"i"中 「 檔案 」。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1158">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 <span data-ttu-id="5f51e-1159">比較路徑名稱為"file"使用序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1159">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="5f51e-1160">若要這樣做的正確程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1160">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1161">下列範例會比較這兩個子字串使用不同的文化特性並忽略大小寫的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1161">The following example compares two substrings using different cultures and ignoring the case of the substrings.</span></span> <span data-ttu-id="5f51e-1162">文化特性的選擇會影響如何的字母"I"都是比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1162">The choice of culture affects how the letter "I" is compared.</span></span>  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-1163"><paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1163"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="5f51e-1164">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1164">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1165"><paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1165"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="5f51e-1166">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1166">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1167"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1167"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-1168">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1168">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1169"><paramref name="strA" /> 或 <paramref name="strB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1169">Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1170"><paramref name="culture" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1170"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-1171">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1171">Character sets include ignorable characters.</span></span> <span data-ttu-id="5f51e-1172"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />方法在執行語言或區分文化特性的比較時不會考慮這些字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1172">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-1173">若要識別可忽略的字元在比較中，呼叫<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="options" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1173">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="5f51e-1174">要用於比較中的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1174">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="5f51e-1175"><c>strA</c> 中子字串的開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1175">The starting position of the substring within <c>strA</c>.</span></span></param>
        <param name="strB"><span data-ttu-id="5f51e-1176">要用於比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1176">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="5f51e-1177"><c>strB</c> 中子字串的開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1177">The starting position of the substring within <c>strB</c>.</span></span></param>
        <param name="length"><span data-ttu-id="5f51e-1178">要比較之子字串的字元數上限。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1178">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="culture"><span data-ttu-id="5f51e-1179">物件，提供文化特性相關的比較資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1179">An object that supplies culture-specific comparison information.</span></span></param>
        <param name="options"><span data-ttu-id="5f51e-1180">執行比較時要使用的選項 (例如忽略大小寫或符號)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1180">Options to use when performing the comparison (such as ignoring case or symbols).</span></span></param>
        <summary><span data-ttu-id="5f51e-1181">比較兩個指定的 <see cref="T:System.String" /> 物件的子字串，使用指定的比較選項及特定文化特性資訊影響比較，然後傳回整數，這個整數表示這兩個子字串在排序次序中彼此的關聯性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1181">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1182">整數，這個整數表示兩個子字串之間的語彙關係，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1182">An integer that indicates the lexical relationship between the two substrings, as shown in the following table.</span></span>  
  
 <span data-ttu-id="5f51e-1183"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-1183"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-1184"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-1184"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-1185"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1185"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-1186"></term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之前。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1186"></term><description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 <span data-ttu-id="5f51e-1187"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1187"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-1188"></term><description>子字串出現在排序次序中的相同位置，或 <paramref name="length" /> 為零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1188"></term><description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>  
  
 <span data-ttu-id="5f51e-1189"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1189"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-1190"></term><description> <paramref name="strA" /> 中的子字串的排序次序在 <paramref name="strB" /> 中的子字串之後。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1190"></term><description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1191">要比較之子字串開始`strA`位置`indexA`和`strB`位置`indexB`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1191">The substrings to compare start in `strA` at position `indexA` and in `strB` at position `indexB`.</span></span> <span data-ttu-id="5f51e-1192">第一個子字串的長度是長度`strA`減去`indexA`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1192">The length of the first substring is the length of `strA` minus `indexA`.</span></span> <span data-ttu-id="5f51e-1193">第二個的子字串的長度是長度`strB`減去`indexB`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1193">The length of the second substring is the length of `strB` minus `indexB`.</span></span>  
  
 <span data-ttu-id="5f51e-1194">要比較的字元數為較小的兩個子字串的長度和`length`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1194">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="5f51e-1195">`indexA`， `indexB`，和`length`參數必須是非負值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1195">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="5f51e-1196">比較會使用`culture`參數來取得特定文化特性資訊，例如大小寫規則和個別字元的字母順序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1196">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="5f51e-1197">例如，某些字元的組合視為單一字元、 大寫和小寫字元進行比較以特定的方式，可以指定特定文化特性或字元的排序次序取決於字元，與其前面或後面。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1197">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5f51e-1198"><xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>方法主要針對用於排序或依字母順序排列作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1198">The <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="5f51e-1199">此外，它不應該使用方法呼叫的主要目的是要判斷這兩個子字串是否相等 （也就是當方法呼叫的目的是要測試傳回值為零） 時。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1199">It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="5f51e-1200">若要判斷兩個字串是否相等，請呼叫<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1200">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="5f51e-1201">一或兩個`strA`和`strB`可以`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1201">One or both of `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="5f51e-1202">根據定義，任何字串，包括<xref:System.String.Empty?displayProperty=nameWithType>，比較彼此相等的比較大於 null 參考，且兩個 null 參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1202">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="5f51e-1203">比較可以進一步指定`options`參數，其中包含一個或多個成員<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1203">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="5f51e-1204">不過，因為此方法的目的是要進行區分文化特性的字串比較，<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>和<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>值沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1204">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>  
  
 <span data-ttu-id="5f51e-1205">當探索到的不等比較，或兩個子字串有相較，則會結束比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1205">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="5f51e-1206">不過，如果兩個字串比較等於一個的字串的結尾，而且其他字串有多餘的字元，其餘字元的字串被視為較大。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1206">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span> <span data-ttu-id="5f51e-1207">傳回值是執行的最後一個比對的結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1207">The return value is the result of the last comparison performed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1208">下列範例會使用<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>方法來比較兩個人員的姓氏。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1208">The following example uses the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method to compare the last names of two people.</span></span> <span data-ttu-id="5f51e-1209">它接著會列出它們依字母順序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1209">It then lists them in alphabetical order.</span></span>  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-1210"><paramref name="options" /> 不是 <see cref="T:System.Globalization.CompareOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1210"><paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-1211"><paramref name="indexA" /> 大於 <paramref name="strA" /><see langword=".Length" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1211"><paramref name="indexA" /> is greater than <paramref name="strA" /><see langword=".Length" />.</span></span>  
  
 <span data-ttu-id="5f51e-1212">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1212">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1213"><paramref name="indexB" /> 大於 <paramref name="strB" /><see langword=".Length" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1213"><paramref name="indexB" /> is greater than <paramref name="strB" /><see langword=".Length" />.</span></span>  
  
 <span data-ttu-id="5f51e-1214">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1214">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1215"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1215"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-1216">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1216">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1217"><paramref name="strA" /> 或 <paramref name="strB" /> 為 <see langword="null" />，且 <paramref name="length" /> 大於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1217">Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1218"><paramref name="culture" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1218"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-1219">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1219">Character sets include ignorable characters.</span></span> <span data-ttu-id="5f51e-1220"><see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法在執行語言或區分文化特性的比較時不會考慮這些字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1220">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-1221">若要識別可忽略的字元在比較中，提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />如<paramref name="options" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1221">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-1222">藉由評估每個字串中對應的 <see cref="T:System.String" /> 物件之數字值，比較兩個 <see cref="T:System.Char" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1222">Compares two <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="5f51e-1223">要比較的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1223">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="5f51e-1224">要比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1224">The second string to compare.</span></span></param>
        <summary><span data-ttu-id="5f51e-1225">藉由評估每個字串中對應的 <see cref="T:System.String" /> 物件之數字值，比較兩個指定 <see cref="T:System.Char" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1225">Compares two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1226">整數，表示兩個比較元 (Comparand) 之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1226">An integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="5f51e-1227"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-1227"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-1228"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-1228"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-1229"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1229"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-1230"></term><description><paramref name="strA" /> 小於 <paramref name="strB" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1230"></term><description><paramref name="strA" /> is less than <paramref name="strB" />.</span></span>  
  
 <span data-ttu-id="5f51e-1231"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1231"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-1232"></term><description><paramref name="strA" /> 和 <paramref name="strB" /> 相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1232"></term><description><paramref name="strA" /> and <paramref name="strB" /> are equal.</span></span>  
  
 <span data-ttu-id="5f51e-1233"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1233"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-1234"></term><description><paramref name="strA" /> 大於 <paramref name="strB" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1234"></term><description><paramref name="strA" /> is greater than <paramref name="strB" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1235">這個方法會執行區分大小寫比較，使用序數排序規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1235">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="5f51e-1236">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1236">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-1237">若要執行不區分大小寫比較，使用序數排序規則，呼叫<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法`comparisonType`引數設定為<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1237">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5f51e-1238">因為<xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>是靜態方法，`strA`和`strB`可以`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1238">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="5f51e-1239">如果這兩個值`null`，方法會傳回 0 （零），這表示`strA`和`strB`相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1239">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="5f51e-1240">如果只有其中一個值為`null`，方法會考慮較大的非 null 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1240">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1241">下列範例會執行並序數比較兩個字串只有大小寫不同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1241">The following example performs and ordinal comparison of two strings that only differ in case.</span></span>  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="5f51e-1242">要用於比較中的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1242">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="5f51e-1243"><c>strA</c> 中子字串的起始索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1243">The starting index of the substring in <c>strA</c>.</span></span></param>
        <param name="strB"><span data-ttu-id="5f51e-1244">要用於比較的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1244">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="5f51e-1245"><c>strB</c> 中子字串的起始索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1245">The starting index of the substring in <c>strB</c>.</span></span></param>
        <param name="length"><span data-ttu-id="5f51e-1246">要比較之子字串的字元數上限。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1246">The maximum number of characters in the substrings to compare.</span></span></param>
        <summary><span data-ttu-id="5f51e-1247">藉由評估每個子字串中對應的 <see cref="T:System.String" /> 物件之數字值，比較兩個指定的 <see cref="T:System.Char" /> 物件之子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1247">Compares substrings of two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each substring.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1248">32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1248">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>  
  
 <span data-ttu-id="5f51e-1249"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-1249"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-1250"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-1250"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-1251"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1251"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-1252"></term><description><paramref name="strA" /> 中的子字串小於 <paramref name="strB" /> 中的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1252"></term><description> The substring in <paramref name="strA" /> is less than the substring in <paramref name="strB" />.</span></span>  
  
 <span data-ttu-id="5f51e-1253"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1253"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-1254"></term><description>子字串相等，或者 <paramref name="length" /> 為零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1254"></term><description> The substrings are equal, or <paramref name="length" /> is zero.</span></span>  
  
 <span data-ttu-id="5f51e-1255"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1255"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-1256"></term><description><paramref name="strA" /> 中的子字串大於 <paramref name="strB" /> 中的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1256"></term><description> The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1257">`indexA`， `indexB`，和`length`參數必須是非負值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1257">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="5f51e-1258">比較的字元數為較小的長度`strA`較少`indexA`，長度`strB`較少`indexB`，和`length`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1258">The number of characters compared is the lesser of the length of `strA` less `indexA`, the length of `strB` less `indexB`, and `length`.</span></span>  
  
 <span data-ttu-id="5f51e-1259">這個方法會執行區分大小寫比較，使用序數排序規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1259">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="5f51e-1260">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1260">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-1261">若要執行不區分大小寫比較，使用序數排序規則，呼叫<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>方法`comparisonType`引數設定為<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1261">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5f51e-1262">因為<xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>是靜態方法，`strA`和`strB`可以`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1262">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="5f51e-1263">如果這兩個值`null`，方法會傳回 0 （零），這表示`strA`和`strB`相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1263">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="5f51e-1264">如果只有其中一個值為`null`，方法會考慮較大的非 null 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1264">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1265">下列範例會示範<xref:System.String.CompareOrdinal%2A>和<xref:System.String.Compare%2A>使用不同排序順序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1265">This following example demonstrates that <xref:System.String.CompareOrdinal%2A> and <xref:System.String.Compare%2A> use different sort orders.</span></span>  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-1266"><paramref name="strA" /> 不是 <see langword="null" />，<paramref name="indexA" /> 大於 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1266"><paramref name="strA" /> is not <see langword="null" /> and <paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="5f51e-1267">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1267">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1268"><paramref name="strB" /> 不是 <see langword="null" />，<paramref name="indexB" /> 大於 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1268"><paramref name="strB" /> is not <see langword="null" /> and <paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>  
  
 <span data-ttu-id="5f51e-1269">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1269">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1270"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 是負數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1270"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span></exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-1271">比較這個執行個體與指定的物件或 <see cref="T:System.String" />，並傳回一個整數，指出這個執行個體在排序次序中，位於指定物件或 <see cref="T:System.String" /> 之前、之後或相同位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1271">Compares this instance with a specified object or <see cref="T:System.String" /> and returns an integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified object or <see cref="T:System.String" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1272">這兩個多載<xref:System.String.CompareTo%2A>方法執行區分文化特性和區分大小寫的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1272">Both overloads of the <xref:System.String.CompareTo%2A> method perform culture-sensitive and case-sensitive comparison.</span></span> <span data-ttu-id="5f51e-1273">您無法使用這個方法來執行不區分文化特性或序數比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1273">You cannot use this method to perform culture-insensitive or ordinal comparisons.</span></span> <span data-ttu-id="5f51e-1274">程式碼的清楚起見，我們建議您避免<xref:System.String.CompareTo%2A>方法，並呼叫<xref:System.String.Compare%2A>方法改為。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1274">For code clarity, we recommend that you avoid the <xref:System.String.CompareTo%2A> method and call the <xref:System.String.Compare%2A> method instead.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-1275">評估為 <see cref="T:System.String" /> 的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1275">An object that evaluates to a <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="5f51e-1276">比較這個執行個體與指定的 <see cref="T:System.Object" />，並且指出這個執行個體在排序次序中，位於所指定 <see cref="T:System.Object" /> 之前、之後或相同位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1276">Compares this instance with a specified <see cref="T:System.Object" /> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1277">32 位元帶正負號的整數，指出這個執行個體在排序次序中，位於 <paramref name="value" /> 參數之前、之後或相同位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1277">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="value" /> parameter.</span></span>  
  
 <span data-ttu-id="5f51e-1278"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-1278"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-1279"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-1279"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-1280"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1280"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-1281"></term><description>這個執行個體位於 <paramref name="value" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1281"></term><description> This instance precedes <paramref name="value" />.</span></span>  
  
 <span data-ttu-id="5f51e-1282"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1282"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-1283"></term><description>這個執行個體在排序次序中的位置與 <paramref name="value" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1283"></term><description> This instance has the same position in the sort order as <paramref name="value" />.</span></span>  
  
 <span data-ttu-id="5f51e-1284"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1284"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-1285"></term><description>這個執行個體位於 <paramref name="value" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1285"></term><description> This instance follows <paramref name="value" />.</span></span>  
  
 <span data-ttu-id="5f51e-1286">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1286">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1287"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1287"><paramref name="value" /> is <see langword="null" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1288">`value` 必須是<xref:System.String>物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1288">`value` must be a <xref:System.String> object.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5f51e-1289"><xref:System.String.CompareTo%2A>方法依設計主要是用於排序或依字母順序排列作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1289">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="5f51e-1290">此外，它不應該使用當方法呼叫的主要目的是要判斷兩個字串是否相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1290">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="5f51e-1291">若要判斷兩個字串是否相等，請呼叫<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1291">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="5f51e-1292">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1292">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="5f51e-1293">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1293">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5f51e-1294">這個方法的行為的詳細資訊，請參閱的 < 備註 > 一節<xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1294">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1295">下列範例會使用<xref:System.String.CompareTo%2A>方法<xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1295">The following example uses the <xref:System.String.CompareTo%2A> method with an <xref:System.Object>.</span></span> <span data-ttu-id="5f51e-1296">因為它嘗試比較<xref:System.String>執行個體`TestClass`物件，方法會擲回<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1296">Because it attempts to compare a <xref:System.String> instance to a `TestClass` object, the method throws an <xref:System.ArgumentException>.</span></span>  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-1297"><paramref name="value" /> 不是 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1297"><paramref name="value" /> is not a <see cref="T:System.String" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-1298">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1298">Character sets include ignorable characters.</span></span> <span data-ttu-id="5f51e-1299"><see cref="M:System.String.CompareTo(System.Object)" />方法執行區分文化特性的比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1299">The <see cref="M:System.String.CompareTo(System.Object)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-1300">例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，"動物 」 與 「 ani 郵件 」 （使用選擇性連字號或 U + 00AD） 的比較，表示兩個字串相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1300">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
 [!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)]
 [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]  
  
 <span data-ttu-id="5f51e-1301">若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.CompareOrdinal(System.String,System.String)" />方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1301">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</span></span></para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB"><span data-ttu-id="5f51e-1302">要和這個執行個體比較的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1302">The string to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="5f51e-1303">比較這個執行個體與指定的 <see cref="T:System.String" /> 物件，並且表示這個執行個體在排序次序中，位於所指定字串之前、之後或相同位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1303">Compares this instance with a specified <see cref="T:System.String" /> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1304">32 位元帶正負號的整數，指出這個執行個體在排序次序中，位於 <paramref name="strB" /> 參數之前、之後或相同位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1304">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="strB" /> parameter.</span></span>  
  
 <span data-ttu-id="5f51e-1305"><list type="table"><listheader><term> 值</span><span class="sxs-lookup"><span data-stu-id="5f51e-1305"><list type="table"><listheader><term> Value</span></span>  
  
 <span data-ttu-id="5f51e-1306"></term><description>條件</span><span class="sxs-lookup"><span data-stu-id="5f51e-1306"></term><description> Condition</span></span>  
  
 <span data-ttu-id="5f51e-1307"></description></listheader><item><term>小於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1307"></description></listheader><item><term> Less than zero</span></span>  
  
 <span data-ttu-id="5f51e-1308"></term><description>這個執行個體位於 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1308"></term><description> This instance precedes <paramref name="strB" />.</span></span>  
  
 <span data-ttu-id="5f51e-1309"></description></item><item><term> 零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1309"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="5f51e-1310"></term><description>這個執行個體在排序次序中的位置與 <paramref name="strB" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1310"></term><description> This instance has the same position in the sort order as <paramref name="strB" />.</span></span>  
  
 <span data-ttu-id="5f51e-1311"></description></item><item><term> 大於零</span><span class="sxs-lookup"><span data-stu-id="5f51e-1311"></description></item><item><term> Greater than zero</span></span>  
  
 <span data-ttu-id="5f51e-1312"></term><description>這個執行個體位於 <paramref name="strB" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1312"></term><description> This instance follows <paramref name="strB" />.</span></span>  
  
 <span data-ttu-id="5f51e-1313">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1313">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1314"><paramref name="strB" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1314"><paramref name="strB" /> is <see langword="null" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1315">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1315">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="5f51e-1316">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1316">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5f51e-1317"><xref:System.String.CompareTo%2A>方法依設計主要是用於排序或依字母順序排列作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1317">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="5f51e-1318">此外，它不應該使用當方法呼叫的主要目的是要判斷兩個字串是否相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1318">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="5f51e-1319">若要判斷兩個字串是否相等，請呼叫<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1319">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="5f51e-1320">這個方法的行為的詳細資訊，請參閱的 < 備註 > 一節<xref:System.String.Compare%28System.String%2CSystem.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1320">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29> method.</span></span>  
  
 <span data-ttu-id="5f51e-1321">這個方法會實作<xref:System.IComparable%601?displayProperty=nameWithType>介面並執行稍微優於<xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType>方法，因為它沒有判斷是否`strB`引數是可變動的值型別，必須為 boxed 而且不需要轉換其從參數<xref:System.Object>至<xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1321">This method implements the <xref:System.IComparable%601?displayProperty=nameWithType> interface and performs slightly better than the <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> method, because it does not have to determine whether the `strB` argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <xref:System.Object> to a <xref:System.String>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1322">下列範例會使用<xref:System.String.CompareTo%2A>方法來比較目前的字串執行個體，以另一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1322">The following example uses the <xref:System.String.CompareTo%2A> method to compare the current string instance with another string.</span></span>  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 <span data-ttu-id="5f51e-1323">下列範例會示範 CompareTo 方法的數個值和參考類型的泛型和非泛型版本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1323">The following example demonstrates generic and non-generic versions of the CompareTo method for several value and reference types.</span></span>  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-1324">字元集包含可忽略的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1324">Character sets include ignorable characters.</span></span> <span data-ttu-id="5f51e-1325"><see cref="M:System.String.CompareTo(System.String)" />方法執行區分文化特性的比較時不會考慮這類字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1325">The <see cref="M:System.String.CompareTo(System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-1326">例如，如果執行下列程式碼[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，"動物 」 與 「 ani 郵件 」 （使用選擇性連字號或 U + 00AD） 的比較，表示兩個字串相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1326">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>  
  
 [!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)]
 [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]  
  
 <span data-ttu-id="5f51e-1327">若要識別可忽略的字元字串比較中，呼叫<see cref="M:System.String.CompareOrdinal(System.String,System.String)" />方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1327">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</span></span></para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-1328">串連一或多個 <see cref="T:System.String" /> 執行個體，或者一或多個 <see cref="T:System.String" /> 執行個體值的 <see cref="T:System.Object" /> 表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1328">Concatenates one or more instances of <see cref="T:System.String" />, or the <see cref="T:System.String" /> representations of the values of one or more instances of <see cref="T:System.Object" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values"><span data-ttu-id="5f51e-1329">集合物件，這個物件實作 <see cref="T:System.Collections.Generic.IEnumerable`1" />，且其泛型類型引數為 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1329">A collection object that implements <see cref="T:System.Collections.Generic.IEnumerable`1" /> and whose generic type argument is <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="5f51e-1330">串連類型 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 之已建構的 <see cref="T:System.String" /> 集合的成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1330">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1331"><paramref name="values" /> 中的串連字串，或如果 <paramref name="values" /> 是空白的 <see langword="IEnumerable(Of String)" />則為 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1331">The concatenated strings in <paramref name="values" />, or <see cref="F:System.String.Empty" /> if <paramref name="values" /> is an empty <see langword="IEnumerable(Of String)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1332">方法會串連中的每個物件`values`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1332">The method concatenates each object in `values`; it does not add any delimiters.</span></span> <span data-ttu-id="5f51e-1333">若要指定的每個成員之間的分隔符號`values`，呼叫<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1333">To specify a delimiter between each member of `values`, call the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 <span data-ttu-id="5f51e-1334"><xref:System.String.Empty>字串來取代任何 null 元素`values`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1334">An <xref:System.String.Empty> string is used in place of any null element in `values`.</span></span>  
  
 <span data-ttu-id="5f51e-1335">如果`values`是空白`IEnumerable(Of String)`，方法會傳回<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1335">If `values` is an empty `IEnumerable(Of String)`, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-1336">如果`values`是`null`，方法會擲回<xref:System.ArgumentNullException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1336">If `values` is `null`, the method throws an <xref:System.ArgumentNullException> exception.</span></span>  
  
 <span data-ttu-id="5f51e-1337"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 是便利的方法，可讓您在串連每個項目`IEnumerable(Of String)`集合，而不先將項目轉換成字串陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1337"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="5f51e-1338">它特別適合使用 Language-Integrated Query (LINQ) 查詢運算式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1338">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="5f51e-1339">下列範例會傳遞`List(Of String)`物件，其中包含英文字母給 lambda 運算式會選取等於或大於特定的字母 （即，在範例中，"M"） 的字母大寫或小寫字母。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1339">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="5f51e-1340">`IEnumerable(Of String)`所傳回的集合<xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>方法傳遞至<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法來顯示以單一字串結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1340">The `IEnumerable(Of String)` collection that is returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1341">下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1341">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="5f51e-1342">它會將結果指派<xref:System.Collections.Generic.List%601>型別的物件<xref:System.String>，這會接著傳遞給<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1342">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1343"><paramref name="values" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1343"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="5f51e-1344">要表示的物件，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1344">The object to represent, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="5f51e-1345">建立指定之物件的字串表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1345">Creates the string  representation of a specified object.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1346"><paramref name="arg0" /> 值的字串表示；如果 <see cref="F:System.String.Empty" /> 為 <paramref name="arg0" />，則為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1346">The string representation of the value of <paramref name="arg0" />, or <see cref="F:System.String.Empty" /> if <paramref name="arg0" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1347"><xref:System.String.Concat%28System.Object%29>方法代表`arg0`藉由呼叫其無參數的字串為`ToString`方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1347">The <xref:System.String.Concat%28System.Object%29> method represents `arg0` as a string by calling its parameterless `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1348">下列範例會示範<xref:System.String.Concat%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1348">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="5f51e-1349">包含要串連之項目的物件陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1349">An object array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="5f51e-1350">串連指定之 <see cref="T:System.Object" /> 陣列中項目的字串表示法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1350">Concatenates the string representations of the elements in a specified <see cref="T:System.Object" /> array.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1351"><paramref name="args" /> 中之項目值的串連字串表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1351">The concatenated string representations of the values of the elements in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1352">方法會串連中的每個物件`args`藉由呼叫無參數`ToString`方法，該物件; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1352">The method concatenates each object in `args` by calling the parameterless `ToString` method of that object; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="5f51e-1353"><xref:System.String.Empty?displayProperty=nameWithType> 用來在陣列中的任何 null 物件取代。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1353"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1354">下列範例示範如何使用<xref:System.String.Concat%2A>方法<xref:System.Object>陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1354">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with an <xref:System.Object> array.</span></span>  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1355"><paramref name="args" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1355"><paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="5f51e-1356">記憶體不足。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1356">Out of memory.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-1357">由 c + + 程式碼，不會呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1357">This method is not called by C++ code.</span></span> <span data-ttu-id="5f51e-1358">C + + 編譯器會解析呼叫<see cref="Overload:System.String.Concat" />具有四個或多個物件的參數與呼叫<see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1358">The C++ compiler resolves calls to <see cref="Overload:System.String.Concat" /> that have four or more object parameters as a call to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</span></span></para>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values"><span data-ttu-id="5f51e-1359">字串執行個體的陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1359">An array of string instances.</span></span></param>
        <summary><span data-ttu-id="5f51e-1360">串連指定 <see cref="T:System.String" /> 陣列中的項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1360">Concatenates the elements of a specified <see cref="T:System.String" /> array.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1361"><paramref name="values" /> 的串連項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1361">The concatenated elements of <paramref name="values" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1362">方法會串連中的每個物件`values`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1362">The method concatenates each object in `values`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="5f51e-1363"><xref:System.String.Empty>字串來取代任何陣列中的 null 物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1363">An <xref:System.String.Empty> string is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1364">下列範例示範如何使用<xref:System.String.Concat%2A>方法<xref:System.String>陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1364">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with a <xref:System.String> array.</span></span>  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1365"><paramref name="values" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1365"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="5f51e-1366">記憶體不足。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1366">Out of memory.</span></span></exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="5f51e-1367">要串連的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1367">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="5f51e-1368">要串連的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1368">The second object to concatenate.</span></span></param>
        <summary><span data-ttu-id="5f51e-1369">串連兩個指定之物件的字串表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1369">Concatenates the string representations of two specified objects.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1370"><paramref name="arg0" /> 和 <paramref name="arg1" /> 之值的串連字串表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1370">The concatenated string representations of the values of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1371">方法會串連`arg0`和`arg1`藉由呼叫無參數`ToString`方法`arg0`和`arg1`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1371">The method concatenates `arg0` and `arg1` by calling the parameterless `ToString` method of `arg0` and `arg1`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="5f51e-1372"><xref:System.String.Empty?displayProperty=nameWithType> 會使用來取代任何 null 引數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1372"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
 <span data-ttu-id="5f51e-1373">如果是引數的陣列參考，方法會串連字串，表示該陣列，而不是其成員 (例如，"System.String[]")。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1373">If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1374">下列範例會示範<xref:System.String.Concat%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1374">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="5f51e-1375">要串連的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1375">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="5f51e-1376">要串連的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1376">The second string to concatenate.</span></span></param>
        <summary><span data-ttu-id="5f51e-1377">串連 <see cref="T:System.String" /> 的兩個指定執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1377">Concatenates two specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1378"><paramref name="str0" /> 和 <paramref name="str1" /> 的串連。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1378">The concatenation of <paramref name="str0" /> and <paramref name="str1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1379">方法會串連`str0`和`str1`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1379">The method concatenates `str0` and `str1`; it does not add any delimiters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-1380">您可以也使用您語言的字串串連運算子，例如`+`在 C# 中，或`&`和`+`在 Visual Basic 中)</span><span class="sxs-lookup"><span data-stu-id="5f51e-1380">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)</span></span>  
>   
>  <span data-ttu-id="5f51e-1381">將字串串連。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1381">, to concatenate strings.</span></span>  
  
 <span data-ttu-id="5f51e-1382"><xref:System.String.Empty>字串來取代任何 null 引數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1382">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1383">下列範例會串連個人的名字、 中間名和姓氏的名稱。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1383">The following example concatenates a person's first, middle, and last name.</span></span>  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="5f51e-1384">要串連的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1384">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="5f51e-1385">要串連的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1385">The second object to concatenate.</span></span></param>
        <param name="arg2"><span data-ttu-id="5f51e-1386">要串連的第三個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1386">The third object to concatenate.</span></span></param>
        <summary><span data-ttu-id="5f51e-1387">串連三個指定之物件的字串表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1387">Concatenates the string representations of three specified objects.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1388"><paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 之值的串連字串表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1388">The concatenated string representations of the values of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1389">方法會串連`arg0`， `arg1`，和`arg2`藉由呼叫無參數`ToString`方法的每個物件; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1389">The method concatenates `arg0`, `arg1`, and `arg2` by calling the parameterless `ToString` method of each object; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="5f51e-1390"><xref:System.String.Empty?displayProperty=nameWithType> 會使用來取代任何 null 引數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1390"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1391">下列範例會示範<xref:System.String.Concat%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1391">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="5f51e-1392">要串連的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1392">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="5f51e-1393">要串連的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1393">The second string to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="5f51e-1394">要串連的第三個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1394">The third string to concatenate.</span></span></param>
        <summary><span data-ttu-id="5f51e-1395">串連 <see cref="T:System.String" /> 的三個指定執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1395">Concatenates three specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1396"><paramref name="str0" />、<paramref name="str1" /> 和 <paramref name="str2" /> 的串連。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1396">The concatenation of <paramref name="str0" />, <paramref name="str1" />, and <paramref name="str2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1397">方法會串連`str0`， `str1`，和`str2`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1397">The method concatenates `str0`, `str1`, and `str2`; it does not add any delimiters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-1398">您可以也使用您語言的字串串連運算子，例如`+`在 C# 中，或`&`和`+`在 Visual Basic 中)</span><span class="sxs-lookup"><span data-stu-id="5f51e-1398">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)</span></span>  
>   
>  <span data-ttu-id="5f51e-1399">將字串串連。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1399">, to concatenate strings.</span></span>  
  
 <span data-ttu-id="5f51e-1400"><xref:System.String.Empty>字串來取代任何 null 引數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1400">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1401">下列範例會使用<xref:System.String.Concat%2A>方法來串連三個字串，並顯示結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1401">The following example uses the <xref:System.String.Concat%2A> method to concatenate three strings and displays the result.</span></span>  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="5f51e-1402">要串連的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1402">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="5f51e-1403">要串連的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1403">The second object to concatenate.</span></span></param>
        <param name="arg2"><span data-ttu-id="5f51e-1404">要串連的第三個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1404">The third object to concatenate.</span></span></param>
        <param name="arg3"><span data-ttu-id="5f51e-1405">要串連的第四個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1405">The fourth object to concatenate.</span></span></param>
        <summary><span data-ttu-id="5f51e-1406">串連四個指定的物件之字串表示和選擇性變數長度參數清單中所指定的任何物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1406">Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1407">參數清單中每個值的已串連字串表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1407">The concatenated string representation of each value in the parameter list.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-1408">此應用程式開發介面不符合 CLS 標準。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1408">This API is not CLS-compliant.</span></span> <span data-ttu-id="5f51e-1409">符合 CLS 標準的替代項目為 <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1409">The CLS-compliant alternative is <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-1410">C# 和 Visual Basic 編譯器自動解決與呼叫此方法的呼叫<xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1410">The C# and Visual Basic compilers automatically resolve a call to this method as a call to <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5f51e-1411">此方法透過呼叫其無參數串連參數清單中的每個物件`ToString`方法; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1411">The method concatenates each object in the parameter list by calling its parameterless `ToString` method; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="5f51e-1412"><xref:System.String.Empty?displayProperty=nameWithType> 會使用來取代任何 null 引數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1412"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-1413">最後一個參數<xref:System.String.Concat%2A>方法是串連的一個或多個其他物件的選擇性逗號分隔清單。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1413">The last parameter of the  <xref:System.String.Concat%2A> method is an optional comma-delimited list of one or more additional objects to concatenate.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1414">下列範例說明使用<xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>来串連的變數參數清單的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1414">The following example illustrates the use of the <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to concatenate a list of variable parameters.</span></span> <span data-ttu-id="5f51e-1415">在此情況下，方法被呼叫有 9 個參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1415">In this case, the method is called with nine parameters.</span></span>  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-1416">這個方法會標示<see langword="vararg" />關鍵字，這表示它支援多個參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1416">This method is marked with the <see langword="vararg" /> keyword, which means that it supports a variable number of parameters.</span></span> <span data-ttu-id="5f51e-1417">可以從 Visual c + + 中，呼叫此方法，但不能從 C# 或 Visual Basic 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1417">The method can be called from Visual C++, but it cannot be called from C# or Visual Basic code.</span></span> <span data-ttu-id="5f51e-1418">C# 和 Visual Basic 編譯器將呼叫解析為<see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />做為呼叫<see cref="M:System.String.Concat(System.Object[])" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1418">The C# and Visual Basic compilers resolve calls to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> as calls to <see cref="M:System.String.Concat(System.Object[])" />.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="5f51e-1419">要串連的第一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1419">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="5f51e-1420">要串連的第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1420">The second string to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="5f51e-1421">要串連的第三個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1421">The third string to concatenate.</span></span></param>
        <param name="str3"><span data-ttu-id="5f51e-1422">要串連的第四個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1422">The fourth string to concatenate.</span></span></param>
        <summary><span data-ttu-id="5f51e-1423">串連 <see cref="T:System.String" /> 的四個指定執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1423">Concatenates four specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1424"><paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" /> 和 <paramref name="str3" /> 的串連。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1424">The concatenation of <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />, and <paramref name="str3" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1425">方法會串連`str0`， `str1`， `str2`，和`str3`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1425">The method concatenates `str0`, `str1`, `str2`, and `str3`; it does not add any delimiters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-1426">您可以也使用您語言的字串串連運算子，例如`+`在 C# 中，或`&`和`+`在 Visual Basic 中)</span><span class="sxs-lookup"><span data-stu-id="5f51e-1426">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)</span></span>  
>   
>  <span data-ttu-id="5f51e-1427">將字串串連。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1427">, to concatenate strings.</span></span>  
  
 <span data-ttu-id="5f51e-1428"><xref:System.String.Empty>字串來取代任何陣列中的 null 物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1428">An <xref:System.String.Empty> string is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1429">下列範例定義的四個-字母的文字陣列，並將字串陣列，其個別字母儲存才能弄亂它們。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1429">The following example defines an array of four-letter words and stores their individual letters to a string array in order to scramble them.</span></span> <span data-ttu-id="5f51e-1430">然後它會呼叫<xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29>方法來切割變碼的單字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1430">It then calls the <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> method to reassemble the scrambled words.</span></span>  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="5f51e-1431">之成員的型別<c>值</c>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1431">The type of the members of <c>values</c>.</span></span></typeparam>
        <param name="values"><span data-ttu-id="5f51e-1432">集合物件，這個物件實作 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 介面。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1432">A collection object that implements the <see cref="T:System.Collections.Generic.IEnumerable`1" /> interface.</span></span></param>
        <summary><span data-ttu-id="5f51e-1433">串連 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 實作的成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1433">Concatenates the members of an <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementation.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1434"><paramref name="values" /> 中的串連成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1434">The concatenated members in <paramref name="values" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1435">方法會串連中的每個物件`values`; 它不會新增任何分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1435">The method concatenates each object in `values`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="5f51e-1436"><xref:System.String.Empty>字串來取代任何 null 引數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1436">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
 <span data-ttu-id="5f51e-1437"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 是便利的方法，可讓您在串連每個項目<xref:System.Collections.Generic.IEnumerable%601>而不先將項目轉換為字串的集合。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1437"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each element in an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting the elements to strings.</span></span> <span data-ttu-id="5f51e-1438">就非常有用使用 Language-Integrated Query (LINQ) 查詢運算式，如範例所示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1438">It is particularly useful with Language-Integrated Query (LINQ) query expressions, as the example illustrates.</span></span> <span data-ttu-id="5f51e-1439">在每個物件的字串表示<xref:System.Collections.Generic.IEnumerable%601>集合藉由呼叫該物件衍生`ToString`方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1439">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1440">下列範例會定義非常簡單`Animal`類別，其中包含代表動物以及其所屬的順序的名稱。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1440">The following example defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="5f51e-1441">然後它會定義<xref:System.Collections.Generic.List%601>物件包含的數字`Animal`物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1441">It then defines a <xref:System.Collections.Generic.List%601> object to contain a number of `Animal` objects.</span></span> <span data-ttu-id="5f51e-1442"><xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>擴充方法呼叫以擷取`Animal`物件`Order`屬性等於"齧齒動物"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1442">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="5f51e-1443">結果會傳遞至<xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法並顯示到主控台。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1443">The result is passed to the <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> method and displayed to the console.</span></span>  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1444"><paramref name="values" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1444"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-1445">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1445">The string to seek.</span></span></param>
        <summary><span data-ttu-id="5f51e-1446">傳回值，這個值表示指定的子字串是否會出現在這個字串內。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1446">Returns a value indicating whether a specified substring occurs within this string.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-1447">如果 <see langword="true" /> 參數出現在這個字串內，或是 <paramref name="value" /> 為空字串 ("")，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1447"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string, or if <paramref name="value" /> is the empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1448">這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1448">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span> <span data-ttu-id="5f51e-1449">這個字串的第一個字元位置開始搜尋，並繼續完成最後一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1449">The search begins at the first character position of this string and continues through the last character position.</span></span>  
  
 <span data-ttu-id="5f51e-1450">若要判斷字串是否包含指定的子字串使用序數比較 （例如，區分文化特性的比較或不區分大小寫的序數比較） 以外的項目，您可以建立自訂的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1450">To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method.</span></span> <span data-ttu-id="5f51e-1451">下列範例將示範一個這類方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1451">The following example illustrates one such approach.</span></span> <span data-ttu-id="5f51e-1452">它會定義<xref:System.String>擴充方法，其中包含<xref:System.StringComparison>參數，表示使用指定的格式字串比較的字串是否包含子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1452">It defines a <xref:System.String> extension method  that includes a <xref:System.StringComparison> parameter and indicates whether a string contains a substring when using the specified form of string comparison.</span></span>  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 <span data-ttu-id="5f51e-1453">下列範例會接著呼叫`Contains`擴充方法，以判斷子字串是否要使用序數比較和區分大小寫的序數比較時的字串中找到。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1453">The following example then calls the `Contains` extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 <span data-ttu-id="5f51e-1454">如果您有興趣的子字串的位置`value`在目前的執行個體，您可以呼叫<xref:System.String.IndexOf%2A>方法來取得的開始位置的第一個相符項，或者您可以呼叫<xref:System.String.LastIndexOf%2A>方法來取得的開始位置其上一次。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1454">If you are interested in the position of the substring `value` in the current instance, you can call the <xref:System.String.IndexOf%2A> method to get the starting position of its first occurrence, or you can call the <xref:System.String.LastIndexOf%2A> method to get the starting position of its last occurrence.</span></span> <span data-ttu-id="5f51e-1455">此範例包含呼叫<xref:System.String.IndexOf%28System.String%29>方法，如果找到子字串的字串執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1455">The example includes a call to the <xref:System.String.IndexOf%28System.String%29> method if a substring is found in a string instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1456">下列範例會判斷"fox"字串是否具有類似引號的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1456">The following example determines whether the string "fox" is a substring of a familiar quotation.</span></span> <span data-ttu-id="5f51e-1457">如果字串中找到"fox"，它也會顯示其開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1457">If "fox" is found in the string, it also displays its starting position.</span></span>  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1458"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1458"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="5f51e-1459">要複製的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1459">The string to copy.</span></span></param>
        <summary><span data-ttu-id="5f51e-1460">使用與指定的 <see cref="T:System.String" /> 相同的值，建立 <see cref="T:System.String" /> 的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1460">Creates a new instance of <see cref="T:System.String" /> with the same value as a specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1461">具有與 <paramref name="str" /> 相同值的新字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1461">A new string with the same value as <paramref name="str" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1462"><xref:System.String.Copy%2A>方法會傳回<xref:System.String>具有相同的值做為原始字串，但代表不同的物件參考的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1462">The <xref:System.String.Copy%2A> method returns a <xref:System.String> object that has the same value as the original string but represents a different object reference.</span></span> <span data-ttu-id="5f51e-1463">它與不同的指派作業，將現有的字串參考其他物件變數指派。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1463">It differs from an assignment operation, which assigns an existing string reference to an additional object variable.</span></span> <span data-ttu-id="5f51e-1464">此範例會說明其間的差異。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1464">The example illustrates the difference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1465">下列範例會建立兩個字串物件與不同的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1465">The following example creates two string objects with different values.</span></span> <span data-ttu-id="5f51e-1466">當呼叫<xref:System.String.Copy%2A>方法來將第一個值指派給第二個字串，輸出會指出雖然其值現在是否相等的字串，代表不同的物件參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1466">When it calls the <xref:System.String.Copy%2A> method to assign the first value to the second string, the output indicates that the strings represent different object references although their values are now equal.</span></span> <span data-ttu-id="5f51e-1467">相反地，當第一個字串指派給第二個字串時，兩個字串有相同的值因為它們代表相同的物件參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1467">On the other hand, when the first string is assigned to the second string, the two strings have identical values because they represent the same object reference.</span></span>  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1468"><paramref name="str" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1468"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex"><span data-ttu-id="5f51e-1469">這個要複製的執行個體中第一個字元的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1469">The index of the first character in this instance to copy.</span></span></param>
        <param name="destination"><span data-ttu-id="5f51e-1470">複製這個執行個體之字元的目標 Unicode 字元陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1470">An array of Unicode characters to which characters in this instance are copied.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="5f51e-1471">在 <c>destination</c> 中開始複製作業的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1471">The index in <c>destination</c> at which the copy operation begins.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-1472">這個執行個體中要複製到 <c>destination</c> 的字元數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1472">The number of characters in this instance to copy to <c>destination</c>.</span></span></param>
        <summary><span data-ttu-id="5f51e-1473">將字元的指定數目從這個執行個體的指定位置，複製到 Unicode 字元陣列的指定位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1473">Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1474">這個方法會複製`count`字元`sourceIndex`這個執行個體的位置`destinationIndex`位置`destination`字元陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1474">This method copies `count` characters from the `sourceIndex` position of this instance to the `destinationIndex` position of `destination` character array.</span></span> <span data-ttu-id="5f51e-1475">這個方法不會調整大小`destination`字元陣列; 它必須有足夠數目的項目，容納已複製的字元，或在方法擲回<xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1475">This method does not resize the `destination` character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="5f51e-1476">`sourceIndex` 和`destinationIndex`是以零起始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1476">`sourceIndex` and `destinationIndex` are zero-based.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1477">下列範例會示範<xref:System.String.CopyTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1477">The following example demonstrates the <xref:System.String.CopyTo%2A> method.</span></span>  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1478"><paramref name="destination" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1478"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-1479"><paramref name="sourceIndex" />、<paramref name="destinationIndex" /> 或 <paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1479"><paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" /> is negative</span></span>  
  
 <span data-ttu-id="5f51e-1480">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1480">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1481"><paramref name="sourceIndex" /> 未識別目前執行個體中的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1481"><paramref name="sourceIndex" /> does not identify a position in the current instance.</span></span>  
  
 <span data-ttu-id="5f51e-1482">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1482">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1483"><paramref name="destinationIndex" /> 未識別 <paramref name="destination" /> 陣列中的有效索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1483"><paramref name="destinationIndex" /> does not identify a valid index in the <paramref name="destination" /> array.</span></span>  
  
 <span data-ttu-id="5f51e-1484">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1484">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1485"><paramref name="count" /> 大於從 <paramref name="sourceIndex" /> 到這個執行個體結尾的子字串長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1485"><paramref name="count" /> is greater than the length of the substring from <paramref name="sourceIndex" /> to the end of this instance</span></span>  
  
 <span data-ttu-id="5f51e-1486">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1486">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1487"><paramref name="count" /> 大於從 <paramref name="destinationIndex" /> 到 <paramref name="destination" /> 陣列結尾的子陣列長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1487"><paramref name="count" /> is greater than the length of the subarray from <paramref name="destinationIndex" /> to the end of the <paramref name="destination" /> array.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5f51e-1488">表示空字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1488">Represents the empty string.</span></span> <span data-ttu-id="5f51e-1489">此欄位為唯讀。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1489">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1490">這個欄位的值是零長度字串""。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1490">The value of this field is the zero-length string, "".</span></span>  
  
 <span data-ttu-id="5f51e-1491">在應用程式碼中，這個欄位是最常用於指派中初始化為空字串的字串變數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1491">In application code, this field is most commonly used in assignments to initialize a string variable to an empty string.</span></span> <span data-ttu-id="5f51e-1492">若要測試的字串值是否`null`或<xref:System.String.Empty?displayProperty=nameWithType>，使用<xref:System.String.IsNullOrEmpty%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1492">To test whether the value of a string is either `null` or <xref:System.String.Empty?displayProperty=nameWithType>, use the <xref:System.String.IsNullOrEmpty%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-1493">判斷這個字串執行個體的結尾是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1493">Determines whether the end of this string instance matches a specified string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-1494">要在這個執行個體結束時，與子字串比較的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1494">The string to compare to the substring at the end of this instance.</span></span></param>
        <summary><span data-ttu-id="5f51e-1495">判斷這個字串執行個體的結尾是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1495">Determines whether the end of this string instance matches the specified string.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-1496">如果 <paramref name="value" /> 符合這個執行個體的結尾，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1496"><see langword="true" /> if <paramref name="value" /> matches the end of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1497">這個方法會比較`value`是相同的長度做為這個執行個體的結尾子字串`value`，並傳回表示是否相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1497">This method compares `value` to the substring at the end of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="5f51e-1498">若要視為相等，`value`必須是相同的執行個體的參考，或比對這個執行個體的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1498">To be equal, `value` must be a reference to this same instance or match the end of this instance.</span></span>  
  
 <span data-ttu-id="5f51e-1499">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1499">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1500">下列範例表示一個陣列中的每個字串是否以句號結尾 ("。")。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1500">The following example indicates whether each string in an array ends with a period (".").</span></span>  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 <span data-ttu-id="5f51e-1501">下列範例會定義`StripEndTags`方法使用<xref:System.String.EndsWith%28System.String%29>方法從行尾移除 HTML 結尾標記。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1501">The following example defines a `StripEndTags` method that uses the <xref:System.String.EndsWith%28System.String%29> method to remove HTML end tags from the end of a line.</span></span> <span data-ttu-id="5f51e-1502">請注意，`StripEndTags`呼叫以遞迴方式來確認移除該行結尾的多個 HTML 結尾標記的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1502">Note that the  `StripEndTags` method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.</span></span>  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1503"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1503"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-1504">中所述[使用字串的最佳作法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1504">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="5f51e-1505">若要判斷字串是否結束特定的子字串以使用目前文化特性的字串比較規則，請呼叫<see cref="M:System.String.EndsWith(System.String,System.StringComparison)" />方法多載，其值為<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1505">To determine whether a string ends with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-1506">要在這個執行個體結束時，與子字串比較的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1506">The string to compare to the substring at the end of this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="5f51e-1507">列舉值之一，指定這個字串和 <c>value</c> 的比較方式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1507">One of the enumeration values that determines how this string and <c>value</c> are compared.</span></span></param>
        <summary><span data-ttu-id="5f51e-1508">判斷當使用指定的比較選項進行比較時，這個字串執行個體的結尾是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1508">Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-1509">如果 <paramref name="value" /> 參數符合這個字串的結尾，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1509"><see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1510"><xref:System.String.EndsWith%2A>方法會比較`value`在這個字串的結尾的子字串的參數和傳回值，指出它們是否相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1510">The <xref:System.String.EndsWith%2A> method compares the `value` parameter to the substring at the end of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="5f51e-1511">若要視為相等，`value`必須是相同的字串的參考，必須是空字串 ("")，或必須符合這個字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1511">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the end of this string.</span></span> <span data-ttu-id="5f51e-1512">所執行的比較類型<xref:System.String.EndsWith%2A>方法取決於值`comparisonType`參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1512">The type of comparison performed by the <xref:System.String.EndsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1513">下列範例會判斷字串是否以特定的子字串結束。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1513">The following example determines whether a string ends with a particular substring.</span></span> <span data-ttu-id="5f51e-1514">文化特性、 是否忽略大小寫，以及是否執行序數比較的選擇會影響結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1514">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1515"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1515"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-1516"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1516"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-1517">要在這個執行個體結束時，與子字串比較的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1517">The string to compare to the substring at the end of this instance.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="5f51e-1518"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1518"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="5f51e-1519">判斷如何比較此執行個體和 <c>value</c> 的文化特性資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1519">Cultural information that determines how this instance and <c>value</c> are compared.</span></span> <span data-ttu-id="5f51e-1520">如果 <c>culture</c> 是 <see langword="null" />，則會使用目前的文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1520">If <c>culture</c> is <see langword="null" />, the current culture is used.</span></span></param>
        <summary><span data-ttu-id="5f51e-1521">判斷當使用指定之文化特性進行比較時，這個字串執行個體的結尾是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1521">Determines whether the end of this string instance matches the specified string when compared using the specified culture.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-1522">如果 <paramref name="value" /> 參數符合這個字串的結尾，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1522"><see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1523">這個方法會比較`value`參數在此與相同長度的字串結尾的子字串`value`，並傳回值，指出它們是否相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1523">This method compares the `value` parameter to the substring at the end of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="5f51e-1524">若要視為相等，`value`必須是相同的執行個體的參考或符合這個字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1524">To be equal, `value` must be a reference to this same instance or match the end of this string.</span></span>  
  
 <span data-ttu-id="5f51e-1525">這個方法會執行使用指定的大小寫和文化特性的字組 （區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1525">This method performs a word (culture-sensitive) comparison using the specified casing and culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1526">下列範例會判斷字串是否發生在另一個字串結尾處。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1526">The following example determines whether a string occurs at the end of another string.</span></span> <span data-ttu-id="5f51e-1527"><xref:System.String.EndsWith%2A>幾次使用區分大小寫、 不區分大小寫和不同的文化特性會影響搜尋的結果呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1527">The <xref:System.String.EndsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1528"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1528"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-1529">判斷兩個 <see cref="T:System.String" /> 物件是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1529">Determines whether two <see cref="T:System.String" /> objects have the same value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="5f51e-1530">要與這個執行個體比較的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1530">The string to compare to this instance.</span></span></param>
        <summary><span data-ttu-id="5f51e-1531">判斷這個執行個體和指定的物件 (同時還必須是 <see cref="T:System.String" /> 物件) 是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1531">Determines whether this instance and a specified object, which must also be a <see cref="T:System.String" /> object, have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-1532">如果 <paramref name="obj" /> 是 <see cref="T:System.String" />，且其值與這個執行個體相同，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1532"><see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.String" /> and its value is the same as this instance; otherwise, <see langword="false" />.</span></span>  <span data-ttu-id="5f51e-1533">如果 <paramref name="obj" /> 是 <see langword="null" />，則方法會傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1533">If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1534">這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1534">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1535">下列範例會示範<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1535">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-1536">要與這個執行個體比較的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1536">The string to compare to this instance.</span></span></param>
        <summary><span data-ttu-id="5f51e-1537">判斷這個執行個體和另一個指定的 <see cref="T:System.String" /> 物件是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1537">Determines whether this instance and another specified <see cref="T:System.String" /> object have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-1538">如果 <see langword="true" /> 參數的值與這個執行個體的值相同，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1538"><see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as the value of this instance; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="5f51e-1539">如果 <paramref name="value" /> 是 <see langword="null" />，則方法會傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1539">If <paramref name="value" /> is <see langword="null" />, the method returns <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1540">這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1540">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1541">下列範例會示範<xref:System.String.Equals%2A>方法。它會比較使用標題大小寫 「 檔案 」 with 字相等的 word、 其小寫的對等項目、 其大寫對等項目和包含拉丁小字母無點 I 字 (U + 0131) 而不是拉丁文小字母 I (U + 0069)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1541">The following example demonstrates the <xref:System.String.Equals%2A> method.It compares the title-cased word "File" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I (U+0131) instead of LATIN SMALL LETTER I (U+0069).</span></span> <span data-ttu-id="5f51e-1542">因為<xref:System.String.Equals%28System.String%29>方法會執行序數比較，使用了相同的字組比較傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1542">Because the <xref:System.String.Equals%28System.String%29> method performs an ordinal comparison, only the comparison with an identical word returns `true`.</span></span>  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="5f51e-1543">要比較的第一個字串，或是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1543">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="5f51e-1544">要比較的第二個字串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1544">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="5f51e-1545">判斷兩個指定的 <see cref="T:System.String" /> 物件是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1545">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-1546">如果 <see langword="true" /> 的值與 <paramref name="a" /> 的值相同，則為 <paramref name="b" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1546"><see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="5f51e-1547">如果 <paramref name="a" /> 和 <paramref name="b" /> 都是 <see langword="null" />，則這個方法會傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1547">If both <paramref name="a" /> and <paramref name="b" /> are <see langword="null" />, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1548">這個方法會執行序數 （區分大小寫且區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1548">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1549">下列範例會示範<xref:System.String.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1549">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-1550">要與這個執行個體比較的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1550">The string to compare to this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="5f51e-1551">其中一個列舉值，指定字串的比較方式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1551">One of the enumeration values that specifies how the strings will be compared.</span></span></param>
        <summary><span data-ttu-id="5f51e-1552">判斷這個字串和指定的 <see cref="T:System.String" /> 物件是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1552">Determines whether this string and a specified <see cref="T:System.String" /> object have the same value.</span></span> <span data-ttu-id="5f51e-1553">參數可指定用於比較的文化特性、大小寫及排序規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1553">A parameter specifies the culture, case, and sort rules used in the comparison.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-1554">如果 <see langword="true" /> 參數的值與這個字串相同，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1554"><see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1555">`comparisonType`參數會指出是否比較應該使用的目前或而異的文化特性、 接受或忽略大小寫的兩個字串進行比較，或使用 word 或序數排序規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1555">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1556">下列範例會建立字串陣列，其中包含以大寫"I"、"i"的小寫和無點"ı"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1556">The following example creates a string array that consists of an uppercase "I", a lowercase "i", and a dotless "ı".</span></span> <span data-ttu-id="5f51e-1557">然後它會呼叫<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>方法來加以比較使用每一個可能的<xref:System.StringComparison>列舉值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1557">It then calls the <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method to compare them by using each possible <xref:System.StringComparison> enumeration value.</span></span>  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 <span data-ttu-id="5f51e-1558">下列範例會使用的每個成員來比較四組字<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1558">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="5f51e-1559">比較使用英文 （美國） 和沙米文 （瑞典上方） 文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1559">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="5f51e-1560">請注意，字串"encyclopædia"和"百科全書"都會被視為對等項目在 EN-US 文化特性，但不是在沙米文 （北瑞典） 文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1560">Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-1561"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1561"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="5f51e-1562">要比較的第一個字串，或是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1562">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="5f51e-1563">要比較的第二個字串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1563">The second string to compare, or <see langword="null" />.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="5f51e-1564">其中一個列舉值，指定比較的規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1564">One of the enumeration values that specifies the rules for the comparison.</span></span></param>
        <summary><span data-ttu-id="5f51e-1565">判斷兩個指定的 <see cref="T:System.String" /> 物件是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1565">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span></span> <span data-ttu-id="5f51e-1566">參數可指定用於比較的文化特性、大小寫及排序規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1566">A parameter specifies the culture, case, and sort rules used in the comparison.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-1567">如果 <see langword="true" /> 參數的值等於 <paramref name="a" /> 參數的值，則為 <paramref name="b" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1567"><see langword="true" /> if the value of the <paramref name="a" /> parameter is equal to the value of the <paramref name="b" /> parameter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1568">`comparisonType`參數會指出是否比較應該使用的目前或而異的文化特性、 接受或忽略大小寫的兩個字串進行比較，或使用 word 或序數排序規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1568">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1569">下列範例會使用的每個成員來比較四組字<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1569">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="5f51e-1570">比較使用英文 （美國） 和沙米文 （瑞典上方） 文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1570">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="5f51e-1571">請注意，字串"encyclopædia"和"百科全書"都會被視為對等項目在 EN-US 文化特性，但不是在沙米文 （北瑞典） 文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1571">Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-1572"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1572"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-1573">根據指定的格式將物件的值轉換為字串，並將它們插入到另一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1573">Converts the value of objects to strings based on the formats specified and inserts them into another string.</span></span>  
  
 <span data-ttu-id="5f51e-1574">如果您不熟悉 `String.Format` 方法，請參閱 [String.Format 方法入門](#Starting)一節以取得快速概觀。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1574">If you are new to the `String.Format` method, see the [Get started with the String.Format method](#Starting) section for a quick overview.</span></span>  
  
 <span data-ttu-id="5f51e-1575">如需 `String.Format` 方法的一般文件，請參閱[備註](#remarks-top)一節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1575">See the [Remarks](#remarks-top) section for general documentation for the `String.Format` method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 <span data-ttu-id="5f51e-1576">本節內容：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1576">In this section:</span></span>  
  
 <span data-ttu-id="5f51e-1577">[String.Format 方法入門](#Starting) </span><span class="sxs-lookup"><span data-stu-id="5f51e-1577">[Get started with the String.Format method](#Starting) </span></span>  
 <span data-ttu-id="5f51e-1578">[沒有呼叫的方法？](#FTaskList) </span><span class="sxs-lookup"><span data-stu-id="5f51e-1578">[Which method do I call?](#FTaskList) </span></span>  
 <span data-ttu-id="5f51e-1579">[Format 方法簡介](#Format_Brief) </span><span class="sxs-lookup"><span data-stu-id="5f51e-1579">[The Format method in brief](#Format_Brief) </span></span>  
 <span data-ttu-id="5f51e-1580">[格式項目](#FormatItem) </span><span class="sxs-lookup"><span data-stu-id="5f51e-1580">[The Format item](#FormatItem) </span></span>  
 <span data-ttu-id="5f51e-1581">[引數格式化的方式](#HowFormatted) </span><span class="sxs-lookup"><span data-stu-id="5f51e-1581">[How arguments are formatted](#HowFormatted) </span></span>  
 <span data-ttu-id="5f51e-1582">[格式項目具有相同的索引](#SameIndex) </span><span class="sxs-lookup"><span data-stu-id="5f51e-1582">[Format items that have the same index](#SameIndex) </span></span>  
 <span data-ttu-id="5f51e-1583">[格式和文化特性](#Format_Culture) </span><span class="sxs-lookup"><span data-stu-id="5f51e-1583">[Formatting and culture](#Format_Culture) </span></span>  
 <span data-ttu-id="5f51e-1584">[自訂格式化作業](#Format_Custom) </span><span class="sxs-lookup"><span data-stu-id="5f51e-1584">[Custom formatting operations](#Format_Custom) </span></span>  
 [<span data-ttu-id="5f51e-1585">String.Format 問與答</span><span class="sxs-lookup"><span data-stu-id="5f51e-1585">String.Format Q & A</span></span>](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a><span data-ttu-id="5f51e-1586">String.Format 方法入門</span><span class="sxs-lookup"><span data-stu-id="5f51e-1586">Get started with the String.Format method</span></span>  
 <span data-ttu-id="5f51e-1587">使用<xref:System.String.Format%2A?displayProperty=nameWithType>如果您要插入到另一個字串的物件、 變數或運算式的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1587">Use <xref:System.String.Format%2A?displayProperty=nameWithType> if you need to insert the value of an object, variable, or expression into another string.</span></span> <span data-ttu-id="5f51e-1588">例如，您可以在其中插入的值<xref:System.Decimal>顯示給使用者以單一字串的字串值：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1588">For example, you can insert the value of a <xref:System.Decimal> value into a string to display it to the user as a single string:</span></span>  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 <span data-ttu-id="5f51e-1589">而且，您可以控制該數值的格式：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1589">And you can control that value's formatting:</span></span>  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 <span data-ttu-id="5f51e-1590">除了格式，您也可以控制對齊和間距。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1590">Besides formatting, you can also control alignment and spacing.</span></span>  
  
 ### <a name="inserting-a-string"></a><span data-ttu-id="5f51e-1591">將字串插入</span><span class="sxs-lookup"><span data-stu-id="5f51e-1591">Inserting a string</span></span>  

 <span data-ttu-id="5f51e-1592"><xref:System.String.Format%2A?displayProperty=nameWithType> 開始使用的格式字串，後面接著一個或多個物件會轉換成字串並插入格式字串中的指定位置的運算式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1592"><xref:System.String.Format%2A?displayProperty=nameWithType> starts with a format string, followed by one or more objects or expressions that will be converted to strings and inserted at a specified place in the format string.</span></span> <span data-ttu-id="5f51e-1593">例如: </span><span class="sxs-lookup"><span data-stu-id="5f51e-1593">For example:</span></span>  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 <span data-ttu-id="5f51e-1594">`{0}`格式字串是格式項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1594">The `{0}` in the format string is a format item.</span></span> <span data-ttu-id="5f51e-1595">`0` 這是的物件的字串值將會插入該位置的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1595">`0` is the index of the object whose string value will be inserted at that position.</span></span> <span data-ttu-id="5f51e-1596">（索引 0 開始。）如果要插入的物件不是字串，其`ToString`呼叫方法，將它轉換成插入結果字串中之前的其中一個。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1596">(Indexes start at 0.) If the object to be inserted is not a string, its `ToString` method is called to convert it to one before inserting it in the result string.</span></span>  
  
 <span data-ttu-id="5f51e-1597">以下是使用 [物件] 清單中的兩個格式項目和兩個物件的另一個範例：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1597">Here's another example that uses two format items and two objects in the object list:</span></span>  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 <span data-ttu-id="5f51e-1598">您可以擁有最多的格式項目，而且想為您的 [物件] 清單中的許多物件，只要每個格式項目的索引物件清單中有相符的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1598">You can have as many format items and as many objects in the object list as you want, as long as the index of every format item has a matching object in the object list.</span></span> <span data-ttu-id="5f51e-1599">您也不必擔心相關的多載呼叫。編譯器會選擇適合您。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1599">You also don't have to worry about which overload you call; the compiler will select the appropriate one for you.</span></span>  
  
 ### <a name="controlling-formatting"></a><span data-ttu-id="5f51e-1600">控制格式設定</span><span class="sxs-lookup"><span data-stu-id="5f51e-1600">Controlling formatting</span></span>  
 <span data-ttu-id="5f51e-1601">您可以遵循格式字串來控制如何格式化物件的格式項目中的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1601">You can follow the index in a format item with a format string to control how an object is formatted.</span></span> <span data-ttu-id="5f51e-1602">例如， `{0:d}` "d"格式字串適用於物件清單中的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1602">For example, `{0:d}` applies the "d" format string to the first object in the object list.</span></span> <span data-ttu-id="5f51e-1603">以下是以單一物件的範例和兩個格式項目：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1603">Here is an example with a single object and two format items:</span></span>  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 <span data-ttu-id="5f51e-1604">類型支援的數字格式字串，包括所有數字類型 (兩者[標準](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自訂](~/docs/standard/base-types/custom-numeric-format-strings.md)格式字串)，所有日期和時間 (同時[標準](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自訂](~/docs/standard/base-types/custom-date-and-time-format-strings.md)格式字串) 和時間間隔 (兩者[標準](~/docs/standard/base-types/standard-timespan-format-strings.md)和[自訂](~/docs/standard/base-types/custom-timespan-format-strings.md)格式字串)，所有列舉型別[列舉型別](~/docs/standard/base-types/enumeration-format-strings.md)，和[Guid](https://msdn.microsoft.com/library/97af8hh4.aspx)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1604">A number of types support format strings, including all numeric types (both [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) and [custom](~/docs/standard/base-types/custom-numeric-format-strings.md) format strings), all dates and times (both [standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [custom](~/docs/standard/base-types/custom-date-and-time-format-strings.md) format strings) and time intervals (both [standard](~/docs/standard/base-types/standard-timespan-format-strings.md) and [custom](~/docs/standard/base-types/custom-timespan-format-strings.md) format strings), all enumeration types [enumeration types](~/docs/standard/base-types/enumeration-format-strings.md), and [GUIDs](https://msdn.microsoft.com/library/97af8hh4.aspx).</span></span> <span data-ttu-id="5f51e-1605">您也可以將格式字串的支援加入自己的型別中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1605">You can also add support for format strings to your own types.</span></span>  
  
 ### <a name="controlling-spacing"></a><span data-ttu-id="5f51e-1606">控制間距</span><span class="sxs-lookup"><span data-stu-id="5f51e-1606">Controlling spacing</span></span>  
 <span data-ttu-id="5f51e-1607">您可以定義使用像是語法插入結果字串之字串的寬度`{0,12}`，其中插入 12 個字元的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1607">You can define the width of the string that is inserted into the result string by using syntax such as `{0,12}`, which inserts a 12-character string.</span></span> <span data-ttu-id="5f51e-1608">在此情況下，第一個物件的字串表示處於靠右對齊 12 個字元的欄位。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1608">In this case, the string representation of the first object is right-aligned in the 12-character field.</span></span>  <span data-ttu-id="5f51e-1609">（如果第一個物件的字串表示的長度超過 12 個字元，不過，會略過慣用的欄位寬度，且整個字串插入結果字串。）</span><span class="sxs-lookup"><span data-stu-id="5f51e-1609">(If the string representation of the first object is more than 12 characters in length, though, the preferred field width is ignored, and the entire string is inserted into the result string.)</span></span>  
  
 <span data-ttu-id="5f51e-1610">下列範例會定義 6 個字元的欄位，來容納字串 「 年 」 和某些年字串，以及 15 個字元的欄位來容納字串 「 母體擴展 」 以及一些母體擴展的資料。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1610">The following example defines a 6-character field to hold the string "Year" and some year strings, as well as an 15-character field to hold the string "Population" and some population data.</span></span> <span data-ttu-id="5f51e-1611">請注意，字元靠右對齊欄位中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1611">Note that the characters are right-aligned in the field.</span></span>  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a><span data-ttu-id="5f51e-1612">控制對齊方式</span><span class="sxs-lookup"><span data-stu-id="5f51e-1612">Controlling alignment</span></span>  
 <span data-ttu-id="5f51e-1613">根據預設，字串才靠右對齊，其欄位中指定欄位寬度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1613">By default, strings are right-aligned within their field if you specify a field width.</span></span> <span data-ttu-id="5f51e-1614">若要靠左對齊欄位中的字串，您前面上欄位寬度，以負號，例如`{0,-12}`定義 12 個字元，靠右對齊的欄位。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1614">To left-align strings in a field, you preface the field width with a negative sign, such as `{0,-12}` to define a 12-character right-aligned field.</span></span>  
  
 <span data-ttu-id="5f51e-1615">下列範例是類似於上一個，，不同之處在於它靠左對齊的標籤和資料。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1615">The following example is similar to the previous one, except that it left-aligns both labels and data.</span></span>  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <span data-ttu-id="5f51e-1616"><xref:System.String.Format%2A?displayProperty=nameWithType> 使用複合格式功能。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1616"><xref:System.String.Format%2A?displayProperty=nameWithType> makes use of the composite formatting feature.</span></span> <span data-ttu-id="5f51e-1617">如需詳細資訊，請參閱[複合格式設定](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1617">For more information, see [Composite Formatting](~/docs/standard/base-types/composite-formatting.md).</span></span>  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a><span data-ttu-id="5f51e-1618">沒有呼叫的方法？</span><span class="sxs-lookup"><span data-stu-id="5f51e-1618">Which method do I call?</span></span>  
  
|<span data-ttu-id="5f51e-1619">以</span><span class="sxs-lookup"><span data-stu-id="5f51e-1619">To</span></span>|<span data-ttu-id="5f51e-1620">Call</span><span class="sxs-lookup"><span data-stu-id="5f51e-1620">Call</span></span>|  
|--------|----------|  
|<span data-ttu-id="5f51e-1621">使用目前文化特性的慣例來格式化一個或多個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1621">Format one or more objects by using the conventions of the current culture.</span></span>|<span data-ttu-id="5f51e-1622">除了包含多載`provider`參數，其餘<xref:System.String.Format%2A>多載包括<xref:System.String>參數後面接著一個或多個物件參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1622">Except for the overloads that include a `provider` parameter, the remaining <xref:System.String.Format%2A> overloads include a <xref:System.String> parameter followed by one or more object parameters.</span></span> <span data-ttu-id="5f51e-1623">因為這個緣故，您不需要判斷哪一個<xref:System.String.Format%2A>您想要呼叫的多載。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1623">Because of this, you don't have to determine which <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="5f51e-1624">您的語言編譯器會選擇從沒有多載中的適當多載`provider`根據引數清單的參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1624">Your language compiler selects the appropriate overload from among the overloads that don't have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="5f51e-1625">例如，如果引數清單有五個引數，編譯器會呼叫<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1625">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>|  
|<span data-ttu-id="5f51e-1626">使用特定文化特性的慣例來格式化一個或多個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1626">Format one or more objects by using the conventions of a specific culture.</span></span>|<span data-ttu-id="5f51e-1627">每個<xref:System.String.Format%2A>開頭的多載`provider`參數後面<xref:System.String>參數和一個或多個物件的參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1627">Each <xref:System.String.Format%2A> overload that begins with a `provider` parameter is followed by a <xref:System.String> parameter and one or more object parameters.</span></span> <span data-ttu-id="5f51e-1628">因為這個緣故，您不需要判斷哪一個特定<xref:System.String.Format%2A>您想要呼叫的多載。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1628">Because of this, you don't have to determine which specific <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="5f51e-1629">您的語言編譯器會選取適當的多載具有多載，從`provider`根據引數清單的參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1629">Your language compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="5f51e-1630">例如，如果引數清單有五個引數，編譯器會呼叫<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1630">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method.</span></span>|  
|<span data-ttu-id="5f51e-1631">不論是透過執行自訂格式化作業<xref:System.ICustomFormatter>實作或<xref:System.IFormattable>實作。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1631">Perform a custom formatting operation either with an <xref:System.ICustomFormatter> implementation or an <xref:System.IFormattable> implementation.</span></span>|<span data-ttu-id="5f51e-1632">任何具有四個多載`provider`參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1632">Any of the four overloads with a `provider` parameter.</span></span> <span data-ttu-id="5f51e-1633">編譯器會選擇適當的多載，從具有的多載`provider`根據引數清單的參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1633">The compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span>|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a><span data-ttu-id="5f51e-1634">Format 方法簡介</span><span class="sxs-lookup"><span data-stu-id="5f51e-1634">The Format method in brief</span></span> 

 <span data-ttu-id="5f51e-1635">每個多載<xref:System.String.Format%2A>方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)以包含以零為起始的索引的位置，稱為*設定項目的格式*，複合格式字串中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1635">Each overload of the <xref:System.String.Format%2A> method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to include zero-based indexed placeholders, called *format items*, in a composite format string.</span></span> <span data-ttu-id="5f51e-1636">在執行階段，每個格式項目會取代對應的引數在參數清單中的字串表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1636">At run time, each format item is replaced with the string representation of the corresponding argument in a parameter list.</span></span> <span data-ttu-id="5f51e-1637">如果引數的值為`null`，格式項目取代<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1637">If the value of the argument is `null`, the format item is replaced with <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-1638">例如，下列呼叫<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法包含三個格式項目，使用格式字串{0}， {1}，和{2}，和引數清單具有三個項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1638">For example, the following call to the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method includes a format string with three format items, {0}, {1}, and {2}, and an argument list with three items.</span></span>  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a><span data-ttu-id="5f51e-1639">格式項目</span><span class="sxs-lookup"><span data-stu-id="5f51e-1639">The format item</span></span>  
 <span data-ttu-id="5f51e-1640">格式項目具有下列語法：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1640">A format item has this syntax:</span></span>  
  
```  
{index[,alignment][:formatString]}  
```  
 
 <span data-ttu-id="5f51e-1641">方括號表示選擇性的項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1641">Brackets denote optional elements.</span></span> <span data-ttu-id="5f51e-1642">需要左和右大括號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1642">The opening and closing braces are required.</span></span> <span data-ttu-id="5f51e-1643">(包含常值的左或右大括弧中的格式字串，請參閱[逸出大括號](~/docs/standard/base-types/composite-formatting.md#escaping-braces)一節中[複合格式化](~/docs/standard/base-types/composite-formatting.md)文件。)</span><span class="sxs-lookup"><span data-stu-id="5f51e-1643">(To include a literal opening or closing brace in the format string, see the [Escaping Braces](~/docs/standard/base-types/composite-formatting.md#escaping-braces) section in the [Composite Formatting](~/docs/standard/base-types/composite-formatting.md) article.)</span></span>  
  
 <span data-ttu-id="5f51e-1644">比方說，若要格式化貨幣值的格式項目可能會出現如下：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1644">For example, a format item to format a currency value might appear like this:</span></span>  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 <span data-ttu-id="5f51e-1645">格式項目具有下列項目：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1645">A format item has the following elements:</span></span>  
  
 <span data-ttu-id="5f51e-1646">*index*</span><span class="sxs-lookup"><span data-stu-id="5f51e-1646">*index*</span></span>  
 <span data-ttu-id="5f51e-1647">以零為起始的索引為其字串表示的引數包含在這個字串中的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1647">The zero-based index of the argument whose string representation is to be included at this position in the string.</span></span> <span data-ttu-id="5f51e-1648">如果這個引數是`null`，空字串會包含在這個字串中的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1648">If this argument is `null`, an empty string will be included at this position in the string.</span></span>  
  
 <span data-ttu-id="5f51e-1649">*對齊方式*</span><span class="sxs-lookup"><span data-stu-id="5f51e-1649">*alignment*</span></span>  
 <span data-ttu-id="5f51e-1650">選擇性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1650">Optional.</span></span> <span data-ttu-id="5f51e-1651">帶正負號的整數，指出欄位的總長度成插入引數，它會靠右對齊 （正整數），或靠左對齊 （負整數）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1651">A signed integer that indicates the total length of the field into which the argument is inserted and whether it is right-aligned (a positive integer) or left-aligned (a negative integer).</span></span> <span data-ttu-id="5f51e-1652">如果您省略*對齊*，對應的引數的字串表示插入任何開頭或尾端空格的欄位中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1652">If you omit *alignment*, the string representation of the corresponding argument is inserted in a field with no leading or trailing spaces.</span></span>  
  
 <span data-ttu-id="5f51e-1653">如果值*對齊*插入，引數的長度小於*對齊*會忽略和引數的字串表示的長度當做欄位寬度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1653">If the value of *alignment* is less than the length of the argument to be inserted, *alignment* is ignored and the length of the string representation of the argument is used as the field width.</span></span>  
  
 <span data-ttu-id="5f51e-1654">*formatString*</span><span class="sxs-lookup"><span data-stu-id="5f51e-1654">*formatString*</span></span>  
 <span data-ttu-id="5f51e-1655">選擇性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1655">Optional.</span></span> <span data-ttu-id="5f51e-1656">字串，指定對應引數的結果字串的格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1656">A string that specifies the format of the corresponding argument's result string.</span></span> <span data-ttu-id="5f51e-1657">如果您省略*formatString*，對應的引數的無參數`ToString`呼叫方法來產生它的字串表示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1657">If you omit *formatString*, the corresponding argument's parameterless `ToString` method is called to produce its string representation.</span></span> <span data-ttu-id="5f51e-1658">如果您指定*formatString*，格式項目所參考的引數必須實作<xref:System.IFormattable>介面。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1658">If you specify *formatString*, the argument referenced by the format item must implement the <xref:System.IFormattable> interface.</span></span> <span data-ttu-id="5f51e-1659">支援格式字串的類型包括：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1659">Types that support format strings include:</span></span>  
  
-   <span data-ttu-id="5f51e-1660">所有的整數和浮點數型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1660">All integral and floating-point types.</span></span> <span data-ttu-id="5f51e-1661">(請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。)</span><span class="sxs-lookup"><span data-stu-id="5f51e-1661">(See [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="5f51e-1662"><xref:System.DateTime> 和 <xref:System.DateTimeOffset>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1662"><xref:System.DateTime> and <xref:System.DateTimeOffset>.</span></span> <span data-ttu-id="5f51e-1663">(請參閱[標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。)</span><span class="sxs-lookup"><span data-stu-id="5f51e-1663">(See [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="5f51e-1664">所有列舉類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1664">All enumeration types.</span></span> <span data-ttu-id="5f51e-1665">(請參閱[列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。)</span><span class="sxs-lookup"><span data-stu-id="5f51e-1665">(See [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="5f51e-1666"><xref:System.TimeSpan> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1666"><xref:System.TimeSpan> values.</span></span> <span data-ttu-id="5f51e-1667">(請參閱[標準 TimeSpan 格式字串](~/docs/standard/base-types/standard-timespan-format-strings.md)和[自訂 TimeSpan 格式字串](~/docs/standard/base-types/custom-timespan-format-strings.md)。)</span><span class="sxs-lookup"><span data-stu-id="5f51e-1667">(See [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) and [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="5f51e-1668">GUID。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1668">GUIDs.</span></span> <span data-ttu-id="5f51e-1669">(請參閱<xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>方法。)</span><span class="sxs-lookup"><span data-stu-id="5f51e-1669">(See the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> method.)</span></span>  
  
 <span data-ttu-id="5f51e-1670">不過，請注意，任何自訂的類型可以實作<xref:System.IFormattable>擴充現有的類型或<xref:System.IFormattable>實作。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1670">However, note that any custom type can implement <xref:System.IFormattable> or extend an existing type's <xref:System.IFormattable> implementation.</span></span>  
  
 <span data-ttu-id="5f51e-1671">下列範例會使用`alignment`和`formatString`引數才能產生格式化的輸出。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1671">The following example uses the `alignment` and `formatString` arguments to produce formatted output.</span></span>  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a><span data-ttu-id="5f51e-1672">引數格式化的方式</span><span class="sxs-lookup"><span data-stu-id="5f51e-1672">How arguments are formatted</span></span>  
 <span data-ttu-id="5f51e-1673">格式項目會依序處理，從字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1673">Format items are processed sequentially from the beginning of the string.</span></span> <span data-ttu-id="5f51e-1674">每個格式項目有對應至方法的引數清單中的物件索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1674">Each format item has an index that corresponds to an object in the method's argument list.</span></span> <span data-ttu-id="5f51e-1675"><xref:System.String.Format%2A>方法擷取的引數，並衍生其字串表示，如下所示：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1675">The <xref:System.String.Format%2A> method retrieves the argument and derives its string representation as follows:</span></span>  
  
-   <span data-ttu-id="5f51e-1676">如果引數是`null`，此方法會插入<xref:System.String.Empty?displayProperty=nameWithType>插入結果字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1676">If the argument is `null`, the method inserts <xref:System.String.Empty?displayProperty=nameWithType> into the result string.</span></span> <span data-ttu-id="5f51e-1677">您不需要顧慮處理<xref:System.NullReferenceException>null 引數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1677">You don't have to be concerned with handling a <xref:System.NullReferenceException> for null arguments.</span></span> 
  
-   <span data-ttu-id="5f51e-1678">如果您呼叫<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>多載而`provider`物件的<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>實作會傳回非 null<xref:System.ICustomFormatter>實作中，引數傳遞至其<xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1678">If you call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> overload and the `provider` object's <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementation returns a non-null <xref:System.ICustomFormatter> implementation, the argument is passed to its <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5f51e-1679">如果格式項目包含*formatString*引數，傳遞時的第一個引數的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1679">If the format item includes a *formatString* argument, it is passed as the first argument to the method.</span></span> <span data-ttu-id="5f51e-1680">如果<xref:System.ICustomFormatter>實作可用，而且會產生的非 null 字串，就會傳回字串做為引數的字串表示; 否則會執行下一個步驟。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1680">If the <xref:System.ICustomFormatter> implementation is available and produces a non-null string, that string is returned as the string representation of the argument; otherwise, the next step executes.</span></span>  
  
-   <span data-ttu-id="5f51e-1681">如果引數實作<xref:System.IFormattable>介面，其<xref:System.IFormattable.ToString%2A?displayProperty=nameWithType>呼叫實作。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1681">If the argument implements the <xref:System.IFormattable> interface, its <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation is called.</span></span>  
  
-   <span data-ttu-id="5f51e-1682">引數的無參數`ToString`方法，它會覆寫或繼承自基底類別實作，會呼叫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1682">The argument's parameterless `ToString` method, which either overrides or inherits from a base class implementation, is called.</span></span>  
  
 <span data-ttu-id="5f51e-1683">如需範例，會呼叫攔截<xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>方法，可讓您查看哪些資訊<xref:System.String.Format%2A>方法傳遞至格式化的方法，以便在複合格式字串中，每個格式項目請參閱[範例： 截距，提供者和羅馬數字格式器](#Format7_Example)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1683">For an example that intercepts calls to the <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> method and allows you to see what information the <xref:System.String.Format%2A> method passes to a formatting method for each format item in a composite format string, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>  

 <span data-ttu-id="5f51e-1684">如需詳細資訊，請參閱[處理順序](~/docs/standard/base-types/composite-formatting.md##processing-order)一節中[複合格式化](~/docs/standard/base-types/composite-formatting.md)發行項。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1684">For more information, see the [Processing Order](~/docs/standard/base-types/composite-formatting.md##processing-order) section in the [Composite Formatting](~/docs/standard/base-types/composite-formatting.md) article.</span></span>  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a><span data-ttu-id="5f51e-1685">格式項目具有相同的索引</span><span class="sxs-lookup"><span data-stu-id="5f51e-1685">Format items that have the same index</span></span>  
 <span data-ttu-id="5f51e-1686"><xref:System.String.Format%2A>方法會擲回<xref:System.FormatException>例外狀況，如果索引項目的索引是大於或等於引數清單中的引數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1686">The <xref:System.String.Format%2A> method throws a <xref:System.FormatException> exception if the index of an index item is greater than or equal to the number of arguments in the argument list.</span></span> <span data-ttu-id="5f51e-1687">不過，`format`可以包含多個格式項目比引數，只要多個格式項目具有相同的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1687">However, `format` can include more format items than there are arguments, as long as multiple format items have the same index.</span></span> <span data-ttu-id="5f51e-1688">在呼叫<xref:System.String.Format%28System.String%2CSystem.Object%29>在下列範例中，引數清單的方法具有單一引數，但是格式字串包含兩個格式項目： 一個顯示數字的十進位值與另一個則顯示十六進位值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1688">In the call to the <xref:System.String.Format%28System.String%2CSystem.Object%29> method in following example, the argument list has a single argument, but the format string includes two format items: one displays the decimal value of a number, and the other displays its hexadecimal value.</span></span>  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a><span data-ttu-id="5f51e-1689">格式和文化特性</span><span class="sxs-lookup"><span data-stu-id="5f51e-1689">Formatting and culture</span></span>  
 <span data-ttu-id="5f51e-1690">一般而言，引數清單中的物件會轉換成其字串表示法傳回使用目前的文化特性的慣例<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1690">Generally, objects in the argument list are converted to their string representations by using the conventions of the current culture, which is returned by the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="5f51e-1691">您可以透過呼叫其中一個多載來控制此行為<xref:System.String.Format%2A>包含`provider`參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1691">You can control this behavior by calling one of the overloads of <xref:System.String.Format%2A> that includes a `provider` parameter.</span></span> <span data-ttu-id="5f51e-1692">`provider`參數是<xref:System.IFormatProvider>處理實作，提供自訂和特定文化特性格式資訊用來進行中等程度的格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1692">The `provider` parameter is an <xref:System.IFormatProvider> implementation that supplies custom and culture-specific formatting information that is used to moderate the formatting process.</span></span>  
  
 <span data-ttu-id="5f51e-1693"><xref:System.IFormatProvider>介面具有單一成員， <xref:System.IFormatProvider.GetFormat%2A>，這是負責傳回的物件，提供格式設定資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1693">The <xref:System.IFormatProvider> interface has a single member, <xref:System.IFormatProvider.GetFormat%2A>, which is responsible for returning the object that provides formatting information.</span></span> <span data-ttu-id="5f51e-1694">.NET Framework 有三個<xref:System.IFormatProvider>實作，以提供特定文化特性的格式：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1694">The .NET Framework has three <xref:System.IFormatProvider> implementations that provide culture-specific formatting:</span></span>  
  
-   <span data-ttu-id="5f51e-1695"><xref:System.Globalization.CultureInfo>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1695"><xref:System.Globalization.CultureInfo>.</span></span> <span data-ttu-id="5f51e-1696">其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法會傳回特定文化特性<xref:System.Globalization.NumberFormatInfo>格式化數值和特定文化特性物件<xref:System.Globalization.DateTimeFormatInfo>來格式化日期和時間值的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1696">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns a culture-specific <xref:System.Globalization.NumberFormatInfo> object for formatting numeric values and a culture-specific <xref:System.Globalization.DateTimeFormatInfo> object for formatting date and time values.</span></span>  
  
-   <span data-ttu-id="5f51e-1697"><xref:System.Globalization.DateTimeFormatInfo>用於特定文化特性格式化的日期和時間值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1697"><xref:System.Globalization.DateTimeFormatInfo>, which is used for culture-specific formatting of date and time values.</span></span> <span data-ttu-id="5f51e-1698">其<xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A>方法會傳回本身。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1698">Its <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> method returns itself.</span></span>  
  
-   <span data-ttu-id="5f51e-1699"><xref:System.Globalization.NumberFormatInfo>用於特定文化特性的數值格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1699"><xref:System.Globalization.NumberFormatInfo>, which is used for culture-specific formatting of numeric values.</span></span> <span data-ttu-id="5f51e-1700">其<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>屬性會傳回本身。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1700">Its <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> property returns itself.</span></span> 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a><span data-ttu-id="5f51e-1701">自訂格式化作業</span><span class="sxs-lookup"><span data-stu-id="5f51e-1701">Custom formatting operations</span></span>  
 <span data-ttu-id="5f51e-1702">您也可以呼叫的多載任一<xref:System.String.Format%2A>方法具有`provider`型別的參數<xref:System.IFormatProvider>執行自訂的格式設定作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1702">You can also call the any of the overloads of the <xref:System.String.Format%2A> method that have a `provider` parameter of type <xref:System.IFormatProvider> to perform custom formatting operations.</span></span> <span data-ttu-id="5f51e-1703">例如，您無法格式化整數當做識別碼或電話號碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1703">For example, you could format an integer as an identification number or as a telephone number.</span></span> <span data-ttu-id="5f51e-1704">若要執行自訂的格式，您`provider`引數必須同時實作<xref:System.IFormatProvider>和<xref:System.ICustomFormatter>介面。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1704">To perform custom formatting, your `provider` argument must implement both the <xref:System.IFormatProvider> and <xref:System.ICustomFormatter> interfaces.</span></span> <span data-ttu-id="5f51e-1705">當<xref:System.String.Format%2A>方法傳遞<xref:System.ICustomFormatter>實作做為`provider`引數，<xref:System.String.Format%2A>方法會呼叫其<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>實作要求類型的物件和<xref:System.ICustomFormatter>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1705">When the <xref:System.String.Format%2A> method is passed an <xref:System.ICustomFormatter> implementation as the `provider` argument, the <xref:System.String.Format%2A> method calls its   <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementation and requests an object of type <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="5f51e-1706">然後它會呼叫傳回<xref:System.ICustomFormatter>物件的<xref:System.ICustomFormatter.Format%2A>方法來格式化複合字串中的每個格式項目傳遞給它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1706">It then calls the returned <xref:System.ICustomFormatter> object's <xref:System.ICustomFormatter.Format%2A> method to format each format item in the composite string passed to it.</span></span>  
  
 <span data-ttu-id="5f51e-1707">如需提供自訂格式解決方案的詳細資訊，請參閱[如何： 定義及使用自訂數值格式提供者](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)和<xref:System.ICustomFormatter>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1707">For more information about providing custom formatting solutions, see [How to: Define and Use Custom Numeric Format Providers](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) and <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="5f51e-1708">如需將整數轉換為格式化自訂的數字的範例，請參閱[範例： 自訂格式化作業](#Format6_Example)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1708">For an example that converts integers to formatted custom numbers, see [Example: A custom formatting operation](#Format6_Example).</span></span> <span data-ttu-id="5f51e-1709">如需將不帶正負號的位元組轉換為羅馬數字的範例，請參閱[範例： 截距，提供者和羅馬數字格式器](#Format7_Example)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1709">For an example that converts unsigned bytes to Roman numerals, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>  
  
<a name="Format6_Example" />  
### <a name="example-a-custom-formatting-operation"></a><span data-ttu-id="5f51e-1710">範例： 自訂格式化作業</span><span class="sxs-lookup"><span data-stu-id="5f51e-1710">Example: A custom formatting operation</span></span>  
 <span data-ttu-id="5f51e-1711">這個範例會定義整數值格式化為客戶帳戶編號中表單 x-xxxxx-xx 的格式提供者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1711">This example defines a format provider that formats an integer value as a customer account number in the form x-xxxxx-xx.</span></span>  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example" />  
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a><span data-ttu-id="5f51e-1712">範例： 截距，提供者和羅馬數字格式器</span><span class="sxs-lookup"><span data-stu-id="5f51e-1712">Example: An intercept provider and Roman numeral formatter</span></span>  
 <span data-ttu-id="5f51e-1713">這個範例會定義自訂的格式提供者實作<xref:System.ICustomFormatter>和<xref:System.IFormatProvider>介面做兩件事：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1713">This example defines a custom format provider that implements the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces to do two things:</span></span>  
  
-   <span data-ttu-id="5f51e-1714">它會顯示參數傳遞至其<xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>實作。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1714">It displays the parameters passed to its <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementation.</span></span> <span data-ttu-id="5f51e-1715">這可讓我們查看哪些參數<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法將傳遞至自訂的格式實作每個物件，它會嘗試格式化。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1715">This enables us to see what parameters the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is passing to the custom formatting implementation for each object that it tries to format.</span></span> <span data-ttu-id="5f51e-1716">當您在偵錯您的應用程式，這非常有用。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1716">This can be useful when you're debugging your application.</span></span>  
  
-   <span data-ttu-id="5f51e-1717">要格式化的物件是否要使用"R"標準格式字串格式化為不帶正負號的位元組值，將自訂格式器會格式化為羅馬數字的數字的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1717">If the object to be formatted is an unsigned byte value that is to be formatted by using the "R" standard format string, the custom formatter formats the numeric value as a Roman numeral.</span></span>  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a><span data-ttu-id="5f51e-1718">String.Format 問與答</span><span class="sxs-lookup"><span data-stu-id="5f51e-1718">String.Format Q & A</span></span>  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a><span data-ttu-id="5f51e-1719">為什麼建議字串插值對呼叫`String.Format`方法？</span><span class="sxs-lookup"><span data-stu-id="5f51e-1719">Why do you recommend string interpolation over calls to the `String.Format` method?</span></span>

<span data-ttu-id="5f51e-1720">字串插值是：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1720">String interpolation is:</span></span>

- <span data-ttu-id="5f51e-1721">更有彈性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1721">More flexible.</span></span> <span data-ttu-id="5f51e-1722">它可以是任何字串中不需要使用支援複合格式方法的呼叫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1722">It can be used in any string without requiring a call to a method that supports composite formatting.</span></span> <span data-ttu-id="5f51e-1723">否則，您必須呼叫<xref:System.String.Format%2A>方法或另一個方法，支援複合格式，例如<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1723">Otherwise, you have to call the <xref:System.String.Format%2A> method or another method that supports composite formatting, such as <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>.</span></span> 

- <span data-ttu-id="5f51e-1724">更容易閱讀。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1724">More readable.</span></span> <span data-ttu-id="5f51e-1725">因為插值運算式中，而不是引數清單中，會出現要插入的字串運算式，字串插值都很不容易，程式碼以及可讀取。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1725">Because the expression to insert into a string appears in the interpolated expression rather than in a argument list, interpolated strings are far easier to code and to read.</span></span> <span data-ttu-id="5f51e-1726">由於其更大的可讀性，字串插值可以取代不只呼叫複合格式方法，但是它們也可用在字串串連作業以產生更簡潔、 清楚的程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1726">Because of their greater readability, interpolated strings can replace not only calls to composite format methods, but they can also be used in string concatenation operations to produce more concise, clearer code.</span></span> 

<span data-ttu-id="5f51e-1727">比較下列兩個程式碼範例說明字串插值的優勢，透過字串串連和複合格式方法的呼叫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1727">A comparison of the following two code examples illustrates the superiority of interpolated strings over string concatenation and calls to composite formatting methods.</span></span> <span data-ttu-id="5f51e-1728">在下列範例中的多個字串串連作業的使用會產生詳細和硬讀取程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1728">The use of multiple string concatenation operations in the following example produces verbose and hard-to-read code.</span></span>

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

<span data-ttu-id="5f51e-1729">相反地，在下列範例中，字串插值的使用會產生更輕鬆、 更簡潔比字串串連陳述式和呼叫的程式碼<xref:System.String.Format%2A>前一個範例中的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1729">In contrast, the use of interpolated strings in the following example produce much clearer, more concise code than the string concatenation statement and the call to the <xref:System.String.Format%2A> method in the previous example.</span></span>

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a><span data-ttu-id="5f51e-1730">哪裡可以找到的預先定義的格式字串清單，可以搭配的格式項目？</span><span class="sxs-lookup"><span data-stu-id="5f51e-1730">Where can I find a list of the predefined format strings that can be used with format items?</span></span>  
  
-   <span data-ttu-id="5f51e-1731">對於所有的整數和浮點數類型，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1731">For all integral and floating-point types, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="5f51e-1732">如需日期和時間值，請參閱[標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1732">For date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
-   <span data-ttu-id="5f51e-1733">列舉值，請參閱[列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1733">For enumeration values, see [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).</span></span>  
  
-   <span data-ttu-id="5f51e-1734">如<xref:System.TimeSpan>值，請參閱[標準 TimeSpan 格式字串](~/docs/standard/base-types/standard-timespan-format-strings.md)和[自訂 TimeSpan 格式字串](~/docs/standard/base-types/custom-timespan-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1734">For <xref:System.TimeSpan> values, see  [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) and [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).</span></span>  
  
-   <span data-ttu-id="5f51e-1735">如<xref:System.Guid>值，請參閱 < 備註 > 一節的<xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>參考頁面。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1735">For <xref:System.Guid> values, see the Remarks section of the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> reference page.</span></span>  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a><span data-ttu-id="5f51e-1736">如何控制結果字串時，取代的項目格式的對齊方式？</span><span class="sxs-lookup"><span data-stu-id="5f51e-1736">How do I control the alignment of the result strings that replace format items?</span></span>  
 <span data-ttu-id="5f51e-1737">格式項目的一般語法如下：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1737">The general syntax of a format item is:</span></span>  
  
```  
{index[,alignment][: formatString]}  
```  
  
 <span data-ttu-id="5f51e-1738">其中*對齊*是帶正負號的整數，定義欄位寬度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1738">where *alignment* is a signed integer that defines the field width.</span></span> <span data-ttu-id="5f51e-1739">如果此值為負數，欄位中的文字是靠左對齊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1739">If this value is negative, text in the field is left-aligned.</span></span> <span data-ttu-id="5f51e-1740">如果是正數，文字是靠右對齊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1740">If it is positive, text is right-aligned.</span></span>  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a><span data-ttu-id="5f51e-1741">如何控制十進位分隔符號之後的數字位數？</span><span class="sxs-lookup"><span data-stu-id="5f51e-1741">How do I control the number of digits after the decimal separator?</span></span>  
 <span data-ttu-id="5f51e-1742">所有[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)except （可搭配只有整數） 的"D"、"G"、"R"，和"X"允許精確度規範定義結果字串中的小數位數數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1742">All [standard numeric format strings](~/docs/standard/base-types/standard-numeric-format-strings.md) except "D" (which is used with integers only), "G", "R", and "X" allow a precision specifier that defines the number of decimal digits in the result string.</span></span> <span data-ttu-id="5f51e-1743">下列範例會使用標準數值格式字串來控制結果字串中的小數位數數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1743">The following example uses standard numeric format strings to control the number of decimal digits in the result string.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 <span data-ttu-id="5f51e-1744">如果您使用[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)，使用"0"格式規範來控制在結果字串中，如下列範例所示的小數位數數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1744">If you're using a [custom numeric format string](~/docs/standard/base-types/custom-numeric-format-strings.md), use the "0" format specifier to control the number of decimal digits in the result string, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a><span data-ttu-id="5f51e-1745">如何控制整數位數數的字？</span><span class="sxs-lookup"><span data-stu-id="5f51e-1745">How do I control the number of integral digits?</span></span>  
 <span data-ttu-id="5f51e-1746">根據預設，格式化作業只會顯示非零的整數位數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1746">By default, formatting operations only display non-zero integral digits.</span></span> <span data-ttu-id="5f51e-1747">如果您正在格式化的整數，您可以使用"D"和"X"標準格式字串的有效位數規範來控制的位數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1747">If you are formatting integers, you can use a precision specifier with the "D" and "X" standard format strings to control the number of digits.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 <span data-ttu-id="5f51e-1748">您可以在使用 「 0 」 產生的結果字串，以指定的數字的整數位數的整數或浮點數，加上前置零填補[自訂數值格式規範](~/docs/standard/base-types/custom-numeric-format-strings.md)，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1748">You can pad an integer or floating-point number with leading zeros to produce a result string with a specified number of integral digits by using the "0" [custom numeric format specifier](~/docs/standard/base-types/custom-numeric-format-strings.md), as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a><span data-ttu-id="5f51e-1749">在 [格式] 清單中可以包含多少個項目？</span><span class="sxs-lookup"><span data-stu-id="5f51e-1749">How many items can I include in the format list?</span></span>  
 <span data-ttu-id="5f51e-1750">沒有任何實用的限制。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1750">There is no practical limit.</span></span> <span data-ttu-id="5f51e-1751">第二個參數<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法會標記為<xref:System.ParamArrayAttribute>屬性，可讓您包含分隔的清單或物件陣列做為格式清單。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1751">The second parameter of the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is tagged with the <xref:System.ParamArrayAttribute> attribute, which allows you to include either a delimited list or an object array as your format list.</span></span>  
  
<a name="braces" />
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a><span data-ttu-id="5f51e-1752">如何包含常值的大括號 ("{"和"}") 在結果字串中？</span><span class="sxs-lookup"><span data-stu-id="5f51e-1752">How do I include literal braces ("{" and "}") in the result string?</span></span>  
 <span data-ttu-id="5f51e-1753">例如，如何避免下列方法呼叫擲回<xref:System.FormatException>例外狀況？</span><span class="sxs-lookup"><span data-stu-id="5f51e-1753">For example, how do you prevent the following method call from throwing a <xref:System.FormatException> exception?</span></span>  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 <span data-ttu-id="5f51e-1754">左或右大括號會解譯為開頭或結尾的格式項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1754">A single opening or closing brace is always interpreted as the beginning or end of a format item.</span></span> <span data-ttu-id="5f51e-1755">若要解譯為常值，則必須逸出。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1755">To be interpreted literally, it must be escaped.</span></span> <span data-ttu-id="5f51e-1756">您加入另一個大括號逸出括號 ("{{"和"}}"而不是"{"和"}")，在下列的方法呼叫中：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1756">You escape a brace by adding another brace ("{{" and "}}" instead of "{" and "}"), as in the following method call:</span></span>  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 <span data-ttu-id="5f51e-1757">不過，即使逸出大括號會輕鬆地譯。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1757">However, even escaped braces are easily misinterpreted.</span></span> <span data-ttu-id="5f51e-1758">我們建議您在 [格式] 清單中包含大括號，並將下列範例所示將其插入結果字串中使用的格式項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1758">We recommend that you include braces in the format list and use format items to insert them in the result string, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a><span data-ttu-id="5f51e-1759">為什麼我 String.Format 方法呼叫擲回 FormatException？</span><span class="sxs-lookup"><span data-stu-id="5f51e-1759">Why does my call to the String.Format method throw a FormatException?</span></span>  
 <span data-ttu-id="5f51e-1760">最常見的例外狀況的原因是格式項目的索引未對應到 [格式] 清單中的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1760">The most common cause of the exception is that the index of a format item doesn't correspond to an object in the format list.</span></span> <span data-ttu-id="5f51e-1761">通常這表示您已經 misnumbered 格式項目的索引，或您忘了在 [格式] 清單中包含的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1761">Usually this indicates that you've misnumbered the indexes of format items or you've forgotten to include an object in the format list.</span></span> <span data-ttu-id="5f51e-1762">嘗試將包含未逸出向左或右大括號字元也會擲回<xref:System.FormatException>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1762">Attempting to include an unescaped left or right brace character also throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="5f51e-1763">有時候，例外狀況會錯字; 的結果例如，一般的錯誤是打錯"["（左括號） 而不是"{"（左大括號）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1763">Occasionally, the exception is the result of a typo; for example, a typical mistake is to mistype "[" (the left bracket) instead of "{" (the left brace).</span></span>  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a><span data-ttu-id="5f51e-1764">如果 Format(System.IFormatProvider,System.String,System.Object[]) 方法支援參數陣列，為什麼的確我的程式碼會擲回例外狀況時使用陣列嗎？</span><span class="sxs-lookup"><span data-stu-id="5f51e-1764">If the Format(System.IFormatProvider,System.String,System.Object[]) method supports parameter arrays, why does my code throw an exception when I use an array?</span></span>  
 <span data-ttu-id="5f51e-1765">例如，下列程式碼會擲回<xref:System.FormatException>例外狀況：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1765">For example, the following code throws a <xref:System.FormatException> exception:</span></span>  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 <span data-ttu-id="5f51e-1766">這是編譯器多載解析的問題。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1766">This is a problem of compiler overload resolution.</span></span> <span data-ttu-id="5f51e-1767">因為編譯器無法轉換成物件陣列的整數的陣列，它會將整數陣列視為單一引數，因此它會呼叫<xref:System.String.Format%28System.String%2CSystem.Object%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1767">Because the compiler cannot convert an array of integers to an object array, it treats the integer array as a single argument, so it calls the <xref:System.String.Format%28System.String%2CSystem.Object%29> method.</span></span> <span data-ttu-id="5f51e-1768">因為有四個格式項目，但單一項目 [格式] 清單中的，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1768">The exception is thrown because there are four format items but only a single item in the format list.</span></span>  
  
 <span data-ttu-id="5f51e-1769">Visual Basic 或 C# 都不可以轉換成物件陣列的整數陣列，所以您必須自行執行轉換，然後再呼叫<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1769">Because neither Visual Basic nor C# can convert an integer array to an object array, you have to perform the conversion yourself before calling the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span> <span data-ttu-id="5f51e-1770">下列範例提供一個實作。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1770">The following example provides one implementation.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

<span data-ttu-id="5f51e-1771">呼叫的數個範例<xref:System.String.Format%2A>方法散佈透過[備註](#remarks)本文一節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1771">Numerous examples that call the <xref:System.String.Format%2A> method are interspersed through the [Remarks](#remarks) section of this article.</span></span>  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

<span data-ttu-id="5f51e-1772">您也可以下載完整的`String.Format`範例中，也就是包含[C#.NET Core 2.0 專案](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip)和[適用於 Visual Basic.NET Core 2.0 專案](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip)，從[dotnet/文件GitHub 儲存機制](https://github.com/dotnet/docs)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1772">You can also download a complete set of `String.Format` examples, which are included a [.NET Core 2.0 project for C#](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip) and a [.NET Core 2.0 project for Visual Basic](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip), from the [dotnet/docs GitHub repository](https://github.com/dotnet/docs).</span></span>

<span data-ttu-id="5f51e-1773">以下是某些發行項中包含的範例：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1773">The following are some of the examples included in the article:</span></span>

### <a name="create-a-format-string"></a><span data-ttu-id="5f51e-1774">建立的格式字串</span><span class="sxs-lookup"><span data-stu-id="5f51e-1774">Create a format string</span></span>

[<span data-ttu-id="5f51e-1775">將字串插入</span><span class="sxs-lookup"><span data-stu-id="5f51e-1775">Inserting a string</span></span>](#inserting-a-string)  
[<span data-ttu-id="5f51e-1776">格式項目</span><span class="sxs-lookup"><span data-stu-id="5f51e-1776">The format item</span></span>](#the-format-item)  
[<span data-ttu-id="5f51e-1777">格式項目具有相同的索引</span><span class="sxs-lookup"><span data-stu-id="5f51e-1777">Format items that have the same index</span></span>](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a><span data-ttu-id="5f51e-1778">控制格式化的輸出</span><span class="sxs-lookup"><span data-stu-id="5f51e-1778">Control formatted output</span></span>

[<span data-ttu-id="5f51e-1779">控制格式設定</span><span class="sxs-lookup"><span data-stu-id="5f51e-1779">Controlling formatting</span></span>](#controlling-formatting)  
[<span data-ttu-id="5f51e-1780">控制間距</span><span class="sxs-lookup"><span data-stu-id="5f51e-1780">Controlling spacing</span></span>](#controlling-spacing)  
[<span data-ttu-id="5f51e-1781">控制對齊方式</span><span class="sxs-lookup"><span data-stu-id="5f51e-1781">Controlling alignment</span></span>](#controlling-alignment)  
[<span data-ttu-id="5f51e-1782">控制整數位數的數目</span><span class="sxs-lookup"><span data-stu-id="5f51e-1782">Controlling the number of integral digits</span></span>](#how-do-i-control-the-number-of-integral-digits)  
[<span data-ttu-id="5f51e-1783">控制小數分隔符號之後的數字的數目</span><span class="sxs-lookup"><span data-stu-id="5f51e-1783">Controlling the number of digits after the decimal separator</span></span>](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[<span data-ttu-id="5f51e-1784">結果字串中包括常值的大括號</span><span class="sxs-lookup"><span data-stu-id="5f51e-1784">Including literal braces in a result string</span></span>](#braces)  

### <a name="make-format-strings-culture-sensitive"></a><span data-ttu-id="5f51e-1785">進行區分文化特性的格式字串</span><span class="sxs-lookup"><span data-stu-id="5f51e-1785">Make format strings culture-sensitive</span></span>

[<span data-ttu-id="5f51e-1786">文化特性格式</span><span class="sxs-lookup"><span data-stu-id="5f51e-1786">Culture-sensitive formatting</span></span>](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a><span data-ttu-id="5f51e-1787">自訂格式化作業</span><span class="sxs-lookup"><span data-stu-id="5f51e-1787">Customize the formatting operation</span></span>

[<span data-ttu-id="5f51e-1788">自訂格式化作業</span><span class="sxs-lookup"><span data-stu-id="5f51e-1788">A custom formatting operation</span></span>](#example-a-custom-formatting-operation)  
[<span data-ttu-id="5f51e-1789">截距，提供者和羅馬數字格式器</span><span class="sxs-lookup"><span data-stu-id="5f51e-1789">An intercept provider and Roman numeral formatter</span></span>](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="5f51e-1790">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1790">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="5f51e-1791">要格式化的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1791">The object to format.</span></span></param>
        <summary><span data-ttu-id="5f51e-1792">以指定物件的字串表示，取代字串中的一或多個格式項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1792">Replaces one or more format items in a string with the string representation of a specified object.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1793"><paramref name="format" /> 的複本，其中的所有格式項目已由 <paramref name="arg0" /> 的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1793">A copy of <paramref name="format" /> in which any format items are replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="5f51e-1794">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)運算式的值轉換成其字串表示，以及該表示嵌入字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1794">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a><span data-ttu-id="5f51e-1795">範例： 格式為單一引數</span><span class="sxs-lookup"><span data-stu-id="5f51e-1795">Example: Formatting a single argument</span></span>  
 
 <span data-ttu-id="5f51e-1796">下列範例會使用<xref:System.String.Format%28System.String%2CSystem.Object%29>內嵌字串中間的個人的年齡的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1796">The following example uses the <xref:System.String.Format%28System.String%2CSystem.Object%29> method to embed an individual's age in the middle of a string.</span></span>  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1797"><paramref name="format" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1797"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="5f51e-1798"><paramref name="format" /> 中的格式項目無效。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1798">The format item in <paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="5f51e-1799">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1799">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1800">格式項目的索引不是零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1800">The index of a format item is not zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="5f51e-1801">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1801">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="args"><span data-ttu-id="5f51e-1802">物件陣列，包含零或多個要格式化的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1802">An object array that contains zero or more objects to format.</span></span></param>
        <summary><span data-ttu-id="5f51e-1803">以指定陣列中對應物件的字串表示，取代指定之字串中的格式項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1803">Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1804"><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="args" /> 中對應物件的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1804">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="5f51e-1805">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)四個或多個運算式的值轉換成其字串表示法，並在這些表示法嵌入字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1805">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="5f51e-1806">因為`args`參數標示為<xref:System.ParamArrayAttribute?displayProperty=nameWithType>屬性，您可以將物件傳遞至方法做為個別引數，或做為<xref:System.Object>陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1806">Since the `args` parameter is marked with the <xref:System.ParamArrayAttribute?displayProperty=nameWithType> attribute, you can pass the objects to the method as individual arguments or as an <xref:System.Object> array.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a><span data-ttu-id="5f51e-1807">範例： 格式化超過三個引數</span><span class="sxs-lookup"><span data-stu-id="5f51e-1807">Example: Formatting more than three arguments</span></span>  
 
 <span data-ttu-id="5f51e-1808">這個範例會建立字串，包含在特定日期的高低溫度資料。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1808">This example creates a string that contains data on the high and low temperature on a particular date.</span></span> <span data-ttu-id="5f51e-1809">複合格式字串有五個格式項目，在 C# 範例和六個 in Visual Basic 範例。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1809">The composite format string has five format items in the C# example and six in the Visual Basic example.</span></span> <span data-ttu-id="5f51e-1810">兩個格式項目定義及其對應值的字串表示，寬度，並將第一個格式項目也會包含標準日期和時間格式字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1810">Two of the format items define the width of their corresponding value's string representation, and the first format item also includes a standard date and time format string.</span></span>  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 <span data-ttu-id="5f51e-1811">您也可以傳遞要格式化為陣列的物件而非引數清單。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1811">You can also pass the objects to be formatted as an array rather than a an argument list.</span></span>  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1812"><paramref name="format" /> 或 <paramref name="args" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1812"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="5f51e-1813"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1813"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="5f51e-1814">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1814">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1815">格式項目的索引小於零，或者大於或等於 <paramref name="args" /> 陣列的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1815">The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-1816">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1816">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="5f51e-1817">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1817">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="5f51e-1818">要格式化的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1818">The object to format.</span></span></param>
        <summary><span data-ttu-id="5f51e-1819">以對應物件的字串表示，取代指定之字串中的一或多個格式項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1819">Replaces the format item or items in a specified string with the string representation of the corresponding object.</span></span> <span data-ttu-id="5f51e-1820">參數提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1820">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1821"><paramref name="format" /> 的複本，其中的一或多個格式項目已由 <paramref name="arg0" /> 的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1821">A copy of <paramref name="format" /> in which the format item or items have been replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="5f51e-1822">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)運算式的值轉換成其字串表示，以及該表示嵌入字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1822">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span> <span data-ttu-id="5f51e-1823">執行轉換，此方法會使用區分文化特性的格式設定或自訂格式器。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1823">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="5f51e-1824">方法會將轉換`arg0`為其字串表示，藉由呼叫其**ToString(IFormatProvider)** 方法或，如果物件的對應格式項目會藉由呼叫包含格式字串，其**ToString (字串，IFormatProvider）** 方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1824">The method converts `arg0` to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="5f51e-1825">如果這些方法不存在，則會呼叫物件的無參數**ToString**方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1825">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1826"><paramref name="format" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1826"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="5f51e-1827"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1827"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="5f51e-1828">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1828">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1829">格式項目的索引不是零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1829">The index of a format item is not zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-1830">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1830">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="5f51e-1831">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1831">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="args"><span data-ttu-id="5f51e-1832">物件陣列，包含零或多個要格式化的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1832">An object array that contains zero or more objects to format.</span></span></param>
        <summary><span data-ttu-id="5f51e-1833">以指定陣列中對應物件的字串表示，取代字串中的格式項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1833">Replaces the format items in a string with the string representations of corresponding objects in a specified array.</span></span> <span data-ttu-id="5f51e-1834">參數提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1834">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1835"><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="args" /> 中對應物件的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1835">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="5f51e-1836">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將四個或多個運算式轉換成其字串表示法，以及這些表示法嵌入字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1836">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="5f51e-1837">執行轉換，此方法會使用區分文化特性的格式設定或自訂格式器。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1837">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="5f51e-1838">方法會將轉換每個<xref:System.Object>引數為其字串表示，藉由呼叫其**ToString(IFormatProvider)** 方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其**ToString(String,IFormatProvider)** 方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1838">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="5f51e-1839">如果這些方法不存在，則會呼叫物件的無參數**ToString**方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1839">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a><span data-ttu-id="5f51e-1840">範例： 區分文化特性的格式化</span><span class="sxs-lookup"><span data-stu-id="5f51e-1840">Example: Culture-sensitive formatting</span></span>  
 <span data-ttu-id="5f51e-1841">這個範例會使用<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法，以顯示一些日期和時間值和數值的字串表示，使用數個不同的文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1841">This example uses the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method to display the string representation of some date and time values and numeric values by using several different cultures.</span></span>  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1842"><paramref name="format" /> 或 <paramref name="args" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1842"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="5f51e-1843"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1843"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="5f51e-1844">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1844">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1845">格式項目的索引小於零，或者大於或等於 <paramref name="args" /> 陣列的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1845">The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="5f51e-1846">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1846">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="5f51e-1847">要格式化的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1847">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="5f51e-1848">要格式化的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1848">The second object to format.</span></span></param>
        <summary><span data-ttu-id="5f51e-1849">以兩個指定物件的字串表示，取代字串中的格式項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1849">Replaces the format items in a string with the string representation of two specified objects.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1850"><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="arg0" /> 和 <paramref name="arg1" /> 的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1850">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="5f51e-1851">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將兩個運算式的值轉換成其字串表示法，並在字串中嵌入這些表示法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1851">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of two expressions to their string representations and to embed those representations in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a><span data-ttu-id="5f51e-1852">範例： 設定格式化的兩個引數</span><span class="sxs-lookup"><span data-stu-id="5f51e-1852">Example: Formatting two arguments</span></span>  
 
 <span data-ttu-id="5f51e-1853">這個範例會使用<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29>方法，以顯示儲存在一般時間和溫度資料<xref:System.Collections.Generic.Dictionary%602>物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1853">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> method to display time and temperature data stored in a generic <xref:System.Collections.Generic.Dictionary%602> object.</span></span> <span data-ttu-id="5f51e-1854">請注意在格式字串有三個格式項目，雖然只有兩個要格式化的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1854">Note that the format string has three format items, although there are only two objects to format.</span></span> <span data-ttu-id="5f51e-1855">這是因為清單 （日期和時間值） 中的第一個物件由兩個格式項目： 第一個格式項目顯示，並且第二個顯示的日期。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1855">This is because the first object in the list (a date and time value) is used by two format items: The first format item displays the time, and the second displays the date.</span></span>  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1856"><paramref name="format" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1856"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="5f51e-1857"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1857"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="5f51e-1858">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1858">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1859">格式項目的索引不是零或一。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1859">The index of a format item is not zero or one.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-1860">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1860">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="5f51e-1861">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1861">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="5f51e-1862">要格式化的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1862">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="5f51e-1863">要格式化的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1863">The second object to format.</span></span></param>
        <summary><span data-ttu-id="5f51e-1864">以兩個指定物件的字串表示，取代字串中的格式項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1864">Replaces the format items in a string with the string representation of two specified objects.</span></span> <span data-ttu-id="5f51e-1865">參數提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1865">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1866"><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="arg0" /> 和 <paramref name="arg1" /> 的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1866">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="5f51e-1867">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)來將兩個運算式轉換成其字串表示法，並在字串中嵌入這些表示法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1867">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert two expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="5f51e-1868">執行轉換，此方法會使用區分文化特性的格式設定或自訂格式器。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1868">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="5f51e-1869">方法會將轉換每個<xref:System.Object>引數為其字串表示，藉由呼叫其**ToString(IFormatProvider)** 方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其**ToString(String,IFormatProvider)** 方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1869">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="5f51e-1870">如果這些方法不存在，則會呼叫物件的無參數**ToString**方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1870">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1871"><paramref name="format" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1871"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="5f51e-1872"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1872"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="5f51e-1873">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1873">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1874">格式項目的索引不是零或一。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1874">The index of a format item is not zero or one.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="5f51e-1875">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1875">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="5f51e-1876">要格式化的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1876">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="5f51e-1877">要格式化的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1877">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="5f51e-1878">要格式化的第三個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1878">The third object to format.</span></span></param>
        <summary><span data-ttu-id="5f51e-1879">以三個指定物件的字串表示，取代字串中的格式項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1879">Replaces the format items in a string with the string representation of three specified objects.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1880"><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1880">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="5f51e-1881">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)三個運算式的值轉換成其字串表示法，並在這些表示法嵌入字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1881">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of three expressions to their string representations and to embed those representations in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a><span data-ttu-id="5f51e-1882">範例： 設定格式化的三個引數</span><span class="sxs-lookup"><span data-stu-id="5f51e-1882">Example: Formatting three arguments</span></span>  
 
 <span data-ttu-id="5f51e-1883">這個範例會使用<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法來建立字串，其中說明的布林值結果`And`具有兩個整數值的作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1883">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to create a string that illustrates the result of a Boolean `And` operation with two integer values.</span></span> <span data-ttu-id="5f51e-1884">請注意，格式字串包含六個格式項目，但是方法只有三個項目在其參數清單中，因為每個項目會以兩個不同的方式格式化。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1884">Note that the format string includes six format items, but the method has only three items in its parameter list, because each item is formatted in two different ways.</span></span>  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1885"><paramref name="format" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1885"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="5f51e-1886"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1886"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="5f51e-1887">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1887">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1888">格式項目的索引小於零或大於二。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1888">The index of a format item is less than zero, or greater than two.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-1889">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1889">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="5f51e-1890">[複合格式字串](~/docs/standard/base-types/composite-formatting.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1890">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="5f51e-1891">要格式化的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1891">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="5f51e-1892">要格式化的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1892">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="5f51e-1893">要格式化的第三個物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1893">The third object to format.</span></span></param>
        <summary><span data-ttu-id="5f51e-1894">以三個指定物件的字串表示，取代字串中的格式項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1894">Replaces the format items in a string with the string representation of three specified objects.</span></span> <span data-ttu-id="5f51e-1895">參數提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1895">An parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1896"><paramref name="format" /> 的複本，其中的格式項目已由 <paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的字串表示取代。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1896">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="5f51e-1897">這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)將三個運算式轉換成其字串表示法，以及這些表示法嵌入字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1897">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert three expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="5f51e-1898">執行轉換，此方法會使用區分文化特性的格式設定或自訂格式器。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1898">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="5f51e-1899">方法會將轉換每個<xref:System.Object>引數為其字串表示，藉由呼叫其**ToString(IFormatProvider)** 方法或，如果物件的對應格式項目會包含格式字串，藉由呼叫其**ToString(String,IFormatProvider)** 方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1899">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="5f51e-1900">如果這些方法不存在，則會呼叫物件的無參數**ToString**方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1900">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1901"><paramref name="format" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1901"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="5f51e-1902"><paramref name="format" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1902"><paramref name="format" /> is invalid.</span></span>  
  
 <span data-ttu-id="5f51e-1903">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-1903">-or-</span></span>  
  
 <span data-ttu-id="5f51e-1904">格式項目的索引小於零或大於二。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1904">The index of a format item is less than zero, or greater than two.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-1905">擷取可以逐一查看這個字串中個別字元的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1905">Retrieves an object that can iterate through the individual characters in this string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1906">列舉程式物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1906">An enumerator object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  <span data-ttu-id="5f51e-1907">而不是呼叫<xref:System.String.GetEnumerator%2A>方法來擷取<xref:System.CharEnumerator>物件，然後使用列舉字串，您應該改為使用您語言的反覆項目建構 (在 C# 中，在 C + + CLR，以及在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1907">Rather than calling the <xref:System.String.GetEnumerator%2A> method to retrieve a <xref:System.CharEnumerator> object that you then use to enumerate a string, you should instead use your language's iteration construct ( in C#,  in C++/CLR, and  in Visual Basic).</span></span>                   <span data-ttu-id="5f51e-1908">[foreach](~/docs/csharp/language-reference/keywords/foreach-in.md)在 C# 中，[每個](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79)在 C + + CLR 和[每個](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1908">[foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in C#,                  [for each](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79) in C++/CLR, and                  [For Each](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) in Visual Basic).</span></span>  
  
 <span data-ttu-id="5f51e-1909">這個方法可讓您逐一查看字串中的個別字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1909">This method enables you to iterate the individual characters in a string.</span></span> <span data-ttu-id="5f51e-1910">例如，Visual Basic`For Each`和 C#`foreach`陳述式會叫用此方法以傳回<xref:System.CharEnumerator>可以提供唯讀存取，這個字串執行個體中的字元的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1910">For example, the Visual Basic `For Each` and C# `foreach` statements invoke this method to return a <xref:System.CharEnumerator> object that can provide read-only access to the characters in this string instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1911">下列範例會逐一查看數個字串中的字元，並顯示其個別字元的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1911">The following example iterates the characters in several strings and displays information about their individual characters.</span></span> <span data-ttu-id="5f51e-1912">它會使用語言反覆項目建構，而不是呼叫<xref:System.String.GetEnumerator%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1912">It uses the language iteration construct rather than a call to the <xref:System.String.GetEnumerator%2A> method.</span></span>  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-1913">傳回這個字串的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1913">Returns the hash code for this string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1914">32 位元帶正負號的整數雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1914">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1915">行為<xref:System.String.GetHashCode%2A>相依於它的實作，可能會變更到另一個版本的 common language runtime。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1915">The behavior of <xref:System.String.GetHashCode%2A> is dependent on its implementation, which might change from one version of the common language runtime to another.</span></span> <span data-ttu-id="5f51e-1916">為什麼這可能會發生的原因是要提升的效能<xref:System.String.GetHashCode%2A>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1916">A reason why this might happen is to improve the performance of <xref:System.String.GetHashCode%2A>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5f51e-1917">如果兩個 string 物件是否相等，<xref:System.String.GetHashCode%2A>方法會傳回相同的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1917">If two string objects are equal, the <xref:System.String.GetHashCode%2A> method returns identical values.</span></span> <span data-ttu-id="5f51e-1918">不過，沒有任何每個唯一字串值的唯一雜湊碼值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1918">However, there is not a unique hash code value for each unique string value.</span></span> <span data-ttu-id="5f51e-1919">不同的字串可以傳回相同的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1919">Different strings can return the same hash code.</span></span>  
>   
>  <span data-ttu-id="5f51e-1920">雜湊程式碼本身並非是穩定。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1920">The hash code itself is not guaranteed to be stable.</span></span> <span data-ttu-id="5f51e-1921">.NET Framework 的版本和跨平台 （例如，32 位元和 64 位元） 的單一版本的.NET framework 相同字串的雜湊程式碼可能會不同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1921">Hash codes for identical strings can differ across versions of the .NET Framework and across platforms (such as 32-bit and 64-bit) for a single version of the .NET Framework.</span></span> <span data-ttu-id="5f51e-1922">在某些情況下，它們可以甚至不同由應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1922">In some cases, they can even differ by application domain.</span></span> <span data-ttu-id="5f51e-1923">這表示兩個後續執行相同的程式可能會傳回不同的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1923">This implies two subsequent runs of the same program may return different hash codes.</span></span>  
>   
>  <span data-ttu-id="5f51e-1924">如此一來，雜湊碼應該永遠不會使用外部應用程式定義域中建立，它們應該永遠不會做為集合中的索引鍵欄位，它們應該永遠不會保存。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1924">As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.</span></span>  
>   
>  <span data-ttu-id="5f51e-1925">最後，不要使用雜湊程式碼而不是如果您需要的密碼編譯強式雜湊，密碼編譯雜湊函式所傳回的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1925">Finally, don't use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="5f51e-1926">密碼編譯雜湊，若為使用衍生自類別<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>或<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>類別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1926">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
>   
>  <span data-ttu-id="5f51e-1927">如需雜湊程式碼的詳細資訊，請參閱<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1927">For more information about hash codes, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5f51e-1928">在桌面應用程式，您可以使用[ \<UseRandomizedStringHashAlgorithm > 項目](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)產生唯一的雜湊程式碼在每個應用程式定義域做為基準。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1928">In desktop apps, you can use the             [\<UseRandomizedStringHashAlgorithm> element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) to generate unique hash codes on a per application domain basis.</span></span> <span data-ttu-id="5f51e-1929">這可減少衝突的數目，並改善整體效能的插入和使用雜湊資料表的查閱。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1929">This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</span></span> <span data-ttu-id="5f51e-1930">下列範例示範如何使用[ \<UseRandomizedStringHashAlgorithm > 項目](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1930">The following example shows how to use the                [\<UseRandomizedStringHashAlgorithm> element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span> <span data-ttu-id="5f51e-1931">它會定義以產生唯一的雜湊程式碼在每個應用程式定義域做為基準。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1931">It defines a  to generate unique hash codes on a per application domain basis.</span></span> <span data-ttu-id="5f51e-1932">這可減少衝突的數目，並改善整體效能的插入和使用雜湊資料表的查閱。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1932">This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</span></span> <span data-ttu-id="5f51e-1933">下列範例示範如何使用。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1933">The following example shows how to use the .</span></span> <span data-ttu-id="5f51e-1934">它會定義`DisplayString`類別，其中包含私用的字串常數， `s`，其值為"This is 字串"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1934">It defines a `DisplayString` class that includes a private string constant, `s`, whose value is "This is a string."</span></span> <span data-ttu-id="5f51e-1935">它也包含 `ShowStringHashCode` 方法，這個方法會將字串值及其雜湊碼與方法執行所在之應用程式定義域的名稱一起顯示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1935">It also includes a `ShowStringHashCode` method that displays the string value and its hash code along with the name of the application domain in which the method is executing.</span></span>  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 <span data-ttu-id="5f51e-1936">當您在沒有提供組態檔的情況下執行此範例，它會顯示類似下列的輸出。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1936">When you run the example without supplying a configuration file, it displays output similar to the following.</span></span> <span data-ttu-id="5f51e-1937">請注意，字串的雜湊碼在兩個應用程式定義域中相同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1937">Note that the hash codes for the string are identical in the two application domains.</span></span>  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 <span data-ttu-id="5f51e-1938">不過，如果您將下列組態檔加入至範例的目錄，然後執行這個範例，相同字串的雜湊碼將會因為應用程式定義域不同而有所不同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1938">However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.</span></span>  
  
```  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 <span data-ttu-id="5f51e-1939">當組態檔存在時，這個範例會顯示下列輸出：</span><span class="sxs-lookup"><span data-stu-id="5f51e-1939">When the configuration file is present, the example displays the following output:</span></span>  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  <span data-ttu-id="5f51e-1940">雜湊程式碼用來插入和有效率地擷取雜湊表中的索引鍵的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1940">Hash codes are used to insert and retrieve keyed objects from hash tables efficiently.</span></span> <span data-ttu-id="5f51e-1941">不過，雜湊程式碼不可唯一識別字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1941">However, hash codes don't uniquely identify strings.</span></span> <span data-ttu-id="5f51e-1942">相同的字串具有相同的雜湊碼，但 common language runtime 也可以將相同的雜湊程式碼指派給不同的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1942">Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings.</span></span> <span data-ttu-id="5f51e-1943">此外，.NET Framework 版本、 平台內的單一版本，和應用程式定義域，可能會不同雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1943">In addition, hash codes can vary by version of the .NET Framework, by platform within a single version, and by application domain.</span></span> <span data-ttu-id="5f51e-1944">因為這個緣故，您不應該序列化，或保存雜湊程式碼的值，也不應使用它們作為雜湊表或字典中索引鍵。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1944">Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.</span></span>  
  
 <span data-ttu-id="5f51e-1945">如需使用雜湊程式碼的其他資訊和`GetHashCode`方法，請參閱<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1945">For additional information about the use of hash codes and the `GetHashCode` method, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1946">下列範例會示範<xref:System.String.GetHashCode%2A>方法使用不同的輸入字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1946">The following example demonstrates the <xref:System.String.GetHashCode%2A> method using various input strings.</span></span>  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-1947">所傳回的值<see cref="M:System.String.GetHashCode" />平台而異。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1947">The value returned by <see cref="M:System.String.GetHashCode" /> is platform-dependent.</span></span> <span data-ttu-id="5f51e-1948">在 32 位元和 64 位元版本的.NET framework 上不相同。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1948">It differs on the 32-bit and 64-bit versions of the .NET Framework.</span></span> <span data-ttu-id="5f51e-1949">它也可以不同的.NET framework 版本之間。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1949">It also can differ between versions of the .NET Framework.</span></span></para>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-1950">傳回類別 <see cref="T:System.TypeCode" /> 的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1950">Returns the <see cref="T:System.TypeCode" /> for class <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1951">列舉常數 <see cref="F:System.TypeCode.String" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1951">The enumerated constant, <see cref="F:System.TypeCode.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="5f51e-1952">下列範例會顯示<xref:System.TypeCode>列舉的常數的<xref:System.String>型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1952">The following example displays the <xref:System.TypeCode> enumerated constant for the <xref:System.String> type.</span></span>  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-1953">報告這個執行個體中指定之 Unicode 字元或字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1953">Reports the zero-based index of the first occurrence of a specified Unicode character or string within this instance.</span></span> <span data-ttu-id="5f51e-1954">如果在此執行個體中找不到該字元或字串，此方法會傳回 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1954">The method returns -1 if the character or string is not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-1955">要搜尋的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1955">A Unicode character to seek.</span></span></param>
        <summary><span data-ttu-id="5f51e-1956">報告這個字串中指定之 Unicode 字元第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1956">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1957">如果找到該字元，則為 <paramref name="value" /> 以零為起始的索引位置，如果找不到為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1957">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1958">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1958">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="5f51e-1959">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1959">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="5f51e-1960">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1960">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1961">下列範例會示範如何搜尋<xref:System.String>字元使用<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1961">The following example demonstrates how you can search a <xref:System.String> for a character using the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-1962">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1962">The string to seek.</span></span></param>
        <summary><span data-ttu-id="5f51e-1963">回報這個執行個體中指定之字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1963">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1964">如果找到該字串，則為 <paramref name="value" /> 以零為起始的索引位置，如未找到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1964">The zero-based index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="5f51e-1965">如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 0。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1965">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1966">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1966">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="5f51e-1967">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1967">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="5f51e-1968">搜尋會從這個執行個體，第一個字元位置開始，並接著直到最後一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1968">The search begins at the first character position of this instance and continues until the last character position.</span></span>  
  
 <span data-ttu-id="5f51e-1969">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1969">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-1970">執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1970">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="5f51e-1971">如果`value`只包含一個或多個可忽略的字元，<xref:System.String.IndexOf%28System.String%29>方法一律會傳回 0 （零），表示比對位於目前的執行個體的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1971">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%29> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</span></span> <span data-ttu-id="5f51e-1972">在下列範例中，<xref:System.String.IndexOf%28System.String%29>方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)、"n"，後面接著選擇性連字號和選擇性的連字號後面接著"m"）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1972">In the following example, the <xref:System.String.IndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="5f51e-1973">只有其中一個字串包含選擇性連字號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1973">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="5f51e-1974">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在每個案例中，因為選擇性連字號是可忽略的字元，結果會與相同選擇性連字號不包含在`value`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1974">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="5f51e-1975">當搜尋軟連，方法會傳回 0 （零），表示它已在字串的開頭找到相符項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1975">When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.</span></span>  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1976">下列範例會搜尋"n"中"動物"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1976">The following example searches for the "n" in "animal".</span></span> <span data-ttu-id="5f51e-1977">由於字串索引從零，而不是一個開始<xref:System.String.IndexOf%28System.String%29>方法表示"n"是在位置 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1977">Because string indexes begin at zero rather than one, the <xref:System.String.IndexOf%28System.String%29> method indicates that the "n" is at position 1.</span></span>  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 <span data-ttu-id="5f51e-1978">下列範例會使用<xref:System.String.IndexOf%2A>方法，以判斷動物名稱的句子中的開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1978">The following example uses the <xref:System.String.IndexOf%2A> method to determine the starting position of an animal name in a sentence.</span></span> <span data-ttu-id="5f51e-1979">然後會使用這個位置插入形容詞所描述的代表動物句子插入。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1979">It then uses this position to insert an adjective that describes the animal into the sentence.</span></span>  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-1980"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1980"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-1981">中所述[使用字串的最佳作法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1981">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="5f51e-1982">若要尋找的字串執行個體的子字串的第一個索引，使用目前文化特性的比較規則，請呼叫<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />方法多載，其值為<see cref="F:System.StringComparison.CurrentCulture" />針對其`comparisonType`參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1982">To find the first index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-1983">要搜尋的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1983">A Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-1984">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1984">The search starting position.</span></span></param>
        <summary><span data-ttu-id="5f51e-1985">報告這個字串中指定之 Unicode 字元第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1985">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span> <span data-ttu-id="5f51e-1986">搜尋從指定的字元位置開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1986">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="5f51e-1987">如果找到該字元，則為從字串起始處之 <paramref name="value" /> 的以零為起始索引位置，如果找不到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1987">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-1988">索引編號從 0 開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1988">Index numbering starts from 0.</span></span> <span data-ttu-id="5f51e-1989">`startIndex` 參數的範圍可以從 0 到字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1989">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="5f51e-1990">如果`startIndex`等於字串執行個體的長度，此方法會傳回-1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1990">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="5f51e-1991">搜尋範圍是從`startIndex`以字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1991">The search ranges from `startIndex` to the end of the string.</span></span>  
  
 <span data-ttu-id="5f51e-1992">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1992">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="5f51e-1993">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1993">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-1994">下列範例會示範<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1994">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-1995"><paramref name="startIndex" /> 小於 0 (零) 或大於字串的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1995"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of the string.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-1996">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1996">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-1997">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1997">The search starting position.</span></span></param>
        <summary><span data-ttu-id="5f51e-1998">回報這個執行個體中指定之字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1998">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span> <span data-ttu-id="5f51e-1999">搜尋從指定的字元位置開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-1999">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2000">如果找到該字串，則為從目前執行個體起始處之 <paramref name="value" /> 的以零為起始索引位置；如果找不到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2000">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="5f51e-2001">如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2001">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2002">索引編號從 0 開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2002">Index numbering starts from 0.</span></span> <span data-ttu-id="5f51e-2003">`startIndex` 參數的範圍可以從 0 到字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2003">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="5f51e-2004">如果`startIndex`等於字串執行個體的長度，此方法會傳回-1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2004">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="5f51e-2005">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2005">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="5f51e-2006">搜尋開始於`startIndex`字元位置，這個執行個體，並接著直到最後一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2006">The search begins at the `startIndex` character position of this instance and continues until the last character position.</span></span>  
  
 <span data-ttu-id="5f51e-2007">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2007">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2008">執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2008">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="5f51e-2009">如果`value`只包含一個或多個可忽略的字元，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>方法一律會傳回`startIndex`，即開始搜尋的字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2009">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="5f51e-2010">在下列範例中，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>方法用來尋找後面接著"m"兩個字串中選擇性連字號 (U + 00AD) 的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2010">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings.</span></span> <span data-ttu-id="5f51e-2011">只有其中一個字串包含必要的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2011">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="5f51e-2012">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2012">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string.</span></span> <span data-ttu-id="5f51e-2013">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2013">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2014">下列範例會搜尋所有出現的目標字串中指定的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2014">The following example searches for all occurrences of a specified string within a target string.</span></span>  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2015"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2015"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2016"><paramref name="startIndex" /> 小於 0 (零) 或大於這個字串的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2016"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2017">中所述[使用字串的最佳作法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2017">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="5f51e-2018">若要尋找特定的字元位置之後的子字串，就會發生的第一個索引，使用目前文化特性的比較規則，請呼叫<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />方法多載，其值為<see cref="F:System.StringComparison.CurrentCulture" />針對其`comparisonType`參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2018">To find the first index of a substring that occurs after a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2019">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2019">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="5f51e-2020">其中一個列舉值，指定搜尋規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2020">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="5f51e-2021">報告目前 <see cref="T:System.String" /> 物件中指定之字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2021">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="5f51e-2022">參數會指定要用於指定字串的搜尋類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2022">A parameter specifies the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2023">如果找到該字串，則為 <paramref name="value" /> 的索引位置，如果沒有找到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2023">The index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="5f51e-2024">如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 0。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2024">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2025">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2025">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="5f51e-2026">`comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用文字或序數比較規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2026">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2027">下列 exampledemonstrates 三個多載的<xref:System.String.IndexOf%2A>尋找另一個使用的不同值的字串內的字串的第一個出現位置的方法<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2027">The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2028"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2028"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-2029"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2029"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2030">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2030">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2031">執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2031">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="5f51e-2032">如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />方法一律會傳回 0 （零），表示比對位於目前的執行個體的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2032">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</span></span>  
  
 <span data-ttu-id="5f51e-2033">在下列範例中，<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)、"n"，後面接著選擇性連字號和選擇性的連字號後面接著"m"）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2033">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="5f51e-2034">只有其中一個字串包含選擇性連字號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2034">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="5f51e-2035">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，因為選擇性連字號是可忽略的字元，區分文化特性的搜尋傳回相同的值，它就會傳回如果搜尋字串中未包含選擇性連字號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2035">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</span></span> <span data-ttu-id="5f51e-2036">序數搜尋，不過，順利在一個字串中尋找選擇性連字號，並報告它不存在從第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2036">An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</span></span>  
  
 [!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)]
 [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2037">要搜尋的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2037">A Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2038">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2038">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-2039">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2039">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="5f51e-2040">報告這個執行個體中指定之字元第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2040">Reports the zero-based index of the first occurrence of the specified character in this instance.</span></span> <span data-ttu-id="5f51e-2041">搜尋從指定的字元位置開始，並檢視指定數目的字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2041">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2042">如果找到該字元，則為從字串起始處之 <paramref name="value" /> 的以零為起始索引位置，如果找不到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2042">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2043">搜尋開始於`startIndex`，並且會繼續`startIndex`  +  `count` -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2043">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="5f51e-2044">在字元`startIndex`  +  `count`未包含在搜尋中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2044">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="5f51e-2045">索引編號從 0 （零） 開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2045">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="5f51e-2046">`startIndex` 參數的範圍可以從 0 到字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2046">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="5f51e-2047">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2047">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="5f51e-2048">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2048">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2049">下列範例會示範<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2049">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2050"><paramref name="count" /> 或 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2050"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-2051">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2051">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2052"><paramref name="startIndex" /> 大於這個字串的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2052"><paramref name="startIndex" /> is greater than the length of this string.</span></span>  
  
 <span data-ttu-id="5f51e-2053">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2053">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2054"><paramref name="count" /> 大於這個字串減 <paramref name="startIndex" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2054"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2055">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2055">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2056">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2056">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-2057">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2057">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="5f51e-2058">回報這個執行個體中指定之字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2058">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span> <span data-ttu-id="5f51e-2059">搜尋從指定的字元位置開始，並檢視指定數目的字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2059">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2060">如果找到該字串，則為從目前執行個體起始處之 <paramref name="value" /> 的以零為起始索引位置；如果找不到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2060">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="5f51e-2061">如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2061">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2062">索引編號從 0 （零） 開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2062">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="5f51e-2063">`startIndex` 參數的範圍可以從 0 到字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2063">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="5f51e-2064">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2064">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="5f51e-2065">搜尋開始於`startIndex`，並且會繼續`startIndex`  +  `count` -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2065">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="5f51e-2066">在字元`startIndex`  +  `count`未包含在搜尋中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2066">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="5f51e-2067">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2067">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2068">執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2068">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="5f51e-2069">如果`value`只包含一個或多個可忽略的字元，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法一律會傳回`startIndex`，即開始搜尋的字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2069">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="5f51e-2070">在下列範例中，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法用來尋找選擇性連字號 (U + 00AD) 後面接著"m"中的第三個透過兩個字串中的第六個字元位置開始的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2070">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</span></span> <span data-ttu-id="5f51e-2071">只有其中一個字串包含必要的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2071">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="5f51e-2072">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2072">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2073">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2073">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2074">下列範例會尋找的索引字串的所有項目之"he"另一個字串的子字串內。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2074">The following example finds the index of all occurrences of the string "he" within a substring of another string.</span></span> <span data-ttu-id="5f51e-2075">請注意要搜尋的字元數，必須重新計算針對每個搜尋反覆項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2075">Note that the number of characters to be searched must be recalculated for each search iteration.</span></span>  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2076"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2076"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2077"><paramref name="count" /> 或 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2077"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-2078">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2078">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2079"><paramref name="startIndex" /> 大於這個字串的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2079"><paramref name="startIndex" /> is greater than the length of this string.</span></span>  
  
 <span data-ttu-id="5f51e-2080">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2080">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2081"><paramref name="count" /> 大於這個字串減 <paramref name="startIndex" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2081"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2082">中所述[使用字串的最佳作法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2082">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="5f51e-2083">若要使用目前文化特性的比較規則，執行這項作業，請呼叫<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法多載，其值為<see cref="F:System.StringComparison.CurrentCulture" />針對其`comparisonType`參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2083">To use the comparison rules of the current culture to perform this operation, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2084">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2084">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2085">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2085">The search starting position.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="5f51e-2086">其中一個列舉值，指定搜尋規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2086">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="5f51e-2087">報告目前 <see cref="T:System.String" /> 物件中指定之字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2087">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="5f51e-2088">參數會指定目前字串中的開始搜尋位置和要用於指定字串的搜尋類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2088">Parameters specify the starting search position in the current string and the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2089">如果找到該字串，則為從目前執行個體起始處之 <paramref name="value" /> 參數的以零為起始索引位置；如果找不到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2089">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="5f51e-2090">如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2090">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2091">索引編號從 0 開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2091">Index numbering starts from 0.</span></span> <span data-ttu-id="5f51e-2092">`startIndex` 參數的範圍可以從 0 到字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2092">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="5f51e-2093">如果`startIndex`等於字串執行個體的長度，此方法會傳回-1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2093">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="5f51e-2094">`comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用文字或序數比較規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2094">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2095">下列 exampledemonstrates 三個多載的<xref:System.String.IndexOf%2A>尋找另一個使用的不同值的字串內的字串的第一個出現位置的方法<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2095">The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2096"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2096"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2097"><paramref name="startIndex" /> 小於 0 (零) 或大於這個字串的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2097"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-2098"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2098"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2099">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2099">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2100">執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2100">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="5f51e-2101">如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />方法一律會傳回<paramref name="startIndex" />，即開始搜尋的字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2101">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
 <span data-ttu-id="5f51e-2102">在下列範例中，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />方法用來尋找選擇性連字號 (U + 00AD) 後面接著"m"中兩個字串的第三個字元位置開始的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2102">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting with the third character position in two strings.</span></span> <span data-ttu-id="5f51e-2103">只有其中一個字串包含必要的子字串。如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2103">Only one of the strings contains the required substring.If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2104">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2104">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span> <span data-ttu-id="5f51e-2105">只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2105">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)]
 [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2106">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2106">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2107">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2107">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-2108">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2108">The number of character positions to examine.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="5f51e-2109">其中一個列舉值，指定搜尋規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2109">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="5f51e-2110">報告目前 <see cref="T:System.String" /> 物件中指定之字串第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2110">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="5f51e-2111">參數會指定目前字串中的開始搜尋位置、目前字串中要搜尋的字元數目，以及要用於指定字串的搜尋類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2111">Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2112">如果找到該字串，則為從目前執行個體起始處之 <paramref name="value" /> 參數的以零為起始索引位置；如果找不到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2112">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="5f51e-2113">如果 <paramref name="value" /> 為 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2113">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2114">索引編號從 0 （零） 開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2114">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="5f51e-2115">`startIndex` 參數的範圍可以從 0 到字串執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2115">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="5f51e-2116">搜尋開始於`startIndex`，並且會繼續`startIndex`  +  `count` -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2116">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="5f51e-2117">在字元`startIndex`  +  `count`未包含在搜尋中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2117">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="5f51e-2118">`comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用文字或序數比較規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2118">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2119">下列 exampledemonstrates 三個多載的<xref:System.String.IndexOf%2A>尋找另一個使用的不同值的字串內的字串的第一個出現位置的方法<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2119">The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2120"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2120"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2121"><paramref name="count" /> 或 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2121"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-2122">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2122">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2123"><paramref name="startIndex" /> 大於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2123"><paramref name="startIndex" /> is greater than the length of this instance.</span></span>  
  
 <span data-ttu-id="5f51e-2124">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2124">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2125"><paramref name="count" /> 大於這個字串減 <paramref name="startIndex" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2125"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-2126"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2126"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2127">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2127">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2128">執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2128">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="5f51e-2129">如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法一律會傳回<paramref name="startIndex" />，即開始搜尋的字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2129">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
 <span data-ttu-id="5f51e-2130">在下列範例中，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法用來尋找選擇性連字號 (U + 00AD) 後面接著"m"中的第三個透過兩個字串中的第六個字元位置開始的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2130">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</span></span> <span data-ttu-id="5f51e-2131">只有其中一個字串包含必要的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2131">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="5f51e-2132">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2132">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2133">當它執行序數比較時，不過，它會尋找子字串只能在第一個字串中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2133">When it performs an ordinal comparison, however, it finds the substring only in the first string.</span></span> <span data-ttu-id="5f51e-2134">請注意，就第一個字串，其中包含選擇性連字號後面接著"m"，此方法無法傳回選擇性連字號的索引執行區分文化特性的比較時，而是傳回"m"的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2134">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2135">只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2135">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)]
 [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-2136">報告指定 Unicode 字元陣列中的任何字元於這個執行個體中第一個符合項目的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2136">Reports the index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="5f51e-2137">如果在此執行個體中找不到陣列中的字元，此方法會傳回 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2137">The method returns -1 if the characters in the array are not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="5f51e-2138">Unicode 字元陣列，含有一或多個要搜尋的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2138">A Unicode character array containing one or more characters to seek.</span></span></param>
        <summary><span data-ttu-id="5f51e-2139">報告指定的 Unicode 字元陣列中，任何字元在這個執行個體中第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2139">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2140">在此執行個體中，<paramref name="anyOf" /> 中的任何字元第一次出現的所在索引位置 (以零為起始)，如果找不到 <paramref name="anyOf" /> 中的字元，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2140">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2141">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2141">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="5f51e-2142">搜尋`anyOf`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2142">The search for `anyOf` is case-sensitive.</span></span> <span data-ttu-id="5f51e-2143">如果`anyOf`是空陣列，字串的開頭比對的方法會尋找 （亦即，索引位置為零）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2143">If `anyOf` is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).</span></span>  
  
 <span data-ttu-id="5f51e-2144">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2144">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="5f51e-2145">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2145">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2146">下列範例會在字串中尋找第一個母音。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2146">The following example finds the first vowel in a string.</span></span>  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2147"><paramref name="anyOf" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2147"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="5f51e-2148">Unicode 字元陣列，含有一或多個要搜尋的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2148">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2149">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2149">The search starting position.</span></span></param>
        <summary><span data-ttu-id="5f51e-2150">報告指定的 Unicode 字元陣列中，任何字元在這個執行個體中第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2150">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="5f51e-2151">搜尋從指定的字元位置開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2151">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2152">在此執行個體中，<paramref name="anyOf" /> 中的任何字元第一次出現的所在索引位置 (以零為起始)，如果找不到 <paramref name="anyOf" /> 中的字元，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2152">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2153">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2153">Index numbering starts from zero.</span></span> <span data-ttu-id="5f51e-2154">`startIndex`參數的範圍可以從 0 到字串執行個體的長度減一。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2154">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>  
  
 <span data-ttu-id="5f51e-2155">搜尋範圍是從`startIndex`以字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2155">The search ranges from `startIndex` to the end of the string.</span></span>  
  
 <span data-ttu-id="5f51e-2156">搜尋`anyOf`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2156">The search for `anyOf` is case-sensitive.</span></span>  
  
 <span data-ttu-id="5f51e-2157">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有當 Unicode 純量值都相同，字元會視為等於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2157">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="5f51e-2158">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2158">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2159">下列範例會尋找的索引字串的任何字元一次出現"is"另一個字串的子字串內。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2159">The following example finds the index of the occurrence of any character of the string "is" within a substring of another string.</span></span>  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2160"><paramref name="anyOf" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2160"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2161"><paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2161"><paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-2162">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2162">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2163"><paramref name="startIndex" /> 大於這個執行個體中的字元數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2163"><paramref name="startIndex" /> is greater than the number of characters in this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="5f51e-2164">Unicode 字元陣列，含有一或多個要搜尋的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2164">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2165">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2165">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-2166">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2166">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="5f51e-2167">報告指定的 Unicode 字元陣列中，任何字元在這個執行個體中第一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2167">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="5f51e-2168">搜尋從指定的字元位置開始，並檢視指定數目的字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2168">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2169">在此執行個體中，<paramref name="anyOf" /> 中的任何字元第一次出現的所在索引位置 (以零為起始)，如果找不到 <paramref name="anyOf" /> 中的字元，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2169">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2170">搜尋開始於`startIndex`，並且會繼續`startIndex`  +  `count` -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2170">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="5f51e-2171">在字元`startIndex`  +  `count`未包含在搜尋中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2171">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="5f51e-2172">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2172">Index numbering starts from zero.</span></span> <span data-ttu-id="5f51e-2173">`startIndex`參數的範圍可以從 0 到字串執行個體的長度減一。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2173">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>  
  
 <span data-ttu-id="5f51e-2174">搜尋`anyOf`會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2174">The search for `anyOf` is case-sensitive.</span></span>  
  
 <span data-ttu-id="5f51e-2175">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有當 Unicode 純量值都相同，字元會視為等於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2175">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="5f51e-2176">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2176">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2177">下列範例會尋找另一個字串的子字串內的任何字元的字串"aid"的項目索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2177">The following example finds the index of the occurrence of any character of the string "aid" within a substring of another string.</span></span>  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2178"><paramref name="anyOf" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2178"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2179"><paramref name="count" /> 或 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2179"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-2180">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2180">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2181"><paramref name="count" /> + <paramref name="startIndex" /> 大於這個執行個體的字元數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2181"><paramref name="count" /> + <paramref name="startIndex" /> is greater than the number of characters in this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="5f51e-2182">插入的索引位置 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2182">The zero-based index position of the insertion.</span></span></param>
        <param name="value"><span data-ttu-id="5f51e-2183">要插入的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2183">The string to insert.</span></span></param>
        <summary><span data-ttu-id="5f51e-2184">傳回新字串，其中已在這個執行個體中指定的索引位置插入指定的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2184">Returns a new string in which a specified string is inserted at a specified index position in this instance.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2185">與這個執行個體相等的新字串，但是在 <paramref name="value" /> 位置插入了 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2185">A new string that is equivalent to this instance, but with <paramref name="value" /> inserted at position <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2186">如果`startIndex`等於這個執行個體的長度`value`附加至這個執行個體的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2186">If `startIndex` is equal to the length of this instance, `value` is appended to the end of this instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-2187">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2187">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-2188">相反地，它會傳回新字串，其中`value`插入至目前的執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2188">Instead, it returns a new string in which `value` is inserted into the current instance.</span></span>  
  
 <span data-ttu-id="5f51e-2189">例如，傳回值的`"abc".Insert(2, "XYZ")`是 「 abXYZc"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2189">For example, the return value of `"abc".Insert(2, "XYZ")` is "abXYZc".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2190">下列範例會將空格字元在字串的第四個字元位置 （位於索引 3 的字元）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2190">The following example inserts a space character in the fourth character position (the character at index 3) of a string.</span></span>  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 <span data-ttu-id="5f51e-2191">下列主控台應用程式會提示使用者輸入一或多個以描述兩個動物形容詞。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2191">The following console application prompts the users to enter one or more adjectives to describe two animals.</span></span> <span data-ttu-id="5f51e-2192">然後它會呼叫<xref:System.String.Insert%2A>方法插入到字串的使用者所輸入的文字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2192">It then calls the <xref:System.String.Insert%2A> method to insert the text entered by the user into a string.</span></span>  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2193"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2193"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2194"><paramref name="startIndex" /> 為負值或大於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2194"><paramref name="startIndex" /> is negative or greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="5f51e-2195">要在保留集區中搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2195">A string to search for in the intern pool.</span></span></param>
        <summary><span data-ttu-id="5f51e-2196">擷取指定的 <see cref="T:System.String" /> 的系統參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2196">Retrieves the system's reference to the specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2197">如果已經保留，則為系統的 <paramref name="str" /> 參考，否則為具有 <paramref name="str" /> 值之字串的新參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2197">The system's reference to <paramref name="str" />, if it is interned; otherwise, a new reference to a string with the value of <paramref name="str" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2198">Common language runtime 可以節省字串儲存體，藉由維護稱為保留集區，其中包含每個唯一的常值字串，宣告或以程式設計方式建立在程式中的單一參考的資料表。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2198">The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program.</span></span> <span data-ttu-id="5f51e-2199">因此，具有特定值的常值字串的執行個體只存在一次在系統中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2199">Consequently, an instance of a literal string with a particular value only exists once in the system.</span></span>  
  
 <span data-ttu-id="5f51e-2200">比方說，如果您將相同的常值字串指派給數個變數時，執行階段擷取的常值字串來保留集區從相同的參考，並將它指派給每個變數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2200">For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.</span></span>  
  
 <span data-ttu-id="5f51e-2201"><xref:System.String.Intern%2A>方法會使用保留集區中，搜尋字串的值等於`str`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2201">The <xref:System.String.Intern%2A> method uses the intern pool to search for a string equal to the value of `str`.</span></span> <span data-ttu-id="5f51e-2202">如果此類字串存在，則會傳回它在保留集區的參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2202">If such a string exists, its reference in the intern pool is returned.</span></span> <span data-ttu-id="5f51e-2203">如果字串不存在，參考`str`保留集區，則會傳回該參考加入。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2203">If the string does not exist, a reference to `str` is added to the intern pool, then that reference is returned.</span></span>  
  
 <span data-ttu-id="5f51e-2204">在下列範例中，字串 s1 有"MyTest"的值，是已被保留，因為它是在程式中的常值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2204">In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program.</span></span> <span data-ttu-id="5f51e-2205"><xref:System.Text.StringBuilder?displayProperty=nameWithType>類別會產生具有相同的值為 s1 的新字串物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2205">The <xref:System.Text.StringBuilder?displayProperty=nameWithType> class generates a new string object that has the same value as s1.</span></span> <span data-ttu-id="5f51e-2206">該字串的參考，則指派給 s2。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2206">A reference to that string is assigned to s2.</span></span> <span data-ttu-id="5f51e-2207"><xref:System.String.Intern%2A>方法會搜尋具有相同的值為 s2 的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2207">The <xref:System.String.Intern%2A> method searches for a string that has the same value as s2.</span></span> <span data-ttu-id="5f51e-2208">因為此類字串存在，則方法會傳回相同的參考指派給 s1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2208">Because such a string exists, the method returns the same reference that is assigned to s1.</span></span> <span data-ttu-id="5f51e-2209">接著，該參考會指派給 s3。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2209">That reference is then assigned to s3.</span></span> <span data-ttu-id="5f51e-2210">參考 s1 和 s2 比較不相等因為兩者參考不同的物件。參考 s1 和 s3 比較相等，因為兩者參考相同的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2210">References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.</span></span>  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 <span data-ttu-id="5f51e-2211">比較這個方法，以<xref:System.String.IsInterned%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2211">Compare this method to the <xref:System.String.IsInterned%2A> method.</span></span>  
  
## <a name="version-considerations"></a><span data-ttu-id="5f51e-2212">版本的考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-2212">Version Considerations</span></span>  
 <span data-ttu-id="5f51e-2213">在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]、<xref:System.String.Intern%2A>方法還原成其行為在.NET Framework 1.0 和 1.1 中的關於實習空字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2213">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], the <xref:System.String.Intern%2A> method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string.</span></span> <span data-ttu-id="5f51e-2214">在下列範例中，變數`str1`參考會指派給<xref:System.String.Empty>，和變數`str2`指派參考<xref:System.String.Empty>藉由呼叫傳回<xref:System.String.Intern%2A>方法轉換之後<xref:System.Text.StringBuilder>物件，其值為<xref:System.String.Empty>為字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2214">In the following example, the variable `str1` is assigned a reference to <xref:System.String.Empty>, and the variable `str2` is assigned the reference to <xref:System.String.Empty> that is returned by calling the <xref:System.String.Intern%2A> method after converting a <xref:System.Text.StringBuilder> object whose value is <xref:System.String.Empty> to a string.</span></span> <span data-ttu-id="5f51e-2215">然後中包含的參考`str1`和`str2`會比較是否相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2215">Then the references contained in `str1` and `str2` are compared for equality.</span></span>  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 <span data-ttu-id="5f51e-2216">在[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]， [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]，和[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]，`str1`和`str2`相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2216">In the [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], and [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` and `str2` are equal.</span></span> <span data-ttu-id="5f51e-2217">在[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]和[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]，`str1`和`str2`不相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2217">In the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] and [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` and `str2` are not equal.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="5f51e-2218">效能考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-2218">Performance Considerations</span></span>  
 <span data-ttu-id="5f51e-2219">如果您嘗試減少記憶體總數量會配置您的應用程式，請記住，實習字串有兩個不必要的副作用。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2219">If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects.</span></span> <span data-ttu-id="5f51e-2220">首先，記憶體配置給實習<xref:System.String>物件不可能會釋出 common language runtime (CLR) 終止為止。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2220">First, the memory allocated for interned <xref:System.String> objects is not likely be released until the common language runtime (CLR) terminates.</span></span> <span data-ttu-id="5f51e-2221">原因在於實習的 CLR 參考<xref:System.String>物件可以保存您的應用程式或甚至是您應用程式定義域之後，會終止。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2221">The reason is that the CLR's reference to the interned <xref:System.String> object can persist after your application, or even your application domain, terminates.</span></span> <span data-ttu-id="5f51e-2222">其次，若 intern 字串，您必須先建立字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2222">Second, to intern a string, you must first create the string.</span></span> <span data-ttu-id="5f51e-2223">所使用的記憶體<xref:System.String>必須仍然即將配置給物件，即使記憶體會最後被記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2223">The memory used by the <xref:System.String> object must still be allocated, even though the memory will eventually be garbage collected.</span></span>  
  
 <span data-ttu-id="5f51e-2224">.NET Framework 2.0 版導入了<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType>列舉成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2224">The .NET Framework version 2.0 introduces the <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> enumeration member.</span></span> <span data-ttu-id="5f51e-2225"><xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>成員標記為不需要字串常值實習組件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2225">The <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> member marks an assembly as not requiring string-literal interning.</span></span> <span data-ttu-id="5f51e-2226">您可以套用<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>使用組件<xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2226">You can apply <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> to an assembly using the <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> attribute.</span></span> <span data-ttu-id="5f51e-2227">此外，當您使用[Ngen.exe （原生映像產生器）](~/docs/framework/tools/ngen-exe-native-image-generator.md)編譯組件之前 執行階段，字串不實習跨模組。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2227">Also, when you use the [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) to compile an assembly in advance of run time, strings are not interned across modules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2228">下列範例會使用三個值來判斷新建立的字串是否相等的字串，並已經保留的字串相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2228">The following example uses three strings that are equal in value to determine whether a newly created string and an interned string are equal.</span></span>  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2229"><paramref name="str" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2229"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="5f51e-2230">要在保留集區中搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2230">The string to search for in the intern pool.</span></span></param>
        <summary><span data-ttu-id="5f51e-2231">擷取對指定 <see cref="T:System.String" /> 的參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2231">Retrieves a reference to a specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2232">如果是在 Common Language Runtime 保留集區中，則為 <paramref name="str" /> 的參考，否則為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2232">A reference to <paramref name="str" /> if it is in the common language runtime intern pool; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2233">Common language runtime 會自動維護的資料表，稱為保留集區，其中包含宣告中的程式，以及任何唯一的執行個體的每個唯一的常值字串常數的單一執行個體<xref:System.String>以程式設計方式將藉由呼叫<xref:System.String.Intern%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2233">The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <xref:System.String> you add programmatically by calling the <xref:System.String.Intern%2A> method.</span></span>  
  
 <span data-ttu-id="5f51e-2234">保留集區可以節省字串儲存體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2234">The intern pool conserves string storage.</span></span> <span data-ttu-id="5f51e-2235">如果您將常值的字串常數指派給數個變數時，每個變數會設定為參考相同的常數在保留集區，而不是參考的數個不同的執行個體<xref:System.String>具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2235">If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <xref:System.String> that have identical values.</span></span>  
  
 <span data-ttu-id="5f51e-2236">這個方法會查詢`str`在保留集區。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2236">This method looks up `str` in the intern pool.</span></span> <span data-ttu-id="5f51e-2237">如果`str`已經過實習，該執行個體的參考會傳回，否則`null`傳回。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2237">If `str` has already been interned, a reference to that instance is returned; otherwise, `null` is returned.</span></span>  
  
 <span data-ttu-id="5f51e-2238">比較這個方法，以<xref:System.String.Intern%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2238">Compare this method to the <xref:System.String.Intern%2A> method.</span></span>  
  
 <span data-ttu-id="5f51e-2239">這個方法不會傳回布林值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2239">This method does not return a Boolean value.</span></span> <span data-ttu-id="5f51e-2240">如果您呼叫的方法，因為您想要的布林值，指出是否要實習的特定字串，您可以使用下列程式碼。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2240">If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.</span></span>  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-2241">從.NET Framework 2.0 版開始，您可以覆寫的保留集區使用當您使用[Ngen.exe （原生映像產生器）](~/docs/framework/tools/ngen-exe-native-image-generator.md)組件安裝至本機電腦上的原生映像快取。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2241">Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) to install an assembly to the native image cache on a local computer.</span></span> <span data-ttu-id="5f51e-2242">如需詳細資訊，請參閱 < 備註 > 一節中的效能考量<xref:System.String.Intern%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2242">For more information, see Performance Considerations in the Remarks section for the <xref:System.String.Intern%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2243">下列範例會示範常值字串由編譯器自動實習。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2243">The following example demonstrates that literal strings are interned automatically by the compiler.</span></span>  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2244"><paramref name="str" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2244"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-2245">指出這個字串是否為特定的 Unicode 正規化格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2245">Indicates whether this string is in a particular Unicode normalization form.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-2246">指出這個字串是否為 Unicode 正規化格式 C。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2246">Indicates whether this string is in Unicode normalization form C.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-2247">如果這個字串為正規化格式 C，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2247"><see langword="true" /> if this string is in normalization form C; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2248">某些 Unicode 字元有組成組結合多個對等二進位表示法和/或複合的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2248">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="5f51e-2249">有多種表示的單一字元得搜尋、 排序、 比對，和其他作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2249">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="5f51e-2250">Unicode 標準會定義稱為會傳回一個二進位表示法時指定任何字元的對等二進位表示的正規化的程序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2250">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="5f51e-2251">可以使用數種演算法，稱為正規化表單，會遵循不同的規則，執行正規化。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2251">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="5f51e-2252">.NET Framework 目前支援的正規化表單 C、 D、 KC 和 KD。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2252">The .NET Framework currently supports normalization forms C, D, KC, and KD.</span></span>  
  
 <span data-ttu-id="5f51e-2253">如需支援的 Unicode 正規化表單的說明，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2253">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2254">下列範例會判斷字串是否成功正規化成各種正規化格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2254">The following example determines whether a string is successfully normalized to various normalization forms.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5f51e-2255">目前的執行個體包含無效的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2255">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2256"><see cref="Overload:System.String.IsNormalized" />方法會傳回<see langword="false" />當它遇到第一個非標準化字元在字串中的。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2256">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="5f51e-2257">因此，如果字串包含非標準化的字元無效的 Unicode 字元後, 接<see cref="Overload:System.String.Normalize" />方法會擲回<see cref="T:System.ArgumentException" />雖然<see cref="Overload:System.String.IsNormalized" />傳回<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2257">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm"><span data-ttu-id="5f51e-2258">Unicode 正規化格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2258">A Unicode normalization form.</span></span></param>
        <summary><span data-ttu-id="5f51e-2259">指出這個字串是否為指定的 Unicode 正規化格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2259">Indicates whether this string is in the specified Unicode normalization form.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-2260">如果這個字串為 <see langword="true" /> 參數指定的正規化格式，則為 <paramref name="normalizationForm" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2260"><see langword="true" /> if this string is in the normalization form specified by the <paramref name="normalizationForm" /> parameter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2261">某些 Unicode 字元有組成組結合多個對等二進位表示法和/或複合的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2261">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="5f51e-2262">有多種表示的單一字元得搜尋、 排序、 比對，和其他作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2262">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="5f51e-2263">Unicode 標準會定義稱為會傳回一個二進位表示法時指定任何字元的對等二進位表示的正規化的程序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2263">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="5f51e-2264">可以使用數種演算法，稱為正規化表單，會遵循不同的規則，執行正規化。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2264">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="5f51e-2265">.NET Framework 目前支援的正規化表單 C、 D、 KC 和 KD。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2265">The .NET Framework currently supports normalization forms C, D, KC, and KD.</span></span>  
  
 <span data-ttu-id="5f51e-2266">如需支援的 Unicode 正規化表單的說明，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2266">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2267">下列範例會示範<xref:System.String.IsNormalized%2A>和<xref:System.String.Normalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2267">The following example demonstrates the <xref:System.String.IsNormalized%2A> and <xref:System.String.Normalize%2A> methods.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5f51e-2268">目前的執行個體包含無效的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2268">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2269"><see cref="Overload:System.String.IsNormalized" />方法會傳回<see langword="false" />當它遇到第一個非標準化字元在字串中的。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2269">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="5f51e-2270">因此，如果字串包含非標準化的字元無效的 Unicode 字元後, 接<see cref="Overload:System.String.Normalize" />方法會擲回<see cref="T:System.ArgumentException" />雖然<see cref="Overload:System.String.IsNormalized" />傳回<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2270">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2271">要測試的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2271">The string to test.</span></span></param>
        <summary><span data-ttu-id="5f51e-2272">表示指定的字串是否為 <see langword="null" /> 或 <see cref="F:System.String.Empty" /> 字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2272">Indicates whether the specified string is <see langword="null" /> or an <see cref="F:System.String.Empty" /> string.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-2273">如果 <paramref name="value" /> 參數為 <see langword="true" /> 或空字串 ("")，則為 <see langword="null" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2273"><see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or an empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2274"><xref:System.String.IsNullOrEmpty%2A> 是便利的方法，可讓您以同時測試您是否<xref:System.String>是`null`或其值為<xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2274"><xref:System.String.IsNullOrEmpty%2A> is a convenience method that enables you to simultaneously test whether a <xref:System.String> is `null` or its value is <xref:System.String.Empty>.</span></span> <span data-ttu-id="5f51e-2275">相當於下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2275">It is equivalent to the following code:</span></span>  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 <span data-ttu-id="5f51e-2276">您可以使用<xref:System.String.IsNullOrWhiteSpace%2A>方法來測試字串是否`null`，其值是<xref:System.String.Empty?displayProperty=nameWithType>，或它只包含空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2276">You can use the <xref:System.String.IsNullOrWhiteSpace%2A> method to test whether a string is `null`, its value is <xref:System.String.Empty?displayProperty=nameWithType>,  or it consists only of white-space characters.</span></span>  
  
## <a name="what-is-a-null-string"></a><span data-ttu-id="5f51e-2277">什麼是 null 字串？</span><span class="sxs-lookup"><span data-stu-id="5f51e-2277">What is a null string?</span></span>  
 <span data-ttu-id="5f51e-2278">字串是`null`如果它尚未指派的值 （以 c + + 和 Visual Basic），或如果已明確指派值為`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2278">A string is `null` if it has not been assigned a value (in C++ and Visual Basic) or if has explicitly been assigned a value of `null`.</span></span> <span data-ttu-id="5f51e-2279">雖然[複合格式化](~/docs/standard/base-types/composite-formatting.md)功能可以依正常程序處理 null 的字串，如下列範例所示，如果其成員擲回，嘗試呼叫其中<xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2279">Although the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <xref:System.NullReferenceException>.</span></span>  
  
 [!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
 [!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
 [!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a><span data-ttu-id="5f51e-2280">什麼是空字串？</span><span class="sxs-lookup"><span data-stu-id="5f51e-2280">What is an empty string?</span></span>  
 <span data-ttu-id="5f51e-2281">字串為空白，如果它被明確指派為空字串 ("") 或<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2281">A string is empty if it  is explicitly assigned an empty string ("") or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-2282">空字串具有<xref:System.String.Length%2A>為 0。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2282">An empty string has a <xref:System.String.Length%2A> of 0.</span></span>  <span data-ttu-id="5f51e-2283">下列範例會建立空的字串，並顯示其值和它的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2283">The following example creates an empty string and displays its value and its length.</span></span>  
  
 [!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
 [!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
 [!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2284">下列範例會檢查三個字串，並判斷每個字串的值、 空字串，還是`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2284">The following example examines three strings and determines whether each string has a value, is an empty string, or is `null`.</span></span>  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2285">要測試的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2285">The string to test.</span></span></param>
        <summary><span data-ttu-id="5f51e-2286">表示指定的字串是否為 <see langword="null" />、空白，或只由空白字元組成的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2286">Indicates whether a specified string is <see langword="null" />, empty, or consists only of white-space characters.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-2287">如果 <see langword="true" /> 參數是 <paramref name="value" /> 或 <see langword="null" />，或者 <see cref="F:System.String.Empty" /> 完全由空白字元組成，則為 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2287"><see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" />, or if <paramref name="value" /> consists exclusively of white-space characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2288"><xref:System.String.IsNullOrWhiteSpace%2A> 是便利的方法，不同之處在於它提供更優異的效能會類似下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2288"><xref:System.String.IsNullOrWhiteSpace%2A> is a convenience method that is similar to the following  code, except that it offers superior performance:</span></span>  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 <span data-ttu-id="5f51e-2289">泛空白字元是由 Unicode 標準定義。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2289">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="5f51e-2290"><xref:System.String.IsNullOrWhiteSpace%2A>方法會傳回值的任何字元將解譯`true`傳遞至時<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法以做為泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2290">The <xref:System.String.IsNullOrWhiteSpace%2A> method interprets any character that returns a value of `true` when it is passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method as a white-space character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2291">下列範例會建立字串陣列，並接著會將傳遞至陣列的每個項目<xref:System.String.IsNullOrWhiteSpace%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2291">The following example creates a string array, and then passes each element of the array to the <xref:System.String.IsNullOrWhiteSpace%2A> method.</span></span>  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-2292">串連指定之陣列的項目或集合的成員，並在每個項目或成員之間使用指定的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2292">Concatenates the elements of a specified array or the members of a collection, using the specified separator between each element or member.</span></span></summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="5f51e-2293">要當做分隔符號的字串。只有在 <c>values</c> 有一個以上元素時，<c>separator</c> 才會包含在傳回的字串中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2293">The string to use as a separator.<c>separator</c> is included in the returned string only if <c>values</c> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="5f51e-2294">包含要串連之字串的集合。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2294">A collection that contains the strings to concatenate.</span></span></param>
        <summary><span data-ttu-id="5f51e-2295">串連類型 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 之已建構的 <see cref="T:System.String" /> 集合的成員，並在每個成員之間使用指定的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2295">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2296">字串，由 <paramref name="values" /> 中的成員組成，且每個成員之間都會以 <paramref name="separator" /> 字串分隔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2296">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="5f51e-2297">如果 <paramref name="values" /> 沒有成員，方法會傳回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2297">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2298">如果`separator`是`null`，空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 改為使用。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2298">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="5f51e-2299">如果任何成員`values`是`null`，改為使用空字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2299">If any member of `values` is `null`, an empty string is used instead.</span></span>  
  
 <span data-ttu-id="5f51e-2300"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 是便利的方法，可讓您在串連每個項目`IEnumerable(Of String)`集合，而不先將項目轉換成字串陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2300"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="5f51e-2301">它特別適合使用 Language-Integrated Query (LINQ) 查詢運算式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2301">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="5f51e-2302">下列範例會傳遞`List(Of String)`物件，其中包含英文字母給 lambda 運算式會選取等於或大於特定的字母 （即，在範例中，"M"） 的字母大寫或小寫字母。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2302">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="5f51e-2303">`IEnumerable(Of String)`所傳回集合<xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>方法傳遞至<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法來顯示以單一字串結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2303">The `IEnumerable(Of String)` collection returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2304">下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2304">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="5f51e-2305">它會將結果指派<xref:System.Collections.Generic.List%601>型別的物件<xref:System.String>，這會接著傳遞給<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2305">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2306"><paramref name="values" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2306"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="5f51e-2307">要當做分隔符號的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2307">The string to use as a separator.</span></span> <span data-ttu-id="5f51e-2308">只有在 <c>values</c> 的元素有一個以上時，<c>separator</c> 才會包含在傳回的字串中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2308"><c>separator</c> is included in the returned string only if <c>values</c> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="5f51e-2309">含有要串連之項目的陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2309">An array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="5f51e-2310">串連物件陣列的項目，並在每個項目之間使用指定的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2310">Concatenates the elements of an object array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2311">字串，由 <paramref name="values" /> 的項目組成，且每個項目之間都會以 <paramref name="separator" /> 字串分隔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2311">A string that consists of the elements of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="5f51e-2312">如果 <paramref name="values" /> 為空陣列，則方法會傳回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2312">If <paramref name="values" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2313">如果`separator`是`null`或的任何項目`values`第一個項目，則除了`null`，空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 改為使用。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2313">If `separator` is `null` or if any element of `values` other than the first element is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="5f51e-2314">如果，請參閱 < 呼叫者 > 一節的附註的第一個元素`values`是`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2314">See the Notes for Callers section if the first element of `values` is `null`.</span></span>  
  
 <span data-ttu-id="5f51e-2315"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> 是便利的方法，可讓您沒有明確將其項目轉換為字串串連物件陣列中的每個項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2315"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings.</span></span> <span data-ttu-id="5f51e-2316">藉由呼叫該物件的陣列中的每個物件的字串表示衍生`ToString`方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2316">The string representation of each object in the array is derived by calling that object's `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2317">下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2317">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="5f51e-2318">將結果指派到的整數陣列，然後將傳遞給<xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2318">It assigns the result to a integer array, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2319"><paramref name="values" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2319"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2320">如果第一個項目<paramref name="values" />是<see langword="null" />、<see cref="M:System.String.Join(System.String,System.Object[])" />方法不會串連中的項目<paramref name="values" />而是傳回<see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2320">If the first element of <paramref name="values" /> is <see langword="null" />, the <see cref="M:System.String.Join(System.String,System.Object[])" /> method does not concatenate the elements in <paramref name="values" /> but instead returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="5f51e-2321">使用此問題的因應措施的數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2321">A number of workarounds for this issue are available.</span></span> <span data-ttu-id="5f51e-2322">若要指派的值的最簡單方法是<see cref="F:System.String.Empty" />陣列的第一個元素，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2322">The easiest is to assign a value of <see cref="F:System.String.Empty" /> to the first element of the array, as the following example shows.</span></span>  
  
 [!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)]
 [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="5f51e-2323">要當做分隔符號的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2323">The string to use as a separator.</span></span> <span data-ttu-id="5f51e-2324">只有在 <c>value</c> 的元素有一個以上時，<c>separator</c> 才會包含在傳回的字串中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2324"><c>separator</c> is included in the returned string only if <c>value</c> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="5f51e-2325">含有要串連之項目的陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2325">An array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="5f51e-2326">串連字串陣列的所有項目，並在每個項目之間使用指定的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2326">Concatenates all the elements of a string array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2327">字串，由 <paramref name="value" /> 中的項目組成，且每個項目之間都會以 <paramref name="separator" /> 字串分隔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2327">A string that consists of the elements in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="5f51e-2328">如果 <paramref name="value" /> 為空陣列，則方法會傳回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2328">If <paramref name="value" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2329">例如，如果`separator`是"，"的項目和`value`為"apple"、 「 橙色 」、 「 grape 」 和 「 西洋梨"`Join(separator, value)`會傳回 「 apple、 橙色、 grape、 西洋梨"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2329">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value)` returns "apple, orange, grape, pear".</span></span>  
  
 <span data-ttu-id="5f51e-2330">如果`separator`是`null`，空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 改為使用。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2330">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="5f51e-2331">如果在任何項目`value`是`null`，改為使用空字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2331">If any element in `value` is `null`, an empty string is used instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2332">下列範例會示範<xref:System.String.Join%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2332">The following example demonstrates the <xref:System.String.Join%2A> method.</span></span>  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2333"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2333"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="5f51e-2334">要當做分隔符號的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2334">The string to use as a separator.</span></span> <span data-ttu-id="5f51e-2335">只有在 <c>value</c> 的元素有一個以上時，<c>separator</c> 才會包含在傳回的字串中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2335"><c>separator</c> is included in the returned string only if <c>value</c> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="5f51e-2336">含有要串連之項目的陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2336">An array that contains the elements to concatenate.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2337"><c>value</c> 中要使用的第一個元素。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2337">The first element in <c>value</c> to use.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-2338">要使用的 <c>value</c> 元素數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2338">The number of elements of <c>value</c> to use.</span></span></param>
        <summary><span data-ttu-id="5f51e-2339">串連字串陣列的指定項目，並在每個項目之間使用指定的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2339">Concatenates the specified elements of a string array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2340">由 <paramref name="value" /> 中之字串組成的字串，每個字串之間都以 <paramref name="separator" /> 字串隔開。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2340">A string that consists of the strings in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span></span>  
  
 <span data-ttu-id="5f51e-2341">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2341">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2342">如果 <see cref="F:System.String.Empty" /> 為零、<paramref name="count" /> 沒有任何項目，或 <paramref name="value" /> 和 <paramref name="separator" /> 的所有項目都是 <paramref name="value" />，則為 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2342"><see cref="F:System.String.Empty" /> if <paramref name="count" /> is zero, <paramref name="value" /> has no elements, or <paramref name="separator" /> and all the elements of <paramref name="value" /> are <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2343">例如，如果`separator`是"，"的項目和`value`為"apple"、 「 橙色 」、 「 grape 」 和 「 西洋梨"`Join(separator, value, 1, 2)`傳回"橙色，grape"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2343">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value, 1, 2)` returns "orange, grape".</span></span>  
  
 <span data-ttu-id="5f51e-2344">如果`separator`是`null`，空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 改為使用。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2344">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="5f51e-2345">如果在任何項目`value`是`null`，改為使用空字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2345">If any element in `value` is `null`, an empty string is used instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2346">下列範例會串連兩個項目從水果名稱的陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2346">The following example concatenates two elements from an array of names of fruit.</span></span>  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2347"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2347"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2348"><paramref name="startIndex" /> 或 <paramref name="count" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2348"><paramref name="startIndex" /> or <paramref name="count" /> is less than 0.</span></span>  
  
 <span data-ttu-id="5f51e-2349">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2349">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2350"><paramref name="startIndex" /> 加上 <paramref name="count" /> 大於 <paramref name="value" /> 中的元素數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2350"><paramref name="startIndex" /> plus <paramref name="count" /> is greater than the number of elements in <paramref name="value" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="5f51e-2351">記憶體不足。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2351">Out of memory.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="5f51e-2352">之成員的型別<c>值</c>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2352">The type of the members of <c>values</c>.</span></span></typeparam>
        <param name="separator"><span data-ttu-id="5f51e-2353">要當做分隔符號的字串。只有在 <c>values</c> 有一個以上元素時，<c>separator</c> 才會包含在傳回的字串中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2353">The string to use as a separator.<c>separator</c> is included in the returned string only if <c>values</c> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="5f51e-2354">包含要串連之物件的集合。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2354">A collection that contains the objects to concatenate.</span></span></param>
        <summary><span data-ttu-id="5f51e-2355">串連集合的成員，並在每個成員之間使用指定的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2355">Concatenates the members of a collection, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2356">字串，由 <paramref name="values" /> 中的成員組成，且每個成員之間都會以 <paramref name="separator" /> 字串分隔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2356">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="5f51e-2357">如果 <paramref name="values" /> 沒有成員，方法會傳回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2357">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2358">如果`separator`是`null`，空字串 (<xref:System.String.Empty?displayProperty=nameWithType>) 改為使用。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2358">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="5f51e-2359">如果任何成員`values`是`null`，改為使用空字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2359">If any member of `values` is `null`, an empty string is used instead.</span></span>  
  
 <span data-ttu-id="5f51e-2360"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 是便利的方法，可讓您在串連的每個成員<xref:System.Collections.Generic.IEnumerable%601>而不先將它們轉換成字串的集合。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2360"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each member of an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting them to strings.</span></span> <span data-ttu-id="5f51e-2361">在每個物件的字串表示<xref:System.Collections.Generic.IEnumerable%601>集合藉由呼叫該物件衍生`ToString`方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2361">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>  
  
 <span data-ttu-id="5f51e-2362">這個方法是在特定使用 Language-Integrated Query (LINQ) 查詢運算式很有用。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2362">This method is particular useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="5f51e-2363">例如，下列程式碼會定義非常簡單`Animal`類別，其中包含代表動物以及其所屬的順序的名稱。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2363">For example, the following code defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="5f51e-2364">然後它會定義<xref:System.Collections.Generic.List%601>物件，其中包含一些`Animal`物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2364">It then defines a <xref:System.Collections.Generic.List%601> object that contains a number of `Animal` objects.</span></span> <span data-ttu-id="5f51e-2365"><xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>擴充方法呼叫以擷取`Animal`物件`Order`屬性等於"齧齒動物"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2365">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="5f51e-2366">結果會傳遞至<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2366">The result is passed to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2367">下列範例會使用 Sieve Eratosthenes 演算法來計算小於或等於 100 的質數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2367">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="5f51e-2368">它會將結果指派<xref:System.Collections.Generic.List%601>物件型別整數，然後將傳遞給<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2368">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type integer, which it then passes to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2369"><paramref name="values" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2369"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-2370">報告這個執行個體中指定之 Unicode 字元或字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2370">Reports the zero-based index position of the last occurrence of a specified Unicode character or string within this instance.</span></span> <span data-ttu-id="5f51e-2371">如果在此執行個體中找不到該字元或字串，此方法會傳回 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2371">The method returns -1 if the character or string is not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2372">要搜尋的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2372">The Unicode character to seek.</span></span></param>
        <summary><span data-ttu-id="5f51e-2373">報告這個執行個體中指定之 Unicode 字元最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2373">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2374">如果找到該字元，則為 <paramref name="value" /> 以零為起始的索引位置，如果找不到為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2374">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2375">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2375">Index numbering starts from zero.</span></span> <span data-ttu-id="5f51e-2376">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2376">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="5f51e-2377">這個方法會在這個執行個體的最後一個字元位置開始搜尋，然後反向朝直到開始進行`value`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2377">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="5f51e-2378">搜尋不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2378">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="5f51e-2379">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2379">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="5f51e-2380">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2380">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2381">下列範例會定義`ExtractFilename`方法使用<xref:System.String.LastIndexOf%28System.Char%29>方法來尋找字串中的最後一個目錄分隔符號字元和擷取字串的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2381">The following example defines an `ExtractFilename` method that uses the <xref:System.String.LastIndexOf%28System.Char%29> method to find the last directory separator character in a string and to extract the string's file name.</span></span> <span data-ttu-id="5f51e-2382">如果檔案存在，則方法會傳回不包含其路徑的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2382">If the file exists, the method returns the file name without its path.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2383">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2383">The string to seek.</span></span></param>
        <summary><span data-ttu-id="5f51e-2384">回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2384">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2385">如果找到該字串，則為 <paramref name="value" /> 以零為起始的起始索引位置，如未找到，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2385">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="5f51e-2386">如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值為這個執行個體中的最後一個索引位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2386">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2387">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2387">Index numbering starts from zero.</span></span> <span data-ttu-id="5f51e-2388">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2388">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="5f51e-2389">搜尋會從這個執行個體，最後一個字元位置開始，然後反向朝直到開始進行`value`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2389">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>  
  
 <span data-ttu-id="5f51e-2390">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2390">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="5f51e-2391">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2391">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2392">執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2392">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="5f51e-2393">如果`value`只包含一個或多個可忽略的字元，<xref:System.String.LastIndexOf%28System.String%29>方法一律會傳回<xref:System.String.Length%2A?displayProperty=nameWithType>– 1，代表在目前執行個體之最後索引位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2393">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%29> method always returns <xref:System.String.Length%2A?displayProperty=nameWithType> – 1, which represents the last index position in the current instance.</span></span> <span data-ttu-id="5f51e-2394">在下列範例中，<xref:System.String.LastIndexOf%28System.String%29>方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)、"n"，後面接著選擇性連字號和選擇性的連字號後面接著"m"）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2394">In the following example, the <xref:System.String.LastIndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="5f51e-2395">只有其中一個字串包含選擇性連字號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2395">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="5f51e-2396">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在每個案例中，因為選擇性連字號是可忽略的字元，結果會與相同選擇性連字號不包含在`value`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2396">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="5f51e-2397">搜尋的選擇性連字號只時，這個方法會傳回 6 和 5。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2397">When searching for a soft hyphen only, the method returns 6 and 5.</span></span> <span data-ttu-id="5f51e-2398">這些值對應到兩個字串中的最後一個字元索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2398">These values correspond to the index of the last character in the two strings.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2399">下列範例會移除開頭和結尾的字串，如果標記開始與結尾字串的 HTML 標記。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2399">The following example removes opening and closing HTML tags from a string if the tags begin and end the string.</span></span> <span data-ttu-id="5f51e-2400">如果字串的結尾的右括號字元 (">")，此範例會使用<xref:System.String.LastIndexOf%2A>方法來找出的結束標記開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2400">If a string ends with a closing bracket character (">"), the example uses the <xref:System.String.LastIndexOf%2A> method to locate the start of the end tag.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2401"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2401"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2402">中所述[使用字串的最佳作法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2402">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="5f51e-2403">若要尋找的字串執行個體的子字串的最後一個索引，使用目前文化特性的比較規則，請呼叫<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />方法多載，其值為<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2403">To find the last index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2404">要搜尋的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2404">The Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2405">搜尋的開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2405">The starting position of the search.</span></span> <span data-ttu-id="5f51e-2406">搜尋會從 <c>startIndex</c> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2406">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="5f51e-2407">報告這個執行個體中指定之 Unicode 字元最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2407">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span></span> <span data-ttu-id="5f51e-2408">搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2408">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2409">如果找到該字元，則為 <paramref name="value" /> 的以零為起始索引位置，如果找不到該字元或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2409">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2410">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2410">Index numbering starts from zero.</span></span> <span data-ttu-id="5f51e-2411">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<xref:System.String.Length%2A>-1.這個方法會在開始搜尋`startIndex`字元位置，這個執行個體與回溯到目前的執行個體的開頭之前會繼續進行`value`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2411">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning of the current instance until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="5f51e-2412">例如，如果`startIndex`是<xref:System.String.Length%2A>-1，方法會搜尋每個字元從最後一個字元字串中要開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2412">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span> <span data-ttu-id="5f51e-2413">搜尋不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2413">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="5f51e-2414">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2414">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="5f51e-2415">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2415">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2416">下列範例會尋找所有出現的字元的索引，在字串中，使用從字串的結尾字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2416">The following example finds the index of all occurrences of a character in a string, working from the end of the string to the start of the string.</span></span>  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f51e-2417">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於零，或者大於或等於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2417">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2418">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2418">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2419">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2419">The search starting position.</span></span> <span data-ttu-id="5f51e-2420">搜尋會從 <c>startIndex</c> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2420">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="5f51e-2421">回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2421">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="5f51e-2422">搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2422">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2423">如果找到該字串，則為 <paramref name="value" /> 的以零為起始索引位置，如果找不到該字串或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2423">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="5f51e-2424">如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" /> 或這個執行個體之最後索引位置，取兩者中較小者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2424">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2425">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2425">Index numbering starts from zero.</span></span> <span data-ttu-id="5f51e-2426">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2426">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="5f51e-2427">搜尋開始於`startIndex`字元位置，此執行個體，會繼續執行直到朝回溯`value`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2427">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="5f51e-2428">例如，如果`startIndex`是<xref:System.String.Length%2A>-1，方法會搜尋每個字元從最後一個字元字串中要開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2428">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>  
  
 <span data-ttu-id="5f51e-2429">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2429">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="5f51e-2430">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2430">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2431">執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2431">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="5f51e-2432">如果`value`只包含一個或多個可忽略的字元，<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>方法一律會傳回`startIndex`，即開始搜尋的字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2432">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="5f51e-2433">在下列範例中，<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>方法用來尋找包含選擇性連字號 (U + 00AD)，而且之前或是在字串中包括最後的"m"的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2433">In the following example, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string.</span></span> <span data-ttu-id="5f51e-2434">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，搜尋字串中的選擇性連字號會被忽略，因為呼叫以尋找子字串包含選擇性連字號和"m"在字串中，傳回"m"的位置而呼叫它來尋找 substrin 方法g 包含選擇性連字號和"n"會傳回"n"的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2434">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n".</span></span> <span data-ttu-id="5f51e-2435">當搜尋字串不包含只選擇性連字號時，方法會傳回"m"，其代表的值索引`startIndex`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2435">When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of `startIndex`.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2436">下列範例會尋找所有出現的字串索引在目標字串中，從目標字串的結尾工作目標字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2436">The following example finds the index of all occurrences of a string in target string, working from the end of the target string to the start of the target string.</span></span>  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2437"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2437"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f51e-2438">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於零或大於目前執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2438">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span></span>  
  
 <span data-ttu-id="5f51e-2439">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2439">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2440">目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於 -1 或大於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2440">The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2441">中所述[使用字串的最佳作法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2441">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="5f51e-2442">若要尋找特定的字元位置之前使用目前文化特性的比較規則的子字串的索引，請呼叫<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />方法多載，其值為<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2442">To find the index of a substring that precedes a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2443">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2443">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="5f51e-2444">其中一個列舉值，指定搜尋規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2444">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="5f51e-2445">報告目前 <see cref="T:System.String" /> 物件中指定之字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2445">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="5f51e-2446">參數會指定要用於指定字串的搜尋類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2446">A parameter specifies the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2447">如果找到該字串，則為 <paramref name="value" /> 參數的以零為起始的起始索引位置，否則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2447">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="5f51e-2448">如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值為這個執行個體中的最後一個索引位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2448">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2449">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2449">Index numbering starts from zero.</span></span> <span data-ttu-id="5f51e-2450">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2450">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="5f51e-2451">`comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用文字或序數比較規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2451">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
 <span data-ttu-id="5f51e-2452">搜尋會從這個執行個體，最後一個字元位置開始，然後反向朝直到開始進行`value`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2452">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2453">下列 exampledemonstrates 三個多載的<xref:System.String.LastIndexOf%2A>尋找使用的不同值的另一個字串中之字串最後一次出現的方法<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2453">The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2454"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2454"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-2455"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2455"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2456">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2456">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2457">執行區分文化特性的搜尋 (也就是說，如果 <paramref name="options" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2457">In a culture-sensitive search (that is, if <paramref name="options" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="5f51e-2458">如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />方法一律會傳回<see cref="P:System.String.Length" />– 1，代表在目前執行個體之最後索引位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2458">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method always returns <see cref="P:System.String.Length" /> – 1, which represents the last index position in the current instance.</span></span>  
  
 <span data-ttu-id="5f51e-2459">在下列範例中，<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />方法用來尋找兩個字串中的三個的子字串 （選擇性連字號 (U + 00AD)、"n"，後面接著選擇性連字號和選擇性的連字號後面接著"m"）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2459">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="5f51e-2460">只有其中一個字串包含選擇性連字號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2460">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="5f51e-2461">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，因為選擇性連字號是可忽略的字元，區分文化特性的搜尋傳回相同的值，它就會傳回如果搜尋字串中未包含選擇性連字號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2461">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</span></span> <span data-ttu-id="5f51e-2462">序數搜尋，不過，順利在一個字串中尋找選擇性連字號，並報告它不存在從第二個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2462">An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)]
 [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2463">要搜尋的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2463">The Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2464">搜尋的開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2464">The starting position of the search.</span></span> <span data-ttu-id="5f51e-2465">搜尋會從 <c>startIndex</c> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2465">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-2466">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2466">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="5f51e-2467">報告這個執行個體的子字串中，指定的 Unicode 字元最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2467">Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance.</span></span> <span data-ttu-id="5f51e-2468">搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2468">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2469">如果找到該字元，則為 <paramref name="value" /> 的以零為起始索引位置，如果找不到該字元或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2469">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2470">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2470">Index numbering starts from zero.</span></span> <span data-ttu-id="5f51e-2471">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2471">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="5f51e-2472">這個方法會在開始搜尋`startIndex`字元位置和繼續回溯朝這個執行個體的開頭，直到`value`找到或`count`字元位置已檢查。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2472">This method begins searching at the `startIndex` character position and proceeds backward toward the beginning of this instance until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="5f51e-2473">例如，如果`startIndex`是<xref:System.String.Length%2A>-1，此方法會向後搜尋`count`從字串中的最後一個字元的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2473">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span> <span data-ttu-id="5f51e-2474">搜尋不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2474">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="5f51e-2475">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有當 Unicode 純量值都相同，字元會視為等於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2475">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="5f51e-2476">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2476">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2477">下列範例會尋找所有出現的字元索引的子字串，處理從子字串的結尾子字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2477">The following example finds the index of all occurrences of a character in a substring, working from the end of the substring to the start of the substring.</span></span>  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f51e-2478">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於零，或者大於或等於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2478">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span></span>  
  
 <span data-ttu-id="5f51e-2479">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2479">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2480">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> - <paramref name="count" /> + 1 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2480">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" /> + 1 is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2481">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2481">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2482">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2482">The search starting position.</span></span> <span data-ttu-id="5f51e-2483">搜尋會從 <c>startIndex</c> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2483">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-2484">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2484">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="5f51e-2485">回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2485">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="5f51e-2486">搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2486">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2487">如果找到該字串，則為 <paramref name="value" /> 的以零為起始索引位置，如果找不到該字串或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2487">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="5f51e-2488">如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" /> 或這個執行個體之最後索引位置，取兩者中較小者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2488">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2489">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2489">Index numbering starts from zero.</span></span> <span data-ttu-id="5f51e-2490">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2490">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="5f51e-2491">搜尋開始於`startIndex`字元位置，此執行個體，會繼續執行直到朝回溯`value`找到或`count`字元位置已檢查。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2491">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="5f51e-2492">例如，如果`startIndex`是<xref:System.String.Length%2A>-1，此方法會向後搜尋`count`從字串中的最後一個字元的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2492">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>  
  
 <span data-ttu-id="5f51e-2493">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2493">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="5f51e-2494">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2494">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2495">執行區分文化特性的搜尋時，如果 `value` 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2495">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="5f51e-2496">如果`value`只包含一個或多個可忽略的字元，<xref:System.String.LastIndexOf%2A>方法一律會傳回`startIndex`，即開始搜尋的字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2496">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%2A> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="5f51e-2497">在下列範例中，<xref:System.String.LastIndexOf%2A>方法用來尋找在前面兩個字串的最後"m"的兩個字元的選擇性連字號 (U + 00AD) 的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2497">In the following example, the <xref:System.String.LastIndexOf%2A> method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings.</span></span> <span data-ttu-id="5f51e-2498">只有其中一個字串包含必要的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2498">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="5f51e-2499">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2499">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2500">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2500">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2501">下列範例會尋找所有出現的字串索引中的子字串，處理從子字串的結尾子字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2501">The following example finds the index of all occurrences of a string in substring, working from the end of the substring to the start of the substring.</span></span>  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2502"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2502"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2503"><paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2503"><paramref name="count" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-2504">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2504">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2505">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2505">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-2506">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2506">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2507">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 大於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2507">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span></span>  
  
 <span data-ttu-id="5f51e-2508">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2508">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2509">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> - <paramref name="count" />+ 1 指定的位置不在此執行個體之內。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2509">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" />+ 1 specifies a position that is not within this instance.</span></span>  
  
 <span data-ttu-id="5f51e-2510">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2510">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2511">目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="start" /> 小於 -1 或大於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2511">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span></span>  
  
 <span data-ttu-id="5f51e-2512">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2512">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2513">目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="count" /> 大於 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2513">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2514">中所述[使用字串的最佳作法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2514">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="5f51e-2515">若要使用目前文化特性的比較規則，以執行這項作業，請呼叫<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法多載，其值為<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2515">To perform this operation by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2516">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2516">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2517">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2517">The search starting position.</span></span> <span data-ttu-id="5f51e-2518">搜尋會從 <c>startIndex</c> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2518">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="5f51e-2519">其中一個列舉值，指定搜尋規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2519">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="5f51e-2520">報告目前 <see cref="T:System.String" /> 物件中指定之字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2520">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="5f51e-2521">搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2521">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span> <span data-ttu-id="5f51e-2522">參數會指定搜尋指定字串時要執行的比較類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2522">A parameter specifies the type of comparison to perform when searching for the specified string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2523">如果找到該字串，則為 <paramref name="value" /> 參數以零為起始的索引位置，如果找不到該字串或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2523">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="5f51e-2524">如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" /> 或這個執行個體之最後索引位置，取兩者中較小者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2524">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2525">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2525">Index numbering starts from zero.</span></span> <span data-ttu-id="5f51e-2526">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2526">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="5f51e-2527">搜尋開始於`startIndex`字元位置然後繼續直到回溯`value`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2527">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="5f51e-2528">例如，如果`startIndex`是<xref:System.String.Length%2A>-1，方法會搜尋每個字元從最後一個字元字串中要開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2528">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>  
  
 <span data-ttu-id="5f51e-2529">`comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用文字或序數比較規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2529">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2530">下列 exampledemonstrates 三個多載的<xref:System.String.LastIndexOf%2A>尋找使用的不同值的另一個字串中之字串最後一次出現的方法<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2530">The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2531"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2531"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f51e-2532">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 小於零或大於目前執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2532">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span></span>  
  
 <span data-ttu-id="5f51e-2533">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2533">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2534">目前的執行個體等於 <see cref="F:System.String.Empty" /> 且 <paramref name="startIndex" /> 小於 -1 或大於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2534">The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-2535"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2535"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2536">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2536">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2537">執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2537">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="5f51e-2538">如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />方法一律會傳回<paramref name="startIndex" />，即開始搜尋的字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2538">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
 <span data-ttu-id="5f51e-2539">在下列範例中，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />方法用來尋找後面接著"m"，開頭為"m"最後兩個字串中選擇性連字號 (U + 00AD) 的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2539">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m", starting with the final "m" in two strings.</span></span> <span data-ttu-id="5f51e-2540">只有其中一個字串包含必要的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2540">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="5f51e-2541">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2541">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2542">請注意，就第一個字串的情況，這個字串是選擇性連字號後面接著 "m"，結果方法不是傳回選擇性連字號的索引，而是傳回 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2542">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span> <span data-ttu-id="5f51e-2543">只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2543">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)]
 [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-2544">要搜尋的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2544">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2545">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2545">The search starting position.</span></span> <span data-ttu-id="5f51e-2546">搜尋會從 <c>startIndex</c> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2546">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-2547">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2547">The number of character positions to examine.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="5f51e-2548">其中一個列舉值，指定搜尋規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2548">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="5f51e-2549">回報這個執行個體中指定之字串最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2549">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="5f51e-2550">搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2550">The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions.</span></span> <span data-ttu-id="5f51e-2551">參數會指定搜尋指定字串時要執行的比較類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2551">A parameter specifies the type of comparison to perform when searching for the specified string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2552">如果找到該字串，則為 <paramref name="value" /> 參數以零為起始的索引位置，如果找不到該字串或者目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2552">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="5f51e-2553">如果 <paramref name="value" /> 是 <see cref="F:System.String.Empty" />，則傳回值是 <paramref name="startIndex" /> 或這個執行個體之最後索引位置，取兩者中較小者。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2553">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2554">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2554">Index numbering starts from zero.</span></span> <span data-ttu-id="5f51e-2555">也就是說，在字串中的第一個字元索引位置為零且最後一個位在<xref:System.String.Length%2A>-1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2555">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="5f51e-2556">搜尋開始於`startIndex`字元位置然後繼續直到回溯`value`找到或`count`字元位置已檢查。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2556">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="5f51e-2557">例如，如果`startIndex`是<xref:System.String.Length%2A>-1，此方法會向後搜尋`count`從字串中的最後一個字元的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2557">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>  
  
 <span data-ttu-id="5f51e-2558">`comparisonType`參數會指定要搜尋`value`參數使用目前或而異的文化特性、 使用區分大小寫或不區分大小寫的搜尋，以及使用文字或序數比較規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2558">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2559">下列 exampledemonstrates 三個多載的<xref:System.String.LastIndexOf%2A>尋找使用的不同值的另一個字串中之字串最後一次出現的方法<xref:System.StringComparison>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2559">The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2560"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2560"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2561"><paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2561"><paramref name="count" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-2562">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2562">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2563">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2563">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-2564">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2564">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2565">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 大於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2565">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span></span>  
  
 <span data-ttu-id="5f51e-2566">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2566">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2567">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> + 1 - <paramref name="count" /> 指定的位置不在此執行個體之內。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2567">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> + 1 - <paramref name="count" /> specifies a position that is not within this instance.</span></span>  
  
 <span data-ttu-id="5f51e-2568">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2568">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2569">目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="start" /> 小於 -1 或大於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2569">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span></span>  
  
 <span data-ttu-id="5f51e-2570">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2570">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2571">目前的執行個體等於 <see cref="F:System.String.Empty" />，且 <paramref name="count" /> 大於 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2571">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-2572"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2572"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2573">字元集包含可忽略的字元，這些字元在執行語言或區分文化特性的比較時不列入考慮。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2573">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2574">執行區分文化特性的搜尋 (也就是說，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 時，如果 <paramref name="value" /> 包含可忽略的字元，則結果等於在已移除該字元的情況下搜尋。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2574">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="5f51e-2575">如果<paramref name="value" />只包含一個或多個可忽略的字元，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法一律會傳回<paramref name="startIndex" />，即開始搜尋的字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2575">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>  
  
 <span data-ttu-id="5f51e-2576">在下列範例中，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法用來尋找兩個字串中的選擇性連字號 (U + 00AD) 後面接著"m"在所有位置，但最終"m"之前的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2576">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in all but the first character position before the final "m" in two strings.</span></span> <span data-ttu-id="5f51e-2577">只有其中一個字串包含必要的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2577">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="5f51e-2578">如果執行範例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更新版本中，在這兩種情況下，因為選擇性連字號是可忽略的字元，方法會傳回"m"在字串中的索引時，它會執行區分文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2578">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2579">當它執行序數比較時，不過，它會尋找子字串只能在第一個字串中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2579">When it performs an ordinal comparison, however, it finds the substring only in the first string.</span></span> <span data-ttu-id="5f51e-2580">請注意，就第一個字串，其中包含選擇性連字號後面接著"m"，此方法無法傳回選擇性連字號的索引執行區分文化特性的比較時，而是傳回"m"的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2580">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="5f51e-2581">只有在執行序數比較時，方法才會傳回第一個字串中選擇性連字號的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2581">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)]
 [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-2582">報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2582">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="5f51e-2583">如果在此執行個體中找不到陣列中的字元，此方法會傳回 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2583">The method returns -1 if the characters in the array are not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="5f51e-2584">Unicode 字元陣列，含有一或多個要搜尋的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2584">A Unicode character array containing one or more characters to seek.</span></span></param>
        <summary><span data-ttu-id="5f51e-2585">報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2585">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2586">這個執行個體中最後項目的索引位置，其中找到了 <paramref name="anyOf" /> 中的任何字元，如果 <paramref name="anyOf" /> 中沒有找到任何字元，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2586">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2587">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2587">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="5f51e-2588">這個方法會在這個執行個體的最後一個字元位置開始搜尋，然後反向朝直到中字元的開頭進行`anyOf`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2588">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="5f51e-2589">搜尋不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2589">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="5f51e-2590">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2590">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="5f51e-2591">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2591">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2592">下列範例會尋找任何字元在字串中最後一個出現的索引"is"內另一個字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2592">The following example finds the index of the last occurrence of any character in the string "is" within another string.</span></span>  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2593"><paramref name="anyOf" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2593"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="5f51e-2594">Unicode 字元陣列，含有一或多個要搜尋的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2594">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2595">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2595">The search starting position.</span></span> <span data-ttu-id="5f51e-2596">搜尋會從 <c>startIndex</c> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2596">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="5f51e-2597">報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2597">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="5f51e-2598">搜尋會從指定的字元位置開始，然後反向朝字串的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2598">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2599">所找到之 <paramref name="anyOf" /> 的任何字元，在這個執行個體中最後一次出現的索引位置；如果找不到 <paramref name="anyOf" /> 中的字元，或目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2599">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2600">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2600">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="5f51e-2601">這個方法會在開始搜尋`startIndex`字元位置，這個執行個體與回溯朝直到中字元的開頭繼續`anyOf`找到或已經檢查的第一個字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2601">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="5f51e-2602">搜尋不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2602">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="5f51e-2603">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2603">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="5f51e-2604">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2604">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2605">下列範例會尋找任何字元在字串中最後一個出現的索引"is"另一個字串的子字串內。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2605">The following example finds the index of the last occurrence of any character in the string "is" within a substring of another string.</span></span>  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2606"><paramref name="anyOf" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2606"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f51e-2607">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> 指定的位置不在這個執行個體之內。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2607">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> specifies a position that is not within this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="5f51e-2608">Unicode 字元陣列，含有一或多個要搜尋的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2608">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="5f51e-2609">搜尋開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2609">The search starting position.</span></span> <span data-ttu-id="5f51e-2610">搜尋會從 <c>startIndex</c> 朝這個執行個體的開頭進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2610">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-2611">要檢視的字元位置數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2611">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="5f51e-2612">報告 Unicode 陣列中的一或多個指定的字元，在這個執行個體中最後一次出現時的所在索引 (以零為起始)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2612">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="5f51e-2613">搜尋會從指定的字元位置開始，然後反向朝字串開頭指定數目的字元位置進行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2613">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2614">所找到之 <paramref name="anyOf" /> 的任何字元，在這個執行個體中最後一次出現的索引位置；如果找不到 <paramref name="anyOf" /> 中的字元，或目前的執行個體等於 <see cref="F:System.String.Empty" />，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2614">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2615">索引編號會從零開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2615">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="5f51e-2616">這個方法會在開始搜尋`startIndex`字元位置，這個執行個體與回溯朝直到中字元的開頭繼續`anyOf`找到或`count`字元位置已檢查。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2616">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="5f51e-2617">搜尋不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2617">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="5f51e-2618">這個方法會執行序數 （不區分文化特性） 搜尋，其中只有 Unicode 純量值相同，字元會視為等於另一個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2618">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="5f51e-2619">若要執行區分文化特性的搜尋，請使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中 Unicode 純量值代表預先的字元，例如"Æ"連字 (U + 00 C 6)，可能會視為字元的元件中的任何項目更正順序，例如"AE 」 (U + 0041，U + 0045)，根據文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2619">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2620">下列範例會尋找另一個字串的子字串內的任何字元在字串"輔助工具 」，最後一個出現的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2620">The following example finds the index of the last occurrence of any character in the string "aid" within a substring of another string.</span></span>  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2621"><paramref name="anyOf" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2621"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f51e-2622">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="count" /> 或 <paramref name="startIndex" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2622">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>  
  
 <span data-ttu-id="5f51e-2623">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2623">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2624">目前的執行個體不等於 <see cref="F:System.String.Empty" />，且 <paramref name="startIndex" /> - <paramref name="count" /> + 1 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2624">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> minus <paramref name="count" /> + 1 is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5f51e-2625">取得目前 <see cref="T:System.String" /> 物件中字元的數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2625">Gets the number of characters in the current <see cref="T:System.String" /> object.</span></span></summary>
        <value><span data-ttu-id="5f51e-2626">目前字串中的字元數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2626">The number of characters in the current string.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2627"><xref:System.String.Length%2A>屬性傳回的數目<xref:System.Char>這個執行個體中的物件、 不是 Unicode 字元的數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2627">The <xref:System.String.Length%2A> property returns the number of <xref:System.Char> objects in this instance, not the number of Unicode characters.</span></span> <span data-ttu-id="5f51e-2628">原因是，可能會將 Unicode 字元表示由多個<xref:System.Char>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2628">The reason is that a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="5f51e-2629">使用<xref:System.Globalization.StringInfo?displayProperty=nameWithType>類別，以使用每個 Unicode 字元，而不是每個<xref:System.Char>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2629">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with each Unicode character instead of each <xref:System.Char>.</span></span>  
  
 <span data-ttu-id="5f51e-2630">在某些語言中，例如 C 與 c + +，null 字元表示字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2630">In some languages, such as C and C++, a null character indicates the end of a string.</span></span> <span data-ttu-id="5f51e-2631">在.NET Framework 中，可以內嵌 null 字元在字串中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2631">In the .NET Framework, a null character can be embedded in a string.</span></span> <span data-ttu-id="5f51e-2632">字串，包含一或多個 null 字元時，它們會包含總字串的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2632">When a string includes one or more null characters, they are included in the length of the total string.</span></span> <span data-ttu-id="5f51e-2633">例如，在下列字串"abc"與"def"會以 null 字元分隔的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2633">For example, in the following string, the substrings "abc" and "def" are separated by a null character.</span></span> <span data-ttu-id="5f51e-2634"><xref:System.String.Length%2A>屬性會傳回 7，這表示它包含六個字母的字元，以及 null 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2634">The <xref:System.String.Length%2A> property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.</span></span>  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2635">下列範例會示範<xref:System.String.Length%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2635">The following example demonstrates the <xref:System.String.Length%2A> property.</span></span>  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-2636">傳回新的字串，其二進位表示為特定的 Unicode 正規化格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2636">Returns a new string whose binary representation is in a particular Unicode normalization form.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-2637">傳回新的字串，其文字值與這個字串相同，但是其二進位表示為 Unicode 正規化格式 C。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2637">Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2638">新的正規化字串，其文字值與這個字串相同，但是其二進位表示為正規化格式 C。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2638">A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2639">某些 Unicode 字元有組成組結合多個對等二進位表示法和/或複合的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2639">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="5f51e-2640">例如，下列字碼指標的任何可代表字母"ắ":</span><span class="sxs-lookup"><span data-stu-id="5f51e-2640">For example, any of the following code points can represent the letter "ắ":</span></span>  
  
-   <span data-ttu-id="5f51e-2641">U + 1EAF</span><span class="sxs-lookup"><span data-stu-id="5f51e-2641">U+1EAF</span></span>  
  
-   <span data-ttu-id="5f51e-2642">U+0103 U+0301</span><span class="sxs-lookup"><span data-stu-id="5f51e-2642">U+0103 U+0301</span></span>  
  
-   <span data-ttu-id="5f51e-2643">U+0061 U+0306 U+0301</span><span class="sxs-lookup"><span data-stu-id="5f51e-2643">U+0061 U+0306 U+0301</span></span>  
  
 <span data-ttu-id="5f51e-2644">有多種表示的單一字元得搜尋、 排序、 比對，和其他作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2644">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="5f51e-2645">Unicode 標準會定義稱為會傳回一個二進位表示法時指定任何字元的對等二進位表示的正規化的程序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2645">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="5f51e-2646">可以使用數種演算法，稱為正規化表單，會遵循不同的規則，執行正規化。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2646">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="5f51e-2647">.NET Framework 支援的四個正規化表單 （C、 D、 KC 和 KD） 由 Unicode 標準所定義。當兩個字串相同的正規化格式表示時，使用序數比較來比較 theycan。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2647">The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, theycan be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="5f51e-2648">若要正常化，並比較兩個字串，執行下列作業：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2648">To normalize and compare two strings, do the following:</span></span>  
  
1.  <span data-ttu-id="5f51e-2649">取得從輸入來源，例如檔案或使用者的輸入的裝置要比較的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2649">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>  
  
2.  <span data-ttu-id="5f51e-2650">呼叫<xref:System.String.Normalize>方法，以將字串標準化為正規化格式 c。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2650">Call the <xref:System.String.Normalize> method to normalize the strings to normalization form C.</span></span>  
  
3.  <span data-ttu-id="5f51e-2651">若要比較兩個字串，呼叫的方法，支援的序數字串比較，例如<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，並提供值<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>做為<xref:System.StringComparison>引數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2651">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="5f51e-2652">若要排序的正規化的字串陣列，傳遞`comparer`值<xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType>或<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType>適當多載<xref:System.Array.Sort%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2652">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>  
  
4.  <span data-ttu-id="5f51e-2653">發出根據上一個步驟所指定的順序排序的輸出中的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2653">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>  
  
 <span data-ttu-id="5f51e-2654">如需支援的 Unicode 正規化表單的說明，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2654">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2655">下列範例會將字串標準化為每四個正規化格式，確認字串已標準化為指定的正規化表單，然後列出正規化的字串中的字碼指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2655">The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5f51e-2656">目前的執行個體包含無效的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2656">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2657"><see cref="Overload:System.String.IsNormalized" />方法會傳回<see langword="false" />當它遇到第一個非標準化字元在字串中的。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2657">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="5f51e-2658">因此，如果字串包含非標準化的字元無效的 Unicode 字元後, 接<see cref="Overload:System.String.Normalize" />方法會擲回<see cref="T:System.ArgumentException" />雖然<see cref="Overload:System.String.IsNormalized" />傳回<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2658">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm"><span data-ttu-id="5f51e-2659">Unicode 正規化格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2659">A Unicode normalization form.</span></span></param>
        <summary><span data-ttu-id="5f51e-2660">傳回新的字串，其文字值與這個字串相同，但是其二進位表示為特定的 Unicode 正規化格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2660">Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2661">新的字串，其文字值與這個字串相同，但是其二進位表示為 <paramref name="normalizationForm" /> 參數指定的正規化格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2661">A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <paramref name="normalizationForm" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2662">某些 Unicode 字元有組成組結合多個對等二進位表示法和/或複合的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2662">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="5f51e-2663">有多種表示的單一字元得搜尋、 排序、 比對，和其他作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2663">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="5f51e-2664">Unicode 標準會定義稱為會傳回一個二進位表示法時指定任何字元的對等二進位表示的正規化的程序。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2664">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="5f51e-2665">可以使用數種演算法，稱為正規化表單，會遵循不同的規則，執行正規化。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2665">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="5f51e-2666">.NET Framework 支援的四個正規化表單 （C、 D、 KC 和 KD） 由 Unicode 標準所定義。當兩個字串都表示相同的正規化格式時，它們可以使用序數比較來比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2666">The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="5f51e-2667">若要正常化，並比較兩個字串，執行下列作業：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2667">To normalize and compare two strings, do the following:</span></span>  
  
1.  <span data-ttu-id="5f51e-2668">取得從輸入來源，例如檔案或使用者的輸入的裝置要比較的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2668">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>  
  
2.  <span data-ttu-id="5f51e-2669">呼叫<xref:System.String.Normalize%28System.Text.NormalizationForm%29>方法，以將字串標準化為指定的正規化格式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2669">Call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29> method to normalize the strings to a specified normalization form.</span></span>  
  
3.  <span data-ttu-id="5f51e-2670">若要比較兩個字串，呼叫的方法，支援的序數字串比較，例如<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，並提供值<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>做為<xref:System.StringComparison>引數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2670">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="5f51e-2671">若要排序的正規化的字串陣列，傳遞`comparer`值<xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType>或<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType>適當多載<xref:System.Array.Sort%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2671">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>  
  
4.  <span data-ttu-id="5f51e-2672">發出根據上一個步驟所指定的順序排序的輸出中的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2672">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>  
  
 <span data-ttu-id="5f51e-2673">如需支援的 Unicode 正規化表單的說明，請參閱<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2673">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2674">下列範例會將字串標準化為每四個正規化格式，確認字串已標準化為指定的正規化表單，然後列出正規化的字串中的字碼指標。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2674">The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5f51e-2675">目前的執行個體包含無效的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2675">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2676"><see cref="Overload:System.String.IsNormalized" />方法會傳回<see langword="false" />當它遇到第一個非標準化字元在字串中的。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2676">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="5f51e-2677">因此，如果字串包含非標準化的字元無效的 Unicode 字元後, 接<see cref="Overload:System.String.Normalize" />方法可能會擲回<see cref="T:System.ArgumentException" />雖然<see cref="Overload:System.String.IsNormalized" />傳回<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2677">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method may throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="5f51e-2678">要比較的第一個字串，或是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2678">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="5f51e-2679">要比較的第二個字串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2679">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="5f51e-2680">判斷兩個指定的字串是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2680">Determines whether two specified strings have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-2681">如果 <see langword="true" /> 的值與 <paramref name="a" /> 的值相同，則為 <paramref name="b" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2681"><see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2682"><xref:System.String.op_Equality%2A>方法定義的等號比較運算子的作業<xref:System.String>類別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2682">The <xref:System.String.op_Equality%2A> method defines the operation of the equality operator for the <xref:System.String> class.</span></span> <span data-ttu-id="5f51e-2683">它可讓程式碼，例如顯示的範例 > 一節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2683">It enables code such as that shown in the Example section.</span></span> <span data-ttu-id="5f51e-2684">運算子，又會呼叫靜態<xref:System.String.Equals%28System.String%2CSystem.String%29>執行序數 （區分大小寫且區分文化特性） 比較方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2684">The operator, in turn, calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-2685">Visual Basic 編譯器不會解析與呼叫的等號比較運算子<xref:System.String.op_Equality%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2685">The Visual Basic compiler does not resolve the equality operator as a call to the <xref:System.String.op_Equality%2A> method.</span></span> <span data-ttu-id="5f51e-2686">相反地，等號比較運算子會呼叫包裝<xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2686">Instead, the equality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2687">下列範例會示範等號比較運算子。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2687">The following example demonstrates the equality operator.</span></span>  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="5f51e-2688">要比較的第一個字串，或是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2688">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="5f51e-2689">要比較的第二個字串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2689">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="5f51e-2690">判斷兩個指定的字串是否具有不同的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2690">Determines whether two specified strings have different values.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-2691">如果 <see langword="true" /> 的值與 <paramref name="a" /> 的值不同，則為 <paramref name="b" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2691"><see langword="true" /> if the value of <paramref name="a" /> is different from the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2692"><xref:System.String.op_Inequality%2A>方法會定義作業的不等比較運算子的<xref:System.String>類別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2692">The <xref:System.String.op_Inequality%2A> method defines the operation of the inequality operator for the <xref:System.String> class.</span></span>   <span data-ttu-id="5f51e-2693">它可讓程式碼，例如顯示的範例 > 一節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2693">It enables code such as that shown in the Examples section.</span></span>  
  
 <span data-ttu-id="5f51e-2694"><xref:System.String.op_Inequality%2A>運算子會呼叫靜態<xref:System.String.Equals%28System.String%2CSystem.String%29>執行序數 （區分大小寫且區分文化特性） 比較方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2694">The <xref:System.String.op_Inequality%2A> operator in turn calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-2695">Visual Basic 編譯器不會解析不等比較運算子，與呼叫<xref:System.String.op_Inequality%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2695">The Visual Basic compiler does not resolve the inequality operator as a call to the <xref:System.String.op_Inequality%2A> method.</span></span> <span data-ttu-id="5f51e-2696">相反地，不等比較運算子會呼叫包裝<xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2696">Instead, the inequality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2697">下列範例會示範不等比較運算子。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2697">The following example demonstrates the inequality operator.</span></span>  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-2698">傳回指定之長度的新字串，其中目前字串的開頭將以空白和或指定的 Unicode 字元填補。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2698">Returns a new string of a specified length in which the beginning of the current string is padded with spaces or with a specified Unicode character.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="5f51e-2699">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2699">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <summary><span data-ttu-id="5f51e-2700">傳回新字串，此字串會以空格填補左側至指定的總長度，靠右對齊這個執行個體中的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2700">Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2701">與這個執行個體相等的新字串，但為靠右對齊，並在左側視需要填補若干空間來建立 <paramref name="totalWidth" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2701">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="5f51e-2702">但是，如果 <paramref name="totalWidth" /> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2702">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="5f51e-2703">如果 <paramref name="totalWidth" /> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2703">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2704">Unicode 空間會定義為十六進位 0x0020。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2704">A Unicode space is defined as hexadecimal 0x0020.</span></span>  
  
 <span data-ttu-id="5f51e-2705"><xref:System.String.PadLeft%28System.Int32%29>方法填補傳回之字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2705">The <xref:System.String.PadLeft%28System.Int32%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="5f51e-2706">這表示，由右至左語言搭配使用時，它會填補字串的右側部分。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2706">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-2707">如果<xref:System.String.PadLeft%2A>方法填補空白字元目前的執行個體，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2707">If the <xref:System.String.PadLeft%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-2708">相反地，它會傳回新字串，使其總長度前置空白字元填補`totalWidth`字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2708">Instead, it returns a new string that is padded with leading white space so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2709">下列範例會示範<xref:System.String.PadLeft%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2709">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2710"><paramref name="totalWidth" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2710"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="5f51e-2711">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2711">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <param name="paddingChar"><span data-ttu-id="5f51e-2712">Unicode 填補字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2712">A Unicode padding character.</span></span></param>
        <summary><span data-ttu-id="5f51e-2713">傳回新字串，此字串會以指定的 Unicode 字元填補左側至指定的總長度，靠右對齊這個執行個體中的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2713">Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2714">與這個執行個體相等的新字串，但為靠右對齊，並在左側視需要填補若干 <paramref name="paddingChar" /> 字元來建立 <paramref name="totalWidth" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2714">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="5f51e-2715">但是，如果 <paramref name="totalWidth" /> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2715">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="5f51e-2716">如果 <paramref name="totalWidth" /> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2716">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2717"><xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29>方法填補傳回之字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2717">The <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="5f51e-2718">這表示，由右至左語言搭配使用時，它會填補字串的右側部分。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2718">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-2719">如果<xref:System.String.PadLeft%2A>方法填補空白字元目前的執行個體，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2719">If the <xref:System.String.PadLeft%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-2720">相反地，它會傳回新字串，以前置填補`paddingChar`個字元，使其總長度`totalWidth`字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2720">Instead, it returns a new string that is padded with leading `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2721">下列範例會示範<xref:System.String.PadLeft%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2721">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2722"><paramref name="totalWidth" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2722"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-2723">傳回指定之長度的新字串，其中目前字串的結尾將以空白和或指定的 Unicode 字元填補。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2723">Returns a new string of a specified length in which the end of the current string is padded with spaces or with a specified Unicode character.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="5f51e-2724">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2724">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <summary><span data-ttu-id="5f51e-2725">傳回新字串，此字串會以空格填補右側至指定的總長度，靠左對齊這個字串中的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2725">Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2726">與這個執行個體相等的新字串，但為靠左對齊，並在右側視需要填補若干空間來建立 <paramref name="totalWidth" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2726">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="5f51e-2727">但是，如果 <paramref name="totalWidth" /> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2727">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="5f51e-2728">如果 <paramref name="totalWidth" /> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2728">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2729">Unicode 空間會定義為十六進位 0x0020。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2729">A Unicode space is defined as hexadecimal 0x0020.</span></span>  
  
 <span data-ttu-id="5f51e-2730"><xref:System.String.PadRight%28System.Int32%29>方法填補傳回之字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2730">The <xref:System.String.PadRight%28System.Int32%29> method pads the end of the returned string.</span></span> <span data-ttu-id="5f51e-2731">這表示，由右至左語言搭配使用時，它會填補字串的左側的部分。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2731">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-2732">如果<xref:System.String.PadRight%2A>方法填補空白字元目前的執行個體，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2732">If the <xref:System.String.PadRight%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-2733">相反地，它會傳回新字串，使其總長度塞滿尾端空白字元`totalWidth`字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2733">Instead, it returns a new string that is padded with trailing white space so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2734">下列範例會示範<xref:System.String.PadRight%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2734">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2735"><paramref name="totalWidth" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2735"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="5f51e-2736">產生的字串中的字元數，等於原始字元加上任何其他填補字元的數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2736">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <param name="paddingChar"><span data-ttu-id="5f51e-2737">Unicode 填補字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2737">A Unicode padding character.</span></span></param>
        <summary><span data-ttu-id="5f51e-2738">傳回新字串，此字串會以指定的 Unicode 字元填補右側至指定的總長度，靠左對齊這個字串中的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2738">Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2739">與這個執行個體相等的新字串，但為靠左對齊，並在右側視需要填補若干 <paramref name="paddingChar" /> 字元來建立 <paramref name="totalWidth" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2739">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="5f51e-2740">但是，如果 <paramref name="totalWidth" /> 小於這個執行個體的長度，此方法會傳回現有執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2740">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="5f51e-2741">如果 <paramref name="totalWidth" /> 等於這個執行個體的長度，此方法會傳回等於這個執行個體的新字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2741">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2742"><xref:System.String.PadRight%28System.Int32%2CSystem.Char%29>方法填補傳回之字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2742">The <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> method pads the end of the returned string.</span></span> <span data-ttu-id="5f51e-2743">這表示，由右至左語言搭配使用時，它會填補字串的左側的部分。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2743">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-2744">如果<xref:System.String.PadRight%2A>方法填補空白字元目前的執行個體，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2744">If the <xref:System.String.PadRight%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-2745">相反地，它會傳回新字串，會以尾端填補`paddingChar`個字元，使其總長度`totalWidth`字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2745">Instead, it returns a new string that is padded with trailing `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2746">下列範例會示範<xref:System.String.PadRight%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2746">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2747"><paramref name="totalWidth" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2747"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-2748">傳回新字串，其中刪除了目前字串中指定的字元數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2748">Returns a new string in which a specified number of characters from the current string are deleted.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="5f51e-2749">要開始刪除字元之以零為起始的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2749">The zero-based position to begin deleting characters.</span></span></param>
        <summary><span data-ttu-id="5f51e-2750">傳回新字串，其中已刪除目前執行個體中的所有字元 (從指定位置開始到最後一個位置為止)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2750">Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2751">新字串，除了已移除的字元以外，其餘部分都與這個字串相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2751">A new string that is equivalent to this string except for the removed characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2752">在[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]，字串都是以零為起始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2752">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="5f51e-2753">值`startIndex`參數的範圍可以從零到字串執行個體的長度大於或等於一。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2753">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-2754">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2754">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-2755">相反地，它會傳回新字串中的所有字元從位置`startIndex`原始字串的結尾已移除。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2755">Instead, it returns a new string in which all characters from position `startIndex` to the end of the original string have been removed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2756">下列範例會示範<xref:System.String.Remove%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2756">The following example demonstrates the <xref:System.String.Remove%2A> method.</span></span> <span data-ttu-id="5f51e-2757">下一步 到最後一個案例會移除從指定之索引到結尾的字串開始的所有文字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2757">The next-to-last case removes all text starting from the specified index through the end of the string.</span></span> <span data-ttu-id="5f51e-2758">最後一種情況會移除從指定索引開始的三個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2758">The last case removes three characters starting from the specified index.</span></span>  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-2759"><paramref name="startIndex" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2759"><paramref name="startIndex" /> is less than zero.</span></span>  
  
 <span data-ttu-id="5f51e-2760">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2760">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2761"><paramref name="startIndex" /> 指定了不在這個字串中的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2761"><paramref name="startIndex" /> specifies a position that is not within this string.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="5f51e-2762">要開始刪除字元之以零為起始的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2762">The zero-based position to begin deleting characters.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-2763">要刪除的字元數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2763">The number of characters to delete.</span></span></param>
        <summary><span data-ttu-id="5f51e-2764">傳回新字串，其中已刪除在目前執行個體中指定位置開始之指定數目的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2764">Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2765">新字串，除了已移除的字元以外，其餘部分都與這個執行個體相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2765">A new string that is equivalent to this instance except for the removed characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2766">在[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]，字串都是以零為起始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2766">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="5f51e-2767">值`startIndex`參數的範圍可以從零到字串執行個體的長度大於或等於一。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2767">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-2768">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2768">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-2769">相反地，它會傳回新字串的字元數所指定`count`已移除參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2769">Instead, it returns a new string in which the number of characters specified by the `count` parameter have been removed.</span></span> <span data-ttu-id="5f51e-2770">字元會在所指定的位置移除`startIndex`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2770">The characters are removed at the position specified by `startIndex`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2771">下列範例會示範如何移除中間名是完整的名稱從。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2771">The following example demonstrates how you can remove the middle name from a complete name.</span></span>  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5f51e-2772"><paramref name="startIndex" /> 或 <paramref name="count" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2772">Either <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="5f51e-2773">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-2773">-or-</span></span>  
  
 <span data-ttu-id="5f51e-2774"><paramref name="startIndex" /> 加上 <paramref name="count" /> 可指定不在這個執行個體中的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2774"><paramref name="startIndex" /> plus <paramref name="count" /> specify a position outside this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-2775">傳回新字串，其中目前字串中指定之 Unicode 字元或 <see cref="T:System.String" /> 的所有項目，全都會被取代成另一個指定的 Unicode 字元或 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2775">Returns a new string in which all occurrences of a specified Unicode character or <see cref="T:System.String" /> in the current string are replaced with another specified Unicode character or <see cref="T:System.String" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar"><span data-ttu-id="5f51e-2776">要被取代的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2776">The Unicode character to be replaced.</span></span></param>
        <param name="newChar"><span data-ttu-id="5f51e-2777">要用來取代所有出現之 <c>oldChar</c> 的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2777">The Unicode character to replace all occurrences of <c>oldChar</c>.</span></span></param>
        <summary><span data-ttu-id="5f51e-2778">傳回新字串，其中這個執行個體中所有出現的指定 Unicode 字元都取代成其他指定的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2778">Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2779">相當於這個執行個體的字串，只是 <paramref name="oldChar" /> 的所有執行個體都會取代成 <paramref name="newChar" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2779">A string that is equivalent to this instance except that all instances of <paramref name="oldChar" /> are replaced with <paramref name="newChar" />.</span></span> <span data-ttu-id="5f51e-2780">如果在目前的執行個體中找不到 <paramref name="oldChar" />，則方法傳回未變更的目前執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2780">If <paramref name="oldChar" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2781">這個方法會執行序數 （區分大小寫且區分文化特性） 搜尋來尋找`oldChar`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2781">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldChar`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-2782">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2782">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-2783">相反地，它會傳回新字串中的所有項目`oldChar`來取代`newChar`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2783">Instead, it returns a new string in which all occurrences of `oldChar` are replaced by `newChar`.</span></span>  
  
 <span data-ttu-id="5f51e-2784">因為這個方法會傳回已修改的字串，您可以鏈結在一起後續呼叫<xref:System.String.Replace%2A>原始字串上執行多個替代方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2784">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="5f51e-2785">方法會呼叫執行從左到右。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2785">Method calls are executed from left to right.</span></span> <span data-ttu-id="5f51e-2786">下列範例提供一個實例。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2786">The following example provides an illustration.</span></span>  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2787">下列範例會建立以逗號分隔值清單所得到的一連串數字之間的空白。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2787">The following example creates a comma separated value list by substituting commas for the blanks between a series of numbers.</span></span>  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="5f51e-2788">要被取代的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2788">The string to be replaced.</span></span></param>
        <param name="newValue"><span data-ttu-id="5f51e-2789">用來取代所有出現之 <c>oldValue</c> 的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2789">The string to replace all occurrences of <c>oldValue</c>.</span></span></param>
        <summary><span data-ttu-id="5f51e-2790">傳回新字串，其中目前執行個體中所有出現的指定字串，都取代成其他指定的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2790">Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2791">相當於目前字串的字串，只是 <paramref name="oldValue" /> 的所有執行個體都會取代成 <paramref name="newValue" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2791">A string that is equivalent to the current string except that all instances of <paramref name="oldValue" /> are replaced with <paramref name="newValue" />.</span></span> <span data-ttu-id="5f51e-2792">如果在目前的執行個體中找不到 <paramref name="oldValue" />，則方法傳回未變更的目前執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2792">If <paramref name="oldValue" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2793">如果`newValue`是`null`的所有項目`oldValue`會移除。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2793">If `newValue` is `null`, all occurrences of `oldValue` are removed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-2794">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2794">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-2795">相反地，它會傳回新字串中的所有項目`oldValue`來取代`newValue`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2795">Instead, it returns a new string in which all occurrences of `oldValue` are replaced by `newValue`.</span></span>  
  
 <span data-ttu-id="5f51e-2796">這個方法會執行序數 （區分大小寫且區分文化特性） 搜尋來尋找`oldValue`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2796">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldValue`.</span></span>  
  
 <span data-ttu-id="5f51e-2797">因為這個方法會傳回已修改的字串，您可以鏈結在一起後續呼叫<xref:System.String.Replace%2A>原始字串上執行多個替代方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2797">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="5f51e-2798">方法會呼叫執行從左到右。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2798">Method calls are executed from left to right.</span></span> <span data-ttu-id="5f51e-2799">下列範例提供一個實例。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2799">The following example provides an illustration.</span></span>  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2800">下列範例示範如何使用<xref:System.String.Replace%2A>更正拼字錯誤的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2800">The following example demonstrates how you can use the <xref:System.String.Replace%2A> method to correct a spelling error.</span></span>  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-2801"><paramref name="oldValue" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2801"><paramref name="oldValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-2802"><paramref name="oldValue" /> 為空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2802"><paramref name="oldValue" /> is the empty string ("").</span></span></exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-2803">傳回字串陣列，這個陣列包含這個執行個體中，由指定的字串或 Unicode 字元陣列之項目所分隔的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2803">Returns a string array that contains the substrings in this instance that are delimited by elements of a specified string or Unicode character array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2804"><xref:System.String.Split%2A> 用來分隔的字串分割成子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2804"><xref:System.String.Split%2A> is used to break a delimited string into substrings.</span></span> <span data-ttu-id="5f51e-2805">您可用來指定零個、 一個或多個分隔字元的字元陣列 (<xref:System.String.Split%28System.Char%5B%5D%29>方法)，或者您可以使用的字元陣列，指定零個、 一個或多個分隔的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2805">You can use either a character array to specify zero, one, or multiple delimiting characters (the <xref:System.String.Split%28System.Char%5B%5D%29> method), or you can use a character array to specify zero, one, or multiple delimiting strings.</span></span> <span data-ttu-id="5f51e-2806">多載<xref:System.String.Split%2A>方法可讓您限制的方法所傳回的子字串數目 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29>方法)，以決定中傳回的子字串是否包含空字串 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29>和<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>方法，或以這兩種 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>和<xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>方法)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2806">Overloads of the <xref:System.String.Split%2A> method allow you to limit the number of substrings returned by the method (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> method), to determine whether empty strings are included in the returned substrings (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> methods, or to do both (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> methods).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5f51e-2807">如需詳細資訊在<xref:System.String.Split%2A>方法，以及呼叫的範例中，每個多載，請參閱個別的多載的文件<xref:System.String.Split%2A>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2807">For more detailed information on the <xref:System.String.Split%2A> method, as well as for examples that call each overload, see the documentation for the individual overloads of <xref:System.String.Split%2A>.</span></span>  
  
 <span data-ttu-id="5f51e-2808"><xref:System.String.Split%2A>方法不一定要分隔的字串分割成子字串的最佳方式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2808">The <xref:System.String.Split%2A> method is not always the best way to break a delimited string into substrings.</span></span> <span data-ttu-id="5f51e-2809">如果您不想要擷取所有的子字串的分隔的字串，或如果您想要根據的模式，而不是一組字元的分隔符號將字串剖析，請考慮下列的替代方案。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2809">If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</span></span>  
  
## <a name="regular-expressions"></a><span data-ttu-id="5f51e-2810">規則運算式</span><span class="sxs-lookup"><span data-stu-id="5f51e-2810">Regular expressions</span></span>  
 <span data-ttu-id="5f51e-2811">如果字串符合固定模式，您可以使用規則運算式來擷取並處理其項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2811">If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</span></span> <span data-ttu-id="5f51e-2812">比方說，如果字串的形式"*數目**運算元**數目*」 可以使用[規則運算式](~/docs/standard/base-types/regular-expressions.md)擷取及處理字串的項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2812">For example, if strings take the form "*number* *operand* *number*" you can use a [regular expression](~/docs/standard/base-types/regular-expressions.md) to extract and handle the string's elements.</span></span> <span data-ttu-id="5f51e-2813">以下為範例：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2813">Here's an example:</span></span>  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 <span data-ttu-id="5f51e-2814">規則運算式模式`(\d+)\s+([-+*/])\s+(\d+)`定義如下：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2814">The regular expression pattern `(\d+)\s+([-+*/])\s+(\d+)` is defined like this:</span></span>  
  
|<span data-ttu-id="5f51e-2815">模式</span><span class="sxs-lookup"><span data-stu-id="5f51e-2815">Pattern</span></span>|<span data-ttu-id="5f51e-2816">描述</span><span class="sxs-lookup"><span data-stu-id="5f51e-2816">Description</span></span>|  
|-------------|-----------------|  
|`(\d+)`|<span data-ttu-id="5f51e-2817">比對一個或多個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2817">Match one or more decimal digits.</span></span> <span data-ttu-id="5f51e-2818">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2818">This is the first capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="5f51e-2819">比對一個或多個空格字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2819">Match one or more whitespace characters.</span></span>|  
|`([-+*/])`|<span data-ttu-id="5f51e-2820">符合號算術運算子 (+、-、 \*、 或 /)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2820">Match an arithmetic operator sign (+, -, \*, or /).</span></span> <span data-ttu-id="5f51e-2821">這是第二個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2821">This is the second capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="5f51e-2822">比對一個或多個空格字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2822">Match one or more whitespace characters.</span></span>|  
|`(\d+)`|<span data-ttu-id="5f51e-2823">比對一個或多個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2823">Match one or more decimal digits.</span></span> <span data-ttu-id="5f51e-2824">這是第三個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2824">This is the third capturing group.</span></span>|  
  
 <span data-ttu-id="5f51e-2825">您也可以使用規則運算式從根據的模式，而不是固定的一組字元的字串擷取子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2825">You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</span></span> <span data-ttu-id="5f51e-2826">當任一條件發生時，這是常見的案例：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2826">This is a common scenario when either of these conditions occurs:</span></span>  
  
-   <span data-ttu-id="5f51e-2827">一或多個分隔符號字元不一定服務中的分隔符號<xref:System.String>執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2827">One or more of the delimiter characters does not always serve as a delimiter in the <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="5f51e-2828">順序及分隔符號字元數是區域變數或未知。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2828">The sequence and number of delimiter characters is variable or unknown.</span></span>  
  
 <span data-ttu-id="5f51e-2829">例如，<xref:System.String.Split%2A>方法無法用來分割下列字串，因為數目`\n`（C# 中） 或`vbCrLf`（在 Visual Basic) 字元是變數，而且它們不一定會做為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2829">For example, the <xref:System.String.Split%2A> method cannot be used to split the following string, because the number of `\n` (in C#) or `vbCrLf` (in Visual Basic) characters is variable, and they don't always serve as delimiters.</span></span>  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 <span data-ttu-id="5f51e-2830">規則運算式可以輕鬆，如下列範例所示分割此字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2830">A regular expression can split this string easily, as the following example shows.</span></span>  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 <span data-ttu-id="5f51e-2831">規則運算式模式`\[([^\[\]]+)\]`定義如下：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2831">The regular expression pattern `\[([^\[\]]+)\]` is defined like this:</span></span>  
  
|<span data-ttu-id="5f51e-2832">模式</span><span class="sxs-lookup"><span data-stu-id="5f51e-2832">Pattern</span></span>|<span data-ttu-id="5f51e-2833">描述</span><span class="sxs-lookup"><span data-stu-id="5f51e-2833">Description</span></span>|  
|-------------|-----------------|  
|`\[`|<span data-ttu-id="5f51e-2834">比對左括號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2834">Match an opening bracket.</span></span>|  
|`([^\[\]]+)`|<span data-ttu-id="5f51e-2835">比對不是左或右括弧一或多次的任何字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2835">Match any character that is not an opening or a closing bracket one or more times.</span></span> <span data-ttu-id="5f51e-2836">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2836">This is the first capturing group.</span></span>|  
|`\]`|<span data-ttu-id="5f51e-2837">比對右括號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2837">Match a closing bracket.</span></span>|  
  
 <span data-ttu-id="5f51e-2838"><xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法是幾乎完全相同<xref:System.String.Split%2A?displayProperty=nameWithType>，只不過它會將分割根據規則運算式模式，而不是固定的字元集的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2838">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method is almost identical to <xref:System.String.Split%2A?displayProperty=nameWithType>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</span></span> <span data-ttu-id="5f51e-2839">例如，下列範例會使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法包含以各種連字號和其他字元的組合分隔的子字串將字串分隔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2839">For example, the following example uses the <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</span></span>  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 <span data-ttu-id="5f51e-2840">規則運算式模式`\s-\s?[+*]?\s?-\s`定義如下：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2840">The regular expression pattern `\s-\s?[+*]?\s?-\s` is defined like this:</span></span>  
  
|<span data-ttu-id="5f51e-2841">模式</span><span class="sxs-lookup"><span data-stu-id="5f51e-2841">Pattern</span></span>|<span data-ttu-id="5f51e-2842">描述</span><span class="sxs-lookup"><span data-stu-id="5f51e-2842">Description</span></span>|  
|-------------|-----------------|  
|`\s-`|<span data-ttu-id="5f51e-2843">比對空白字元後面接著連字號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2843">Match a whitespace character followed by a hyphen.</span></span>|  
|`\s?`|<span data-ttu-id="5f51e-2844">比對零個或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2844">Match zero or one whitespace character.</span></span>|  
|`[+*]?`|<span data-ttu-id="5f51e-2845">比對零個或一個任一個的 + 或 \* 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2845">Match zero or one occurrence of either the + or \* character.</span></span>|  
|`\s?`|<span data-ttu-id="5f51e-2846">比對零個或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2846">Match zero or one whitespace character.</span></span>|  
|`-\s`|<span data-ttu-id="5f51e-2847">比對後面接著空白字元的字元是連字號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2847">Match a hyphen followed by a whitespace character.</span></span>|  
  
## <a name="search-methods-and-the-substring-method"></a><span data-ttu-id="5f51e-2848">搜尋方法和 Substring 方法</span><span class="sxs-lookup"><span data-stu-id="5f51e-2848">Search methods and the Substring method</span></span>  
 <span data-ttu-id="5f51e-2849">如果您不想要在字串中子字串的所有項目，您可能想要使用其中一個會傳回的索引開始比對的字串比較方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2849">If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</span></span> <span data-ttu-id="5f51e-2850">您可以接著呼叫<xref:System.String.Substring%2A>方法，可擷取您想要的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2850">You can then call the <xref:System.String.Substring%2A> method to extract the substring that you want.</span></span> <span data-ttu-id="5f51e-2851">字串比較方法包括：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2851">The string comparison methods include:</span></span>  
  
-   <span data-ttu-id="5f51e-2852"><xref:System.String.IndexOf%2A>它會傳回字元或字串第一次出現的以零為起始的索引中的字串執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2852"><xref:System.String.IndexOf%2A>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="5f51e-2853"><xref:System.String.IndexOfAny%2A>它會傳回目前的字串執行個體中，字元陣列中的任何字元第一次出現的以零為起始的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2853"><xref:System.String.IndexOfAny%2A>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</span></span>  
  
-   <span data-ttu-id="5f51e-2854"><xref:System.String.LastIndexOf%2A>它會傳回字元或字串最後一次出現的以零為起始的索引中的字串執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2854"><xref:System.String.LastIndexOf%2A>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="5f51e-2855"><xref:System.String.LastIndexOfAny%2A>它會傳回以零為起始的索引中目前的最後一個出現的字元陣列中的任何字元的字串執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2855"><xref:System.String.LastIndexOfAny%2A>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</span></span>  
  
 <span data-ttu-id="5f51e-2856">下列範例會使用<xref:System.String.IndexOf%2A>方法來尋找字串中的句點。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2856">The following example uses the <xref:System.String.IndexOf%2A> method to find the periods in a string.</span></span> <span data-ttu-id="5f51e-2857">然後它會使用<xref:System.String.Substring%2A>方法以傳回完整的句子。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2857">It then uses the <xref:System.String.Substring%2A> method to return full sentences.</span></span>  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="5f51e-2858">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2858">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="5f51e-2859">根據陣列中的字元分割字串成子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2859">Splits a string into substrings that are based on the characters in an array.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2860">陣列，其項目中包含了這個執行個體中的子字串，由 <paramref name="separator" /> 內的一或多個字元分隔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2860">An array whose elements contain the substrings from this instance that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="5f51e-2861">如需詳細資訊，請參閱＜備註＞一節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2861">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2862">當已知的一組字元所分隔的字串時，您可以使用<xref:System.String.Split%28System.Char%5B%5D%29>分隔成子字串的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2862">When a string is delimited by a known set of characters, you can use the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate it into substrings.</span></span> <span data-ttu-id="5f51e-2863">從字串擷取子字串的其他方式，請參閱[String.Split 的替代方案](#Alternatives)> 一節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2863">For other ways to extract substrings from a string, see the [Alternatives to String.Split](#Alternatives) section.</span></span>  
  
## <a name="return-value-details"></a><span data-ttu-id="5f51e-2864">傳回值的詳細資料</span><span class="sxs-lookup"><span data-stu-id="5f51e-2864">Return value details</span></span>  
 <span data-ttu-id="5f51e-2865">傳回陣列的項目中不包含分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2865">Delimiter characters are not included in the elements of the returned array.</span></span> <span data-ttu-id="5f51e-2866">例如，如果分隔符號陣列包含字元"-"，目前的字串執行個體的值是"aa 位 bb-cc"方法會傳回陣列，其中包含三個項目:"aa"、"bb"和"cc"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2866">For example, if the separator array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="5f51e-2867">如果這個執行個體不包含任何字元`separator`，傳回的陣列包含這個執行個體的單一項目所組成。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2867">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="5f51e-2868">每個項目`separator`定義不同的分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2868">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="5f51e-2869">如果兩個分隔符號是相鄰的或是位於分隔符號的開頭或結尾的這個執行個體，傳回陣列中對應的項目包含<xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2869">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <xref:System.String.Empty>.</span></span> <span data-ttu-id="5f51e-2870">以下是一些範例：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2870">Here are some examples:</span></span>  
  
|<span data-ttu-id="5f51e-2871">字串值</span><span class="sxs-lookup"><span data-stu-id="5f51e-2871">String value</span></span>|<span data-ttu-id="5f51e-2872">Separator</span><span class="sxs-lookup"><span data-stu-id="5f51e-2872">Separator</span></span>|<span data-ttu-id="5f51e-2873">傳回的陣列</span><span class="sxs-lookup"><span data-stu-id="5f51e-2873">Returned array</span></span>|  
|------------------|---------------|--------------------|  
|<span data-ttu-id="5f51e-2874">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="5f51e-2874">"42, 12, 19"</span></span>|<span data-ttu-id="5f51e-2875">新 Char [] {'，' ' '} (C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2875">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="5f51e-2876">Char （) = {"，"c""c}) (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2876">Char() = {","c, " "c}) (Visual Basic)</span></span>|<span data-ttu-id="5f51e-2877">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="5f51e-2877">{"42", "", "12", "", "19"}</span></span>|  
|<span data-ttu-id="5f51e-2878">"42..12..19"</span><span class="sxs-lookup"><span data-stu-id="5f51e-2878">"42..12..19"</span></span>|<span data-ttu-id="5f51e-2879">新 Char [] {'。 '}</span><span class="sxs-lookup"><span data-stu-id="5f51e-2879">new Char[] {'.'}</span></span> <span data-ttu-id="5f51e-2880">(C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2880">(C#)</span></span><br /><br /> <span data-ttu-id="5f51e-2881">Char （) = {"。"c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2881">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="5f51e-2882">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="5f51e-2882">{"42", "", "12", "", "19"}</span></span>|  
|<span data-ttu-id="5f51e-2883">「 Banana"</span><span class="sxs-lookup"><span data-stu-id="5f51e-2883">"Banana"</span></span>|<span data-ttu-id="5f51e-2884">新 Char [] {'。 '}</span><span class="sxs-lookup"><span data-stu-id="5f51e-2884">new Char[] {'.'}</span></span> <span data-ttu-id="5f51e-2885">(C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2885">(C#)</span></span><br /><br /> <span data-ttu-id="5f51e-2886">Char （) = {"。"c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2886">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="5f51e-2887">{"香蕉"}</span><span class="sxs-lookup"><span data-stu-id="5f51e-2887">{"Banana"}</span></span>|  
|<span data-ttu-id="5f51e-2888">「 Darb\nSmarba 」 (C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2888">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="5f51e-2889">「 Darb"vbLf &"Smarba 」 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2889">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="5f51e-2890">新 Char [] {} (C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2890">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="5f51e-2891">Char （) = {} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2891">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="5f51e-2892">{"Darb"，"Smarba"}</span><span class="sxs-lookup"><span data-stu-id="5f51e-2892">{"Darb", "Smarba"}</span></span>|  
|<span data-ttu-id="5f51e-2893">「 Darb\nSmarba 」 (C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2893">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="5f51e-2894">「 Darb"vbLf &"Smarba 」 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2894">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="5f51e-2895">null (C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2895">null (C#)</span></span><br /><br /> <span data-ttu-id="5f51e-2896">Nothing (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2896">Nothing (Visual Basic)</span></span>|<span data-ttu-id="5f51e-2897">{"Darb"，"Smarba"}</span><span class="sxs-lookup"><span data-stu-id="5f51e-2897">{"Darb", "Smarba"}</span></span>|  
  
## <a name="the-separator-array"></a><span data-ttu-id="5f51e-2898">分隔陣列</span><span class="sxs-lookup"><span data-stu-id="5f51e-2898">The separator array</span></span>  
 <span data-ttu-id="5f51e-2899">每個項目分隔符號的定義不同的分隔符號包含單一字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2899">Each element of separator defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="5f51e-2900">如果`separator`引數是`null`或未包含任何字元，方法會將空白字元視為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2900">If the `separator` argument is `null` or contains no characters, the method treats white-space characters as the delimiters.</span></span> <span data-ttu-id="5f51e-2901">泛空白字元是由 Unicode 標準; 定義它們會傳回`true`如果傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2901">White-space characters are defined by the Unicode standard; they return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
## <a name="stringsplitchar-and-compiler-overload-resolution"></a><span data-ttu-id="5f51e-2902">String.Split(Char[]) 和編譯器多載解析</span><span class="sxs-lookup"><span data-stu-id="5f51e-2902">String.Split(Char[]) and compiler overload resolution</span></span>  
 <span data-ttu-id="5f51e-2903">雖然的這個多載的單一參數<xref:System.String.Split%2A?displayProperty=nameWithType>是字元陣列中，呼叫以單一字元，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2903">Although the single parameter for this overload of <xref:System.String.Split%2A?displayProperty=nameWithType> is a character array, you can call it with a single character, as the following example shows.</span></span>  
  
 [!code-csharp[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 <span data-ttu-id="5f51e-2904">因為`separator`參數以裝飾<xref:System.ParamArrayAttribute>屬性，編譯器會解譯為單一字元做為單一元素字元陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2904">Because the `separator` parameter is decorated  with the <xref:System.ParamArrayAttribute> attribute, compilers will interpret a single character as a single-element character array.</span></span> <span data-ttu-id="5f51e-2905">這不是為其他案例<xref:System.String.Split%2A?displayProperty=nameWithType>包含的多載`separator`參數，您必須明確傳遞這些多載字元陣列，做為`separator`引數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2905">This is not the case for other <xref:System.String.Split%2A?displayProperty=nameWithType> overloads that include a `separator` parameter; you must explicitly pass these overloads a character array as the `separator` argument.</span></span>  
  
## <a name="comparison-details"></a><span data-ttu-id="5f51e-2906">比較詳細資料</span><span class="sxs-lookup"><span data-stu-id="5f51e-2906">Comparison details</span></span>  
 <span data-ttu-id="5f51e-2907"><xref:System.String.Split%28System.Char%5B%5D%29>方法還會擷取一或多個中的字元會分隔這個字串中子字串`separator`陣列，並將傳回的子字串做為陣列的項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2907">The <xref:System.String.Split%28System.Char%5B%5D%29> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` array, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="5f51e-2908"><xref:System.String.Split%28System.Char%5B%5D%29>方法會尋找分隔符號執行比較使用區分大小寫的序數排序規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2908">The <xref:System.String.Split%28System.Char%5B%5D%29> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="5f51e-2909">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2909">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
<a name="Alternatives"></a>   
## <a name="alternatives-to-stringsplit"></a><span data-ttu-id="5f51e-2910">String.Split 的替代方案</span><span class="sxs-lookup"><span data-stu-id="5f51e-2910">Alternatives to String.Split</span></span>  
 <span data-ttu-id="5f51e-2911"><xref:System.String.Split%2A>方法不一定要分隔的字串分割成子字串的最佳方式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2911">The <xref:System.String.Split%2A> method is not always the best way to break a delimited string into substrings.</span></span> <span data-ttu-id="5f51e-2912">如果您不想要擷取所有的子字串的分隔的字串，或如果您想要根據的模式，而不是一組字元的分隔符號將字串剖析，請考慮下列的替代方案。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2912">If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</span></span>  
  
### <a name="regular-expressions"></a><span data-ttu-id="5f51e-2913">規則運算式</span><span class="sxs-lookup"><span data-stu-id="5f51e-2913">Regular expressions</span></span>  
 <span data-ttu-id="5f51e-2914">如果字串符合固定模式，您可以使用規則運算式來擷取並處理其項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2914">If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</span></span> <span data-ttu-id="5f51e-2915">比方說，如果字串的形式"*數目**運算元**數目*」 可以使用[規則運算式](~/docs/standard/base-types/regular-expressions.md)擷取及處理字串的項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2915">For example, if strings take the form "*number* *operand* *number*" you can use a [regular expression](~/docs/standard/base-types/regular-expressions.md) to extract and handle the string's elements.</span></span> <span data-ttu-id="5f51e-2916">以下為範例：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2916">Here's an example:</span></span>  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 <span data-ttu-id="5f51e-2917">規則運算式模式`(\d+)\s+([-+*/])\s+(\d+)`定義如下：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2917">The regular expression pattern `(\d+)\s+([-+*/])\s+(\d+)` is defined like this:</span></span>  
  
|<span data-ttu-id="5f51e-2918">模式</span><span class="sxs-lookup"><span data-stu-id="5f51e-2918">Pattern</span></span>|<span data-ttu-id="5f51e-2919">描述</span><span class="sxs-lookup"><span data-stu-id="5f51e-2919">Description</span></span>|  
|-------------|-----------------|  
|`(\d+)`|<span data-ttu-id="5f51e-2920">比對一個或多個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2920">Match one or more decimal digits.</span></span> <span data-ttu-id="5f51e-2921">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2921">This is the first capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="5f51e-2922">比對一個或多個空格字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2922">Match one or more whitespace characters.</span></span>|  
|`([-+*/])`|<span data-ttu-id="5f51e-2923">符合號算術運算子 (+、-、 \*、 或 /)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2923">Match an arithmetic operator sign (+, -, \*, or /).</span></span> <span data-ttu-id="5f51e-2924">這是第二個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2924">This is the second capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="5f51e-2925">比對一個或多個空格字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2925">Match one or more whitespace characters.</span></span>|  
|`(\d+)`|<span data-ttu-id="5f51e-2926">比對一個或多個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2926">Match one or more decimal digits.</span></span> <span data-ttu-id="5f51e-2927">這是第三個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2927">This is the third capturing group.</span></span>|  
  
 <span data-ttu-id="5f51e-2928">您也可以使用規則運算式從根據的模式，而不是固定的一組字元的字串擷取子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2928">You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</span></span> <span data-ttu-id="5f51e-2929">當任一條件發生時，這是常見的案例：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2929">This is a common scenario when either of these conditions occurs:</span></span>  
  
-   <span data-ttu-id="5f51e-2930">一或多個分隔符號字元不一定服務中的分隔符號<xref:System.String>執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2930">One or more of the delimiter characters does not always serve as a delimiter in the <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="5f51e-2931">順序及分隔符號字元數是區域變數或未知。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2931">The sequence and number of delimiter characters is variable or unknown.</span></span>  
  
 <span data-ttu-id="5f51e-2932">例如，<xref:System.String.Split%2A>方法無法用來分割下列字串，因為數目`\n`（C# 中） 或`vbCrLf`（在 Visual Basic) 字元是變數，而且它們不一定會做為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2932">For example, the <xref:System.String.Split%2A> method cannot be used to split the following string, because the number of `\n` (in C#) or `vbCrLf` (in Visual Basic) characters is variable, and they don't always serve as delimiters.</span></span>  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 <span data-ttu-id="5f51e-2933">規則運算式可以輕鬆，如下列範例所示分割此字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2933">A regular expression can split this string easily, as the following example shows.</span></span>  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 <span data-ttu-id="5f51e-2934">規則運算式模式`\[([^\[\]]+)\]`定義如下：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2934">The regular expression pattern `\[([^\[\]]+)\]` is defined like this:</span></span>  
  
|<span data-ttu-id="5f51e-2935">模式</span><span class="sxs-lookup"><span data-stu-id="5f51e-2935">Pattern</span></span>|<span data-ttu-id="5f51e-2936">描述</span><span class="sxs-lookup"><span data-stu-id="5f51e-2936">Description</span></span>|  
|-------------|-----------------|  
|`\[`|<span data-ttu-id="5f51e-2937">比對左括號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2937">Match an opening bracket.</span></span>|  
|`([^\[\]]+)`|<span data-ttu-id="5f51e-2938">比對不是左或右括弧一或多次的任何字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2938">Match any character that is not an opening or a closing bracket one or more times.</span></span> <span data-ttu-id="5f51e-2939">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2939">This is the first capturing group.</span></span>|  
|`\]`|<span data-ttu-id="5f51e-2940">比對右括號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2940">Match a closing bracket.</span></span>|  
  
 <span data-ttu-id="5f51e-2941"><xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法是幾乎完全相同<xref:System.String.Split%2A?displayProperty=nameWithType>，只不過它會將分割根據規則運算式模式，而不是固定的字元集的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2941">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method is almost identical to <xref:System.String.Split%2A?displayProperty=nameWithType>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</span></span> <span data-ttu-id="5f51e-2942">例如，下列範例會使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法包含以各種連字號和其他字元的組合分隔的子字串將字串分隔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2942">For example, the following example uses the <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</span></span>  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 <span data-ttu-id="5f51e-2943">規則運算式模式`\s-\s?[+*]?\s?-\s`定義如下：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2943">The regular expression pattern `\s-\s?[+*]?\s?-\s` is defined like this:</span></span>  
  
|<span data-ttu-id="5f51e-2944">模式</span><span class="sxs-lookup"><span data-stu-id="5f51e-2944">Pattern</span></span>|<span data-ttu-id="5f51e-2945">描述</span><span class="sxs-lookup"><span data-stu-id="5f51e-2945">Description</span></span>|  
|-------------|-----------------|  
|`\s-`|<span data-ttu-id="5f51e-2946">比對空白字元後面接著連字號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2946">Match a whitespace character followed by a hyphen.</span></span>|  
|`\s?`|<span data-ttu-id="5f51e-2947">比對零個或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2947">Match zero or one whitespace character.</span></span>|  
|`[+*]?`|<span data-ttu-id="5f51e-2948">比對零個或一個任一個的 + 或 \* 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2948">Match zero or one occurrence of either the + or \* character.</span></span>|  
|`\s?`|<span data-ttu-id="5f51e-2949">比對零個或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2949">Match zero or one whitespace character.</span></span>|  
|`-\s`|<span data-ttu-id="5f51e-2950">比對後面接著空白字元的字元是連字號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2950">Match a hyphen followed by a whitespace character.</span></span>|  
  
### <a name="search-methods-and-the-substring-method"></a><span data-ttu-id="5f51e-2951">搜尋方法和 Substring 方法</span><span class="sxs-lookup"><span data-stu-id="5f51e-2951">Search methods and the Substring method</span></span>  
 <span data-ttu-id="5f51e-2952">如果您不想要在字串中子字串的所有項目，您可能想要使用其中一個會傳回的索引開始比對的字串比較方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2952">If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</span></span> <span data-ttu-id="5f51e-2953">您可以接著呼叫<xref:System.String.Substring%2A>方法，可擷取您想要的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2953">You can then call the <xref:System.String.Substring%2A> method to extract the substring that you want.</span></span> <span data-ttu-id="5f51e-2954">字串比較方法包括：</span><span class="sxs-lookup"><span data-stu-id="5f51e-2954">The string comparison methods include:</span></span>  
  
-   <span data-ttu-id="5f51e-2955"><xref:System.String.IndexOf%2A>它會傳回字元或字串第一次出現的以零為起始的索引中的字串執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2955"><xref:System.String.IndexOf%2A>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="5f51e-2956"><xref:System.String.IndexOfAny%2A>它會傳回目前的字串執行個體中，字元陣列中的任何字元第一次出現的以零為起始的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2956"><xref:System.String.IndexOfAny%2A>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</span></span>  
  
-   <span data-ttu-id="5f51e-2957"><xref:System.String.LastIndexOf%2A>它會傳回字元或字串最後一次出現的以零為起始的索引中的字串執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2957"><xref:System.String.LastIndexOf%2A>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="5f51e-2958"><xref:System.String.LastIndexOfAny%2A>它會傳回以零為起始的索引中目前的最後一個出現的字元陣列中的任何字元的字串執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2958"><xref:System.String.LastIndexOfAny%2A>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</span></span>  
  
 <span data-ttu-id="5f51e-2959">下列範例會使用<xref:System.String.IndexOf%2A>方法來尋找字串中的句點。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2959">The following example uses the <xref:System.String.IndexOf%2A> method to find the periods in a string.</span></span> <span data-ttu-id="5f51e-2960">然後它會使用<xref:System.String.Substring%2A>方法以傳回完整的句子。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2960">It then uses the <xref:System.String.Substring%2A> method to return full sentences.</span></span>  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
## <a name="performance-considerations"></a><span data-ttu-id="5f51e-2961">效能考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-2961">Performance Considerations</span></span>  
 <span data-ttu-id="5f51e-2962"><xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2962">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="5f51e-2963">如果您的應用程式需要最佳效能，或管理記憶體配置是關鍵應用程式中，請考慮使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2963">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method.</span></span> <span data-ttu-id="5f51e-2964">您也可以選擇使用<xref:System.String.Compare%2A>方法來找出在字串內子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2964">You also have the option of using the <xref:System.String.Compare%2A> method to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="5f51e-2965">若要分割位於分隔字元字串，請使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出字串中的分隔字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2965">To split a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="5f51e-2966">若要分割的分隔符號字串的字串，請使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出第一個字元的分隔符號字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2966">To split a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="5f51e-2967">然後使用<xref:System.String.Compare%2A>方法，以判斷是否相等的分隔符號字串的其餘字元之後的第一個字元的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2967">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="5f51e-2968">此外，如果相同設定的字元用來分割在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2968">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="5f51e-2969">這會大幅降低每個方法呼叫的額外負擔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2969">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-2970">下列範例示範如何從一個區塊的文字擷取個別文字，藉由將做為分隔符號的泛空白字元和標點符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2970">The following example demonstrates how to extract individual words from a block of text by treating white space and punctuation marks as delimiters.</span></span> <span data-ttu-id="5f51e-2971">字元陣列傳遞至`separator`參數<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法包含空格字元和定位字元，以及一些常見的標點符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2971">The character array passed to the `separator` parameter of the <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> method consists of a space character and a tab character, together with some common punctuation symbols.</span></span>  
  
 [!code-csharp[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-2972">在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和舊版中，如果<see cref="M:System.String.Split(System.Char[])" />方法傳遞<paramref name="separator" />也就是<see langword="null" />或未包含任何字元，方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪該字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2972">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="5f51e-2973">在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，這兩種方法使用一組完全相同的 Unicode 空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2973">In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</span></span></para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="5f51e-2974">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2974">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-2975">要傳回的子字串之最大數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2975">The maximum number of substrings to return.</span></span></param>
        <summary><span data-ttu-id="5f51e-2976">根據陣列中的字元分割字串成最大數目的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2976">Splits a string into a maximum number of substrings based on the characters in an array.</span></span> <span data-ttu-id="5f51e-2977">您也要指定傳回的子字串之最大數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2977">You also specify the maximum number of substrings to return.</span></span></summary>
        <returns><span data-ttu-id="5f51e-2978">陣列，其項目中包含了這個執行個體中的子字串，由 <paramref name="separator" /> 內的一或多個字元分隔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2978">An array whose elements contain the substrings in this instance that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="5f51e-2979">如需詳細資訊，請參閱＜備註＞一節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2979">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-2980">傳回陣列的項目中不包含分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2980">Delimiter characters are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="5f51e-2981">如果這個執行個體不包含任何字元`separator`，傳回的陣列包含這個執行個體的單一項目所組成。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2981">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="5f51e-2982">如果`count`為零，則傳回空陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2982">If `count` is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="5f51e-2983">如果`separator`參數是`null`未包含任何字元，或空格字元會假設為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2983">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="5f51e-2984">空白字元會由 Unicode 標準和傳回`true`如果傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2984">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="5f51e-2985">每個項目`separator`定義不同的分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2985">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="5f51e-2986">如果兩個分隔符號是相鄰的或是位於分隔符號的開頭或結尾的這個執行個體，對應的陣列元素包含<xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2986">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="5f51e-2987">如果有多個`count`子字串，在本例中，第一個`count`減 1 的子字串會傳回在第一個`count`減 1 的傳回值，而其餘字元在這個執行個體中的項目會傳回在過去傳回值的項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2987">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="5f51e-2988">如果`count`數目大於可用的子字串所傳回的子字串，並擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2988">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
 <span data-ttu-id="5f51e-2989">下表提供範例。</span><span class="sxs-lookup"><span data-stu-id="5f51e-2989">The following table provides examples.</span></span>  
  
|<span data-ttu-id="5f51e-2990">字串值</span><span class="sxs-lookup"><span data-stu-id="5f51e-2990">String value</span></span>|<span data-ttu-id="5f51e-2991">Separator</span><span class="sxs-lookup"><span data-stu-id="5f51e-2991">Separator</span></span>|<span data-ttu-id="5f51e-2992">計數</span><span class="sxs-lookup"><span data-stu-id="5f51e-2992">Count</span></span>|<span data-ttu-id="5f51e-2993">傳回的陣列</span><span class="sxs-lookup"><span data-stu-id="5f51e-2993">Returned array</span></span>|  
|------------------|---------------|-----------|--------------------|  
|<span data-ttu-id="5f51e-2994">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="5f51e-2994">"42, 12, 19"</span></span>|<span data-ttu-id="5f51e-2995">新 Char [] {'，' ' '} (C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2995">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="5f51e-2996">Char （) = {"，"c""c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-2996">Char() = {","c, " "c} (Visual Basic)</span></span>|<span data-ttu-id="5f51e-2997">2</span><span class="sxs-lookup"><span data-stu-id="5f51e-2997">2</span></span>|<span data-ttu-id="5f51e-2998">{"42", " 12, 19"}</span><span class="sxs-lookup"><span data-stu-id="5f51e-2998">{"42", " 12, 19"}</span></span>|  
|<span data-ttu-id="5f51e-2999">"42..12..19"</span><span class="sxs-lookup"><span data-stu-id="5f51e-2999">"42..12..19"</span></span>|<span data-ttu-id="5f51e-3000">新 Char [] {'。 '}</span><span class="sxs-lookup"><span data-stu-id="5f51e-3000">new Char[] {'.'}</span></span> <span data-ttu-id="5f51e-3001">(C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3001">(C#)</span></span><br /><br /> <span data-ttu-id="5f51e-3002">Char （) = {"。"c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3002">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="5f51e-3003">4</span><span class="sxs-lookup"><span data-stu-id="5f51e-3003">4</span></span>|<span data-ttu-id="5f51e-3004">{"42", "", "12", ".19"}</span><span class="sxs-lookup"><span data-stu-id="5f51e-3004">{"42", "", "12", ".19"}</span></span>|  
|<span data-ttu-id="5f51e-3005">「 Banana"</span><span class="sxs-lookup"><span data-stu-id="5f51e-3005">"Banana"</span></span>|<span data-ttu-id="5f51e-3006">新 Char [] {'。 '}</span><span class="sxs-lookup"><span data-stu-id="5f51e-3006">new Char[] {'.'}</span></span> <span data-ttu-id="5f51e-3007">(C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3007">(C#)</span></span><br /><br /> <span data-ttu-id="5f51e-3008">Char （) = {"。"c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3008">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="5f51e-3009">2</span><span class="sxs-lookup"><span data-stu-id="5f51e-3009">2</span></span>|<span data-ttu-id="5f51e-3010">{"香蕉"}</span><span class="sxs-lookup"><span data-stu-id="5f51e-3010">{"Banana"}</span></span>|  
|<span data-ttu-id="5f51e-3011">「 Darb\nSmarba 」 (C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3011">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="5f51e-3012">「 Darb"vbLf &"Smarba 」 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3012">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="5f51e-3013">新 Char [] {} (C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3013">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="5f51e-3014">Char （) = {} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3014">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="5f51e-3015">1</span><span class="sxs-lookup"><span data-stu-id="5f51e-3015">1</span></span>|<span data-ttu-id="5f51e-3016">{"Darb\nSmarba"}(C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3016">{"Darb\nSmarba"} (C#)</span></span><br /><br /> <span data-ttu-id="5f51e-3017">「 Darb"vbLf &"Smarba 」 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3017">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|  
|<span data-ttu-id="5f51e-3018">「 Darb\nSmarba 」 (C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3018">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="5f51e-3019">「 Darb"vbLf &"Smarba 」 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3019">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="5f51e-3020">新 Char [] null (C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3020">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="5f51e-3021">Char （) = Nothing</span><span class="sxs-lookup"><span data-stu-id="5f51e-3021">Char() = Nothing</span></span>|<span data-ttu-id="5f51e-3022">2</span><span class="sxs-lookup"><span data-stu-id="5f51e-3022">2</span></span>|<span data-ttu-id="5f51e-3023">{"Darb"，"Smarba"}</span><span class="sxs-lookup"><span data-stu-id="5f51e-3023">{"Darb", "Smarba"}</span></span>|  
|<span data-ttu-id="5f51e-3024">「 Darb\nSmarba 」 (C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3024">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="5f51e-3025">「 Darb"vbLf &"Smarba 」 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3025">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="5f51e-3026">新 Char [] null (C#)</span><span class="sxs-lookup"><span data-stu-id="5f51e-3026">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="5f51e-3027">Char （) = Nothing</span><span class="sxs-lookup"><span data-stu-id="5f51e-3027">Char() = Nothing</span></span>|<span data-ttu-id="5f51e-3028">100</span><span class="sxs-lookup"><span data-stu-id="5f51e-3028">100</span></span>|<span data-ttu-id="5f51e-3029">{"Darb"，"Smarba"}</span><span class="sxs-lookup"><span data-stu-id="5f51e-3029">{"Darb", "Smarba"}</span></span>|  
  
## <a name="performance-considerations"></a><span data-ttu-id="5f51e-3030">效能考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-3030">Performance Considerations</span></span>  
 <span data-ttu-id="5f51e-3031"><xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3031">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="5f51e-3032">如果您的應用程式需要最佳效能，或管理記憶體配置是關鍵應用程式中，請考慮使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出在字串內子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3032">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="5f51e-3033">如果您要分割位於分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出字串中的分隔字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3033">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="5f51e-3034">如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出第一個字元的分隔符號字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3034">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="5f51e-3035">然後使用<xref:System.String.Compare%2A>方法，以判斷是否相等的分隔符號字串的其餘字元之後的第一個字元的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3035">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="5f51e-3036">此外，如果相同設定的字元用來分割在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3036">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="5f51e-3037">這會大幅降低每個方法呼叫的額外負擔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3037">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3038">下列範例會示範如何`count`影響字串所傳回的數字<xref:System.String.Split%2A>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3038">The following example demonstrates how `count` affects the number of strings returned by <xref:System.String.Split%2A>.</span></span>  
  
 [!code-csharp[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-3039"><paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3039"><paramref name="count" /> is negative.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-3040">在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和舊版中，如果<see cref="M:System.String.Split(System.Char[])" />方法傳遞<paramref name="separator" />也就是<see langword="null" />或未包含任何字元，方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪該字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3040">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="5f51e-3041">在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，這兩種方法使用一組完全相同的 Unicode 空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3041">In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</span></span></para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="5f51e-3042">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3042">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="options">
          <span data-ttu-id="5f51e-3043"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> 表示要省略傳回陣列中的空陣列項目，否則 <see cref="F:System.StringSplitOptions.None" /> 表示要包含傳回陣列中的空陣列項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3043"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="5f51e-3044">根據陣列中的字元分割字串成子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3044">Splits a string into substrings based on the characters in an array.</span></span> <span data-ttu-id="5f51e-3045">您可以指定子字串是否包含空的陣列元素。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3045">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3046">陣列，其項目包含了這個字串中由 <paramref name="separator" /> 內的一或多個字元所分隔的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3046">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="5f51e-3047">如需詳細資訊，請參閱＜備註＞一節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3047">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a><span data-ttu-id="5f51e-3048">傳回值的詳細資料</span><span class="sxs-lookup"><span data-stu-id="5f51e-3048">Return value details</span></span>  
 <span data-ttu-id="5f51e-3049">分隔符號字元 (中的字元`separator`陣列) 不包含在傳回陣列中的項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3049">Delimiter characters (the characters in the `separator` array) are not included in the elements of the returned array.</span></span> <span data-ttu-id="5f51e-3050">例如，如果`separator`陣列包含字元"-"，目前的字串執行個體的值是"aa 位 bb-cc"方法會傳回陣列，其中包含三個項目:"aa"、"bb"和"cc"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3050">For example, if the `separator` array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="5f51e-3051">如果這個執行個體不包含任何字元`separator`，傳回的陣列包含這個執行個體的單一項目所組成。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3051">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="5f51e-3052">如果`options`參數是<xref:System.StringSplitOptions.RemoveEmptyEntries>和這個執行個體的長度為零，方法會傳回空陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3052">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>  
  
 <span data-ttu-id="5f51e-3053">每個項目`separator`定義不同的分隔符號包含單一字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3053">Each element of `separator` defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="5f51e-3054">如果`options`引數是<xref:System.StringSplitOptions.None>，和兩個分隔符號相鄰或分隔符號位於開頭或結尾的這個執行個體，對應的陣列元素包含<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3054">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-3055">比方說，如果`separator`包含兩個項目，"-"和"\_"，字串執行個體的值是"-\_aa 位\_」，和值`options`引數是<xref:System.StringSplitOptions.None>，方法會傳回字串陣列下列五個項目：</span><span class="sxs-lookup"><span data-stu-id="5f51e-3055">For example, if `separator` includes  two elements, "-" and "\_", the value of the string instance is "-\_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a string array with the following five elements:</span></span>  
  
1.  <span data-ttu-id="5f51e-3056"><xref:System.String.Empty?displayProperty=nameWithType>表示之前的空字串"-"字元位於索引 0。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3056"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" character at index 0.</span></span>  
  
2.  <span data-ttu-id="5f51e-3057"><xref:System.String.Empty?displayProperty=nameWithType>表示之間的空白字串"-"字元在索引 0 和位於索引 1 的"_"字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3057"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</span></span>  
  
3.  <span data-ttu-id="5f51e-3058">"aa"，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3058">"aa",</span></span>  
  
4.  <span data-ttu-id="5f51e-3059"><xref:System.String.Empty?displayProperty=nameWithType>代表索引 4 上的"_"字元後面接著的空字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3059"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" character at index 4.</span></span>  
  
5.  <span data-ttu-id="5f51e-3060"><xref:System.String.Empty?displayProperty=nameWithType>表示後面之空字串"-"5 索引處的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3060"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" character at index 5.</span></span>  
  
## <a name="the-separator-array"></a><span data-ttu-id="5f51e-3061">分隔陣列</span><span class="sxs-lookup"><span data-stu-id="5f51e-3061">The separator array</span></span>  
 <span data-ttu-id="5f51e-3062">如果`separator`參數是`null`未包含任何字元，或空格字元會假設為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3062">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="5f51e-3063">空白字元會由 Unicode 標準和傳回`true`如果傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3063">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="5f51e-3064">如果`separator`參數在呼叫這個方法多載是`null`，編譯器多載解析失敗時。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3064">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="5f51e-3065">若要明確地識別所呼叫的方法，您的程式碼必須指出的型別`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3065">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="5f51e-3066">下列範例顯示數種方式可明確識別這個多載。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3066">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
## <a name="comparison-details"></a><span data-ttu-id="5f51e-3067">比較詳細資料</span><span class="sxs-lookup"><span data-stu-id="5f51e-3067">Comparison details</span></span>  
 <span data-ttu-id="5f51e-3068"><xref:System.String.Split%2A>方法還會擷取一或多個中的字元會分隔這個字串中子字串`separator`參數，並傳回這些子字串做為陣列的項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3068">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="5f51e-3069"><xref:System.String.Split%2A>方法會尋找分隔符號執行比較使用區分大小寫的序數排序規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3069">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="5f51e-3070">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3070">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="5f51e-3071">效能考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-3071">Performance Considerations</span></span>  
 <span data-ttu-id="5f51e-3072"><xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3072">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="5f51e-3073">如果您的應用程式需要最佳效能，或管理記憶體配置是關鍵應用程式中，請考慮使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出在字串內子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3073">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="5f51e-3074">如果您要分割位於分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出字串中的分隔字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3074">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="5f51e-3075">如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出第一個字元的分隔符號字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3075">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="5f51e-3076">然後使用<xref:System.String.Compare%2A>方法，以判斷是否相等的分隔符號字串的其餘字元之後的第一個字元的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3076">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="5f51e-3077">此外，如果相同設定的字元用來分割在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3077">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="5f51e-3078">這會大幅降低每個方法呼叫的額外負擔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3078">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3079">下列範例會使用<xref:System.StringSplitOptions>列舉来包含或排除所產生的子字串<xref:System.String.Split%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3079">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-3080"><paramref name="options" /> 不是其中一個 <see cref="T:System.StringSplitOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3080"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-3081">在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和舊版中，如果<see cref="M:System.String.Split(System.Char[])" />方法傳遞<paramref name="separator" />也就是<see langword="null" />或未包含任何字元，方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪該字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3081">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="5f51e-3082">在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，這兩種方法使用一組完全相同的 Unicode 空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3082">In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="5f51e-3083">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3083">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="options">
          <span data-ttu-id="5f51e-3084"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> 表示要省略傳回陣列中的空陣列項目，否則 <see cref="F:System.StringSplitOptions.None" /> 表示要包含傳回陣列中的空陣列項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3084"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="5f51e-3085">根據陣列中的字串分割字串成子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3085">Splits a string into substrings based on the strings in an array.</span></span> <span data-ttu-id="5f51e-3086">您可以指定子字串是否包含空的陣列元素。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3086">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3087">陣列，其項目包含了這個字串中由 <paramref name="separator" /> 內的一或多個字串所分隔的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3087">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span></span> <span data-ttu-id="5f51e-3088">如需詳細資訊，請參閱＜備註＞一節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3088">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3089">當一組已知的字串所分隔的字串時，您可以使用<xref:System.String.Split%2A>分隔成子字串的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3089">When a string is delimited by a known set of strings, you can use the <xref:System.String.Split%2A> method to separate it into substrings.</span></span>  
  
## <a name="return-value-details"></a><span data-ttu-id="5f51e-3090">傳回值的詳細資料</span><span class="sxs-lookup"><span data-stu-id="5f51e-3090">Return value details</span></span>  
 <span data-ttu-id="5f51e-3091">傳回陣列的項目中不包含分隔符號字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3091">Delimiter strings are not included in the elements of the returned array.</span></span> <span data-ttu-id="5f51e-3092">例如，如果`separator`陣列包含字串"-"，目前的字串執行個體的值是"aa-bb cc"方法會傳回陣列，其中包含三個項目:"aa"、"bb"和"cc"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3092">For example, if the `separator` array includes the string "--" and the value of the current string instance is "aa--bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="5f51e-3093">如果這個執行個體不包含任何的字串中`separator`，傳回的陣列包含這個執行個體的單一項目所組成。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3093">If this instance does not contain any of the strings in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="5f51e-3094">如果`options`參數是<xref:System.StringSplitOptions.RemoveEmptyEntries>和這個執行個體的長度為零，方法會傳回空陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3094">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>  
  
 <span data-ttu-id="5f51e-3095">每個項目`separator`定義不同的分隔符號所組成的一或多個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3095">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="5f51e-3096">如果`options`引數是<xref:System.StringSplitOptions.None>，和兩個分隔符號相鄰或分隔符號位於開頭或結尾的這個執行個體，對應的陣列元素包含<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3096">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-3097">比方說，如果`separator`包含兩個項目，"-"和"_"、 字串執行個體的值是"-_aa-\_」，和值`options`引數是<xref:System.StringSplitOptions.None>，方法會傳回字串陣列，包含下列五個元素：</span><span class="sxs-lookup"><span data-stu-id="5f51e-3097">For example, if `separator` includes  two elements, "-" and "_", the value of the string instance is "-_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a sting array with the following five elements:</span></span>  
  
1.  <span data-ttu-id="5f51e-3098"><xref:System.String.Empty?displayProperty=nameWithType>表示之前的空字串"-"位於索引 0 的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3098"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" substring at index 0.</span></span>  
  
2.  <span data-ttu-id="5f51e-3099"><xref:System.String.Empty?displayProperty=nameWithType>表示之間的空白字串"-"在索引 0 和"_"子字串，位於索引 1 的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3099"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" substring at index 0 and the "_" substring at index 1.</span></span>  
  
3.  <span data-ttu-id="5f51e-3100">"aa"，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3100">"aa",</span></span>  
  
4.  <span data-ttu-id="5f51e-3101"><xref:System.String.Empty?displayProperty=nameWithType>表示後面"_"上的子字串索引 4 之空字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3101"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" substring at index 4.</span></span>  
  
5.  <span data-ttu-id="5f51e-3102"><xref:System.String.Empty?displayProperty=nameWithType>表示後面之空字串"-"5 索引處的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3102"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" substring at index 5.</span></span>  
  
## <a name="the-separator-array"></a><span data-ttu-id="5f51e-3103">分隔陣列</span><span class="sxs-lookup"><span data-stu-id="5f51e-3103">The separator array</span></span>  
 <span data-ttu-id="5f51e-3104">如果有任何項目中`separator`包含多個字元，將整個子字串會被視為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3104">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="5f51e-3105">例如，如果一個中的項目`separator`為"10"，請嘗試分割字串"This10is10a10string。 」</span><span class="sxs-lookup"><span data-stu-id="5f51e-3105">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="5f51e-3106">會傳回下列四個元素陣列: {"This"、"is"，"a"、"string"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3106">returns the following four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="5f51e-3107">}.</span><span class="sxs-lookup"><span data-stu-id="5f51e-3107">}.</span></span>  
  
 <span data-ttu-id="5f51e-3108">如果`separator`參數是`null`未包含任何字元，或空格字元會假設為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3108">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="5f51e-3109">空白字元會由 Unicode 標準和傳回`true`如果傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3109">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="5f51e-3110">如果`separator`參數在呼叫這個方法多載是`null`，編譯器多載解析失敗時。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3110">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="5f51e-3111">若要明確地識別所呼叫的方法，您的程式碼必須指出的型別`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3111">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="5f51e-3112">下列範例顯示數種方式可明確識別這個多載。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3112">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
## <a name="comparison-details"></a><span data-ttu-id="5f51e-3113">比較詳細資料</span><span class="sxs-lookup"><span data-stu-id="5f51e-3113">Comparison details</span></span>  
 <span data-ttu-id="5f51e-3114"><xref:System.String.Split%2A>方法還會擷取由一個或多個字串中分隔這個字串中的子字串`separator`參數，並傳回這些子字串做為陣列的項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3114">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="5f51e-3115"><xref:System.String.Split%2A>方法會尋找分隔符號執行比較使用區分大小寫的序數排序規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3115">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="5f51e-3116">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3116">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
 <span data-ttu-id="5f51e-3117"><xref:System.String.Split%2A>方法就會忽略任何項目`separator`其實`null`或空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3117">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>  
  
 <span data-ttu-id="5f51e-3118">若要避免模稜兩可的結果時中的字串`separator`共通字元<xref:System.String.Split%2A>作業從開頭到結尾的執行個體的值，並且在符合中的第一個項目`separator`等於中的分隔符號執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3118">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="5f51e-3119">基元執行個體中的子字串順序的優先順序高於中項目的順序`separator`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3119">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>  
  
 <span data-ttu-id="5f51e-3120">例如，假設其值為"abcdef"執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3120">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="5f51e-3121">如果中的第一個項目`separator`"ef"，而第二個元素是"bcde"、 split 作業的結果會是字串陣列，其中包含兩個項目，"a"和"f"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3121">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be a string array that contains two elements, "a" and "f".</span></span> <span data-ttu-id="5f51e-3122">這是因為發生的子字串中的執行個體，"bcde"，且會符合中的項目`separator`之前遇到"f"的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3122">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>  
  
 <span data-ttu-id="5f51e-3123">不過，如果第一個項目`separator`"bcd"，而第二個元素是"bc"、 split 作業的結果會是字串陣列，其中包含兩個項目，"a"和"ef"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3123">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be a string array that contains two elements, "a" and "ef".</span></span> <span data-ttu-id="5f51e-3124">這是因為"bcd"中的第一個分隔符號`separator`符合執行個體中的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3124">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="5f51e-3125">如果分隔符號的順序相反，因此第一個項目為"bc"，而第二個項目已"bcd"，結果會是字串陣列，其中包含兩個項目，"a"和"def"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3125">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be a string array that contains two elements,  "a" and "def".</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="5f51e-3126">效能考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-3126">Performance considerations</span></span>  
 <span data-ttu-id="5f51e-3127"><xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3127">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="5f51e-3128">如果您的應用程式需要最佳效能，或管理記憶體配置是關鍵應用程式中，請考慮使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出在字串內子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3128">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="5f51e-3129">如果您要分割位於分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出字串中的分隔字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3129">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="5f51e-3130">如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出第一個字元的分隔符號字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3130">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="5f51e-3131">然後使用<xref:System.String.Compare%2A>方法，以判斷是否相等的分隔符號字串的其餘字元之後的第一個字元的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3131">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="5f51e-3132">此外，如果相同設定的字元用來分割在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3132">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="5f51e-3133">這會大幅降低每個方法呼叫的額外負擔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3133">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3134">下列範例說明透過呼叫的字串所傳回陣列中的差異<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType>方法及其`options`參數等於<xref:System.StringSplitOptions.None?displayProperty=nameWithType>和<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3134">The following example illustrates the difference in the arrays returned by calling a string's <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> method with its `options` parameter equal to <xref:System.StringSplitOptions.None?displayProperty=nameWithType> and <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 <span data-ttu-id="5f51e-3135">下列範例會定義包含標點符號和空格字元的分隔符號的陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3135">The following example defines an array of separators that include punctuation and white-space characters.</span></span> <span data-ttu-id="5f51e-3136">傳遞的值以及此陣列<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>至<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>方法會傳回從字串的個別字所組成的陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3136">Passing this array along with a value of <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> to the <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> method returns an array that consists of the individual words from the string.</span></span>  
  
 [!code-csharp[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 <span data-ttu-id="5f51e-3137">請注意，方法以呼叫`options`引數設定為<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3137">Note that the method is called with the `options` argument set to <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f51e-3138">這可防止在傳回的陣列包括<xref:System.String.Empty?displayProperty=nameWithType>代表標點符號和空格字元之間的空白子字串相符的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3138">This prevents the returned array from including <xref:System.String.Empty?displayProperty=nameWithType> values that represent empty substring matches between punctuation marks and white-space characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-3139"><paramref name="options" /> 不是其中一個 <see cref="T:System.StringSplitOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3139"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-3140">在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和舊版中，如果<see cref="M:System.String.Split(System.Char[])" />方法傳遞<paramref name="separator" />也就是<see langword="null" />或未包含任何字元，方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪該字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3140">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="5f51e-3141">在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，這兩種方法使用一組完全相同的 Unicode 空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3141">In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="5f51e-3142">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3142">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-3143">要傳回的子字串之最大數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3143">The maximum number of substrings to return.</span></span></param>
        <param name="options">
          <span data-ttu-id="5f51e-3144"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> 表示要省略傳回陣列中的空陣列項目，否則 <see cref="F:System.StringSplitOptions.None" /> 表示要包含傳回陣列中的空陣列項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3144"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="5f51e-3145">根據陣列中的字元分割字串成最大數目的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3145">Splits a string into a maximum number of substrings based on the characters in an array.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3146">陣列，其項目包含了這個字串中由 <paramref name="separator" /> 內的一或多個字元所分隔的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3146">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="5f51e-3147">如需詳細資訊，請參閱＜備註＞一節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3147">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3148">傳回陣列的項目中不包含分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3148">Delimiter characters are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="5f51e-3149">如果這個執行個體不包含任何字元`separator`，或`count`參數為 1，傳回的陣列包含這個執行個體的單一項目所組成。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3149">If this instance does not contain any of the characters in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="5f51e-3150">如果`separator`參數是`null`未包含任何字元，或空格字元會假設為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3150">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="5f51e-3151">空白字元會由 Unicode 標準和傳回`true`如果傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3151">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5f51e-3152">不過，如果`separator`參數在呼叫這個方法多載是`null`，編譯器多載解析失敗時。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3152">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="5f51e-3153">若要明確地識別所呼叫的方法，您的程式碼必須指出 null 的類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3153">To unambiguously identify the called method, your code must indicate the type of the null.</span></span> <span data-ttu-id="5f51e-3154">下列範例顯示數種方式可明確識別這個多載。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3154">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 <span data-ttu-id="5f51e-3155">如果`count`參數為零，或`options`參數是<xref:System.StringSplitOptions.RemoveEmptyEntries>和這個執行個體的長度為零，則傳回空陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3155">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="5f51e-3156">每個項目`separator`定義不同的分隔符號字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3156">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="5f51e-3157">如果`options`參數是<xref:System.StringSplitOptions.None>，和兩個分隔符號相鄰或分隔符號位於開頭或結尾的這個執行個體，對應的陣列元素包含<xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3157">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="5f51e-3158">如果有多個`count`子字串，在本例中，第一個`count`減 1 的子字串會傳回在第一個`count`減 1 的傳回值，而其餘字元在這個執行個體中的項目會傳回在過去傳回值的項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3158">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="5f51e-3159">如果`count`數目大於可用的子字串所傳回的子字串，並擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3159">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="5f51e-3160">效能考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-3160">Performance Considerations</span></span>  
 <span data-ttu-id="5f51e-3161"><xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3161">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="5f51e-3162">如果您的應用程式需要最佳效能，或管理記憶體配置是關鍵應用程式中，請考慮使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出在字串內子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3162">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="5f51e-3163">如果您要分割位於分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出字串中的分隔字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3163">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="5f51e-3164">如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出第一個字元的分隔符號字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3164">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="5f51e-3165">然後使用<xref:System.String.Compare%2A>方法，以判斷是否相等的分隔符號字串的其餘字元之後的第一個字元的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3165">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="5f51e-3166">此外，如果相同設定的字元用來分割在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3166">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="5f51e-3167">這會大幅降低每個方法呼叫的額外負擔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3167">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3168">下列範例會使用<xref:System.StringSplitOptions>列舉来包含或排除所產生的子字串<xref:System.String.Split%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3168">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-3169"><paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3169"><paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-3170"><paramref name="options" /> 不是其中一個 <see cref="T:System.StringSplitOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3170"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-3171">在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和舊版中，如果<see cref="M:System.String.Split(System.Char[])" />方法傳遞<paramref name="separator" />也就是<see langword="null" />或未包含任何字元，方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪該字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3171">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="5f51e-3172">在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，這兩種方法使用一組完全相同的 Unicode 空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3172">In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="5f51e-3173">字串陣列 (可分隔這個字串中的子字串)、不含任何分隔符號的空陣列，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3173">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="5f51e-3174">要傳回的子字串之最大數目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3174">The maximum number of substrings to return.</span></span></param>
        <param name="options">
          <span data-ttu-id="5f51e-3175"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> 表示要省略傳回陣列中的空陣列項目，否則 <see cref="F:System.StringSplitOptions.None" /> 表示要包含傳回陣列中的空陣列項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3175"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="5f51e-3176">根據陣列中的字串分割字串成最大數目的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3176">Splits a string into a maximum number of substrings based on the strings in an array.</span></span> <span data-ttu-id="5f51e-3177">您可以指定子字串是否包含空的陣列元素。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3177">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3178">陣列，其項目包含了這個字串中由 <paramref name="separator" /> 內的一或多個字串所分隔的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3178">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span></span> <span data-ttu-id="5f51e-3179">如需詳細資訊，請參閱＜備註＞一節。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3179">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a><span data-ttu-id="5f51e-3180">傳回值的詳細資料</span><span class="sxs-lookup"><span data-stu-id="5f51e-3180">Return value details</span></span>  
 <span data-ttu-id="5f51e-3181">傳回陣列的項目中不包含分隔符號字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3181">Delimiter strings are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="5f51e-3182">如果這個執行個體不包含任何的字串中`separator`，或`count`參數為 1，傳回的陣列包含這個執行個體的單一項目所組成。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3182">If this instance does not contain any of the strings in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="5f51e-3183">如果`separator`參數是`null`未包含任何字元，或空格字元會假設為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3183">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="5f51e-3184">空白字元會由 Unicode 標準和傳回`true`如果傳遞至<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3184">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5f51e-3185">不過，如果`separator`參數在呼叫這個方法多載是`null`，編譯器多載解析失敗時。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3185">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="5f51e-3186">若要明確地識別所呼叫的方法，您的程式碼必須指出的型別`null`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3186">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="5f51e-3187">下列範例顯示數種方式可明確識別這個多載。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3187">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 <span data-ttu-id="5f51e-3188">如果`count`參數為零，或`options`參數是<xref:System.StringSplitOptions.RemoveEmptyEntries>和這個執行個體的長度為零，則傳回空陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3188">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="5f51e-3189">每個項目`separator`定義不同的分隔符號所組成的一或多個字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3189">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="5f51e-3190">如果`options`參數是<xref:System.StringSplitOptions.None>，和兩個分隔符號相鄰或分隔符號位於開頭或結尾的這個執行個體，對應的陣列元素包含<xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3190">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="5f51e-3191">如果有多個`count`子字串，在本例中，第一個`count`減 1 的子字串會傳回在第一個`count`減 1 的傳回值，而其餘字元在這個執行個體中的項目會傳回在過去傳回值的項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3191">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="5f51e-3192">如果`count`數目大於可用的子字串所傳回的子字串，並擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3192">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
## <a name="the-separator-array"></a><span data-ttu-id="5f51e-3193">分隔陣列</span><span class="sxs-lookup"><span data-stu-id="5f51e-3193">The separator array</span></span>  
 <span data-ttu-id="5f51e-3194">如果有任何項目中`separator`包含多個字元，將整個子字串會被視為分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3194">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="5f51e-3195">例如，如果一個中的項目`separator`為"10"，請嘗試分割字串"This10is10a10string。 」</span><span class="sxs-lookup"><span data-stu-id="5f51e-3195">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="5f51e-3196">傳回這個四個元素陣列: {"This"、"is"，"a"、"string"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3196">returns this four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="5f51e-3197">}.</span><span class="sxs-lookup"><span data-stu-id="5f51e-3197">}.</span></span>  
  
## <a name="comparison-details"></a><span data-ttu-id="5f51e-3198">比較詳細資料</span><span class="sxs-lookup"><span data-stu-id="5f51e-3198">Comparison details</span></span>  
 <span data-ttu-id="5f51e-3199"><xref:System.String.Split%2A>方法還會擷取由一個或多個字串中分隔這個字串中的子字串`separator`參數，並傳回這些子字串做為陣列的項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3199">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="5f51e-3200"><xref:System.String.Split%2A>方法會尋找分隔符號執行比較使用區分大小寫的序數排序規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3200">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="5f51e-3201">如需 word、 字串和序數排序的詳細資訊，請參閱<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3201">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
 <span data-ttu-id="5f51e-3202"><xref:System.String.Split%2A>方法就會忽略任何項目`separator`其實`null`或空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3202">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>  
  
 <span data-ttu-id="5f51e-3203">若要避免模稜兩可的結果時中的字串`separator`共通字元<xref:System.String.Split%2A>方法從開頭到結尾的執行個體的值，並且在符合中的第一個項目`separator`等於中的分隔符號執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3203">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> method proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="5f51e-3204">基元執行個體中的子字串順序的優先順序高於中項目的順序`separator`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3204">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>  
  
 <span data-ttu-id="5f51e-3205">例如，假設其值為"abcdef"執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3205">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="5f51e-3206">如果中的第一個項目`separator`"ef"，而第二個元素是"bcde"、 split 作業的結果會是"a"和"f"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3206">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f".</span></span> <span data-ttu-id="5f51e-3207">這是因為發生的子字串中的執行個體，"bcde"，且會符合中的項目`separator`之前遇到"f"的子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3207">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>  
  
 <span data-ttu-id="5f51e-3208">不過，如果第一個項目`separator`"bcd"，而第二個元素是"bc"、 split 作業的結果會是"a"和"ef"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3208">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef".</span></span> <span data-ttu-id="5f51e-3209">這是因為"bcd"中的第一個分隔符號`separator`符合執行個體中的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3209">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="5f51e-3210">如果分隔符號的順序相反，因此第一個項目為"bc"，而第二個項目已"bcd"，結果會是"a"和"def"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3210">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def".</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="5f51e-3211">效能考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-3211">Performance considerations</span></span>  
 <span data-ttu-id="5f51e-3212"><xref:System.String.Split%2A>方法傳回的陣列物件配置記憶體和<xref:System.String>每個陣列元素的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3212">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="5f51e-3213">如果您的應用程式需要最佳效能，或管理記憶體配置是關鍵應用程式中，請考慮使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法，並選擇性地<xref:System.String.Compare%2A>方法，來找出在字串內子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3213">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="5f51e-3214">如果您要分割位於分隔字元字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出字串中的分隔字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3214">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="5f51e-3215">如果您要分割的分隔符號字串的字串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法來找出第一個字元的分隔符號字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3215">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="5f51e-3216">然後使用<xref:System.String.Compare%2A>方法，以判斷是否相等的分隔符號字串的其餘字元之後的第一個字元的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3216">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="5f51e-3217">此外，如果相同設定的字元用來分割在多個字串<xref:System.String.Split%2A>方法呼叫，請考慮建立單一的陣列，並在每個方法呼叫中參考它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3217">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="5f51e-3218">這會大幅降低每個方法呼叫的額外負擔。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3218">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3219">下列範例會使用<xref:System.StringSplitOptions>列舉来包含或排除所產生的子字串<xref:System.String.Split%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3219">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-3220"><paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3220"><paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-3221"><paramref name="options" /> 不是其中一個 <see cref="T:System.StringSplitOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3221"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-3222">在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和舊版中，如果<see cref="M:System.String.Split(System.Char[])" />方法傳遞<paramref name="separator" />也就是<see langword="null" />或未包含任何字元，方法會使用稍有不同的一組字元分割字串比<see cref="M:System.String.Trim(System.Char[])" />方法會以修剪該字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3222">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="5f51e-3223">在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，這兩種方法使用一組完全相同的 Unicode 空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3223">In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</span></span></para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-3224">判斷這個字串執行個體的開頭是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3224">Determines whether the beginning of this string instance matches a specified string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-3225">要比較的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3225">The string to compare.</span></span></param>
        <summary><span data-ttu-id="5f51e-3226">判斷這個字串執行個體的開頭是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3226">Determines whether the beginning of this string instance matches the specified string.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-3227">如果 <see langword="true" /> 符合這個字串的開頭，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3227"><see langword="true" /> if <paramref name="value" /> matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3228">這個方法會比較`value`是相同的長度做為這個執行個體的開頭的子字串`value`，並傳回表示是否相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3228">This method compares `value` to the substring at the beginning of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="5f51e-3229">若要視為相等，`value`必須是空字串 (<xref:System.String.Empty?displayProperty=nameWithType>)，必須是這個相同的執行個體的參考，或是必須符合這個執行個體的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3229">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>  
  
 <span data-ttu-id="5f51e-3230">這個方法會執行使用目前文化特性的字組 （區分大小寫和區分文化特性） 比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3230">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3231">下列範例會定義`StripStartTags`方法使用<xref:System.String.StartsWith%28System.String%29>移除 HTML 方法從字串開頭開始標記。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3231">The following example defines a `StripStartTags` method that uses the <xref:System.String.StartsWith%28System.String%29> method to remove HTML start tags from the beginning of a string.</span></span> <span data-ttu-id="5f51e-3232">請注意，`StripStartTags`方法稱為遞迴運作，以確保要移除的多個 HTML 開始標記，在一行的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3232">Note that the `StripStartTags` method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed.</span></span> <span data-ttu-id="5f51e-3233">此範例不會移除內嵌在字串中的 HTML 標記。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3233">The example does not remove HTML tags embedded in a string.</span></span>  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-3234"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3234"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-3235">中所述[使用字串的最佳作法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串比較方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3235">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="5f51e-3236">若要判斷是否字串開頭為特定的子字串使用目前文化特性的字串比較規則，請呼叫<see cref="M:System.String.StartsWith(System.String,System.StringComparison)" />方法多載，其值為<see cref="F:System.StringComparison.CurrentCulture" />針對其<paramref name="comparisonType" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3236">To determine whether a string begins with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-3237">要比較的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3237">The string to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="5f51e-3238">列舉值之一，指定這個字串和 <c>value</c> 的比較方式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3238">One of the enumeration values that determines how this string and <c>value</c> are compared.</span></span></param>
        <summary><span data-ttu-id="5f51e-3239">判斷當使用指定之比較選項進行比較時，這個字串執行個體的開頭是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3239">Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-3240">如果這個執行個體以 <see langword="true" /> 為開頭，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3240"><see langword="true" /> if this instance begins with <paramref name="value" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3241"><xref:System.String.StartsWith%2A>方法會比較`value`在這個字串的開頭的子字串的參數和傳回值，指出它們是否相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3241">The <xref:System.String.StartsWith%2A> method compares the `value` parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="5f51e-3242">若要視為相等，`value`必須是相同的字串的參考，必須是空字串 ("")，或必須符合這個字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3242">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the beginning of this string.</span></span> <span data-ttu-id="5f51e-3243">所執行的比較類型<xref:System.String.StartsWith%2A>方法取決於值`comparisonType`參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3243">The type of comparison performed by the <xref:System.String.StartsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span> <span data-ttu-id="5f51e-3244">比較可以使用目前文化特性的慣例 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>和<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) 或文化特性而異 (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>和<xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>)，或者也可以包含字碼指標的逐字元比較 (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="5f51e-3244">The comparison can use the conventions of the current culture (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> and <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) or the invariant culture (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> and <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), or it can consist of a character-by-character comparison of code points (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span> <span data-ttu-id="5f51e-3245">比較也可以是區分大小寫 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>， <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>，或<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>)，或它可以忽略大小寫 (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>， <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>， <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3245">The comparison can also be case-sensitive (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, or <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), or it can ignore case (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3246">下列範例會搜尋字串"the"開頭字較長字串的開頭"The"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3246">The following example searches for the string "the" at the beginning of a longer string that begins with the word "The".</span></span> <span data-ttu-id="5f51e-3247">從範例所示，呼叫輸出<xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29>方法，執行區分大小寫，但不區分文化特性的比較時，無法比對字串中，而執行的文化特性和 case insensitive 比較的呼叫會比對字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3247">As the output from the example shows, a call to the <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> method that performs a culture-insensitive but case-sensitive comparison fails to match the string, while a call that performs a culture- and case-insensitive comparison matches the string.</span></span>  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 <span data-ttu-id="5f51e-3248">下列範例會判斷字串是否以特定的子字串開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3248">The following example determines whether a string starts with a particular substring.</span></span> <span data-ttu-id="5f51e-3249">它會初始化二維的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3249">It initializes a two-dimensional string array.</span></span> <span data-ttu-id="5f51e-3250">第二個維度中的第一個項目包含字串，而第二個元素包含要搜尋的第一個字串的開頭的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3250">The first element in the second dimension contains a string, and the second element contains the string to search for at the start of the first string.</span></span> <span data-ttu-id="5f51e-3251">文化特性、 是否忽略大小寫，以及是否執行序數比較的選擇會影響結果。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3251">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span> <span data-ttu-id="5f51e-3252">請注意，當字串執行個體包含連字，其連續字元的區分文化特性的比較成功比對。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3252">Note that when the string instance contains a ligature, culture-sensitive comparisons with its consecutive characters successfully match.</span></span>  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-3253"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3253"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="5f51e-3254"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3254"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5f51e-3255">要比較的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3255">The string to compare.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="5f51e-3256"><see langword="true" /> 表示在比較時忽略大小寫，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3256"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="5f51e-3257">判斷如何比較此字串和 <c>value</c> 的文化特性資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3257">Cultural information that determines how this string and <c>value</c> are compared.</span></span> <span data-ttu-id="5f51e-3258">如果 <c>culture</c> 是 <see langword="null" />，則會使用目前的文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3258">If <c>culture</c> is <see langword="null" />, the current culture is used.</span></span></param>
        <summary><span data-ttu-id="5f51e-3259">判斷當使用指定之文化特性進行比較時，這個字串執行個體的開頭是否符合指定的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3259">Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-3260">如果 <see langword="true" /> 參數符合這個字串的開頭，則為 <paramref name="value" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3260"><see langword="true" /> if the <paramref name="value" /> parameter matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3261">這個方法會比較`value`參數在此與相同長度的字串開頭的子字串`value`，並傳回值，指出它們是否相等。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3261">This method compares the `value` parameter to the substring at the beginning of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="5f51e-3262">若要視為相等，`value`必須是空字串 (<xref:System.String.Empty?displayProperty=nameWithType>)，必須是這個相同的執行個體的參考，或是必須符合這個執行個體的開頭。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3262">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>  
  
 <span data-ttu-id="5f51e-3263">這個方法會執行使用指定的大小寫和文化特性的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3263">This method performs a comparison using the specified casing and culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3264">下列範例會判斷字串是否會在另一個字串的開頭發生。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3264">The following example determines whether a string occurs at the beginning of another string.</span></span> <span data-ttu-id="5f51e-3265"><xref:System.String.StartsWith%2A>幾次使用區分大小寫、 不區分大小寫和不同的文化特性會影響搜尋的結果呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3265">The <xref:System.String.StartsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-3266"><paramref name="value" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3266"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-3267">從這個執行個體擷取子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3267">Retrieves a substring from this instance.</span></span>  
  
 <span data-ttu-id="5f51e-3268">這個成員是多載的。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3268">This member is overloaded.</span></span> <span data-ttu-id="5f51e-3269">如需這個成員的完整資訊，包含語法、使用方式和範例，請按一下多載清單中的名稱。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3269">For complete information about this member, including syntax, usage, and examples, click a name in the overload list.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="5f51e-3270">這個執行個體中子字串之以零為起始的起始字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3270">The zero-based starting character position of a substring in this instance.</span></span></param>
        <summary><span data-ttu-id="5f51e-3271">從這個執行個體擷取子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3271">Retrieves a substring from this instance.</span></span> <span data-ttu-id="5f51e-3272">子字串會在指定的字元位置開始並繼續到字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3272">The substring starts at a specified character position and continues to the end of the string.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3273">與這個執行個體中從 <paramref name="startIndex" /> 開始之子字串相等的字串；如果 <see cref="F:System.String.Empty" /> 等於這個執行個體的長度，則為 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3273">A string that is equivalent to the substring that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3274">您呼叫<xref:System.String.Substring%2A>方法，以從指定的字元位置開始，且字串的結尾當做結尾的字串擷取子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3274">You call the <xref:System.String.Substring%2A> method to extract a substring from a string that begins at a specified character position and ends at the end of the string.</span></span> <span data-ttu-id="5f51e-3275">起始字元的位置以零為起始。換句話說，在字串中的第一個字元是在索引 0，索引 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3275">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="5f51e-3276">若要擷取的子字串，指定的字元位置開始並以字串的結尾結束之前，請呼叫<xref:System.String.Substring%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3276">To extract a substring that begins at a specified character position and ends before to the end of the string, call the <xref:System.String.Substring%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-3277">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3277">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-3278">相反地，它會傳回新字串，起點`startIndex`目前字串中的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3278">Instead, it returns a new string that begins at the `startIndex` position in the current string.</span></span>  
  
 <span data-ttu-id="5f51e-3279">若要擷取特定字元或字元序列的開頭的子字串，呼叫的方法如<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOf%2A>取得的值`startIndex`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3279">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> to get the value of `startIndex`.</span></span> <span data-ttu-id="5f51e-3280">第二個範例將說明這點。它會擷取一個字元位置開始"="字元後面的金鑰值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3280">The second example illustrates this; it extracts a key value that begins one character position after the "=" character.</span></span>  
  
 <span data-ttu-id="5f51e-3281">如果`startIndex`等於零，則方法會傳回原始字串不變。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3281">If `startIndex` is equal to zero, the method returns the original string unchanged.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3282">下列範例會示範從字串取得子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3282">The following example demonstrates obtaining a substring from a string.</span></span>  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 <span data-ttu-id="5f51e-3283">下列範例會使用<xref:System.String.Substring%2A>方法，以不同的以等號分隔的索引鍵/值配對 （"="） 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3283">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <span data-ttu-id="5f51e-3284"><xref:System.String.IndexOf%2A>方法用來取得等字元的字串中的位置...</span><span class="sxs-lookup"><span data-stu-id="5f51e-3284">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string..</span></span> <span data-ttu-id="5f51e-3285">若要呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法還會擷取索引鍵名稱。，它會從字串中的第一個字元開始，並延伸來呼叫所傳回的字元數個<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3285">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="5f51e-3286">若要呼叫<xref:System.String.Substring%28System.Int32%29>方法接著會擷取指定的索引鍵的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3286">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="5f51e-3287">它會從一個等號字元後面的字元位置，並延伸到字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3287">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-3288"><paramref name="startIndex" /> 小於零或大於此執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3288"><paramref name="startIndex" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="5f51e-3289">這個執行個體中子字串之以零為起始的起始字元位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3289">The zero-based starting character position of a substring in this instance.</span></span></param>
        <param name="length"><span data-ttu-id="5f51e-3290">子字串中的字元數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3290">The number of characters in the substring.</span></span></param>
        <summary><span data-ttu-id="5f51e-3291">從這個執行個體擷取子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3291">Retrieves a substring from this instance.</span></span> <span data-ttu-id="5f51e-3292">子字串起始於指定的字元位置，並且具有指定的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3292">The substring starts at a specified character position and has a specified length.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3293">與長度為 <paramref name="length" /> 且在這個執行個體中從 <paramref name="startIndex" /> 開始之子字串相等的字串；如果 <see cref="F:System.String.Empty" /> 等於這個執行個體的長度且 <paramref name="startIndex" /> 為零，則為 <paramref name="length" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3293">A string that is equivalent to the substring of length <paramref name="length" /> that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance and <paramref name="length" /> is zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3294">您呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法，以從指定的字元位置開始，且字串的結尾之前結束的字串擷取子字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3294">You call the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method to extract a substring from a string that begins at a specified character position and ends before the end of the string.</span></span> <span data-ttu-id="5f51e-3295">起始字元的位置以零為起始。換句話說，在字串中的第一個字元是在索引 0，索引 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3295">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="5f51e-3296">若要擷取的子字串，指定的字元位置開始並繼續到字串的結尾，呼叫<xref:System.String.Substring%28System.Int32%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3296">To extract a substring that begins at a specified character position and continues to the end of the string, call the <xref:System.String.Substring%28System.Int32%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-3297">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3297">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-3298">相反地，它會傳回新字串，`length`起的字元`startIndex`目前字串中的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3298">Instead, it returns a new string with `length` characters starting from the `startIndex` position in the current string.</span></span>  
  
 <span data-ttu-id="5f51e-3299">`length`參數代表要從目前的字串執行個體中擷取的字元總數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3299">The `length` parameter represents the total number of characters to extract from the current string instance.</span></span> <span data-ttu-id="5f51e-3300">這包括起始字元的索引，請參閱`startIndex`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3300">This includes the starting character found at index  `startIndex`.</span></span>  <span data-ttu-id="5f51e-3301">換句話說，<xref:System.String.Substring%2A>方法會嘗試從索引擷取字元`startIndex`索引`startIndex`  +  `length` -1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3301">In other words, the <xref:System.String.Substring%2A> method attempts to extract characters from index `startIndex` to index `startIndex` + `length` - 1.</span></span>  
  
 <span data-ttu-id="5f51e-3302">若要擷取特定字元或字元序列的開頭的子字串，呼叫的方法如<xref:System.String.IndexOf%2A>或<xref:System.String.LastIndexOf%2A>取得的值`startIndex`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3302">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the value of `startIndex`.</span></span>  
  
 <span data-ttu-id="5f51e-3303">如果從子字串開始`startIndex`在指定的字元順序，您可以呼叫方法例如<xref:System.String.IndexOf%2A>或<xref:System.String.LastIndexOf%2A>取得結束的字元或字元序列的索引。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3303">If the substring extends from `startIndex` to a specified character sequence, you can call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the index of the ending character or character sequence.</span></span>  <span data-ttu-id="5f51e-3304">您可以再將該值轉換成字串中的索引位置，如下所示：</span><span class="sxs-lookup"><span data-stu-id="5f51e-3304">You can then convert that value to an index position in the string as follows:</span></span>  
  
-   <span data-ttu-id="5f51e-3305">如果您要標記的子字串結尾的單一字元搜尋過`length`參數等於`endIndex`  -  `startIndex` + 1，其中`endIndex`是傳回值的<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3305">If you've searched for a single character that is to mark the end of the substring, the `length` parameter equals  `endIndex` - `startIndex` + 1, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="5f51e-3306">下列範例會從字串擷取"b"字元的連續的區塊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3306">The following example extracts a continuous block of "b" characters from a string.</span></span>  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   <span data-ttu-id="5f51e-3307">如果您要標記的子字串結尾的多個字元的搜尋過`length`參數等於`endIndex`  +  `endMatchLength`  -  `startIndex`，其中`endIndex`的傳回值<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOf%2A>方法。 和`endMatchLength`標記結尾的子字串的字元序列的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3307">If you've searched for multiple characters that are to mark the end of the substring, the `length` parameter equals  `endIndex` + `endMatchLength` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method., and `endMatchLength` is the length of the character sequence that marks the end of the substring.</span></span> <span data-ttu-id="5f51e-3308">下列範例會擷取包含 XML 的文字區塊`<definition>`項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3308">The following example extracts a block of text that contains an XML `<definition>` element.</span></span>  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   <span data-ttu-id="5f51e-3309">如果字元或字元序列未包含在子字串的結尾`length`參數等於`endIndex`  -  `startIndex`，其中`endIndex`是傳回值的<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3309">If the character or character sequence is not included in the end of the substring, the `length` parameter equals `endIndex` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span>  
  
 <span data-ttu-id="5f51e-3310">如果`startIndex`等於零和字串的長度目前，此方法傳回未變更的原始字串的等號。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3310">If `startIndex` is equal to zero and  equals the length of the current string, the method returns the original string unchanged.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3311">下列範例說明簡單呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>從字串的第六個的字元位置開始擷取兩個字元的方法 （也就是在索引 5）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3311">The following example illustrates a simple call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method that extracts two characters from a string starting at the sixth character position (that is, at index five).</span></span>  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 <span data-ttu-id="5f51e-3312">下列範例會使用<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>在下列三個情況下，若要找出在字串內子字串的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3312">The following example uses the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method in the following three cases to isolate substrings within a string.</span></span> <span data-ttu-id="5f51e-3313">在兩個情況下之子字串會用來比較，並在第三個情況下擲回例外狀況因為指定的參數無效。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3313">In two cases the substrings are used in comparisons, and in the third case an exception is thrown because invalid parameters are specified.</span></span>  
  
-   <span data-ttu-id="5f51e-3314">它會擷取單一字元和字串 （位於索引 2） 中的第三個位置，並比較它與"c"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3314">It extracts the single character and the third position in the string (at index 2) and compares it with a "c".</span></span> <span data-ttu-id="5f51e-3315">這項比較會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3315">This comparison returns `true`.</span></span>  
  
-   <span data-ttu-id="5f51e-3316">它會擷取的第四個位置中 （位於索引 3） 的字串開頭的零個字元，並將其傳遞給<xref:System.String.IsNullOrEmpty%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3316">It extracts zero characters starting at the fourth position in the string (at index 3) and passes it to the <xref:System.String.IsNullOrEmpty%2A> method.</span></span> <span data-ttu-id="5f51e-3317">這個傳回 true，因為呼叫<xref:System.String.Substring%2A>方法會傳回<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3317">This returns true because the call to the <xref:System.String.Substring%2A> method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="5f51e-3318">它會嘗試擷取一個字元字串中第四個位置開始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3318">It attempts to extract one character starting at the fourth position in the string.</span></span> <span data-ttu-id="5f51e-3319">因為沒有在該位置的字元，方法呼叫會擲回<xref:System.ArgumentOutOfRangeException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3319">Because there is no character at that position, the method call throws an <xref:System.ArgumentOutOfRangeException> exception.</span></span>  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 <span data-ttu-id="5f51e-3320">下列範例會使用<xref:System.String.Substring%2A>方法，以不同的以等號分隔的索引鍵/值配對 （"="） 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3320">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <span data-ttu-id="5f51e-3321"><xref:System.String.IndexOf%2A>方法用來取得等字元的字串中的位置...</span><span class="sxs-lookup"><span data-stu-id="5f51e-3321">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string..</span></span> <span data-ttu-id="5f51e-3322">若要呼叫<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法還會擷取索引鍵名稱。，它會從字串中的第一個字元開始，並延伸來呼叫所傳回的字元數個<xref:System.String.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3322">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="5f51e-3323">若要呼叫<xref:System.String.Substring%28System.Int32%29>方法接著會擷取指定的索引鍵的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3323">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="5f51e-3324">它會從一個等號字元後面的字元位置，並延伸到字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3324">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-3325"><paramref name="startIndex" /> 加上 <paramref name="length" /> 表示不在此執行個體中的位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3325"><paramref name="startIndex" /> plus <paramref name="length" /> indicates a position not within this instance.</span></span>  
  
 <span data-ttu-id="5f51e-3326">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-3326">-or-</span></span>  
  
 <span data-ttu-id="5f51e-3327"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3327"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span></exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-3328">傳回列舉值，可逐一查看目前的 <see cref="T:System.String" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3328">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3329">強型別列舉值，可用來逐一查看目前的 <see cref="T:System.String" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3329">A strongly-typed enumerator that can be used to iterate through the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3330">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3330">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3331">它可用時，才<xref:System.String>執行個體轉換成<xref:System.Collections.Generic.IEnumerable%601>介面物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3331">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.Generic.IEnumerable%601> interface object.</span></span> <span data-ttu-id="5f51e-3332">如需詳細資訊，請參閱 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3332">For more information, see the <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-3333">傳回列舉值，可逐一查看目前的 <see cref="T:System.String" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3333">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3334">可用來逐一查看目前字串的列舉程式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3334">An enumerator that can be used to iterate through the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3335">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3335">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3336">只有在 <xref:System.String> 執行個體轉換成 <xref:System.Collections.IEnumerable> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3336">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.IEnumerable> interface.</span></span> <span data-ttu-id="5f51e-3337">如需詳細資訊，請參閱 <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3337">For more information, see the <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3338">這個參數已忽略。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3338">This parameter is ignored.</span></span></param>
        <summary><span data-ttu-id="5f51e-3339">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3339">For a description of this member, see <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</span></span></summary>
        <returns>
          <span data-ttu-id="5f51e-3340">如果目前字串的值為 <see langword="true" />，則為 <see cref="F:System.Boolean.TrueString" />；如果目前字串的值為 <see langword="false" />，則為 <see cref="F:System.Boolean.FalseString" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3340"><see langword="true" /> if the value of the current string is <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> if the value of the current string is <see cref="F:System.Boolean.FalseString" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3341">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3341">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3342">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3342">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3343">建議的替代方式是呼叫<xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3343">The recommended alternative is to call the <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="5f51e-3344">目前字串的值不是 <see cref="F:System.Boolean.TrueString" /> 或 <see cref="F:System.Boolean.FalseString" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3344">The value of the current string is not <see cref="F:System.Boolean.TrueString" /> or <see cref="F:System.Boolean.FalseString" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3345">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3345">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3346">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3346">For a description of this member, see <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3347">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3347">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3348">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3348">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3349">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3349">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3350">建議的替代方式是呼叫<xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3350">The recommended alternative is to call the <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="5f51e-3351">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3351">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="5f51e-3352">目前 <see cref="T:System.String" /> 物件的值為大於 <see cref="F:System.Byte.MaxValue" /> 或小於 <see cref="F:System.Byte.MinValue" /> 的數字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3352">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Byte.MaxValue" /> or less than <see cref="F:System.Byte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3353">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3353">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3354">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3354">For a description of this member, see <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3355">目前 <see cref="T:System.String" /> 物件中位於索引 0 的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3355">The character at index 0 in the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3356">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3356">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3357">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3357">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3358">建議的替代方式是呼叫<xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3358">The recommended alternative is to call the <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3359">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3359">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3360">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3360">For a description of this member, see <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3361">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3361">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3362">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3362">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3363">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3363">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3364">建議的替代方式是呼叫<xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3364">The recommended alternative is to call the <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3365">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3365">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3366">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3366">For a description of this member, see <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3367">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3367">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3368">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3368">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3369">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3369">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3370">建議的替代方式是呼叫<xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3370">The recommended alternative is to call the <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="5f51e-3371">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3371">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="5f51e-3372">目前 <see cref="T:System.String" /> 物件的值為小於 <see cref="F:System.Decimal.MinValue" /> 或大於 <see cref="F:System.Decimal.MaxValue" /> 的數字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3372">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Decimal.MinValue" /> or than <see cref="F:System.Decimal.MaxValue" /> greater.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3373">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3373">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3374">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3374">For a description of this member, see <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3375">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3375">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3376">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3376">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3377">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3377">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3378">建議的替代方式是呼叫<xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3378">The recommended alternative is to call the <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="5f51e-3379">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3379">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="5f51e-3380">目前 <see cref="T:System.String" /> 物件的值為小於 <see cref="F:System.Double.MinValue" /> 或大於 <see cref="F:System.Double.MaxValue" /> 的數字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3380">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Double.MinValue" /> or greater than <see cref="F:System.Double.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3381">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3381">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3382">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3382">For a description of this member, see <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3383">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3383">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3384">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3384">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3385">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3385">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3386">建議的替代方式是呼叫<xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3386">The recommended alternative is to call the <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="5f51e-3387">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3387">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="5f51e-3388">目前 <see cref="T:System.String" /> 物件的值為大於 <see cref="F:System.Int16.MaxValue" /> 或小於 <see cref="F:System.Int16.MinValue" /> 的數字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3388">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Int16.MaxValue" /> or less than <see cref="F:System.Int16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3389">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3389">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3390">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3390">For a description of this member, see <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3391">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3391">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3392">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3392">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3393">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3393">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3394">建議的替代方式是呼叫<xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3394">The recommended alternative is to call the <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3395">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3395">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3396">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3396">For a description of this member, see <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3397">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3397">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3398">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3398">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3399">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3399">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3400">建議的替代方式是呼叫<xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3400">The recommended alternative is to call the <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3401">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3401">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3402">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3402">For a description of this member, see <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3403">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3403">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3404">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3404">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3405">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3405">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3406">建議的替代方式是呼叫<xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3406">The recommended alternative is to call the <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="5f51e-3407">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3407">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="5f51e-3408">目前 <see cref="T:System.String" /> 物件的值為大於 <see cref="F:System.SByte.MaxValue" /> 或小於 <see cref="F:System.SByte.MinValue" /> 的數字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3408">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.SByte.MaxValue" /> or less than <see cref="F:System.SByte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3409">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3409">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3410">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3410">For a description of this member, see <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3411">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3411">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3412">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3412">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3413">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3413">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3414">建議的替代方式是呼叫<xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3414">The recommended alternative is to call the <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="5f51e-3415">傳回的物件之類型。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3415">The type of the returned object.</span></span></param>
        <param name="provider"><span data-ttu-id="5f51e-3416">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3416">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3417">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3417">For a description of this member, see <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3418">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3418">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3419">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3419">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3420">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3420">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3421">建議的替代方式是呼叫<xref:System.Convert.ChangeType%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3421">The recommended alternative is to call the <xref:System.Convert.ChangeType%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-3422"><paramref name="type" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3422"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="5f51e-3423">目前 <see cref="T:System.String" /> 物件的值不能轉換為 <paramref name="type" /> 參數指定的型別。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3423">The value of the current <see cref="T:System.String" /> object cannot be converted to the type specified by the <paramref name="type" /> parameter.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3424">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3424">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3425">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3425">For a description of this member, see <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3426">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3426">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3427">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3427">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3428">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3428">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3429">建議的替代方式是呼叫<xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3429">The recommended alternative is to call the <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="5f51e-3430">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3430">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="5f51e-3431">目前 <see cref="T:System.String" /> 物件的值為大於 <see cref="F:System.UInt16.MaxValue" /> 或小於 <see cref="F:System.UInt16.MinValue" /> 的數字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3431">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.UInt16.MaxValue" /> or less than <see cref="F:System.UInt16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3432">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3432">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3433">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3433">For a description of this member, see <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3434">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3434">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3435">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3435">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3436">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3436">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3437">建議的替代方式是呼叫<xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3437">The recommended alternative is to call the <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="5f51e-3438">無法剖析目前 <see cref="T:System.String" /> 物件的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3438">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="5f51e-3439">目前 <see cref="T:System.String" /> 物件的值為大於 <see cref="F:System.UInt32.MaxValue" /> 或小於 <see cref="F:System.UInt32.MinValue" /> 的數字。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3439">The value of the current <see cref="T:System.String" /> object is a number greater <see cref="F:System.UInt32.MaxValue" /> or less than <see cref="F:System.UInt32.MinValue" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3440">物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3440">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3441">如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3441">For a description of this member, see <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3442">目前 <see cref="T:System.String" /> 物件的轉換值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3442">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3443">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="5f51e-3443">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5f51e-3444">只有在 <xref:System.String> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3444">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="5f51e-3445">建議的替代方式是呼叫<xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3445">The recommended alternative is to call the <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-3446">將這個執行個體中的字元複製到 Unicode 字元陣列中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3446">Copies the characters in this instance to a Unicode character array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-3447">將這個執行個體中的字元複製到 Unicode 字元陣列中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3447">Copies the characters in this instance to a Unicode character array.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3448">Unicode 字元陣列，其項目是這個執行個體的個別字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3448">A Unicode character array whose elements are the individual characters of this instance.</span></span> <span data-ttu-id="5f51e-3449">如果這個執行個體是空字串，則傳回的陣列會是空的且長度為零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3449">If this instance is an empty string, the returned array is empty and has a zero length.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3450">這個方法會複製每個字元 (亦即，每個<xref:System.Char>物件) 中的字元陣列的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3450">This method copies each character (that is, each <xref:System.Char> object) in a string to a character array.</span></span> <span data-ttu-id="5f51e-3451">複製的第一個字元是索引位置為零的傳回的字元陣列。複製的最後一個字元是在索引<xref:System.Array.Length%2A?displayProperty=nameWithType>– 1。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3451">The first character copied is at index zero of the returned character array; the last character copied is at index <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1.</span></span>  
  
 <span data-ttu-id="5f51e-3452">若要建立字元陣列中的字元字串，呼叫<xref:System.String.%23ctor%28System.Char%5B%5D%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3452">To create a string from the characters in a character array, call the <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor.</span></span>  
  
 <span data-ttu-id="5f51e-3453">若要建立包含編碼的字元在字串中的位元組陣列，產生適當<xref:System.Text.Encoding>物件並呼叫其<xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3453">To create a byte array that contains the encoded characters in a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5f51e-3454">.NET Framework 中可用之標準編碼包括下列：</span><span class="sxs-lookup"><span data-stu-id="5f51e-3454">Some of the standard encodings available in the .NET Framework include the following:</span></span>  
  
|<span data-ttu-id="5f51e-3455">編碼</span><span class="sxs-lookup"><span data-stu-id="5f51e-3455">Encoding</span></span>|<span data-ttu-id="5f51e-3456">Object</span><span class="sxs-lookup"><span data-stu-id="5f51e-3456">Object</span></span>|  
|--------------|------------|  
|<span data-ttu-id="5f51e-3457">ASCII</span><span class="sxs-lookup"><span data-stu-id="5f51e-3457">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|  
|<span data-ttu-id="5f51e-3458">UTF-7</span><span class="sxs-lookup"><span data-stu-id="5f51e-3458">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|  
|<span data-ttu-id="5f51e-3459">UTF-8</span><span class="sxs-lookup"><span data-stu-id="5f51e-3459">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|  
|<span data-ttu-id="5f51e-3460">UTF-16</span><span class="sxs-lookup"><span data-stu-id="5f51e-3460">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|  
|<span data-ttu-id="5f51e-3461">UTF-32</span><span class="sxs-lookup"><span data-stu-id="5f51e-3461">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|  
  
 <span data-ttu-id="5f51e-3462">如需詳細資訊，請參閱[字元編碼方式在.NET Framework](~/docs/standard/base-types/character-encoding.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3462">For more information, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3463">下列範例會呼叫<xref:System.String.ToCharArray%2A>方法來擷取字元的字元陣列的字串中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3463">The following example calls the <xref:System.String.ToCharArray%2A> method to extract the characters in a string to a character array.</span></span> <span data-ttu-id="5f51e-3464">接著會顯示原始的字串和項目陣列中。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3464">It then displays the original string and the elements in the array.</span></span>  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 <span data-ttu-id="5f51e-3465">下列範例會定義包含做為分隔符號分隔的字串中字元的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3465">The following example defines a string containing the characters that serve as delimiters in a delimited string.</span></span> <span data-ttu-id="5f51e-3466">然後它會呼叫<xref:System.String.ToCharArray%2A>方法來建立可以傳遞至字元陣列<xref:System.String.Split%28System.Char%5B%5D%29>來分隔的字串分隔成其個別的子字串的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3466">It then calls the <xref:System.String.ToCharArray%2A> method to create a character array that can be passed to the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate the delimited string into its individual substrings.</span></span>  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="5f51e-3467">這個執行個體中的子字串開始位置。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3467">The starting position of a substring in this instance.</span></span></param>
        <param name="length"><span data-ttu-id="5f51e-3468">這個執行個體中的子字串長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3468">The length of the substring in this instance.</span></span></param>
        <summary><span data-ttu-id="5f51e-3469">將這個執行個體的指定子字串字元複製到 Unicode 字元陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3469">Copies the characters in a specified substring in this instance to a Unicode character array.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3470">Unicode 字元陣列，其項目是從 <paramref name="length" /> 字元位置起始的這個執行個體中的 <paramref name="startIndex" /> 字元數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3470">A Unicode character array whose elements are the <paramref name="length" /> number of characters in this instance starting from character position <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3471">這個方法將部份字串字元複製的字元陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3471">This method copies the characters in a portion of a string to a character array.</span></span> <span data-ttu-id="5f51e-3472">若要建立一個範圍的字元陣列中的字元字串，呼叫<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3472">To create a string from a range of characters in a character array, call the  <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span>  
  
 <span data-ttu-id="5f51e-3473">`startIndex`參數以零為起始。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3473">The `startIndex` parameter is zero-based.</span></span> <span data-ttu-id="5f51e-3474">也就是索引的第一個字元的字串執行個體是零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3474">That is, the index of the first character in the string instance is zero.</span></span>  
  
 <span data-ttu-id="5f51e-3475">如果`length`為零，傳回的陣列是空的且長度為零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3475">If `length` is zero, the returned array is empty and has a zero length.</span></span> <span data-ttu-id="5f51e-3476">如果這個執行個體`null`或空字串 ("")，則傳回的陣列是空的且長度為零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3476">If this instance is `null` or an empty string (""), the returned array is empty and has a zero length.</span></span>  
  
 <span data-ttu-id="5f51e-3477">若要建立包含編碼的字元字串的部分位元組陣列，產生適當<xref:System.Text.Encoding>物件並呼叫其<xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3477">To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="5f51e-3478">.NET Framework 中可用之標準編碼包括下列：</span><span class="sxs-lookup"><span data-stu-id="5f51e-3478">Some of the standard encodings available in the .NET Framework include the following:</span></span>  
  
|<span data-ttu-id="5f51e-3479">編碼</span><span class="sxs-lookup"><span data-stu-id="5f51e-3479">Encoding</span></span>|<span data-ttu-id="5f51e-3480">Object</span><span class="sxs-lookup"><span data-stu-id="5f51e-3480">Object</span></span>|  
|--------------|------------|  
|<span data-ttu-id="5f51e-3481">ASCII</span><span class="sxs-lookup"><span data-stu-id="5f51e-3481">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|  
|<span data-ttu-id="5f51e-3482">UTF-7</span><span class="sxs-lookup"><span data-stu-id="5f51e-3482">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|  
|<span data-ttu-id="5f51e-3483">UTF-8</span><span class="sxs-lookup"><span data-stu-id="5f51e-3483">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|  
|<span data-ttu-id="5f51e-3484">UTF-16</span><span class="sxs-lookup"><span data-stu-id="5f51e-3484">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|  
|<span data-ttu-id="5f51e-3485">UTF-32</span><span class="sxs-lookup"><span data-stu-id="5f51e-3485">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|  
  
 <span data-ttu-id="5f51e-3486">如需詳細資訊，請參閱[字元編碼方式在.NET Framework](~/docs/standard/base-types/character-encoding.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3486">For more information, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3487">下列範例將字串內子字串轉換成陣列的字元，則列舉，並顯示陣列的項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3487">The following example converts a substring within a string to an array of characters, then enumerates and displays the elements of the array.</span></span>  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="5f51e-3488"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3488"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>  
  
 <span data-ttu-id="5f51e-3489">-或-</span><span class="sxs-lookup"><span data-stu-id="5f51e-3489">-or-</span></span>  
  
 <span data-ttu-id="5f51e-3490"><paramref name="startIndex" /> 加上 <paramref name="length" /> 大於這個執行個體的長度。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3490"><paramref name="startIndex" /> plus <paramref name="length" /> is greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-3491">傳回此字串轉換為小寫的版本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3491">Returns a copy of this string converted to lowercase.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-3492">傳回此字串轉換為小寫的版本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3492">Returns a copy of this string converted to lowercase.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3493">小寫的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3493">A string in lowercase.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3494">這個方法會考量目前的文化特性的大小寫規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3494">This method takes into account the casing rules of the current culture.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-3495">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3495">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-3496">相反地，它會傳回新的目前執行個體中的所有字元都轉換成小寫的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3496">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="5f51e-3497">安全性考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-3497">Security Considerations</span></span>  
 <span data-ttu-id="5f51e-3498">呼叫結果大小寫作業<xref:System.String.ToLower>方法會考量目前的文化特性的大小寫慣例。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3498">The casing operation that results from calling the <xref:System.String.ToLower> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="5f51e-3499">如果您需要的作業系統識別碼，例如檔案名稱、 大寫或小寫版本具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3499">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span> <span data-ttu-id="5f51e-3500">這會產生相同的結果中每個文化特性 (不同於<xref:System.String.ToLower>方法)，並且更有效率地執行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3500">This produces the same result in every culture (unlike the <xref:System.String.ToLower> method) and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3501">下列範例會將數個混合大小寫的字串轉換成小寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3501">The following example converts several mixed case strings to lowercase.</span></span>  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-3502">中所述[使用字串的最佳作法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串大小寫的方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3502">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="5f51e-3503">若要使用目前文化特性的大小寫慣例小寫字元轉換，呼叫<see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />方法多載，其值為<see cref="P:System.Globalization.CultureInfo.CurrentCulture" />針對其<paramref name="culture" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3503">To convert a character to lowercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</span></span></para>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="5f51e-3504">提供文化特性大小寫規則的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3504">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="5f51e-3505">使用指定之文化特性的大小寫規則，傳回這個字串轉換成小寫的複本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3505">Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3506">目前字串的小寫對應項。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3506">The lowercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3507">所指定的文化特性的大小寫規則`culture`參數可讓您判斷變更字串的大小寫的方式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3507">The casing rules of the culture specified by the `culture` parameter determine the way the case of the string is changed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-3508">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3508">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-3509">相反地，它會傳回新的目前執行個體中的所有字元都轉換成小寫的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3509">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="5f51e-3510">安全性考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-3510">Security Considerations</span></span>  
 <span data-ttu-id="5f51e-3511">如果您要傳入<xref:System.String.ToLower%28System.Globalization.CultureInfo%29>方法<xref:System.Globalization.CultureInfo>物件以外<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>，大小寫作業會列入考量的特定文化特性的規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3511">If you pass the <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="5f51e-3512">如果您需要的作業系統識別碼，例如檔案名稱、 大寫或小寫版本具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3512">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="5f51e-3513">這會產生相同的結果，每個文化特性中，且更有效率地執行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3513">This produces the same result in every culture and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3514">下列範例會將轉換成小寫字元使用美國和土耳其文的文化特性，大寫字元的兩個字串，然後比較小寫的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3514">The following example converts two strings of uppercase characters to lowercase characters using the English-United States and Turkish-Turkey cultures, then compares the lowercase strings.</span></span> <span data-ttu-id="5f51e-3515">大寫的字串完全相同，不同之處在於 Unicode LATIN CAPITAL LETTER 我在一個字串中的每個相符項目，另一個字串包含 LATIN CAPITAL LETTER 我與點上方。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3515">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-3516"><paramref name="culture" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3516"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-3517">使用不因文化特性而異的大小寫規則，傳回轉換成小寫的這個 <see cref="T:System.String" /> 物件之複本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3517">Returns a copy of this <see cref="T:System.String" /> object converted to lowercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3518">目前字串的小寫對應項。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3518">The lowercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3519">文化特性而異表示不區分文化特性的文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3519">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="5f51e-3520">相關聯，所以與英文，但不是能搭配特定國家或地區。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3520">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="5f51e-3521">如需詳細資訊，請參閱 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 屬性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3521">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="5f51e-3522">如果您的應用程式而定的字串，並不會受到目前文化特性使用的可預測的方式變更大小寫<xref:System.String.ToLowerInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3522">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToLowerInvariant%2A> method.</span></span> <span data-ttu-id="5f51e-3523"><xref:System.String.ToLowerInvariant%2A>方法相當於`ToLower(CultureInfo.InvariantCulture)`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3523">The <xref:System.String.ToLowerInvariant%2A> method is equivalent to `ToLower(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="5f51e-3524">字串的集合必須出現在使用者介面控制項中可預測的順序時，建議的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3524">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-3525">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3525">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-3526">相反地，它會傳回新的目前執行個體中的所有字元都轉換成小寫的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3526">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="5f51e-3527">安全性考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-3527">Security Considerations</span></span>  
 <span data-ttu-id="5f51e-3528">如果您需要的作業系統識別碼，例如檔案名稱、 大寫或小寫版本具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3528">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3529">下列範例會定義包含有多種語言中的一個字的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3529">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="5f51e-3530"><xref:System.String.ToLowerInvariant%2A>方法用來填入平行陣列的項目與每個字不區分大小寫版本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3530">The <xref:System.String.ToLowerInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="5f51e-3531"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法用來排序依據以確保項目，會出現在相同的順序，不論語言為何小寫的陣列中項目順序區分大小寫的陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3531">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the lowercase array to ensure that elements appear in the same order regardless of language.</span></span>  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-3532">將這個執行個體的值轉換為 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3532">Converts the value of this instance to a <see cref="T:System.String" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-3533">傳回這個 <see cref="T:System.String" /> 執行個體；不會實際執行轉換。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3533">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3534">目前的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3534">The current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3535">因為這個方法只會傳回目前的字串不變，所以不需要直接呼叫它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3535">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span> <span data-ttu-id="5f51e-3536">它通常隱含地呼叫中的複合格式的作業，如範例所示。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3536">It is usually called implicitly in a composite formatting operation, as the example shows.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3537">下列範例會示範<xref:System.String.ToString%2A>方法。請注意，此範例不會明確呼叫<xref:System.String.ToString%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3537">The following example demonstrates the <xref:System.String.ToString%2A> method.Note that the example does not explicitly call the <xref:System.String.ToString%2A> method.</span></span> <span data-ttu-id="5f51e-3538">相反地，此方法會隱含地呼叫[複合格式化](~/docs/standard/base-types/composite-formatting.md)功能。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3538">Instead, the method is called implicitly by the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature.</span></span>  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5f51e-3539">(保留) 物件，提供特定文化特性格式資訊。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3539">(Reserved) An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="5f51e-3540">傳回這個 <see cref="T:System.String" /> 執行個體；不會實際執行轉換。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3540">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3541">目前的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3541">The current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3542">`provider` 已保留，以及目前參與這項作業。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3542">`provider` is reserved, and does not currently participate in this operation.</span></span>  
  
 <span data-ttu-id="5f51e-3543">因為這個方法只會傳回目前的字串不變，所以不需要直接呼叫它。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3543">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-3544">傳回此字串轉換為大寫的版本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3544">Returns a copy of this string converted to uppercase.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-3545">傳回此字串轉換為大寫的版本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3545">Returns a copy of this string converted to uppercase.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3546">目前字串的大寫對應項。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3546">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3547">這個方法會使用目前文化特性的大小寫規則，將目前的執行個體中的每個字元轉換成其對等大寫。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3547">This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent.</span></span> <span data-ttu-id="5f51e-3548">如果字元沒有對等大寫，它會包含傳回的字串中保持不變。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3548">If a character does not have an uppercase equivalent, it is included unchanged in the returned string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-3549">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3549">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-3550">相反地，它會傳回新的目前執行個體中的所有字元都轉換成大寫的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3550">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
 <span data-ttu-id="5f51e-3551"><xref:System.String.ToUpper%2A>方法通常用來將字串轉換成大寫，使其可以用於在不區分大小寫的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3551">The <xref:System.String.ToUpper%2A> method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison.</span></span> <span data-ttu-id="5f51e-3552">更好的方法，以執行不區分大小寫的比較是呼叫有字串比較方法<xref:System.StringComparison>參數值設為<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>進行區分文化特性、 不區分大小寫的比較。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3552">A better method to perform case-insensitive comparison is to call a string comparison method that has a <xref:System.StringComparison> parameter whose value you set to <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> for a culture-sensitive, case-insensitive comparison.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="5f51e-3553">安全性考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-3553">Security Considerations</span></span>  
 <span data-ttu-id="5f51e-3554">呼叫結果大小寫作業<xref:System.String.ToUpper>方法會考量目前的文化特性的大小寫慣例。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3554">The casing operation that results from calling the <xref:System.String.ToUpper> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="5f51e-3555">如果您需要的作業系統識別碼，例如檔案名稱、 大寫或小寫版本具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3555">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="5f51e-3556">這會產生相同的結果中每個文化特性 (不同於<xref:System.String.ToUpper>方法)，並且更有效率地執行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3556">This produces the same result in every culture (unlike the <xref:System.String.ToUpper> method) and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3557">下列範例會呼叫<xref:System.String.ToUpper%2A>方法，將一系列的單字元字串包含基本拉丁、 拉丁文 1 補充和拉丁文擴充-A 字元集中的每個字元的轉換。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3557">The following example calls the <xref:System.String.ToUpper%2A> method to convert a series of one-character strings that contain each character in the Basic Latin, Latin-1 Supplement, and Latin Extended-A character sets.</span></span> <span data-ttu-id="5f51e-3558">然後，它會顯示每個字串的大寫字元是不同於其小寫的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3558">It then displays each string whose uppercase character is different from its lowercase character.</span></span>  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-3559">中所述[使用字串的最佳作法](~/docs/standard/base-types/best-practices-strings.md)，我們建議您避免呼叫字串大小寫的方法，以取代預設值，並改為呼叫需要明確指定參數的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3559">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="5f51e-3560">若要將字串轉換為大寫使用目前文化特性的大小寫慣例，呼叫<see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" />方法多載，其值為<see cref="P:System.Globalization.CultureInfo.CurrentCulture" />針對其<paramref name="culture" />參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3560">To convert a string to uppercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</span></span></para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="5f51e-3561">提供文化特性大小寫規則的物件。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3561">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="5f51e-3562">使用指定之文化特性的大小寫規則，傳回這個字串轉換成大寫的複本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3562">Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3563">目前字串的大寫對應項。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3563">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3564">所指定的文化特性的大小寫規則`culture`參數可讓您判斷變更字串的大小寫的方式。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3564">The casing rules of the culture specified by the `culture` parameter determine the way the case of a string is changed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-3565">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3565">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-3566">相反地，它會傳回新的目前執行個體中的所有字元都轉換成大寫的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3566">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="5f51e-3567">安全性考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-3567">Security Considerations</span></span>  
 <span data-ttu-id="5f51e-3568">如果您要傳入<xref:System.String.ToUpper%28System.Globalization.CultureInfo%29>方法<xref:System.Globalization.CultureInfo>物件以外<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>，大小寫作業會列入考量的特定文化特性的規則。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3568">If you pass the <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="5f51e-3569">如果您需要的作業系統識別碼，例如檔案名稱、 大寫或小寫版本具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3569">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="5f51e-3570">這會產生相同的結果，每個文化特性中，且更有效率地執行。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3570">This produces the same result in every culture and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3571">下列範例會將小寫字元的字串轉換成大寫字元使用美國和土耳其文的文化特性的兩個字串，然後比較大寫的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3571">The following example converts a string of lowercase characters to two strings of uppercase characters using the English-United States and Turkish-Turkey cultures, then compares the uppercase strings.</span></span> <span data-ttu-id="5f51e-3572">大寫的字串完全相同，不同之處在於 Unicode LATIN CAPITAL LETTER 我在一個字串中的每個相符項目，另一個字串包含 LATIN CAPITAL LETTER 我與點上方。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3572">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5f51e-3573"><paramref name="culture" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3573"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-3574">使用不因文化特性而異的大小寫規則，傳回轉換成大寫的這個 <see cref="T:System.String" /> 物件之複本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3574">Returns a copy of this <see cref="T:System.String" /> object converted to uppercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3575">目前字串的大寫對應項。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3575">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3576">文化特性而異表示不區分文化特性的文化特性。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3576">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="5f51e-3577">相關聯，所以與英文，但不是能搭配特定國家或地區。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3577">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="5f51e-3578">如需詳細資訊，請參閱 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 屬性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3578">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="5f51e-3579">如果您的應用程式而定的字串，並不會受到目前文化特性使用的可預測的方式變更大小寫<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3579">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="5f51e-3580"><xref:System.String.ToUpperInvariant%2A>方法相當於`ToUpper(CultureInfo.InvariantCulture)`。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3580">The <xref:System.String.ToUpperInvariant%2A> method is equivalent to `ToUpper(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="5f51e-3581">字串的集合必須出現在使用者介面控制項中可預測的順序時，建議的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3581">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-3582">這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3582">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-3583">相反地，它會傳回新的目前執行個體中的所有字元都轉換成大寫的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3583">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="5f51e-3584">安全性考量</span><span class="sxs-lookup"><span data-stu-id="5f51e-3584">Security Considerations</span></span>  
 <span data-ttu-id="5f51e-3585">如果您需要的作業系統識別碼，例如檔案名稱、 大寫或小寫版本具名管道或登錄機碼，使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3585">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3586">下列範例會定義包含有多種語言中的一個字的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3586">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="5f51e-3587"><xref:System.String.ToUpperInvariant%2A>方法用來填入平行陣列的項目與每個字不區分大小寫版本。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3587">The <xref:System.String.ToUpperInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="5f51e-3588"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法用來排序依據以確保項目，會出現在相同的順序，不論語言為何大寫的陣列中項目順序區分大小寫的陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3588">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the uppercase array to ensure that elements appear in the same order regardless of language.</span></span>  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5f51e-3589">傳回新字串，其中已經移除出現在目前 <see cref="T:System.String" /> 物件中之所有開頭與結尾的一組指定的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3589">Returns a new string in which all leading and trailing occurrences of a set of specified characters from the current <see cref="T:System.String" /> object are removed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5f51e-3590">從目前的 <see cref="T:System.String" /> 物件中移除所有的開頭和結尾空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3590">Removes all leading and trailing white-space characters from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3591">從目前字串的開頭和結尾移除所有空白字元後，所保留下來的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3591">The string that remains after all white-space characters are removed from the start and end of the current string.</span></span> <span data-ttu-id="5f51e-3592">如果在目前的執行個體中無法修剪任何字元，則方法傳回未變更的目前執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3592">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3593"><xref:System.String.Trim%2A>方法從目前字串中移除所有開頭和尾端空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3593">The <xref:System.String.Trim%2A> method removes from the current string all leading and trailing white-space characters.</span></span> <span data-ttu-id="5f51e-3594">每個前置和尾端的修剪作業停止時遇到非空格字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3594">Each leading and trailing trim operation stops when a non-white-space character is encountered.</span></span> <span data-ttu-id="5f51e-3595">例如，如果目前的字串為"abc xyz"，<xref:System.String.Trim%2A>方法會傳回"abc xyz"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3595">For example, if the current string is "   abc   xyz   ", the <xref:System.String.Trim%2A> method returns "abc   xyz".</span></span> <span data-ttu-id="5f51e-3596">若要移除字串中的文字之間的空格字元，請使用[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3596">To remove white-space characters between words in a string, use a [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-3597">如果<xref:System.String.Trim%2A>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3597">If the <xref:System.String.Trim%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-3598">相反地，它會傳回新字串，目前的執行個體中之所有開頭和尾端的空格字元都會被移除。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3598">Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.</span></span>  
  
 <span data-ttu-id="5f51e-3599">如果目前字串等於<xref:System.String.Empty>或目前的執行個體中的所有字元都包含空白字元，則方法會傳回<xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3599">If the current string equals <xref:System.String.Empty> or all the characters in the current instance consist of white-space characters, the method returns <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="5f51e-3600">泛空白字元是由 Unicode 標準定義。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3600">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="5f51e-3601"><xref:System.String.Trim>方法中移除傳回值會產生任何開頭和尾端字元`true`傳遞至時<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3601">The <xref:System.String.Trim> method removes any leading and trailing characters that produce a return value of `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3602">下列範例會使用<xref:System.String.Trim?displayProperty=nameWithType>方法，以從使用者輸入之前它們串連的字串中移除任何額外的空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3602">The following example uses the <xref:System.String.Trim?displayProperty=nameWithType> method to remove any extra white space from strings entered by the user before concatenating them.</span></span>  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-3603">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和舊版維護的內部清單，這個方法會修剪的空格字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3603">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintain an internal list of white-space characters that this method trims.</span></span> <span data-ttu-id="5f51e-3604">從開始[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，方法會修剪所有 Unicode 空格字元 (也就是字元產生<see langword="true" />傳回值時傳遞至<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3604">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="5f51e-3605">這項變更，因為<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本中移除兩個字元，零寬度空格 (U + 200B) 和零寬度的不中斷空格 (U + FEFF)，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]更新版本，並無法移除。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3605">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove.</span></span> <span data-ttu-id="5f51e-3606">此外，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本不會修剪三種 Unicode 空白字元： 蒙古母音分隔符號 (U + 180E)、 窄不中斷空格 (U + 202F) 及中型數學空格 (U + 205F)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3606">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="5f51e-3607">要移除的 Unicode 字元陣列或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3607">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="5f51e-3608">從目前的 <see cref="T:System.String" /> 物件中移除陣列中指定之一組字元的所有開頭和結尾指定項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3608">Removes all leading and trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3609">從目前的字串開頭和結尾處移除 <paramref name="trimChars" /> 參數中所有出現的字元後，所保留下來的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3609">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the start and end of the current string.</span></span> <span data-ttu-id="5f51e-3610">如果 <paramref name="trimChars" /> 是 <see langword="null" /> 或空陣列，則反而會移除空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3610">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span></span> <span data-ttu-id="5f51e-3611">如果在目前的執行個體中無法修剪任何字元，則方法傳回未變更的目前執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3611">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3612"><xref:System.String.Trim%2A>方法會移除目前字串中的所有開頭和尾端字元`trimChars`參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3612">The <xref:System.String.Trim%2A> method removes from the current string all leading and trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="5f51e-3613">每一個開頭和尾端空白位置修剪作業停止時未出現在字元`trimChars`為止。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3613">Each leading and trailing trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="5f51e-3614">例如，如果目前的字串為"123abc456xyz789 」 和`trimChars`包含數字"1"到"9"，從<xref:System.String.Trim%2A>方法會傳回"abc456xyz"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3614">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.Trim%2A> method returns "abc456xyz".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-3615">如果<xref:System.String.Trim%2A>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3615">If the <xref:System.String.Trim%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-3616">相反地，它會傳回新字串中所有開頭和尾端`trimChars`移除目前的執行個體中的字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3616">Instead, it returns a new string in which all leading and trailing `trimChars` characters found in the current instance are removed.</span></span>  
  
 <span data-ttu-id="5f51e-3617">如果目前字串等於<xref:System.String.Empty>或中的字元，包含目前執行個體中的所有字元`trimChars`陣列，此方法會傳回<xref:System.String.Empty>。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3617">If the current string equals <xref:System.String.Empty> or all the characters in the current instance consist of characters in the `trimChars` array, the method returns <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="5f51e-3618">如果`trimChars`是`null`或空陣列，這個方法會移除任何開頭或結尾字元，導致方法傳回`true`傳遞至時<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法</span><span class="sxs-lookup"><span data-stu-id="5f51e-3618">If `trimChars` is `null` or an empty array, this method removes any leading or trailing characters that result in the method returning `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method,</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3619">下列範例會使用<xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType>方法從字串中移除空間、 星號 （\*），以及單引號 （'） 字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3619">The following example uses the <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> method to remove space, asterisk (\*), and apostrophe (') characters from a string.</span></span>  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-3620">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本維護的內部清單，如果這個方法會修剪的空格字元<paramref name="trimChars" />是<see langword="null" />或空陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3620">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="5f51e-3621">從開始[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，如果<paramref name="trimChars" />是<see langword="null" />或空陣列，此方法會修剪所有 Unicode 空格字元 (也就是字元產生<see langword="true" />傳回值時傳遞至<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3621">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="5f51e-3622">這項變更，因為<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本中移除兩個字元，零寬度空格 (U + 200B) 和零寬度的不中斷空格 (U + FEFF)，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]更新版本，並無法移除。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3622">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove.</span></span> <span data-ttu-id="5f51e-3623">此外，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本不會修剪三種 Unicode 空白字元： 蒙古母音分隔符號 (U + 180E)、 窄不中斷空格 (U + 202F) 及中型數學空格 (U + 205F)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3623">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="5f51e-3624">要移除的 Unicode 字元陣列或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3624">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="5f51e-3625">從目前的 <see cref="T:System.String" /> 物件中移除陣列中指定之一組字元的所有結尾指定項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3625">Removes all trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3626">從目前的字串結尾處移除 <paramref name="trimChars" /> 參數中所有出現的字元後，所保留下來的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3626">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the end of the current string.</span></span> <span data-ttu-id="5f51e-3627">如果 <paramref name="trimChars" /> 是 <see langword="null" /> 或空陣列，則反而會移除 Unicode 空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3627">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, Unicode white-space characters are removed instead.</span></span> <span data-ttu-id="5f51e-3628">如果在目前的執行個體中無法修剪任何字元，則方法傳回未變更的目前執行個體。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3628">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3629"><xref:System.String.TrimEnd%2A>方法會移除目前字串中的所有行尾字元`trimChars`參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3629">The <xref:System.String.TrimEnd%2A> method removes from the current string all trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="5f51e-3630">修剪作業停止時的第一個字元不在`trimChars`發生在字串結尾處。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3630">The trim operation stops when the first character that is not in `trimChars` is encountered at the end of the string.</span></span> <span data-ttu-id="5f51e-3631">例如，如果目前的字串為"123abc456xyz789 」 和`trimChars`包含數字"1"到"9"，從<xref:System.String.TrimEnd%2A>方法會傳回"123abc456xyz"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3631">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.TrimEnd%2A> method returns "123abc456xyz".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-3632">如果<xref:System.String.TrimEnd%2A>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3632">If the <xref:System.String.TrimEnd%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-3633">相反地，它會傳回新字串中哪些中找到的所有尾端字元`trimChars`會從目前的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3633">Instead, it returns a new string in which all trailing characters found in `trimChars` are removed from the current string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3634">下列範例示範如何使用<xref:System.String.TrimEnd%28System.Char%5B%5D%29>方法来修剪空白字元或標點符號從字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3634">The following example demonstrates how you can use the <xref:System.String.TrimEnd%28System.Char%5B%5D%29> method to trim white space or punctuation marks from the end of a string.</span></span>  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-3635">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本維護的內部清單，如果這個方法會修剪的空格字元<paramref name="trimChars" />是<see langword="null" />或空陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3635">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="5f51e-3636">從開始[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，如果<paramref name="trimChars" />是<see langword="null" />或空陣列，此方法會修剪所有 Unicode 空格字元 (也就是字元產生<see langword="true" />傳回值時傳遞至<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3636">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="5f51e-3637">這項變更，因為<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本中移除兩個字元，零寬度空格 (U + 200B) 和零寬度的不中斷空格 (U + FEFF)，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]更新版本，並無法移除。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3637">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove.</span></span> <span data-ttu-id="5f51e-3638">此外，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本不會修剪三種 Unicode 空白字元： 蒙古母音分隔符號 (U + 180E)、 窄不中斷空格 (U + 202F) 及中型數學空格 (U + 205F)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3638">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="5f51e-3639">要移除的 Unicode 字元陣列或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3639">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="5f51e-3640">從目前的 <see cref="T:System.String" /> 物件中移除陣列中指定之一組字元的所有開頭指定項目。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3640">Removes all leading occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="5f51e-3641">從目前的字串開頭處移除 <paramref name="trimChars" /> 參數中所有出現的字元後，所保留下來的字串。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3641">The string that remains after all occurrences of characters in the <paramref name="trimChars" /> parameter are removed from the start of the current string.</span></span> <span data-ttu-id="5f51e-3642">如果 <paramref name="trimChars" /> 是 <see langword="null" /> 或空陣列，則反而會移除空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3642">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5f51e-3643"><xref:System.String.TrimStart%2A>方法會移除目前字串中的所有前置字元`trimChars`參數。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3643">The <xref:System.String.TrimStart%2A> method removes from the current string all leading characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="5f51e-3644">不是一個字元時，就會停止修剪作業`trimChars`為止。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3644">The trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="5f51e-3645">例如，如果目前的字串為"123abc456xyz789 」 和`trimChars`包含數字"1"到"9"，從<xref:System.String.TrimStart%2A>方法會傳回"abc456xyz789"。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3645">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.TrimStart%2A> method returns "abc456xyz789".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5f51e-3646">如果<xref:System.String.TrimStart%2A>方法會移除目前的執行個體中的任何字元，這個方法不會修改目前的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3646">If the <xref:System.String.TrimStart%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="5f51e-3647">相反地，它會傳回新字串，目前的執行個體中的所有前置空格字元會被移除。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3647">Instead, it returns a new string in which all leading white space characters found in the current instance are removed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5f51e-3648">下列範例會使用<xref:System.String.TrimStart%2A>修剪泛空白字元和註解字元從原始程式碼的方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3648">The following example uses the <xref:System.String.TrimStart%2A> method to trim white space and comment characters from lines of source code.</span></span> <span data-ttu-id="5f51e-3649">`StripComments`方法會包裝呼叫<xref:System.String.TrimStart%2A>並將其傳遞字元陣列，其中包含一個空格和註解字元，也就是單引號 （'） 在 Visual Basic 和 C# 中的斜線 （/）。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3649">The `StripComments` method wraps a call to <xref:System.String.TrimStart%2A> and passes it a character array that contains a space and the comment character, which is an apostrophe ( ' ) in Visual Basic and a slash ( / ) in C#.</span></span> <span data-ttu-id="5f51e-3650"><xref:System.String.TrimStart%2A>也會呼叫方法來評估字串是否為註解時，移除前置空白字元。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3650">The <xref:System.String.TrimStart%2A> method is also called to remove leading white space when evaluating whether a string is a comment.</span></span>  
  
 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]  
  
 <span data-ttu-id="5f51e-3651">下列範例說明如何呼叫 `StripComments` 方法。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3651">The following example then illustrates a call to the `StripComments` method.</span></span>  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="5f51e-3652">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]及更早版本維護的內部清單，如果這個方法會修剪的空格字元<paramref name="trimChars" />是<see langword="null" />或空陣列。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3652">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="5f51e-3653">從開始[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，如果<paramref name="trimChars" />是<see langword="null" />或空陣列，此方法會修剪所有 Unicode 空格字元 (也就是字元產生<see langword="true" />傳回值時傳遞至<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3653">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="5f51e-3654">這項變更，因為<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本中移除兩個字元，零寬度空格 (U + 200B) 和零寬度的不中斷空格 (U + FEFF)，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]更新版本，並無法移除。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3654">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove.</span></span> <span data-ttu-id="5f51e-3655">此外，<see cref="M:System.String.Trim" />方法中的[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本不會修剪三種 Unicode 空白字元： 蒙古母音分隔符號 (U + 180E)、 窄不中斷空格 (U + 202F) 及中型數學空格 (U + 205F)。</span><span class="sxs-lookup"><span data-stu-id="5f51e-3655">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>
