<Type Name="GC" FullName="System.GC">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c8c0e69634df9ae33ac5d21d72ad8ca2edd45573" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36431725" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Controls the system garbage collector, a service that automatically reclaims unused memory.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 記憶體回收行程是控制項的配置和釋放的 managed 記憶體的通用語言執行階段元件。 物件和釋放物件所配置的資源時執行記憶體回收時，就會影響此類別中的方法。 此類別中的屬性系統的年齡類別目錄或產生，配置給物件的記憶體中提供可用的記憶體總數量的相關資訊。  
  
 記憶體回收行程會追蹤，而且會回收配置於 managed 記憶體中的物件。 定期記憶體回收行程執行記憶體回收回收記憶體配置給物件的有無有效的參考。 使用可用記憶體無法滿足記憶體要求時，會自動發生記憶體回收。 或者，應用程式可以強制記憶體回收集合使用<xref:System.GC.Collect%2A>方法。  
  
 記憶體回收包含下列步驟：  
  
1.  記憶體回收行程會搜尋在 managed 程式碼所參考的 managed 物件。  
  
2.  記憶體回收行程會嘗試完成未參考的物件。  
  
3.  記憶體回收行程釋放未參考的物件，並會回收記憶體。  
  
 本主題包含下列章節：  
  
 [記憶體回收行程和 unmanaged 的資源](#unmanaged)   
 [物件的過時和層代](#generations)   
 [不允許記憶體回收](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a>記憶體回收行程和 unmanaged 的資源  
 在回收期間，記憶體回收行程不會釋放物件如果 managed 程式碼中發現一個或多個物件的參考。 不過，記憶體回收行程無法辨識從 unmanaged 程式碼中，物件的參考，而且可能釋放物件，除非明確地防止這樣使用 unmanaged 程式碼中以獨佔方式。 <xref:System.GC.KeepAlive%2A>方法提供一套機制，可以防止記憶體回收行程收集的物件仍在使用 unmanaged 程式碼中。  
  
 除了 managed 的記憶體配置的記憶體回收行程實作不會維護的物件，例如檔案控制代碼或資料庫連接所持有的資源的相關資訊。 當型別使用的 unmanaged 的資源，必須釋放回收的類型執行個體之前時，類型可以實作完成項。  
  
 在大部分情況下，完成項會實作覆寫<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法; 不過，撰寫 C# 或 c + + 中的類型實作解構函式的編譯器將轉換的覆寫成<xref:System.Object.Finalize%2A?displayProperty=nameWithType>。 在大部分情況下，如果物件具有完成項中，記憶體回收行程呼叫它之前釋出物件。 不過，記憶體回收行程不需要在所有情況下，呼叫完成項例如，<xref:System.GC.SuppressFinalize%2A>方法明確地防止物件的完成項呼叫。 此外，記憶體回收行程不需要使用特定的執行緒，以便最終處理物件，保證彼此參考，但可進行記憶體回收的物件呼叫完成項的順序。  
  
 在特定時間必須釋放資源的情況下，類別可以實作<xref:System.IDisposable>介面，其中包含<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>方法，執行資源管理和清除工作。 類別可實作<xref:System.IDisposable.Dispose%2A>必須指定，做為其類別合約的一部分時類別取用者呼叫方法，以清除物件。 記憶體回收行程不會根據預設，呼叫<xref:System.IDisposable.Dispose%2A>方法; 不過，實作<xref:System.IDisposable.Dispose%2A>方法可以呼叫方法中<xref:System.GC>類別來自訂記憶體回收行程的最終處理行為。  
  
 如需有關物件最終處理和 dispose 模式的詳細資訊，請參閱[清除 Unmanaged 資源上](~/docs/standard/garbage-collection/unmanaged.md)。  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a>物件的過時和層代  
 Common language runtime 在記憶體回收行程支援物件使用的層代的時效性。 層代是測量的記憶體中物件的相對存在時間單位。 層代編號或年齡物件表示物件所屬的層代。 建立多個物件最近是較新的層代的一部分，而且具有小於物件先前在應用程式生命週期的層代編號。 層代 0 中，是最新的層代中的物件。 記憶體回收行程的這項實作支援三個層代的物件，這些層代 0、 1 和 2。 您可以擷取的值<xref:System.GC.MaxGeneration%2A>屬性，以判斷系統所支援的最大層代編號。  
  
 物件的時效性允許目標回收應用程式，在一組特定的層代，而不是需要評估所有層代記憶體回收行程。 多載<xref:System.GC.Collect%2A>方法包含`generation`參數可讓您指定要進行記憶體回收的最舊層代。  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a>不允許記憶體回收  
 從開始[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，記憶體回收行程支援無 GC 區域延遲模式，可以在記憶體回收的集合可以有負面影響的應用程式效能的關鍵路徑的執行期間使用。 無 GC 區域延遲模式需要您指定可從記憶體回收行程配置不受干擾的記憶體數量。 如果執行階段可以配置的記憶體，執行階段不會執行回收時執行的關鍵路徑中的程式碼。  
  
 您透過呼叫其中一個多載定義的無 GC 區域的關鍵路徑的開頭<xref:System.GC.TryStartNoGCRegion%2A>。 您可以指定其關鍵路徑的結尾呼叫<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。 換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），和不應呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功，因為第一次呼叫<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
   
  
## Examples  
 下列範例會使用數個 GC 方法，以取得產生和記憶體未使用物件的區塊資訊並列印到主控台。 然後會回收未使用的物件，而且會顯示產生的記憶體總數。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">The incremental amount of unmanaged memory that has been allocated.</param>
        <summary>Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在決定何時要排定記憶體回收時，執行階段會考量已配置的受管理的記憶體。 如果小型的 managed 的物件會配置大量的未受管理的記憶體，執行階段會考量只有受管理的記憶體，並因此低估排定記憶體回收的急迫性。 <xref:System.GC.AddMemoryPressure%2A>方法告知執行階段，此額外系統記憶體不足。  
  
 在最簡單的使用方式模式中，受管理的物件配置 unmanaged 的記憶體中的建構函式，並釋放它在`Dispose`或`Finalize`方法。 呼叫<xref:System.GC.AddMemoryPressure%2A>方法之後配置 unmanaged 的記憶體中，並呼叫<xref:System.GC.RemoveMemoryPressure%2A>之後釋出它的方法。  
  
 在更複雜的情況，其中 unmanaged 的記憶體配置的 managed 物件的存留期間變更本質上，您可以呼叫<xref:System.GC.AddMemoryPressure%2A>和<xref:System.GC.RemoveMemoryPressure%2A>通訊這些執行階段的累加變更的方法。  
  
> [!CAUTION]
>  您必須確定您移除完全壓力您新增的數量。 不這樣做的話，可能會影響系統的長時間執行的應用程式的效能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> is less than or equal to 0.  -or-  On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供管理回收優先順序時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels the registration of a garbage collection notification.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會取消，使用已註冊記憶體回收通知<xref:System.GC.RegisterForFullGCNotification%2A>方法。 您不需要調整臨界值參數值在後續呼叫之前呼叫這個方法<xref:System.GC.RegisterForFullGCNotification%2A>方法。  
  
   
  
## Examples  
 下列範例會取消註冊記憶體回收集合。 這個範例是針對所提供之較大範例的一部分[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)主題。  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This member is not available when concurrent garbage collection is enabled. See the [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Forces garbage collection.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Forces an immediate garbage collection of all generations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法，嘗試回收所有無法存取的記憶體。 它會執行所有層代的封鎖記憶體回收。  
  
 所有的物件，不論多久已在記憶體中，會被視為集合;不過，不會收集 managed 程式碼中所參考的物件。 使用這個方法來強制系統嘗試回收的最大可用記憶體數量。  
  
 從開始[!INCLUDE[net_v451](~/includes/net-v451-md.md)]，您可以藉由設定壓縮大型物件堆積 (LOH)<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>屬性<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>之前先呼叫<xref:System.GC.Collect%2A>方法，如下列範例會說明。  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.GC.Collect%2A>方法執行所有層代的記憶體回收。 程式碼會產生未使用的物件數目，然後呼叫<xref:System.GC.Collect%2A>方法來從記憶體清除它們。  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">The number of the oldest generation to be garbage collected.</param>
        <summary>Forces an immediate garbage collection from generation 0 through a specified generation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再試一次回收記憶體而無法使用這個方法。 不過，使用此方法不保證會回收所有存取的記憶體中指定的層代。  
  
 如果物件的時效性實作時，記憶體回收行程無法回收物件以產生數字高於指定層代。 未實作物件的時效性，如果記憶體回收行程會考慮在記憶體回收期間的所有物件。  
  
 使用<xref:System.GC.MaxGeneration%2A>屬性來判斷最大有效值`generation`參數。  
  
 若要考慮所有的物件，不論其層代記憶體回收行程，請使用這個方法不採用參數的版本。 若要將記憶體回收行程回收物件根據<xref:System.GCCollectionMode>設定，請使用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType>方法多載。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.GC.Collect%2A>執行回收的記憶體的個別圖層上的方法。 程式碼會產生未使用的物件數目，然後呼叫<xref:System.GC.Collect%2A>方法來從記憶體清除它們。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">The number of the oldest generation to be garbage collected.</param>
        <param name="mode">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <summary>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`mode`參數來指定是否應該發生記憶體回收立即] 或 [僅時間是否最佳回收物件。 使用此方法不保證會回收所有存取的記憶體中指定的層代。  
  
 若要調整應用程式中的重大期間記憶體回收的干擾程度，請設定<xref:System.Runtime.GCSettings.LatencyMode%2A>屬性。  
  
 記憶體回收行程不會收集以產生數字高於所指定的物件`generation`參數。 使用<xref:System.GC.MaxGeneration%2A>屬性來判斷最大有效值`generation`。  
  
 若要考慮所有的物件，不論其層代記憶體回收行程，請使用這個方法不採用參數的版本。  
  
 若要讓記憶體回收行程回收最多指定物件層代的物件，請使用<xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType>方法多載。 當您指定最大層代時，則會收集所有物件。  
  
   
  
## Examples  
 下列範例強制執行記憶體回收層代 2 物件<xref:System.GCCollectionMode.Optimized>設定。  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> is not valid.  -or-  <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">The number of the oldest generation to be garbage collected.</param>
        <param name="mode">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</param>
        <summary>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表摘要說明之間的互動`mode`和`blocking`參數：  
  
|`mode`|`blocking` 是 `true`|`blocking` 是 `false`|  
|-|-|-|  
|<xref:System.GCCollectionMode.Forced> 或 <xref:System.GCCollectionMode.Default>|會盡快執行封鎖回收。 如果正在進行中的背景集合和`generation`是 0 或 1，<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>方法立即觸發封鎖的集合，並在完成集合後傳回。 如果正在進行中的背景集合和`generation`為 2，則方法會等候直到背景回收完成時，封鎖的層代 2 回收，觸發程序，然後傳回。|會盡快執行回收。 <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> 方法會要求背景集合，但不保證可取得。視情況而定，可能仍會執行封鎖集合。 如果已在進行背景回收，則這個方法會立即返回。|  
|<xref:System.GCCollectionMode.Optimized>|可能會因記憶體回收行程和 `generation` 參數的狀態而執行封鎖集合。 記憶體回收行程會嘗試提供最佳效能。|根據記憶體回收行程的狀態，可能會執行回收。 <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> 方法會要求背景集合，但不保證可取得。視情況而定，可能仍會執行封鎖集合。 記憶體回收行程會嘗試提供最佳效能。 如果已在進行背景回收，則這個方法會立即返回。|  
  
 如果呼叫<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>方法會執行完全封鎖記憶體回收，您也可以藉由設定壓縮大型物件堆積<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>屬性<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>之前先呼叫<xref:System.GC.Collect%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> is not valid.  -or-  <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">The number of the oldest generation to be garbage collected.</param>
        <param name="mode">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</param>
        <param name="compacting">
          <see langword="true" /> to compact the small object heap; <see langword="false" /> to sweep only.</param>
        <summary>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with values that specify whether the collection should be blocking and compacting.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`blocking`是`false`，GC 會決定是否要執行的背景或封鎖記憶體回收。 如果`compacting`是`true`，它會執行封鎖記憶體回收。  
  
 如果`compacting`是`true`，執行階段會壓縮小型物件堆積 (SOH)。 除非，不會壓縮大型物件堆積 (LOH)<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>屬性設定為<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>。 請注意，這包含所有封鎖記憶體回收，不只完整封鎖記憶體回收。  
  
 您可以呼叫<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法，以減少受管理的堆積大小最小，如下列程式碼片段所示。  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 指定`true`如`compacting`引數可保證壓縮、 完整封鎖記憶體回收。 設定<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>屬性<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>可確保會壓縮 LOH 與 SOH。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">The generation of objects for which the garbage collection count is to be determined.</param>
        <summary>Returns the number of times garbage collection has occurred for the specified generation of objects.</summary>
        <returns>The number of times garbage collection has occurred for the specified generation since the process was started.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您實作您自己的資源管理，您可能需要定期強制記憶體回收，藉由呼叫<xref:System.GC.Collect%2A>方法。 因為這是昂貴的作業，您可以藉由略過呼叫時最近發生記憶體回收改善效能。 儲存所傳回的值<xref:System.GC.CollectionCount%2A>後立即呼叫<xref:System.GC.Collect%2A>。 您需要呼叫在下一次<xref:System.GC.Collect%2A>，所傳回的目前值相比較<xref:System.GC.CollectionCount%2A>已儲存的值。 如果兩個值相等，過渡中發生任何集合，而且很合理地呼叫<xref:System.GC.Collect%2A>一次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> is less than 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ends the no GC region latency mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.EndNoGCRegion%2A>方法會擲回<xref:System.InvalidOperationException>如果記憶體回收行程不處於無 GC 區域延遲模式。 發生這種情況下下列任何一個狀況：  
  
-   <xref:System.GC.TryStartNoGCRegion%2A>不先前呼叫方法。  
  
-   若要呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法會傳回`false`。  
  
-   若要呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法會擲回例外狀況。  
  
 您可以使用程式碼如下所示，基於這些原因避免例外狀況：  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The garbage collector is not in no GC region latency mode.  -or-  The no GC region latency mode was ended previously because a garbage collection was induced.  -or-  A memory allocation exceeded the amount specified in the call to the <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> method.</exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the current generation number of an object.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object that generation information is retrieved for.</param>
        <summary>Returns the current generation number of the specified object.</summary>
        <returns>The current generation number of <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來判斷物件的存留期，然後使用該資訊與<xref:System.GC.Collect%2A>相同的層代中的方法，以強制記憶體回收行程回收物件。 例如，當您有一組群組所建立的並且在相同的時間，變成無法存取的物件時，才能使用這個方法。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.GC.GetGeneration%2A>方法，以判斷物件的存留期。 此範例接著會執行記憶體回收集合來清除記憶體並比較預先張貼集合在主控台中的記憶體總數。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined.</param>
        <summary>Returns the current generation number of the target of a specified weak reference.</summary>
        <returns>The current generation number of the target of <paramref name="wo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何使用<xref:System.GC.GetGeneration%2A>方法，以判斷最弱式參考物件的時間。  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Garbage collection has already been performed on <paramref name="wo" />.</exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">
          <see langword="true" /> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <see langword="false" />.</param>
        <summary>Retrieves the number of bytes currently thought to be allocated. A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</summary>
        <returns>A number that is the best available approximation of the number of bytes currently allocated in managed memory.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`forceFullCollection`參數是`true`，這個方法會等候再傳回較短的間隔時，系統會收集記憶體回收，並終結物件。 內部指定的限制，取決於已完成記憶體回收週期數目和復原循環之間的記憶體變更間隔的持續時間。 記憶體回收行程不保證會收集所有存取的記憶體。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.GC.GetTotalMemory%2A>方法來取得並顯示目前配置於 managed 記憶體中的位元組數目。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object to reference.</param>
        <summary>References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目的<xref:System.GC.KeepAlive%2A>方法是確保可能過早被記憶體回收行程回收物件的參考是否存在。 這其中可能會發生的常見案例是當沒有物件參考 managed 程式碼或資料，但物件仍在使用 unmanaged 程式碼，例如 Win32 Api，unmanaged Dll，或使用 COM 方法  
  
 這個方法所參考`obj`參數，使該物件適合記憶體回收從常式的開始點，以執行順序，會呼叫這個方法。 這個方法在結束時，無法開始時，指示的範圍的程式碼位置`obj`必須可供使用。  
  
 <xref:System.GC.KeepAlive%2A>方法會執行任何作業，並產生沒有副作用以外延伸做為參數傳遞的物件的存留期。  
  
   
  
## Examples  
 下列程式碼範例會建立物件的開頭其`Main`方法，而且不會一次，直到結束時，無法參考物件時<xref:System.GC.KeepAlive%2A>方法呼叫。 30 秒期間的物件保存`Main`方法，儘管呼叫<xref:System.GC.Collect%2A>和<xref:System.GC.WaitForPendingFinalizers%2A>方法。  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum number of generations that the system currently supports.</summary>
        <value>範圍從零至所支援最大層代編號的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 層代編號或年齡，物件會實作定義相對量值物件的使用期限。 最新建立的物件是層代 0 中，最舊的物件是小於或等於產生傳回的層代<xref:System.GC.MaxGeneration%2A>屬性。  
  
 記憶體回收行程會假設較新的記憶體是比較可能是較舊的記憶體回收。 因此，記憶體回收行程會改善其效能調整它會回收記憶體，每次產生數字和<xref:System.GC.MaxGeneration%2A>屬性值可以隨著時間成長。  
  
 如果實作物件的時效性，<xref:System.GC.MaxGeneration%2A>屬性會傳回系統所使用的最大層代編號，否則這個屬性會傳回零。  
  
   
  
## Examples  
 下列範例會示範如何使用 MaxGeneration 屬性來使用目前顯示的最大層代編號。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此實作中，傳回的值由<see cref="P:System.GC.MaxGeneration" />屬性會保證執行的應用程式的存留期間保持不變。使用<see cref="P:System.GC.MaxGeneration" />屬性來判斷呼叫時，您可以指定的最大值<see cref="M:System.GC.Collect(System.Int32)" />採用產生參數的方法。</para>
        </block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</param>
        <param name="largeObjectHeapThreshold">A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</param>
        <summary>Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對每個層代中，記憶體回收行程會設定成該層代的配置臨界值。 當配置的記憶體大小超過此臨界值時，該層代上觸發記憶體回收。 如範例中，如果層代 2 的臨界值是 20 MB （亦即未層代 1 回收 20 MB，並提升至層代 2），超過 20 MB 尚未被第 1 代，而且會提示輸入至層代 2 中，將會嘗試下一個記憶體回收為層代 2 回收。 同樣地，如果大型物件堆積 (LOH) 臨界值是 20 MB，您的應用程式有已配置超過 20 MB 的大型物件下, 一個記憶體回收也會嘗試為層代 2 回收 （因為，gen2 記憶體回收中才會收集 LOH）。  
  
 `maxGenerationThreshold`和`largeObjectHeapThreshold`臨界值會控制多少事先通知您完整記憶體回收發生之前。 閾值愈通知和下一個完整記憶體回收之間可能的多個配置。  
  
 如果您在其中完整回收，common language runtime 會影響您的應用程式效能的情況下，您可以要求執行完整記憶體回收和規避該集合，由執行階段時收到通知自行引發集合 (使用<xref:System.GC.Collect%2A>方法) 時仍理想狀況。 除了變更自己的記憶體回收集合排程，完整 GC 通知適用於下列案例：  
  
-   您進行監視的完整記憶體回收的方法，當系統通知您其中一個已接近，您縮小即時資料 （例如，藉由釋放某些快取項目）。 如此一來，當記憶體回收發生時，便能將回收更多記憶體。  
  
-   您監視的完整記憶體回收完成，而您可以收集一些統計資料。  例如，您可以測量在 GC 完成堆積的大小，好讓您知道即時資料的大小。 （完整的 GC，堆積之後的最小大小。）  
  
 如需有關什麼代表完整記憶體回收的詳細資訊，請參閱[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)。  
  
 當您註冊記憶體回收通知時，接近完整記憶體回收時和完成時，則會通知您可以。 此模式類似於如何作業系統用來監視記憶體不足的通知。  
  
 使用下列指導方針來指定`maxGenerationThreshold`和`largeObjectHeapThreshold`參數：  
  
-   臨界值越大，更多的配置會通知與完整記憶體回收之間發生。  
  
     較大的臨界值會提供更多的機會，為了讓執行階段檢查接近的集合。 這會增加，系統會通知您的可能性。 不過，您不應該設定過高臨界值，因為這樣會造成更多的配置之前執行階段產生的下一個集合。  
  
     當您自行引發回收告知使用高臨界值時，會由執行階段的下一次回收收回比回收較少的物件。  
  
-   小臨界值，較少通知與完整記憶體回收之間配置。  
  
   
  
## Examples  
 下列範例會示範如何註冊記憶體回收通知並啟動執行緒來監視記憶體回收通知的狀態。 這個程式碼範例是針對所提供之較大範例的一部分[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)主題。  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxGenerationThreshold" /> or <paramref name="largeObjectHeapThreshold" /> is not between 1 and 99.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">The amount of unmanaged memory that has been released.</param>
        <summary>Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在決定何時要排定記憶體回收時，執行階段會考量已配置的受管理的記憶體。 如果小型的 managed 的物件會配置大量的未受管理的記憶體，執行階段會考量只有受管理的記憶體，並因此低估排定記憶體回收的急迫性。 <xref:System.GC.AddMemoryPressure%2A>方法告知執行階段，系統記憶體，此額外的壓力而<xref:System.GC.RemoveMemoryPressure%2A>方法會通知執行階段已釋放額外的壓力。  
  
 在最簡單的使用方式模式中，受管理的物件配置 unmanaged 的記憶體中的建構函式，並釋放它在`Dispose`或`Finalize`方法。 呼叫<xref:System.GC.AddMemoryPressure%2A>方法之後配置 unmanaged 的記憶體中，並呼叫<xref:System.GC.RemoveMemoryPressure%2A>之後釋出它的方法。  
  
 在更複雜的情況，其中 unmanaged 的記憶體配置的 managed 物件的存留期間變更本質上，您可以呼叫<xref:System.GC.AddMemoryPressure%2A>和<xref:System.GC.RemoveMemoryPressure%2A>通訊這些執行階段的累加變更的方法。  
  
> [!CAUTION]
>  您必須確定您移除完全壓力您新增的數量。 不這樣做的話，可能會影響系統的長時間執行的應用程式的效能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> is less than or equal to 0.  -or-  On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供管理回收優先順序時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object that a finalizer must be called for.</param>
        <summary>Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.ReRegisterForFinalize%2A>方法會將`obj`參數的記憶體回收行程釋放物件之前，要求最終處理的物件清單。 `obj`參數必須是這個方法的呼叫端。  
  
 呼叫<xref:System.GC.ReRegisterForFinalize%2A>方法不保證記憶體回收行程會呼叫物件的完成項。  
  
 根據預設，會實作完成項的所有物件都加入至所需的最終處理; 的物件清單不過，物件可能已完成，或可能已停用最終處理藉由呼叫<xref:System.GC.SuppressFinalize%2A>方法。  
  
 完成項可以使用這個方法重新恢復它本身或它所參考的物件。  
  
   
  
## Examples  
 下列範例示範如何使用 ReRegisterForFinalize 方法來完成第二個物件在回收之後的時間。  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object whose finalizer must not be executed.</param>
        <summary>Requests that the common language runtime not call the finalizer for the specified object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會設定位元的物件標頭中`obj`，當呼叫完成項，執行階段檢查。 完成項，它由<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法，用於物件被記憶體回收前釋放 unmanaged 的資源。 如果`obj`沒有完成項中，呼叫<xref:System.GC.SuppressFinalize%2A>方法沒有任何作用。  
  
 物件，實作<xref:System.IDisposable>介面可以呼叫這個方法的物件從<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>實作，以防止記憶體回收行程呼叫<xref:System.Object.Finalize%2A?displayProperty=nameWithType>上不需要的物件。 一般而言，這為了釋放已釋放的 unmanaged 的資源時，防止完成項<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>實作。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.GC.SuppressFinalize%2A>中的資源類別，以避免多餘的記憶體回收集合時呼叫的方法。 此範例會使用[處置模式](~/docs/standard/design-guidelines/dispose-pattern.md)同時釋放 managed 資源 (也就是物件，實作<xref:System.IDisposable>) 與 unmanaged 資源。  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attempts to disallow garbage collection during the execution of a critical path.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。 換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），和不應呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功，因為第一次呼叫<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">The amount of memory in bytes to allocate without triggering a garbage collection. It must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</param>
        <summary>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</summary>
        <returns>
          <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%29>方法會嘗試將記憶體回收行程中不允許記憶體回收，而應用程式執行的程式碼的重要區域無 GC 區域延遲模式。  如果執行階段無法一開始配置要求的記憶體數量，記憶體回收行程會執行完全封鎖記憶體回收，嘗試釋放出額外的記憶體。 記憶體回收行程進入無 GC 區域延遲模式，它是否能夠配置所需的數量的記憶體，在此情況下為實際 2 *`totalSize`位元組 (它會嘗試配置`totalSize`小型物件堆積位元組和`totalSize`的位元組數大型物件堆積）。  
  
 `totalSize` 必須要夠大，無法處理發生的關鍵路徑中的所有記憶體配置。 這包括應用程式時，所配置，以及執行階段可讓應用程式的代表的配置。  
  
> [!IMPORTANT]
>  您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。 換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），和不應呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功，因為第一次呼叫<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 您藉由呼叫結束無 GC 區域延遲模式<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> exceeds the ephemeral segment size.</exception>
        <exception cref="T:System.InvalidOperationException">The process is already in no GC region latency mode.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">The amount of memory in bytes to allocate without triggering a garbage collection. It must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <c>totalSize</c> bytes; otherwise, <see langword="false" />.</param>
        <summary>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</summary>
        <returns>
          <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29>方法會嘗試將記憶體回收行程中不允許記憶體回收，而應用程式執行的程式碼的重要區域無 GC 區域延遲模式。  如果執行階段是無法一開始配置要求的記憶體數量和`disallowFullBlockingGC`引數是`false`，記憶體回收行程執行完全封鎖記憶體回收，嘗試釋放出額外的記憶體; 否則配置失敗，而且方法會傳回`false`。 記憶體回收行程進入無 GC 區域延遲模式，它是否能夠配置所需的數量的記憶體，在此情況下為實際 2 * `totalSize` (它會嘗試配置`totalSize`針對小物件堆積和`totalSize`大型物件堆積）。  
  
 `totalSize` 必須要夠大，無法處理發生的關鍵路徑中的所有記憶體配置。 這包括應用程式時，所配置，以及執行階段可讓應用程式的代表的配置。  
  
 設定`disallowFullBlockingGC`至`true`為了避免完整的封鎖記憶體回收集合，如果沒有足夠的記憶體一開始是負載平衡案例中最為有用： 一個系統可以呼叫這個方法，並報告本身為準備好接受要求，如果它傳回`true`，而且如果它傳回，將要求重新導向至其他系統的負載平衡器`false`。 它不藉由呼叫處理要求時，它可以再執行完全封鎖記憶體回收<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法。  
  
> [!IMPORTANT]
>  您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。 換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），和不應呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功，因為第一次呼叫<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 您藉由呼叫結束無 GC 區域延遲模式<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> exceeds the ephemeral segment size.</exception>
        <exception cref="T:System.InvalidOperationException">The process is already in no GC region latency mode.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">The amount of memory in bytes to allocate without triggering a garbage collection. <c>totalSize</c> –<c>lohSize</c> must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</param>
        <param name="lohSize">The number of bytes in <c>totalSize</c> to use for large object heap (LOH) allocations.</param>
        <summary>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</summary>
        <returns>
          <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29>方法會嘗試將記憶體回收行程中不允許記憶體回收，而應用程式執行的程式碼的重要區域無 GC 區域延遲模式。  如果執行階段無法一開始配置要求的記憶體數量，記憶體回收行程會執行完全封鎖記憶體回收，嘗試釋放出額外的記憶體。 記憶體回收行程會進入無 GC 區域延遲模式，它是否能夠配置`lohSize`如 LOH 和`totalSize`–`lohSize`針對小物件堆積 (SOH)。  
  
 `lohSize` 必須要夠大，無法處理 LOH，針對發生的關鍵路徑中的所有記憶體配置和`totalSize`–`lohSize`必須夠大，無法都處理的 SOH 中發生的關鍵路徑中的所有記憶體配置。 這包括應用程式時，所配置，以及執行階段可讓應用程式的代表的配置。  
  
> [!IMPORTANT]
>  您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。 換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），和不應呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功，因為第一次呼叫<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 您藉由呼叫結束無 GC 區域延遲模式<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</exception>
        <exception cref="T:System.InvalidOperationException">The process is already in no GC region latency mode.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">The amount of memory in bytes to allocate without triggering a garbage collection. <c>totalSize</c> –<c>lohSize</c> must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</param>
        <param name="lohSize">The number of bytes in <c>totalSize</c> to use for large object heap (LOH) allocations.</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <see langword="false" />.</param>
        <summary>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</summary>
        <returns>
          <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29>方法會嘗試將記憶體回收行程中不允許記憶體回收，而應用程式執行的程式碼的重要區域無 GC 區域延遲模式。  如果執行階段是無法一開始配置要求的記憶體數量和`disallowFullBlockingGC`引數是`false`，記憶體回收行程執行完全封鎖記憶體回收，嘗試釋放出額外的記憶體; 否則配置失敗，而且方法會傳回`false`。 記憶體回收行程會進入無 GC 區域延遲模式，它是否能夠配置`lohSize`如 LOH 和`totalSize`–`lohSize`針對小物件堆積 (SOH)。  
  
 `lohSize` 必須要夠大，無法處理 LOH，針對發生的關鍵路徑中的所有記憶體配置和`totalSize`–`lohSize`必須夠大，無法都處理的 SOH 中發生的關鍵路徑中的所有記憶體配置。 這包括應用程式時，所配置，以及執行階段可讓應用程式的代表的配置。  
  
 設定`disallowFullBlockingGC`至`true`為了避免完整的封鎖記憶體回收集合，如果沒有足夠的記憶體一開始是負載平衡案例中最為有用： 一個系統可以呼叫這個方法，並報告本身為準備好接受要求，如果它傳回`true`，而且如果它傳回，將要求重新導向至其他系統的負載平衡器`false`。 它不藉由呼叫處理要求時，它可以再執行完全封鎖記憶體回收<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法。  
  
> [!IMPORTANT]
>  您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。 換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），和不應呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功，因為第一次呼叫<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 您藉由呼叫結束無 GC 區域延遲模式<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</exception>
        <exception cref="T:System.InvalidOperationException">The process is already in no GC region latency mode.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</summary>
        <returns>The status of the registered garbage collection notification.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.GCNotificationStatus>來判斷目前記憶體回收通知的使用已註冊狀態，這個方法所傳回的列舉<xref:System.GC.RegisterForFullGCNotification%2A>方法。 您也可以使用<xref:System.GC.WaitForFullGCComplete%2A>方法，以判斷是否已完成完整記憶體回收。  
  
 當列舉型別傳回<xref:System.GCNotificationStatus.Succeeded>，您可以執行工作，例如防止其他物件所配置和與自行引發集合<xref:System.GC.Collect%2A>方法。 請注意通知並不保證，完整記憶體回收，就會發生，但是條件已達到是負責完整記憶體回收發生的臨界值。  
  
 這個方法會無限期地等候取得記憶體回收通知。 如果您想要指定要傳回如果無法取得通知的方法逾時期間，使用<xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>方法多載。 如果您未指定逾時呼叫這個方法，您可以呼叫<xref:System.GC.CancelFullGCNotification%2A>方法，如果您在慣用再等候。  
  
 您應該遵循此方法透過呼叫<xref:System.GC.WaitForFullGCComplete%2A>方法，確定您有完整記憶體回收。 單獨呼叫這個方法會造成未定的結果。  
  
   
  
## Examples  
 下列範例會示範如何使用這個方法來判斷是否已接近完整的封鎖記憶體回收。 每當通知的狀態是<xref:System.GCNotificationStatus.Succeeded>，使用者方法`OnFullGCApproachNotify`呼叫以執行動作以回應至接近的集合。 這個程式碼範例是針對所提供之較大範例的一部分[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)主題。  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">The length of time to wait before a notification status can be obtained. Specify -1 to wait indefinitely.</param>
        <summary>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</summary>
        <returns>The status of the registered garbage collection notification.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.GCNotificationStatus>來判斷目前記憶體回收通知的使用已註冊狀態，這個方法所傳回的列舉<xref:System.GC.RegisterForFullGCNotification%2A>方法。 您也可以使用<xref:System.GC.WaitForFullGCComplete%2A>方法，以判斷是否已完成完整記憶體回收。  
  
 請注意，這個方法會傳回每次記憶體回收集合取得通知，不論所指定的值，請立即`millisecondsTimeout`。 如果記憶體回收集合未取得通知之前`millisecondsTimeout`時間時，這個方法會傳回<xref:System.GCNotificationStatus.NotApplicable>。  
  
 當列舉型別傳回<xref:System.GCNotificationStatus.Succeeded>，您可以執行工作，例如防止其他物件所配置和與自行引發集合<xref:System.GC.Collect%2A>方法。 請注意通知並不保證，完整記憶體回收，就會發生，但是條件已達到是負責完整記憶體回收發生的臨界值。  
  
 您可以呼叫<xref:System.GC.CancelFullGCNotification%2A>方法時，您無法等候逾時時間過去。  
  
 您應該遵循此方法透過呼叫<xref:System.GC.WaitForFullGCComplete%2A>方法，確定您有完整記憶體回收。 單獨呼叫這個方法會造成未定的結果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</summary>
        <returns>The status of the registered garbage collection notification.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.GCNotificationStatus>來判斷目前記憶體回收通知的使用已註冊狀態，這個方法所傳回的列舉<xref:System.GC.RegisterForFullGCNotification%2A>方法。 您也可以使用<xref:System.GC.WaitForFullGCApproach%2A>方法，以判斷是否即將完整記憶體回收。  
  
 當列舉型別傳回<xref:System.GCNotificationStatus.Succeeded>，您可以執行工作，例如繼續工作，並取得與集合計數<xref:System.GC.CollectionCount%2A>屬性。  
  
 這個方法會無限期地等候取得記憶體回收通知。 如果您想要指定要傳回如果無法取得通知的方法逾時期間，使用<xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>方法多載。 如果您未指定逾時呼叫這個方法，您可以呼叫<xref:System.GC.CancelFullGCNotification%2A>方法，如果您在慣用再等候。  
  
 這個方法呼叫應該在前面加上呼叫<xref:System.GC.WaitForFullGCApproach%2A>方法，確定您有完整記憶體回收。 單獨呼叫這個方法可能會產生未定的結果。  
  
   
  
## Examples  
 下列範例會示範如何使用這個方法來判斷是否已完成完整記憶體回收。 每當通知的狀態是<xref:System.GCNotificationStatus.Succeeded>，使用者方法`OnFullGCCompletedNotify`呼叫以執行動作以回應至已完成的集合。 這個程式碼範例是針對所提供之較大範例的一部分[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)主題。  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">The length of time to wait before a notification status can be obtained. Specify -1 to wait indefinitely.</param>
        <summary>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</summary>
        <returns>The status of the registered garbage collection notification.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.GCNotificationStatus>來判斷目前記憶體回收通知的使用已註冊狀態，這個方法所傳回的列舉<xref:System.GC.RegisterForFullGCNotification%2A>方法。 您也可以使用<xref:System.GC.WaitForFullGCApproach%2A>方法，以判斷是否即將完整記憶體回收。  
  
 請注意，這個方法會傳回每次記憶體回收集合取得通知，不論所指定的值，請立即`millisecondsTimeout`。 如果記憶體回收集合未取得通知之前`millisecondsTimeout`時間時，這個方法會傳回<xref:System.GCNotificationStatus.NotApplicable>。  
  
 當列舉型別傳回<xref:System.GCNotificationStatus.Succeeded>，您可以執行工作，例如繼續工作，並取得與集合計數<xref:System.GC.CollectionCount%2A>屬性。  
  
 您可以呼叫<xref:System.GC.CancelFullGCNotification%2A>方法時，您無法等候逾時時間過去。  
  
 這個方法呼叫應該在前面加上呼叫<xref:System.GC.WaitForFullGCApproach%2A>方法，確定您有完整記憶體回收。 單獨呼叫這個方法可能會產生未定的結果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當記憶體回收行程會發現可以回收的物件時，它會檢查每個物件，以判斷物件的最終處理需求。 如果物件實作完成項且具有未停用最終處理藉由呼叫<xref:System.GC.SuppressFinalize%2A>，該物件放在標示為準備進行最終處理物件的清單。 記憶體回收行程呼叫<xref:System.Object.Finalize%2A>此清單中移除的項目從清單中物件的方法。 這個方法會封鎖直到所有的完成項已完成執行。  
  
 完成項執行所在的執行緒未指定，因此不保證此方法將會終止。 不過，這個執行緒可以會暫時中斷時的另一個執行緒<xref:System.GC.WaitForPendingFinalizers%2A>方法正在進行中。 例如，您可以啟動另一個執行緒等候一段時間，然後插斷這個執行緒，如果仍然暫止這個執行緒。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.GC.WaitForPendingFinalizers%2A>暫停目前的執行緒，直到最終處理的所有收集到的物件已完成的方法。  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>