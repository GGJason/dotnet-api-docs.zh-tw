<Type Name="GC" FullName="System.GC">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6c38b21659aa141b32c988dfe140585d7feda29b" />
    <Meta Name="ms.sourcegitcommit" Value="9d1bf7e4c6d697123f26c810c1a049a755634634" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="12/06/2018" />
    <Meta Name="ms.locfileid" Value="52982016" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="36d63-101">控制系統記憶體回收行程，它是自動回收未使用之記憶體的服務。</span>
      <span class="sxs-lookup">
        <span data-stu-id="36d63-101">Controls the system garbage collector, a service that automatically reclaims unused memory.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-102">記憶體回收行程是控制項的配置和釋放的 managed 記憶體 common language runtime 元件。</span><span class="sxs-lookup"><span data-stu-id="36d63-102">The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</span></span> <span data-ttu-id="36d63-103">物件上並釋放物件所配置的資源執行記憶體回收時，就會影響此類別中的方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-103">The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</span></span> <span data-ttu-id="36d63-104">此類別中的屬性系統和年齡類別目錄或產生，配置給物件的記憶體中提供可用的記憶體總數量的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="36d63-104">Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</span></span>  
  
 <span data-ttu-id="36d63-105">記憶體回收行程會追蹤，並回收在受管理的記憶體中配置的物件。</span><span class="sxs-lookup"><span data-stu-id="36d63-105">The garbage collector tracks and reclaims objects allocated in managed memory.</span></span> <span data-ttu-id="36d63-106">會定期記憶體回收行程執行回收來回收記憶體配置給物件的有無有效的參考。</span><span class="sxs-lookup"><span data-stu-id="36d63-106">Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</span></span> <span data-ttu-id="36d63-107">使用提供的可用記憶體無法滿足記憶體要求時，會自動發生記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-107">Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</span></span> <span data-ttu-id="36d63-108">或者，應用程式可以強制記憶體回收集合使用<xref:System.GC.Collect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-108">Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.</span></span>  
  
 <span data-ttu-id="36d63-109">記憶體回收是由下列步驟所組成：</span><span class="sxs-lookup"><span data-stu-id="36d63-109">Garbage collection consists of the following steps:</span></span>  
  
1.  <span data-ttu-id="36d63-110">記憶體回收行程會搜尋在 managed 程式碼中參考的 managed 物件。</span><span class="sxs-lookup"><span data-stu-id="36d63-110">The garbage collector searches for managed objects that are referenced in managed code.</span></span>  
  
2.  <span data-ttu-id="36d63-111">記憶體回收行程會嘗試將完成未參考的物件。</span><span class="sxs-lookup"><span data-stu-id="36d63-111">The garbage collector tries to finalize objects that are not referenced.</span></span>  
  
3.  <span data-ttu-id="36d63-112">記憶體回收行程釋放未參考的物件，並回收其記憶體。</span><span class="sxs-lookup"><span data-stu-id="36d63-112">The garbage collector frees objects that are not referenced and reclaims their memory.</span></span>  
  
 <span data-ttu-id="36d63-113">本主題包含下列章節：</span><span class="sxs-lookup"><span data-stu-id="36d63-113">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="36d63-114">[記憶體回收行程和 unmanaged 的資源](#unmanaged) </span><span class="sxs-lookup"><span data-stu-id="36d63-114">[The garbage collector and unmanaged resources](#unmanaged) </span></span>  
 <span data-ttu-id="36d63-115">[物件的過時和層代](#generations) </span><span class="sxs-lookup"><span data-stu-id="36d63-115">[Object aging and generations](#generations) </span></span>  
 [<span data-ttu-id="36d63-116">不允許記憶體回收</span><span class="sxs-lookup"><span data-stu-id="36d63-116">Disallowing garbage collection</span></span>](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a><span data-ttu-id="36d63-117">記憶體回收行程和 unmanaged 的資源</span><span class="sxs-lookup"><span data-stu-id="36d63-117">The garbage collector and unmanaged resources</span></span>  
 <span data-ttu-id="36d63-118">在回收期間，記憶體回收行程不會釋放物件如果 managed 程式碼中找到一或多個物件的參考。</span><span class="sxs-lookup"><span data-stu-id="36d63-118">During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</span></span> <span data-ttu-id="36d63-119">不過，記憶體回收行程無法辨識從 unmanaged 程式碼，一個物件的參考，而且可能釋放物件，除非明確地防止這種方式使用 unmanaged 程式碼中以獨佔方式。</span><span class="sxs-lookup"><span data-stu-id="36d63-119">However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</span></span> <span data-ttu-id="36d63-120"><xref:System.GC.KeepAlive%2A>方法提供一種機制，防止記憶體回收行程收集是仍在使用 unmanaged 程式碼中的物件。</span><span class="sxs-lookup"><span data-stu-id="36d63-120">The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</span></span>  
  
 <span data-ttu-id="36d63-121">除了 managed 的記憶體配置的記憶體回收行程的實作不會維護物件，例如檔案控制代碼或資料庫連線所持有的資源的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="36d63-121">Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</span></span> <span data-ttu-id="36d63-122">當型別會使用型別的執行個體，會回收之前，必須先釋放的 unmanaged 的資源時，類型可以實作完成項。</span><span class="sxs-lookup"><span data-stu-id="36d63-122">When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</span></span>  
  
 <span data-ttu-id="36d63-123">在大部分情況下，完成項會實作藉由覆寫<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法; 不過，C# 或 c + + 撰寫的類型會實作解構函式的編譯器轉換成的覆寫<xref:System.Object.Finalize%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="36d63-123">In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="36d63-124">在大部分情況下，如果物件具有完成項，記憶體回收行程會呼叫它之前釋放物件。</span><span class="sxs-lookup"><span data-stu-id="36d63-124">In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</span></span> <span data-ttu-id="36d63-125">不過，記憶體回收行程並不需要在所有情況下，呼叫完成項比方說，<xref:System.GC.SuppressFinalize%2A>方法明確地防止物件的完成項呼叫。</span><span class="sxs-lookup"><span data-stu-id="36d63-125">However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called.</span></span> <span data-ttu-id="36d63-126">此外，記憶體回收行程不需要使用特定的執行緒完成物件，或是保證彼此參考，但可進行記憶體回收的物件呼叫完成項的順序。</span><span class="sxs-lookup"><span data-stu-id="36d63-126">Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</span></span>  
  
 <span data-ttu-id="36d63-127">在指定的時間必須釋放資源的情況下，類別可以實作<xref:System.IDisposable>介面，其中包含<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>方法，以執行資源管理和清除工作。</span><span class="sxs-lookup"><span data-stu-id="36d63-127">In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method that performs resource management and cleanup tasks.</span></span> <span data-ttu-id="36d63-128">類別實作<xref:System.IDisposable.Dispose%2A>必須指定，其類別合約是否以及何時類別的取用者呼叫方法，以清除物件。</span><span class="sxs-lookup"><span data-stu-id="36d63-128">Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</span></span> <span data-ttu-id="36d63-129">記憶體回收行程不會根據預設，呼叫<xref:System.IDisposable.Dispose%2A>方法; 不過，實作<xref:System.IDisposable.Dispose%2A>方法可以呼叫方法中<xref:System.GC>類別來自訂記憶體回收行程的最終處理行為。</span><span class="sxs-lookup"><span data-stu-id="36d63-129">The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.</span></span>  
  
 <span data-ttu-id="36d63-130">如需有關物件最終處理和 dispose 模式的詳細資訊，請參閱[清除 Unmanaged 資源總](~/docs/standard/garbage-collection/unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="36d63-130">For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a><span data-ttu-id="36d63-131">物件的過時和層代</span><span class="sxs-lookup"><span data-stu-id="36d63-131">Object aging and generations</span></span>  
 <span data-ttu-id="36d63-132">Common language runtime 在記憶體回收行程會支援使用層代物件過時。</span><span class="sxs-lookup"><span data-stu-id="36d63-132">The garbage collector in the common language runtime supports object aging using generations.</span></span> <span data-ttu-id="36d63-133">層代是測量的記憶體中物件的相對存在時間單位。</span><span class="sxs-lookup"><span data-stu-id="36d63-133">A generation is a unit of measure of the relative age of objects in memory.</span></span> <span data-ttu-id="36d63-134">層代編號或年齡，物件表示物件所屬的產生。</span><span class="sxs-lookup"><span data-stu-id="36d63-134">The generation number, or age, of an object indicates the generation to which an object belongs.</span></span> <span data-ttu-id="36d63-135">建立多個物件最近屬於較新的層代，而且必須小於物件稍早建立的應用程式生命週期的層代編號。</span><span class="sxs-lookup"><span data-stu-id="36d63-135">Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</span></span> <span data-ttu-id="36d63-136">最新的層代中的物件是在層代 0。</span><span class="sxs-lookup"><span data-stu-id="36d63-136">Objects in the most recent generation are in generation 0.</span></span> <span data-ttu-id="36d63-137">記憶體回收行程的這項實作支援之物件的三個層代，這些層代 0、 1 和 2。</span><span class="sxs-lookup"><span data-stu-id="36d63-137">This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</span></span> <span data-ttu-id="36d63-138">您可以擷取的值<xref:System.GC.MaxGeneration%2A>屬性，以判斷系統所支援的最大層代編號。</span><span class="sxs-lookup"><span data-stu-id="36d63-138">You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.</span></span>  
  
 <span data-ttu-id="36d63-139">物件的時效性會允許目標回收應用程式在一組特定的層代，而不需要評估所有層代記憶體回收行程。</span><span class="sxs-lookup"><span data-stu-id="36d63-139">Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</span></span> <span data-ttu-id="36d63-140">多載<xref:System.GC.Collect%2A>方法，包括`generation`參數可讓您指定要進行記憶體回收的最舊層代。</span><span class="sxs-lookup"><span data-stu-id="36d63-140">Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.</span></span>  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a><span data-ttu-id="36d63-141">不允許記憶體回收</span><span class="sxs-lookup"><span data-stu-id="36d63-141">Disallowing garbage collection</span></span>  
 <span data-ttu-id="36d63-142">從開始[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，記憶體回收行程支援無 GC 區域延遲模式可在記憶體回收的集合可能會影響應用程式效能的關鍵路徑期間。</span><span class="sxs-lookup"><span data-stu-id="36d63-142">Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</span></span> <span data-ttu-id="36d63-143">無 GC 區域延遲模式會要求您指定可從記憶體回收行程配置不受干擾的記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="36d63-143">The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</span></span> <span data-ttu-id="36d63-144">如果執行階段可以配置的記憶體，執行階段不會執行回收時執行的關鍵路徑中的程式碼。</span><span class="sxs-lookup"><span data-stu-id="36d63-144">If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</span></span>  
  
 <span data-ttu-id="36d63-145">您藉由呼叫其中一個多載定義的無 GC 區域的關鍵路徑的開頭<xref:System.GC.TryStartNoGCRegion%2A>。</span><span class="sxs-lookup"><span data-stu-id="36d63-145">You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>.</span></span> <span data-ttu-id="36d63-146">您可以指定其關鍵路徑的結尾呼叫<xref:System.GC.EndNoGCRegion%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-146">You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 <span data-ttu-id="36d63-147">您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。</span><span class="sxs-lookup"><span data-stu-id="36d63-147">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="36d63-148">換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），而且不應會呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功的第一次呼叫時，就算<xref:System.GC.TryStartNoGCRegion%2A>成功。</span><span class="sxs-lookup"><span data-stu-id="36d63-148">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-149">下列範例會使用數個 GC 方法來取得產生和記憶體區塊的未使用物件的相關的資訊，並列印到主控台。</span><span class="sxs-lookup"><span data-stu-id="36d63-149">The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</span></span> <span data-ttu-id="36d63-150">然後回收未使用的物件，並會顯示產生的記憶體總計。</span><span class="sxs-lookup"><span data-stu-id="36d63-150">The unused objects are then collected, and the resulting memory totals are displayed.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md">
      <span data-ttu-id="36d63-151">記憶體回收</span>
      <span class="sxs-lookup">
        <span data-stu-id="36d63-151">Garbage Collection</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
      <span data-ttu-id="36d63-152">記憶體回收的基本概念</span>
      <span class="sxs-lookup">
        <span data-stu-id="36d63-152">Fundamentals of Garbage Collection</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">
          <span data-ttu-id="36d63-153">已配置的 Unmanaged 記憶體累加數量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-153">The incremental amount of unmanaged memory that has been allocated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-154">告知執行階段，在排定記憶體回收時應考慮的大量 Unmanaged 記憶體配置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-154">Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-155">在決定何時要排定記憶體回收時，執行階段會考慮到配置的受管理的記憶體。</span><span class="sxs-lookup"><span data-stu-id="36d63-155">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="36d63-156">如果小型的 managed 的物件會配置大量 unmanaged 記憶體，執行階段會考量只受管理的記憶體，並因此低估排定記憶體回收的急迫性。</span><span class="sxs-lookup"><span data-stu-id="36d63-156">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="36d63-157"><xref:System.GC.AddMemoryPressure%2A>方法告知執行階段，此額外系統記憶體不足的壓力。</span><span class="sxs-lookup"><span data-stu-id="36d63-157">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.</span></span>  
  
 <span data-ttu-id="36d63-158">在最簡單的使用方式模式中，受管理的物件配置建構函式中的 unmanaged 的記憶體和釋放它在`Dispose`或`Finalize`方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-158">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="36d63-159">呼叫<xref:System.GC.AddMemoryPressure%2A>方法之後配置 unmanaged 的記憶體中，並呼叫<xref:System.GC.RemoveMemoryPressure%2A>之後釋放它的方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-159">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="36d63-160">在更複雜的案例，其中的 unmanaged 的記憶體配置的 managed 物件的存留期間變更本質上，您可以呼叫<xref:System.GC.AddMemoryPressure%2A>和<xref:System.GC.RemoveMemoryPressure%2A>通訊這些執行階段的累加變更的方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-160">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="36d63-161">您必須確定您移除完全您新增的壓力總量。</span><span class="sxs-lookup"><span data-stu-id="36d63-161">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="36d63-162">不這麼做的話，可能會影響在系統中的長時間執行的應用程式的效能。</span><span class="sxs-lookup"><span data-stu-id="36d63-162">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="36d63-163">
            <paramref name="bytesAllocated" /> 小於或等於 0。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-163">
              <paramref name="bytesAllocated" /> is less than or equal to 0.</span>
          </span>
          <span data-ttu-id="36d63-164">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-164">-or-</span>
          </span>
          <span data-ttu-id="36d63-165">在 32 位元電腦上，<paramref name="bytesAllocated" /> 大於 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-165">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="36d63-166">提供管理回收優先順序時，呼叫 unmanaged 程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-166">for the ability to call unmanaged code when manipulating garbage-collection priority.</span>
          </span>
          <span data-ttu-id="36d63-167">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-167">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="36d63-168">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-168">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-169">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-169">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="36d63-170">取消註冊記憶體回收通知。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-170">Cancels the registration of a garbage collection notification.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-171">這個方法會取消所註冊的使用記憶體回收通知<xref:System.GC.RegisterForFullGCNotification%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-171">This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="36d63-172">您不需要調整臨界值參數值，在後續呼叫之前呼叫這個方法<xref:System.GC.RegisterForFullGCNotification%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-172">You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-173">下列範例會先取消記憶體回收註冊。</span><span class="sxs-lookup"><span data-stu-id="36d63-173">The following example cancels a garbage collection registration.</span></span> <span data-ttu-id="36d63-174">這個範例是針對提供之較大範例的一部分[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)主題。</span><span class="sxs-lookup"><span data-stu-id="36d63-174">This example is part of a larger example provided for the [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="36d63-175">啟用並行記憶體回收時，無法使用這個成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-175">This member is not available when concurrent garbage collection is enabled.</span>
          </span>
          <span data-ttu-id="36d63-176">如需如何停用並行記憶體回收的資訊，請參閱 [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) 執行階段設定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-176">See the [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="36d63-177">針對完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-177">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-178">這個成員無法供部分信任的程式碼使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-178">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="36d63-179">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-179">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-180">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-180">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="36d63-181">記憶體回收告知</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-181">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="36d63-182">強制記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-182">Forces garbage collection.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="36d63-183">強制立即執行所有層代的記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-183">Forces an immediate garbage collection of all generations.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-184">使用這個方法，嘗試回收所有無法存取的記憶體。</span><span class="sxs-lookup"><span data-stu-id="36d63-184">Use this method to try to reclaim all memory that is inaccessible.</span></span> <span data-ttu-id="36d63-185">它會執行封鎖記憶體回收所有層代。</span><span class="sxs-lookup"><span data-stu-id="36d63-185">It performs a blocking garbage collection of all generations.</span></span>  
  
 <span data-ttu-id="36d63-186">所有的物件，不論時間已在記憶體中，會被視為集合;不過，不會收集在 managed 程式碼中參考的物件。</span><span class="sxs-lookup"><span data-stu-id="36d63-186">All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</span></span> <span data-ttu-id="36d63-187">您可以使用此方法，強制系統將嘗試回收的最大可用記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="36d63-187">Use this method to force the system to try to reclaim the maximum amount of available memory.</span></span>  
  
 <span data-ttu-id="36d63-188">開頭[!INCLUDE[net_v451](~/includes/net-v451-md.md)]，您可以藉由設定壓縮大型物件堆積 (LOH)<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>屬性設<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>再呼叫<xref:System.GC.Collect%2A>方法，如下列範例會示範。</span><span class="sxs-lookup"><span data-stu-id="36d63-188">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="36d63-189">下列範例示範如何使用<xref:System.GC.Collect%2A>執行回收所有層代的記憶體上的方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-189">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on all generations of memory.</span></span> <span data-ttu-id="36d63-190">程式碼會產生多個未使用的物件，然後再呼叫<xref:System.GC.Collect%2A>方法，以從記憶體清除它們。</span><span class="sxs-lookup"><span data-stu-id="36d63-190">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">
          <span data-ttu-id="36d63-191">引發的集合</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-191">Induced Collections</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="36d63-192">要進行記憶體回收的最舊層代數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-192">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-193">強制立即執行層代 0 至指定層代的記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-193">Forces an immediate garbage collection from generation 0 through a specified generation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-194">嘗試以回收記憶體而無法使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-194">Use this method to try to reclaim memory that is inaccessible.</span></span> <span data-ttu-id="36d63-195">不過，使用此方法不保證會回收所有存取的記憶體中指定的層代。</span><span class="sxs-lookup"><span data-stu-id="36d63-195">However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="36d63-196">如果實作物件過時，記憶體回收行程不會收集物件以產生數字大於指定層代。</span><span class="sxs-lookup"><span data-stu-id="36d63-196">If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</span></span> <span data-ttu-id="36d63-197">如果未實作物件過時，記憶體回收行程會考慮所有物件在記憶體回收期間。</span><span class="sxs-lookup"><span data-stu-id="36d63-197">If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</span></span>  
  
 <span data-ttu-id="36d63-198">使用<xref:System.GC.MaxGeneration%2A>屬性來判斷的最大有效值`generation`參數。</span><span class="sxs-lookup"><span data-stu-id="36d63-198">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter.</span></span>  
  
 <span data-ttu-id="36d63-199">若要考慮所有的物件，不論其層代記憶體回收行程，請使用這個方法不採用參數的版本。</span><span class="sxs-lookup"><span data-stu-id="36d63-199">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span> <span data-ttu-id="36d63-200">若要將記憶體回收行程回收物件根據<xref:System.GCCollectionMode>設定，使用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType>方法多載。</span><span class="sxs-lookup"><span data-stu-id="36d63-200">To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-201">下列範例示範如何使用<xref:System.GC.Collect%2A>執行回收記憶體的個別圖層上的方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-201">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on individual layers of memory.</span></span> <span data-ttu-id="36d63-202">程式碼會產生多個未使用的物件，然後再呼叫<xref:System.GC.Collect%2A>方法，以從記憶體清除它們。</span><span class="sxs-lookup"><span data-stu-id="36d63-202">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="36d63-203">
            <paramref name="generation" /> 無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-203">
              <paramref name="generation" /> is not valid.</span>
          </span>
        </exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">
          <span data-ttu-id="36d63-204">引發的集合</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-204">Induced Collections</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="36d63-205">要進行記憶體回收的最舊層代數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-205">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="36d63-206">列舉值，指定是要強制記憶體回收 (<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />) 還是進行最佳化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-206">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-207">在 <see cref="T:System.GCCollectionMode" /> 值所指定的時間，強制執行層代 0 至指定層代的記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-207">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-208">使用`mode`參數來指定是否發生記憶體回收應該立刻] 或 [僅時間是否最適合回收物件。</span><span class="sxs-lookup"><span data-stu-id="36d63-208">Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</span></span> <span data-ttu-id="36d63-209">使用此方法不保證會回收所有存取的記憶體中指定的層代。</span><span class="sxs-lookup"><span data-stu-id="36d63-209">Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="36d63-210">若要調整的應用程式中的重要期間回收干擾程度，請設定<xref:System.Runtime.GCSettings.LatencyMode%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="36d63-210">To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.</span></span>  
  
 <span data-ttu-id="36d63-211">記憶體回收行程不會收集物件與比所指定更高的層代編號`generation`參數。</span><span class="sxs-lookup"><span data-stu-id="36d63-211">The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter.</span></span> <span data-ttu-id="36d63-212">使用<xref:System.GC.MaxGeneration%2A>屬性來判斷的最大有效值`generation`。</span><span class="sxs-lookup"><span data-stu-id="36d63-212">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.</span></span>  
  
 <span data-ttu-id="36d63-213">若要考慮所有的物件，不論其層代記憶體回收行程，請使用這個方法不採用參數的版本。</span><span class="sxs-lookup"><span data-stu-id="36d63-213">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span>  
  
 <span data-ttu-id="36d63-214">若要將記憶體回收行程回收物件到指定的層代的物件，請使用<xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType>方法多載。</span><span class="sxs-lookup"><span data-stu-id="36d63-214">To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="36d63-215">當您指定最大層代時，則會收集所有物件。</span><span class="sxs-lookup"><span data-stu-id="36d63-215">When you specify the maximum generation, all objects are collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-216">下列範例會強制記憶體回收層代 2 物件<xref:System.GCCollectionMode.Optimized>設定。</span><span class="sxs-lookup"><span data-stu-id="36d63-216">The following example forces a garbage collection for generation 2 objects with the <xref:System.GCCollectionMode.Optimized> setting.</span></span>  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="36d63-217">
            <paramref name="generation" /> 無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-217">
              <paramref name="generation" /> is not valid.</span>
          </span>
          <span data-ttu-id="36d63-218">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-218">-or-</span>
          </span>
          <span data-ttu-id="36d63-219">
            <paramref name="mode" /> 不是其中一個 <see cref="T:System.GCCollectionMode" /> 值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-219">
              <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span>
          </span>
        </exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">
          <span data-ttu-id="36d63-220">引發的集合</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-220">Induced Collections</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="36d63-221">要進行記憶體回收的最舊層代數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-221">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="36d63-222">列舉值，指定是要強制記憶體回收 (<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />) 還是進行最佳化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-222">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <param name="blocking">
          <span data-ttu-id="36d63-223">
            <see langword="true" /> 表示要執行封鎖記憶體回收，<see langword="false" /> 表示要盡可能執行背景記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-223">
              <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-224">在 <see cref="T:System.GCCollectionMode" /> 值 (含有指定是否應該封鎖回收作業的值) 所指定的時間，強制執行從層代 0 到指定之層代的記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-224">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-225">下表摘要說明的互動`mode`和`blocking`參數：</span><span class="sxs-lookup"><span data-stu-id="36d63-225">The following table summarizes the interaction of the `mode` and `blocking` parameters:</span></span>  
  
|`mode`|<span data-ttu-id="36d63-226">`blocking` 是 `true`</span><span class="sxs-lookup"><span data-stu-id="36d63-226">`blocking` is `true`</span></span>|<span data-ttu-id="36d63-227">`blocking` 是 `false`</span><span class="sxs-lookup"><span data-stu-id="36d63-227">`blocking` is `false`</span></span>|  
|-|-|-|  
|<span data-ttu-id="36d63-228"><xref:System.GCCollectionMode.Forced> 或 <xref:System.GCCollectionMode.Default></span><span class="sxs-lookup"><span data-stu-id="36d63-228"><xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default></span></span>|<span data-ttu-id="36d63-229">會盡快執行封鎖回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-229">A blocking collection is performed as soon as possible.</span></span> <span data-ttu-id="36d63-230">如果正在進行背景回收並`generation`是 0 或 1，<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>方法立即觸發封鎖回收，並在回收完成時傳回。</span><span class="sxs-lookup"><span data-stu-id="36d63-230">If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished.</span></span> <span data-ttu-id="36d63-231">如果正在進行背景回收和`generation`為 2，方法會等到背景回收完成時，觸發封鎖層代 2 回收，，然後傳回。</span><span class="sxs-lookup"><span data-stu-id="36d63-231">If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</span></span>|<span data-ttu-id="36d63-232">會盡快執行回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-232">A collection is performed as soon as possible.</span></span> <span data-ttu-id="36d63-233"><xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> 方法會要求背景集合，但不保證可取得。視情況而定，可能仍會執行封鎖集合。</span><span class="sxs-lookup"><span data-stu-id="36d63-233">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="36d63-234">如果已在進行背景回收，則這個方法會立即返回。</span><span class="sxs-lookup"><span data-stu-id="36d63-234">If a background collection is already in progress, the method returns immediately.</span></span>|  
|<xref:System.GCCollectionMode.Optimized>|<span data-ttu-id="36d63-235">可能會因記憶體回收行程和 `generation` 參數的狀態而執行封鎖集合。</span><span class="sxs-lookup"><span data-stu-id="36d63-235">A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter.</span></span> <span data-ttu-id="36d63-236">記憶體回收行程會嘗試提供最佳效能。</span><span class="sxs-lookup"><span data-stu-id="36d63-236">The garbage collector tries to provide optimal performance.</span></span>|<span data-ttu-id="36d63-237">根據記憶體回收行程的狀態，可能會執行回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-237">A collection may be performed, depending on the state of the garbage collector.</span></span> <span data-ttu-id="36d63-238"><xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> 方法會要求背景集合，但不保證可取得。視情況而定，可能仍會執行封鎖集合。</span><span class="sxs-lookup"><span data-stu-id="36d63-238">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="36d63-239">記憶體回收行程會嘗試提供最佳效能。</span><span class="sxs-lookup"><span data-stu-id="36d63-239">The garbage collector tries to provide optimal performance.</span></span> <span data-ttu-id="36d63-240">如果已在進行背景回收，則這個方法會立即返回。</span><span class="sxs-lookup"><span data-stu-id="36d63-240">If a background collection is already in progress, the method returns immediately.</span></span>|  
  
 <span data-ttu-id="36d63-241">如果呼叫<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>方法會執行完全封鎖記憶體回收，您也可以藉由設定壓縮大型物件堆積<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>屬性設<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>再呼叫<xref:System.GC.Collect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-241">If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="36d63-242">
            <paramref name="generation" /> 無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-242">
              <paramref name="generation" /> is not valid.</span>
          </span>
          <span data-ttu-id="36d63-243">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-243">-or-</span>
          </span>
          <span data-ttu-id="36d63-244">
            <paramref name="mode" /> 不是其中一個 <see cref="T:System.GCCollectionMode" /> 值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-244">
              <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="36d63-245">要進行記憶體回收的最舊層代數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-245">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="36d63-246">列舉值，指定是要強制記憶體回收 (<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />) 還是進行最佳化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-246">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <param name="blocking">
          <span data-ttu-id="36d63-247">
            <see langword="true" /> 表示要執行封鎖記憶體回收，<see langword="false" /> 表示要盡可能執行背景記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-247">
              <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span>
          </span>
        </param>
        <param name="compacting">
          <span data-ttu-id="36d63-248">
            <see langword="true" /> 表示壓縮小型物件堆積；<see langword="false" /> 表示僅整理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-248">
              <see langword="true" /> to compact the small object heap; <see langword="false" /> to sweep only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-249">在 <see cref="T:System.GCCollectionMode" /> 值 (含有指定是否應該封鎖及壓縮回收作業的值) 所指定的時間，強制執行從層代 0 到指定之層代的記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-249">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with values that specify whether the collection should be blocking and compacting.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-250">如果`blocking`是`false`，GC 會決定是否要執行為背景或封鎖記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-250">If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection.</span></span> <span data-ttu-id="36d63-251">如果`compacting`是`true`，它會執行封鎖記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-251">If `compacting` is `true`, it performs a blocking garbage collection.</span></span>  
  
 <span data-ttu-id="36d63-252">如果`compacting`是`true`，執行階段會壓縮小型物件堆積 (SOH)。</span><span class="sxs-lookup"><span data-stu-id="36d63-252">If `compacting` is `true`, the runtime compacts the small object heap (SOH).</span></span> <span data-ttu-id="36d63-253">大型物件堆積 (LOH) 不會壓縮，除非<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>屬性設定為<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="36d63-253">The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span></span> <span data-ttu-id="36d63-254">請注意，這也包含所有封鎖記憶體回收，不只是完整封鎖記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-254">Note that this includes all blocking garbage collections, not just full blocking garbage collections.</span></span>  
  
 <span data-ttu-id="36d63-255">您可以呼叫<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法，以減少大小最小，managed 的堆積，如下列程式碼片段所示。</span><span class="sxs-lookup"><span data-stu-id="36d63-255">You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</span></span>  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 <span data-ttu-id="36d63-256">指定`true`針對`compacting`引數可保證壓縮、 完整封鎖記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-256">Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection.</span></span> <span data-ttu-id="36d63-257">設定<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>屬性設<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>可確保會壓縮 LOH 和 SOH。</span><span class="sxs-lookup"><span data-stu-id="36d63-257">Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> ensures that both the LOH and SOH are compacted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="36d63-258">要判斷記憶體回收計數的物件層代。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-258">The generation of objects for which the garbage collection count is to be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-259">傳回指定物件層代已發生記憶體回收的次數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-259">Returns the number of times garbage collection has occurred for the specified generation of objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="36d63-260">自從啟動處理程序之後，指定層代已發生記憶體回收的次數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-260">The number of times garbage collection has occurred for the specified generation since the process was started.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-261">如果您實作您自己的資源管理，您可能需要強制執行記憶體回收會定期呼叫<xref:System.GC.Collect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-261">If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="36d63-262">因為這是成本高昂的作業，您可以略過進行記憶體回收發生最近的呼叫來改善效能。</span><span class="sxs-lookup"><span data-stu-id="36d63-262">Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</span></span> <span data-ttu-id="36d63-263">儲存所傳回的值<xref:System.GC.CollectionCount%2A>後立即呼叫<xref:System.GC.Collect%2A>。</span><span class="sxs-lookup"><span data-stu-id="36d63-263">Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>.</span></span> <span data-ttu-id="36d63-264">您必須呼叫在下一次<xref:System.GC.Collect%2A>，所傳回的目前值相比較<xref:System.GC.CollectionCount%2A>已儲存的值。</span><span class="sxs-lookup"><span data-stu-id="36d63-264">The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value.</span></span> <span data-ttu-id="36d63-265">如果兩個值相等，在此過渡期間發生任何集合，而它可合理地呼叫<xref:System.GC.Collect%2A>一次。</span><span class="sxs-lookup"><span data-stu-id="36d63-265">If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="36d63-266">
            <paramref name="generation" /> 小於 0。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-266">
              <paramref name="generation" /> is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="36d63-267">結束無 GC 區域延遲模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-267">Ends the no GC region latency mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-268"><xref:System.GC.EndNoGCRegion%2A>方法會擲回<xref:System.InvalidOperationException>如果記憶體回收行程不處於無 GC 區域延遲模式。</span><span class="sxs-lookup"><span data-stu-id="36d63-268">The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode.</span></span> <span data-ttu-id="36d63-269">發生這種情況下任何下列條件：</span><span class="sxs-lookup"><span data-stu-id="36d63-269">This occurs under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="36d63-270"><xref:System.GC.TryStartNoGCRegion%2A>不先前呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-270">The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.</span></span>  
  
-   <span data-ttu-id="36d63-271">若要在呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="36d63-271">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`.</span></span>  
  
-   <span data-ttu-id="36d63-272">若要呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="36d63-272">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.</span></span>  
  
 <span data-ttu-id="36d63-273">您可以使用如下所示的程式碼的下列任何一個原因的檔案，以避免例外狀況：</span><span class="sxs-lookup"><span data-stu-id="36d63-273">You can prevent an exception for any of these reasons by using code such as the following:</span></span>  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="36d63-274">記憶體回收行程不在無 GC 區域延遲模式下。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-274">The garbage collector is not in no GC region latency mode.</span>
          </span>
          <span data-ttu-id="36d63-275">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-275">-or-</span>
          </span>
          <span data-ttu-id="36d63-276">無 GC 區域延遲模式之前已結束，因為已包含記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-276">The no GC region latency mode was ended previously because a garbage collection was induced.</span>
          </span>
          <span data-ttu-id="36d63-277">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-277">-or-</span>
          </span>
          <span data-ttu-id="36d63-278">記憶體配置超過 <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> 方法呼叫中所指定的數量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-278">A memory allocation exceeded the amount specified in the call to the <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> method.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="36d63-279">延遲模式</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-279">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="36d63-280">取得自目前執行緒的存留期開始，已配置給該執行緒的位元組總數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-280">Gets the total number of bytes allocated to the current thread since the beginning of its lifetime.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="36d63-281">自目前執行緒的存留期開始，已配置給該執行緒的位元組總數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-281">The total number of bytes allocated to the current thread since the beginning of its lifetime.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="36d63-282">`GetAllocatedBytesForCurrentThread`方法傳回的執行緒，而不的未被記憶體回收的位元組總數的存留期間，managed 堆積上配置的位元組總數。</span><span class="sxs-lookup"><span data-stu-id="36d63-282">The `GetAllocatedBytesForCurrentThread` method returns the total number of bytes allocated on the managed heap during the lifetime of a thread, not the total number of bytes that have survived garbage collection.</span></span> <span data-ttu-id="36d63-283">傳回的值也不包括任何原生的配置。</span><span class="sxs-lookup"><span data-stu-id="36d63-283">The returned value also does not include any native allocations.</span></span>

<span data-ttu-id="36d63-284">這個方法是在監視案例來測量時間間隔或事件之間的記憶體配置差異最有用的。</span><span class="sxs-lookup"><span data-stu-id="36d63-284">This method is most useful in monitoring scenarios for measuring the difference in memory allocation between time intervals or events.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="36d63-285">傳回物件的目前層代編號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-285">Returns the current generation number of an object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="36d63-286">要為其擷取層代資訊的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-286">The object that generation information is retrieved for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-287">傳回指定物件的目前層代編號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-287">Returns the current generation number of the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="36d63-288">
            <paramref name="obj" /> 的目前層代編號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-288">The current generation number of <paramref name="obj" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-289">使用此方法來判斷物件的時間，並接著使用該項資訊與<xref:System.GC.Collect%2A>相同的層代中的方法，以強制記憶體回收行程回收物件。</span><span class="sxs-lookup"><span data-stu-id="36d63-289">Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation.</span></span> <span data-ttu-id="36d63-290">例如，當您有一組群組所建立的並且在此同時，變成無法存取的物件時，才使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-290">For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-291">下列範例示範如何使用<xref:System.GC.GetGeneration%2A>方法，以判斷物件的存留期。</span><span class="sxs-lookup"><span data-stu-id="36d63-291">The following example demonstrates how to use the <xref:System.GC.GetGeneration%2A> method to determine the age of an object.</span></span> <span data-ttu-id="36d63-292">此範例接著會執行廢棄項目集合，來清除記憶體並比較前張貼集合在主控台中的記憶體總計。</span><span class="sxs-lookup"><span data-stu-id="36d63-292">The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">
          <span data-ttu-id="36d63-293">
            <see cref="T:System.WeakReference" />，參考要判斷層代編號的目標物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-293">A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-294">傳回指定弱式參考之目標的目前層代編號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-294">Returns the current generation number of the target of a specified weak reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="36d63-295">
            <paramref name="wo" /> 之目標的目前層代編號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-295">The current generation number of the target of <paramref name="wo" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="36d63-296">下列範例示範如何使用<xref:System.GC.GetGeneration%2A>方法，以判斷弱式參考物件的存留期。</span><span class="sxs-lookup"><span data-stu-id="36d63-296">The following example demonstrates the use of the <xref:System.GC.GetGeneration%2A> method to determine the age of a weak reference object.</span></span>  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="36d63-297">在 <paramref name="wo" /> 上已執行記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-297">Garbage collection has already been performed on <paramref name="wo" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">
          <span data-ttu-id="36d63-298">如果這個方法可以等待記憶體回收發生後再傳回則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-298">
              <see langword="true" /> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-299">擷取目前被視為已配置的位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-299">Retrieves the number of bytes currently thought to be allocated.</span>
          </span>
          <span data-ttu-id="36d63-300">參數會指出這個方法是否可以先等待短暫間隔後再傳回，以便讓系統回收記憶體和最終處理物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-300">A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="36d63-301">數目，為目前配置於 Managed 記憶體中位元組的最佳可用近似數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-301">A number that is the best available approximation of the number of bytes currently allocated in managed memory.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-302">如果`forceFullCollection`參數是`true`，這個方法會等候傳回之前在短時間內時，系統會收集記憶體回收，並終結物件。</span><span class="sxs-lookup"><span data-stu-id="36d63-302">If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects.</span></span> <span data-ttu-id="36d63-303">在內部指定的限制，取決於完成記憶體回收週期數目和復原循環之間的記憶體變更間隔的持續時間。</span><span class="sxs-lookup"><span data-stu-id="36d63-303">The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</span></span> <span data-ttu-id="36d63-304">記憶體回收行程並不保證會收集所有存取的記憶體。</span><span class="sxs-lookup"><span data-stu-id="36d63-304">The garbage collector does not guarantee that all inaccessible memory is collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-305">下列範例示範如何使用<xref:System.GC.GetTotalMemory%2A>方法來取得並顯示目前在受管理的記憶體中配置的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="36d63-305">The following example demonstrates how to use the <xref:System.GC.GetTotalMemory%2A> method to get and display the number of bytes currently allocated in managed memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="36d63-306">要參考的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-306">The object to reference.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-307">參考指定的物件，使它從目前常式的開始至呼叫這個方法時都不適合記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-307">References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-308">目的<xref:System.GC.KeepAlive%2A>方法可確保有風險的不當記憶體回收行程回收物件的參考是否存在。</span><span class="sxs-lookup"><span data-stu-id="36d63-308">The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</span></span> <span data-ttu-id="36d63-309">這可能發生的常見案例是當沒有物件參考，在 managed 程式碼或資料，但物件仍在使用處於未受管理的程式碼，例如 Win32 Api，unmanaged 的 Dll，或使用 COM 方法</span><span class="sxs-lookup"><span data-stu-id="36d63-309">A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.</span></span>  
  
 <span data-ttu-id="36d63-310">這個方法所參考`obj`參數，使該物件進行記憶體回收不適合從常式的開始點，以執行順序，會呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-310">This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</span></span> <span data-ttu-id="36d63-311">在結束時，不，範圍的開頭的指示，此方法的程式碼位置`obj`必須可供使用。</span><span class="sxs-lookup"><span data-stu-id="36d63-311">Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.</span></span>  
  
 <span data-ttu-id="36d63-312"><xref:System.GC.KeepAlive%2A>方法會執行任何作業，並產生非擴充做為參數傳入的物件的存留期沒有副作用。</span><span class="sxs-lookup"><span data-stu-id="36d63-312">The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-313">下列程式碼範例會建立物件的開頭及其`Main`方法並不是指的物件直到結束時時,<xref:System.GC.KeepAlive%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="36d63-313">The following code example creates an object at the beginning of its `Main` method and does not refer to the object again until the end, when the <xref:System.GC.KeepAlive%2A> method is called.</span></span> <span data-ttu-id="36d63-314">30 秒期間持續存在的物件`Main`方法，呼叫儘管<xref:System.GC.Collect%2A>和<xref:System.GC.WaitForPendingFinalizers%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-314">The object persists for the 30-second duration of the `Main` method, despite calls to the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods.</span></span>  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="36d63-315">取得系統目前支援的最大層代編號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-315">Gets the maximum number of generations that the system currently supports.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="36d63-316">範圍從零至所支援最大層代編號的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-316">A value that ranges from zero to the maximum number of supported generations.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-317">層代編號或年齡，物件是實作定義相對量值物件的存留時間。</span><span class="sxs-lookup"><span data-stu-id="36d63-317">The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</span></span> <span data-ttu-id="36d63-318">最近建立的物件層代 0 中，而且舊的物件是小於或等於產生傳回的層代中<xref:System.GC.MaxGeneration%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="36d63-318">The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.</span></span>  
  
 <span data-ttu-id="36d63-319">記憶體回收行程假設較新的記憶體是更有可能是比較舊的記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-319">The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</span></span> <span data-ttu-id="36d63-320">因此，記憶體回收行程回收記憶體，每次調整產生數字中改善其效能和<xref:System.GC.MaxGeneration%2A>屬性值可以隨著時間成長。</span><span class="sxs-lookup"><span data-stu-id="36d63-320">Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.</span></span>  
  
 <span data-ttu-id="36d63-321">如果實作物件過時，<xref:System.GC.MaxGeneration%2A>屬性會傳回系統所使用的最大層代編號; 否則這個屬性會傳回零。</span><span class="sxs-lookup"><span data-stu-id="36d63-321">If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-322">下列範例示範如何使用 MaxGeneration 屬性來顯示目前使用的最大的層代編號。</span><span class="sxs-lookup"><span data-stu-id="36d63-322">The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="36d63-323">此實作中，傳回的值由<see cref="P:System.GC.MaxGeneration" />屬性一定會執行的應用程式的存留期內保持不變。</span>
            <span class="sxs-lookup">
              <span data-stu-id="36d63-323">For this implementation, the value returned by the <see cref="P:System.GC.MaxGeneration" /> property is guaranteed to remain constant for the lifetime of an executing application.</span>
            </span>
            <span data-ttu-id="36d63-324">使用<see cref="P:System.GC.MaxGeneration" />屬性來判斷呼叫時，您可以指定的最大值<see cref="M:System.GC.Collect(System.Int32)" />採用 generation 參數的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="36d63-324">Use the <see cref="P:System.GC.MaxGeneration" /> property to determine the maximum value you can specify when calling the <see cref="M:System.GC.Collect(System.Int32)" /> method that takes a generation parameter.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">
          <span data-ttu-id="36d63-325">範圍從 1 到 99 的數字，指定何時應根據層代 2 中所配置的物件加以引發通知。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-325">A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</span>
          </span>
        </param>
        <param name="largeObjectHeapThreshold">
          <span data-ttu-id="36d63-326">範圍從 1 到 99 的數字，指定何時根據大型物件堆積中所配置的物件加以引發通知。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-326">A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-327">指定當情況需要完整記憶體回收時和回收完成時，應引發記憶體回收通知。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-327">Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-328">針對每個層代，記憶體回收行程會設定配置到該層代的臨界值。</span><span class="sxs-lookup"><span data-stu-id="36d63-328">For each generation, the garbage collector sets a threshold for allocations into that generation.</span></span> <span data-ttu-id="36d63-329">當配置的記憶體大小超過此臨界值時，該層代上觸發記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-329">When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</span></span> <span data-ttu-id="36d63-330">如範例中，如果層代 2 的臨界值是 20 MB （亦即 20 MB 不受影響的層代 1 回收和提升至層代 2），以及超過 20 MB 尚未被第 1 代，而且會提示輸入至層代 2，將會嘗試下一個記憶體回收為層代 2 回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-330">For example, if generation 2's threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</span></span> <span data-ttu-id="36d63-331">同樣地，如果大型物件堆積 (LOH) 的臨界值為 20 MB 和您的應用程式已配置超過 20 MB 的大型物件下, 一個記憶體回收也會嘗試為層代 2 集合 （因為 gen2 回收中，才會收集 LOH）。</span><span class="sxs-lookup"><span data-stu-id="36d63-331">Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</span></span>  
  
 <span data-ttu-id="36d63-332">`maxGenerationThreshold`和`largeObjectHeapThreshold`臨界值可讓您控制多少事先通知您發生完整記憶體回收之前。</span><span class="sxs-lookup"><span data-stu-id="36d63-332">The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs.</span></span> <span data-ttu-id="36d63-333">大於臨界值，可能會發生通知與下一個完整記憶體回收之間的多個配置。</span><span class="sxs-lookup"><span data-stu-id="36d63-333">The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</span></span>  
  
 <span data-ttu-id="36d63-334">如果您已在其中完整記憶體回收的 common language runtime 會效能產生負面影響您的應用程式的情況下，您可以要求在執行階段即將執行完整記憶體回收，並對讓該集合時收到通知自行引發集合 (使用<xref:System.GC.Collect%2A>方法) 時仍有利於條件。</span><span class="sxs-lookup"><span data-stu-id="36d63-334">If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable.</span></span> <span data-ttu-id="36d63-335">除了自行變更廢棄項目集合排程，完整的 GC 通知是用於下列案例：</span><span class="sxs-lookup"><span data-stu-id="36d63-335">In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</span></span>  
  
-   <span data-ttu-id="36d63-336">您完整記憶體回收的方法進行監視，並當系統通知您即將達到其中一個，您即時資料的大小縮減 （比方說，釋出一些快取項目）。</span><span class="sxs-lookup"><span data-stu-id="36d63-336">You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</span></span> <span data-ttu-id="36d63-337">如此一來，當記憶體回收發生時，它就能夠以回收更多的記憶體。</span><span class="sxs-lookup"><span data-stu-id="36d63-337">As a result, when the garbage collection occurs, it is able to reclaim more memory.</span></span>  
  
-   <span data-ttu-id="36d63-338">您完整記憶體回收完成監視，而您可以收集一些統計資料。</span><span class="sxs-lookup"><span data-stu-id="36d63-338">You monitor for the completion of a full garbage collection so that you can collect some statistics.</span></span>  <span data-ttu-id="36d63-339">比方說，您可能想要測量 GC 完成在堆積的大小，好讓您知道即時資料的大小。</span><span class="sxs-lookup"><span data-stu-id="36d63-339">For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</span></span> <span data-ttu-id="36d63-340">（在完整的 GC 之後, 堆積是以其最小的大小）。</span><span class="sxs-lookup"><span data-stu-id="36d63-340">(After a full GC, the heap is at its smallest size.)</span></span>  
  
 <span data-ttu-id="36d63-341">如需有關所代表的意義完整記憶體回收的詳細資訊，請參閱[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)。</span><span class="sxs-lookup"><span data-stu-id="36d63-341">For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md).</span></span>  
  
 <span data-ttu-id="36d63-342">當您註冊記憶體回收通知時，您就可以收到已接近完整記憶體回收時，並在完成時。</span><span class="sxs-lookup"><span data-stu-id="36d63-342">When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</span></span> <span data-ttu-id="36d63-343">此模式類似於作業系統如何監視記憶體不足的通知。</span><span class="sxs-lookup"><span data-stu-id="36d63-343">This pattern resembles how the operating system monitors for low memory notifications.</span></span>  
  
 <span data-ttu-id="36d63-344">使用下列指導方針來指定`maxGenerationThreshold`和`largeObjectHeapThreshold`參數：</span><span class="sxs-lookup"><span data-stu-id="36d63-344">Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:</span></span>  
  
-   <span data-ttu-id="36d63-345">臨界值越大，更多的配置會通知與完整記憶體回收之間發生。</span><span class="sxs-lookup"><span data-stu-id="36d63-345">The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</span></span>  
  
     <span data-ttu-id="36d63-346">較大的臨界值會提供更多的機會，讓執行階段檢查即將進行的回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-346">A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</span></span> <span data-ttu-id="36d63-347">這會增加您會收到通知的可能性。</span><span class="sxs-lookup"><span data-stu-id="36d63-347">This increases the likelihood that you will be notified.</span></span> <span data-ttu-id="36d63-348">不過，您不應該設定的臨界值太高，因為這會導致更多的配置之前執行階段引發的下一步 的集合。</span><span class="sxs-lookup"><span data-stu-id="36d63-348">However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</span></span>  
  
     <span data-ttu-id="36d63-349">當您自行引發回收通知使用高臨界值時，較少的物件會回收比原本回收的執行階段的下一步 的集合。</span><span class="sxs-lookup"><span data-stu-id="36d63-349">When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</span></span>  
  
-   <span data-ttu-id="36d63-350">較小的臨界值，較少通知與完整記憶體回收之間配置。</span><span class="sxs-lookup"><span data-stu-id="36d63-350">The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-351">下列範例示範如何註冊記憶體回收通知，並啟動執行緒來監視記憶體回收通知的狀態。</span><span class="sxs-lookup"><span data-stu-id="36d63-351">The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</span></span> <span data-ttu-id="36d63-352">此程式碼範例是針對提供之較大範例的一部分[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)主題。</span><span class="sxs-lookup"><span data-stu-id="36d63-352">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="36d63-353">
            <paramref name="maxGenerationThreshold" /> 或 <paramref name="largeObjectHeapThreshold" /> 未介於 1 和 99 之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-353">
              <paramref name="maxGenerationThreshold" /> or <paramref name="largeObjectHeapThreshold" /> is not between 1 and 99.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="36d63-354">針對完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-354">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-355">這個成員無法供部分信任的程式碼使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-355">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="36d63-356">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-356">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-357">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-357">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="36d63-358">記憶體回收告知</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-358">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">
          <span data-ttu-id="36d63-359">已釋放的 Unmanaged 記憶體數量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-359">The amount of unmanaged memory that has been released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-360">告知執行階段，Unmanaged 記憶體已釋放，所以排定記憶體回收時不需要再考慮它。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-360">Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-361">在決定何時要排定記憶體回收時，執行階段會考慮到配置的受管理的記憶體。</span><span class="sxs-lookup"><span data-stu-id="36d63-361">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="36d63-362">如果小型的 managed 的物件會配置大量 unmanaged 記憶體，執行階段會考量只受管理的記憶體，並因此低估排定記憶體回收的急迫性。</span><span class="sxs-lookup"><span data-stu-id="36d63-362">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="36d63-363"><xref:System.GC.AddMemoryPressure%2A>方法會通知執行階段的系統記憶體，造成此額外的壓力和<xref:System.GC.RemoveMemoryPressure%2A>方法會通知執行階段造成額外的壓力，已發行。</span><span class="sxs-lookup"><span data-stu-id="36d63-363">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.</span></span>  
  
 <span data-ttu-id="36d63-364">在最簡單的使用方式模式中，受管理的物件配置建構函式中的 unmanaged 的記憶體和釋放它在`Dispose`或`Finalize`方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-364">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="36d63-365">呼叫<xref:System.GC.AddMemoryPressure%2A>方法之後配置 unmanaged 的記憶體中，並呼叫<xref:System.GC.RemoveMemoryPressure%2A>之後釋放它的方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-365">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="36d63-366">在更複雜的案例，其中的 unmanaged 的記憶體配置的 managed 物件的存留期間變更本質上，您可以呼叫<xref:System.GC.AddMemoryPressure%2A>和<xref:System.GC.RemoveMemoryPressure%2A>通訊這些執行階段的累加變更的方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-366">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="36d63-367">您必須確定您移除完全您新增的壓力總量。</span><span class="sxs-lookup"><span data-stu-id="36d63-367">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="36d63-368">不這麼做的話，可能會影響在系統中的長時間執行的應用程式的效能。</span><span class="sxs-lookup"><span data-stu-id="36d63-368">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="36d63-369">
            <paramref name="bytesAllocated" /> 小於或等於 0。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-369">
              <paramref name="bytesAllocated" /> is less than or equal to 0.</span>
          </span>
          <span data-ttu-id="36d63-370">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-370">-or-</span>
          </span>
          <span data-ttu-id="36d63-371">在 32 位元電腦上，<paramref name="bytesAllocated" /> 大於 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-371">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="36d63-372">提供管理回收優先順序時，呼叫 unmanaged 程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-372">for the ability to call unmanaged code when manipulating garbage-collection priority.</span>
          </span>
          <span data-ttu-id="36d63-373">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-373">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="36d63-374">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-374">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-375">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-375">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="36d63-376">必須呼叫完成項的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-376">The object that a finalizer must be called for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-377">要求系統為指定物件 (先前已經為其呼叫 <see cref="M:System.GC.SuppressFinalize(System.Object)" />) 呼叫完成項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-377">Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-378"><xref:System.GC.ReRegisterForFinalize%2A>方法會將`obj`參數的記憶體回收行程釋放物件之前，要求最終處理的物件清單。</span><span class="sxs-lookup"><span data-stu-id="36d63-378">The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object.</span></span> <span data-ttu-id="36d63-379">`obj`參數必須是這個方法的呼叫端。</span><span class="sxs-lookup"><span data-stu-id="36d63-379">The `obj` parameter must be the caller of this method.</span></span>  
  
 <span data-ttu-id="36d63-380">呼叫<xref:System.GC.ReRegisterForFinalize%2A>方法不保證記憶體回收行程會呼叫物件的完成項。</span><span class="sxs-lookup"><span data-stu-id="36d63-380">Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.</span></span>  
  
 <span data-ttu-id="36d63-381">根據預設，會實作完成項的所有物件都加入到需要結束; 的物件清單不過，物件可能已經結束，或可能已停用完成項呼叫<xref:System.GC.SuppressFinalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-381">By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 <span data-ttu-id="36d63-382">完成項可以使用這個方法，重新恢復它本身或它所參考的物件。</span><span class="sxs-lookup"><span data-stu-id="36d63-382">A finalizer can use this method to resurrect itself or an object that it references.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-383">下列範例示範如何使用 ReRegisterForFinalize; 方法來完成第二個物件回收之後的時間。</span><span class="sxs-lookup"><span data-stu-id="36d63-383">The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</span></span>  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="36d63-384">
            <paramref name="obj" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-384">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="36d63-385">完成項不得執行的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-385">The object whose finalizer must not be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-386">要求 Common Language Runtime 不要為指定之物件呼叫完成項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-386">Requests that the common language runtime not call the finalizer for the specified object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-387">這個方法的物件標頭中設定一個位元`obj`，當呼叫完成項，執行階段檢查。</span><span class="sxs-lookup"><span data-stu-id="36d63-387">This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers.</span></span> <span data-ttu-id="36d63-388">完成項，由表示<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法，用來物件被記憶體回收前釋放 unmanaged 的資源。</span><span class="sxs-lookup"><span data-stu-id="36d63-388">A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method, is used to release unmanaged resources before an object is garbage-collected.</span></span> <span data-ttu-id="36d63-389">如果`obj`沒有完成項，呼叫<xref:System.GC.SuppressFinalize%2A>方法沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="36d63-389">If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.</span></span>  
  
 <span data-ttu-id="36d63-390">物件，實作<xref:System.IDisposable>介面可以從物件的呼叫此方法<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>實作，以防止記憶體回收行程呼叫<xref:System.Object.Finalize%2A?displayProperty=nameWithType>上不需要的物件。</span><span class="sxs-lookup"><span data-stu-id="36d63-390">Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=nameWithType> on an object that does not require it.</span></span> <span data-ttu-id="36d63-391">一般而言，這為了釋放已由釋放的 unmanaged 的資源時，防止完成項<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>實作。</span><span class="sxs-lookup"><span data-stu-id="36d63-391">Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-392">下列範例示範如何使用<xref:System.GC.SuppressFinalize%2A>中的資源類別，以避免重複回收，呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-392">The following example demonstrates how to use the <xref:System.GC.SuppressFinalize%2A> method in a resource class to prevent a redundant garbage collection from being called.</span></span> <span data-ttu-id="36d63-393">此範例會使用[處置模式](~/docs/standard/design-guidelines/dispose-pattern.md)同時釋放 managed 資源 (也就是物件實作<xref:System.IDisposable>) 與 unmanaged 資源。</span><span class="sxs-lookup"><span data-stu-id="36d63-393">The example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) to free both managed resources (that is, objects that implement <xref:System.IDisposable>) and unmanaged resources.</span></span>  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="36d63-394">
            <paramref name="obj" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-394">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="https://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb">
          <span data-ttu-id="36d63-395">Dispose 模式</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-395">Dispose Pattern</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="36d63-396">嘗試在執行關鍵路徑期間，禁止記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-396">Attempts to disallow garbage collection during the execution of a critical path.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="36d63-397">您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。</span><span class="sxs-lookup"><span data-stu-id="36d63-397">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="36d63-398">換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），而且不應會呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功的第一次呼叫時，就算<xref:System.GC.TryStartNoGCRegion%2A>成功。</span><span class="sxs-lookup"><span data-stu-id="36d63-398">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="36d63-399">在不觸發記憶體回收的情況下，要配置的記憶體數量 (以位元組為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-399">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="36d63-400">該值必須小於或等於暫時區段的大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-400">It must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="36d63-401">如需暫時區段大小的資訊，請參閱[記憶體回收的基本概念](~/docs/standard/garbage-collection/fundamentals.md)一文中的＜暫時層代和區段＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-401">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-402">嘗試在有指定數量記憶體可用時，於執行關鍵路徑期間，禁止記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-402">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="36d63-403">如果執行階段可以認可所需的記憶體數量且記憶體回收行程可以進入無 GC 區域延遲模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-403">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-404"><xref:System.GC.TryStartNoGCRegion%28System.Int64%29>方法會嘗試將記憶體回收行程放在應用程式執行的程式碼的關鍵區域時，不允許記憶體回收無 GC 區域延遲模式。</span><span class="sxs-lookup"><span data-stu-id="36d63-404">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="36d63-405">如果執行階段無法一開始配置要求的記憶體數量，記憶體回收行程會執行完全封鎖記憶體回收，嘗試釋放其他記憶體。</span><span class="sxs-lookup"><span data-stu-id="36d63-405">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="36d63-406">記憶體回收行程會進入無 GC 區域延遲模式，如果無法配置所需的數量的記憶體，在此情況下為實際 2 \*`totalSize`位元組 (它會嘗試配置`totalSize`小型物件堆積位元組和`totalSize`的位元組數大型物件堆積）。</span><span class="sxs-lookup"><span data-stu-id="36d63-406">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).</span></span>  
  
 <span data-ttu-id="36d63-407">`totalSize` 必須夠大，無法處理發生的關鍵路徑中的所有記憶體配置。</span><span class="sxs-lookup"><span data-stu-id="36d63-407">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="36d63-408">這包括應用程式時，所配置，以及執行階段可讓應用程式的名義的配置。</span><span class="sxs-lookup"><span data-stu-id="36d63-408">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="36d63-409">您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。</span><span class="sxs-lookup"><span data-stu-id="36d63-409">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="36d63-410">換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），而且不應會呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功的第一次呼叫時，就算<xref:System.GC.TryStartNoGCRegion%2A>成功。</span><span class="sxs-lookup"><span data-stu-id="36d63-410">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="36d63-411">您藉由呼叫結束無 GC 區域延遲模式<xref:System.GC.EndNoGCRegion%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-411">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="36d63-412">
            <paramref name="totalSize" /> 超過暫時區段的大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-412">
              <paramref name="totalSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="36d63-413">處理序處於無 GC 區域延遲模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-413">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
          <span data-ttu-id="36d63-414">記憶體回收的基本概念</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-414">Fundamentals of Garbage Collection</span>
          </span>
        </related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="36d63-415">延遲模式</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-415">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="36d63-416">在不觸發記憶體回收的情況下，要配置的記憶體數量 (以位元組為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-416">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="36d63-417">該值必須小於或等於暫時區段的大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-417">It must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="36d63-418">如需暫時區段大小的資訊，請參閱[記憶體回收的基本概念](~/docs/standard/garbage-collection/fundamentals.md)一文中的＜暫時層代和區段＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-418">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="disallowFullBlockingGC">
          <span data-ttu-id="36d63-419">
            <see langword="true" /> 表示如果記憶體回收行程最初無法配置 <paramref name="totalSize" /> 個位元組，則省略完全封鎖記憶體回收；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-419">
              <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <paramref name="totalSize" /> bytes; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-420">嘗試在有指定數量記憶體可用時，於執行關鍵路徑期間，禁止記憶體回收，並控制在最初沒有足夠的記憶體可用時，記憶體回收行程是否執行完全封鎖記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-420">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="36d63-421">如果執行階段可以認可所需的記憶體數量且記憶體回收行程可以進入無 GC 區域延遲模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-421">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-422"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29>方法會嘗試將記憶體回收行程放在應用程式執行的程式碼的關鍵區域時，不允許記憶體回收無 GC 區域延遲模式。</span><span class="sxs-lookup"><span data-stu-id="36d63-422">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="36d63-423">執行階段是否無法一開始配置要求的記憶體數量和`disallowFullBlockingGC`引數是`false`，記憶體回收行程執行完全封鎖記憶體回收，嘗試釋放其他記憶體; 否則配置失敗，而且方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="36d63-423">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="36d63-424">記憶體回收行程會進入無 GC 區域延遲模式，如果無法配置所需的數量的記憶體，在此情況下為實際 2 \* `totalSize` (它會嘗試配置`totalSize`針對小物件堆積和`totalSize`大型物件堆積）。</span><span class="sxs-lookup"><span data-stu-id="36d63-424">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).</span></span>  
  
 <span data-ttu-id="36d63-425">`totalSize` 必須夠大，無法處理發生的關鍵路徑中的所有記憶體配置。</span><span class="sxs-lookup"><span data-stu-id="36d63-425">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="36d63-426">這包括應用程式時，所配置，以及執行階段可讓應用程式的名義的配置。</span><span class="sxs-lookup"><span data-stu-id="36d63-426">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="36d63-427">設定`disallowFullBlockingGC`至`true`為了避免完整封鎖記憶體回收集合，如果沒有足夠的記憶體可用的一開始是在負載平衡案例中最有用： 一個系統呼叫這個方法，並準備好接受要求，如果它傳回為報表本身`true`，如果它傳回，將要求重新導向至其他系統的負載平衡器和`false`。</span><span class="sxs-lookup"><span data-stu-id="36d63-427">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="36d63-428">它不藉由呼叫來處理要求時，它可以再執行完全封鎖記憶體回收<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-428">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="36d63-429">您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。</span><span class="sxs-lookup"><span data-stu-id="36d63-429">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="36d63-430">換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），而且不應會呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功的第一次呼叫時，就算<xref:System.GC.TryStartNoGCRegion%2A>成功。</span><span class="sxs-lookup"><span data-stu-id="36d63-430">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="36d63-431">您藉由呼叫結束無 GC 區域延遲模式<xref:System.GC.EndNoGCRegion%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-431">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="36d63-432">
            <paramref name="totalSize" /> 超過暫時區段的大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-432">
              <paramref name="totalSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="36d63-433">處理序處於無 GC 區域延遲模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-433">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
          <span data-ttu-id="36d63-434">記憶體回收的基本概念</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-434">Fundamentals of Garbage Collection</span>
          </span>
        </related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="36d63-435">延遲模式</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-435">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="36d63-436">在不觸發記憶體回收的情況下，要配置的記憶體數量 (以位元組為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-436">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="36d63-437">
            <paramref name="totalSize" /> - <paramref name="lohSize" /> 必須小於或等於暫時區段的大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-437">
              <paramref name="totalSize" /> –<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="36d63-438">如需暫時區段大小的資訊，請參閱[記憶體回收的基本概念](~/docs/standard/garbage-collection/fundamentals.md)一文中的＜暫時層代和區段＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-438">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="lohSize">
          <span data-ttu-id="36d63-439">
            <paramref name="totalSize" /> 中要用於大型物件堆積 (LOH) 配置的位元組數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-439">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-440">嘗試在大型物件堆積與小型物件堆積有指定數量記憶體可用時，於執行關鍵路徑期間，禁止記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-440">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="36d63-441">如果執行階段可以認可所需的記憶體數量且記憶體回收行程可以進入無 GC 區域延遲模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-441">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-442"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29>方法會嘗試將記憶體回收行程放在應用程式執行的程式碼的關鍵區域時，不允許記憶體回收無 GC 區域延遲模式。</span><span class="sxs-lookup"><span data-stu-id="36d63-442">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="36d63-443">如果執行階段無法一開始配置要求的記憶體數量，記憶體回收行程會執行完全封鎖記憶體回收，嘗試釋放其他記憶體。</span><span class="sxs-lookup"><span data-stu-id="36d63-443">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="36d63-444">記憶體回收行程會進入無 GC 區域延遲模式，它是否能夠配置`lohSize`loh 與`totalSize`–`lohSize`針對小物件堆積 (SOH)。</span><span class="sxs-lookup"><span data-stu-id="36d63-444">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="36d63-445">`lohSize` 必須要夠大，無法處理對於 LOH 來說發生的關鍵路徑中的所有記憶體配置和`totalSize`–`lohSize`必須夠大，無法都處理的 SOH 中發生的關鍵路徑中的所有記憶體配置。</span><span class="sxs-lookup"><span data-stu-id="36d63-445">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="36d63-446">這包括應用程式時，所配置，以及執行階段可讓應用程式的名義的配置。</span><span class="sxs-lookup"><span data-stu-id="36d63-446">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="36d63-447">您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。</span><span class="sxs-lookup"><span data-stu-id="36d63-447">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="36d63-448">換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），而且不應會呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功的第一次呼叫時，就算<xref:System.GC.TryStartNoGCRegion%2A>成功。</span><span class="sxs-lookup"><span data-stu-id="36d63-448">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="36d63-449">您藉由呼叫結束無 GC 區域延遲模式<xref:System.GC.EndNoGCRegion%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-449">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="36d63-450">
            <paramref name="totalSize" /> - <paramref name="lohSize" /> 超過暫時區段大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-450">
              <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="36d63-451">處理序處於無 GC 區域延遲模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-451">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
          <span data-ttu-id="36d63-452">記憶體回收的基本概念</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-452">Fundamentals of Garbage Collection</span>
          </span>
        </related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="36d63-453">延遲模式</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-453">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="36d63-454">在不觸發記憶體回收的情況下，要配置的記憶體數量 (以位元組為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-454">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="36d63-455">
            <paramref name="totalSize" /> - <paramref name="lohSize" /> 必須小於或等於暫時區段的大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-455">
              <paramref name="totalSize" /> –<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="36d63-456">如需暫時區段大小的資訊，請參閱[記憶體回收的基本概念](~/docs/standard/garbage-collection/fundamentals.md)一文中的＜暫時層代和區段＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-456">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="lohSize">
          <span data-ttu-id="36d63-457">
            <paramref name="totalSize" /> 中要用於大型物件堆積 (LOH) 配置的位元組數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-457">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span>
          </span>
        </param>
        <param name="disallowFullBlockingGC">
          <span data-ttu-id="36d63-458">
            <see langword="true" /> 表示如果記憶體回收行程最初無法在小型物件堆積 (SOH) 及 LOH 上配置指定的記憶體，則省略完全封鎖記憶體回收；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-458">
              <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-459">嘗試在大型物件堆積與小型物件堆積有指定數量記憶體可用時，於執行關鍵路徑期間，禁止記憶體回收，並控制在最初沒有足夠的記憶體可用時，記憶體回收行程是否執行完全封鎖記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-459">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="36d63-460">如果執行階段可以認可所需的記憶體數量且記憶體回收行程可以進入無 GC 區域延遲模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-460">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-461"><xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29>方法會嘗試將記憶體回收行程放在應用程式執行的程式碼的關鍵區域時，不允許記憶體回收無 GC 區域延遲模式。</span><span class="sxs-lookup"><span data-stu-id="36d63-461">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="36d63-462">執行階段是否無法一開始配置要求的記憶體數量和`disallowFullBlockingGC`引數是`false`，記憶體回收行程執行完全封鎖記憶體回收，嘗試釋放其他記憶體; 否則配置失敗，而且方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="36d63-462">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="36d63-463">記憶體回收行程會進入無 GC 區域延遲模式，它是否能夠配置`lohSize`loh 與`totalSize`–`lohSize`針對小物件堆積 (SOH)。</span><span class="sxs-lookup"><span data-stu-id="36d63-463">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="36d63-464">`lohSize` 必須要夠大，無法處理對於 LOH 來說發生的關鍵路徑中的所有記憶體配置和`totalSize`–`lohSize`必須夠大，無法都處理的 SOH 中發生的關鍵路徑中的所有記憶體配置。</span><span class="sxs-lookup"><span data-stu-id="36d63-464">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="36d63-465">這包括應用程式時，所配置，以及執行階段可讓應用程式的名義的配置。</span><span class="sxs-lookup"><span data-stu-id="36d63-465">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="36d63-466">設定`disallowFullBlockingGC`至`true`為了避免完整封鎖記憶體回收集合，如果沒有足夠的記憶體可用的一開始是在負載平衡案例中最有用： 一個系統呼叫這個方法，並準備好接受要求，如果它傳回為報表本身`true`，如果它傳回，將要求重新導向至其他系統的負載平衡器和`false`。</span><span class="sxs-lookup"><span data-stu-id="36d63-466">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="36d63-467">它不藉由呼叫來處理要求時，它可以再執行完全封鎖記憶體回收<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-467">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="36d63-468">您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。</span><span class="sxs-lookup"><span data-stu-id="36d63-468">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="36d63-469">換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），而且不應會呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功的第一次呼叫時，就算<xref:System.GC.TryStartNoGCRegion%2A>成功。</span><span class="sxs-lookup"><span data-stu-id="36d63-469">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="36d63-470">您藉由呼叫結束無 GC 區域延遲模式<xref:System.GC.EndNoGCRegion%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-470">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="36d63-471">
            <paramref name="totalSize" /> - <paramref name="lohSize" /> 超過暫時區段大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-471">
              <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="36d63-472">處理序處於無 GC 區域延遲模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-472">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
          <span data-ttu-id="36d63-473">記憶體回收的基本概念</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-473">Fundamentals of Garbage Collection</span>
          </span>
        </related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="36d63-474">延遲模式</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-474">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="36d63-475">傳回註冊通知的狀態，以判斷 Common Language Runtime 是否即將執行完整的封鎖記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-475">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="36d63-476">傳回註冊通知的狀態，以判斷 Common Language Runtime 是否即將執行完整的封鎖記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-476">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="36d63-477">已註冊記憶體回收通知的狀態。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-477">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-478">使用<xref:System.GCNotificationStatus>列舉型別，這個方法來判斷目前記憶體回收通知，使用已註冊狀態傳回<xref:System.GC.RegisterForFullGCNotification%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-478">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="36d63-479">您也可以使用<xref:System.GC.WaitForFullGCComplete%2A>方法，以判斷是否已完成完整記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-479">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="36d63-480">當此列舉會傳回<xref:System.GCNotificationStatus.Succeeded>，您可以執行工作，例如防止其他物件配置，並使用您自己誘導集合<xref:System.GC.Collect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-480">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="36d63-481">請注意，通知並不保證，完整記憶體回收，就會發生只有該條件已達到是負責進行完整記憶體回收的臨界值。</span><span class="sxs-lookup"><span data-stu-id="36d63-481">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="36d63-482">這個方法會無限期地等候取得記憶體回收通知。</span><span class="sxs-lookup"><span data-stu-id="36d63-482">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="36d63-483">如果您想要指定這個方法傳回 如果無法取得通知的逾時期間，使用<xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>方法多載。</span><span class="sxs-lookup"><span data-stu-id="36d63-483">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="36d63-484">如果您未指定逾時呼叫這個方法，您可以呼叫<xref:System.GC.CancelFullGCNotification%2A>方法，如果您在慣用的內容超過等候。</span><span class="sxs-lookup"><span data-stu-id="36d63-484">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="36d63-485">您應該遵循藉由呼叫這個方法<xref:System.GC.WaitForFullGCComplete%2A>方法以確定您已完整記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-485">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="36d63-486">呼叫這個方法只會造成未定的結果。</span><span class="sxs-lookup"><span data-stu-id="36d63-486">Calling this method alone causes indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-487">下列範例示範如何使用此方法來判斷是否已接近完整的封鎖記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-487">The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</span></span> <span data-ttu-id="36d63-488">通知的狀態是每當<xref:System.GCNotificationStatus.Succeeded>，將使用者方法`OnFullGCApproachNotify`呼叫以執行動作以回應到接近的集合。</span><span class="sxs-lookup"><span data-stu-id="36d63-488">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCApproachNotify` is called to perform actions in response to the approaching collection.</span></span> <span data-ttu-id="36d63-489">此程式碼範例是針對提供之較大範例的一部分[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)主題。</span><span class="sxs-lookup"><span data-stu-id="36d63-489">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="36d63-490">針對完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-490">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-491">這個成員無法供部分信任的程式碼使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-491">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="36d63-492">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-492">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-493">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-493">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="36d63-494">記憶體回收告知</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-494">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="36d63-495">在可以取得通知之前所要等待的時間長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-495">The length of time to wait before a notification status can be obtained.</span>
          </span>
          <span data-ttu-id="36d63-496">指定 -1 會無限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-496">Specify -1 to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-497">在指定的逾時期間傳回註冊通知的狀態，以判斷 Common Language Runtime 是否即將執行完整的封鎖記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-497">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="36d63-498">已註冊記憶體回收通知的狀態。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-498">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-499">使用<xref:System.GCNotificationStatus>列舉型別，這個方法來判斷目前記憶體回收通知，使用已註冊狀態傳回<xref:System.GC.RegisterForFullGCNotification%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-499">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="36d63-500">您也可以使用<xref:System.GC.WaitForFullGCComplete%2A>方法，以判斷是否已完成完整記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-500">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="36d63-501">請注意，這個方法傳回時要取得記憶體回收集合通知狀態，不論所指定的值，請立即`millisecondsTimeout`。</span><span class="sxs-lookup"><span data-stu-id="36d63-501">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="36d63-502">如果之前未取得記憶體回收集合通知狀態`millisecondsTimeout`次，這個方法會傳回<xref:System.GCNotificationStatus.NotApplicable>。</span><span class="sxs-lookup"><span data-stu-id="36d63-502">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="36d63-503">當此列舉會傳回<xref:System.GCNotificationStatus.Succeeded>，您可以執行工作，例如防止其他物件配置，並使用您自己誘導集合<xref:System.GC.Collect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-503">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="36d63-504">請注意，通知並不保證，完整記憶體回收，就會發生只有該條件已達到是負責進行完整記憶體回收的臨界值。</span><span class="sxs-lookup"><span data-stu-id="36d63-504">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="36d63-505">您可以呼叫<xref:System.GC.CancelFullGCNotification%2A>方法時您不能等候逾時週期過後。</span><span class="sxs-lookup"><span data-stu-id="36d63-505">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="36d63-506">您應該遵循藉由呼叫這個方法<xref:System.GC.WaitForFullGCComplete%2A>方法以確定您已完整記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-506">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="36d63-507">呼叫這個方法只會造成未定的結果。</span><span class="sxs-lookup"><span data-stu-id="36d63-507">Calling this method alone causes indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="36d63-508">
            <paramref name="millisecondsTimeout" /> 必須為非負數，或是小於或等於 <see cref="F:System.Int32.MaxValue" /> 或 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-508">
              <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="36d63-509">針對完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-509">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-510">這個成員無法供部分信任的程式碼使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-510">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="36d63-511">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-511">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-512">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-512">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="36d63-513">記憶體回收告知</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-513">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="36d63-514">傳回註冊通知的狀態，以判斷 Common Language Runtime 是否已完成完整的封鎖記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-514">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="36d63-515">傳回註冊通知的狀態，以判斷 Common Language Runtime 是否已完成完整的封鎖記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-515">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="36d63-516">已註冊記憶體回收通知的狀態。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-516">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-517">使用<xref:System.GCNotificationStatus>列舉型別，這個方法來判斷目前記憶體回收通知，使用已註冊狀態傳回<xref:System.GC.RegisterForFullGCNotification%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-517">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="36d63-518">您也可以使用<xref:System.GC.WaitForFullGCApproach%2A>方法，以判斷是否即將完整記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-518">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="36d63-519">當此列舉會傳回<xref:System.GCNotificationStatus.Succeeded>，您可以執行工作，例如繼續執行的工作，並取得與集合計數<xref:System.GC.CollectionCount%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="36d63-519">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="36d63-520">這個方法會無限期地等候取得記憶體回收通知。</span><span class="sxs-lookup"><span data-stu-id="36d63-520">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="36d63-521">如果您想要指定這個方法傳回 如果無法取得通知的逾時期間，使用<xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>方法多載。</span><span class="sxs-lookup"><span data-stu-id="36d63-521">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="36d63-522">如果您未指定逾時呼叫這個方法，您可以呼叫<xref:System.GC.CancelFullGCNotification%2A>方法，如果您在慣用的內容超過等候。</span><span class="sxs-lookup"><span data-stu-id="36d63-522">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="36d63-523">這個方法呼叫應該在前面加上呼叫<xref:System.GC.WaitForFullGCApproach%2A>方法以確定您已完整記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-523">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="36d63-524">單獨呼叫這個方法可能會產生未定的結果。</span><span class="sxs-lookup"><span data-stu-id="36d63-524">Calling this method alone can produce indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-525">下列範例示範如何使用這個方法來判斷是否已完成完整記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-525">The following example shows how to use this method to determine whether a full garbage collection has completed.</span></span> <span data-ttu-id="36d63-526">通知的狀態是每當<xref:System.GCNotificationStatus.Succeeded>，將使用者方法`OnFullGCCompletedNotify`呼叫以執行動作以回應已完成的集合。</span><span class="sxs-lookup"><span data-stu-id="36d63-526">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCCompletedNotify` is called to perform actions in response to the completed collection.</span></span> <span data-ttu-id="36d63-527">此程式碼範例是針對提供之較大範例的一部分[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)主題。</span><span class="sxs-lookup"><span data-stu-id="36d63-527">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="36d63-528">針對完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-528">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-529">這個成員無法供部分信任的程式碼使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-529">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="36d63-530">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-530">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-531">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-531">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="36d63-532">記憶體回收告知</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-532">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="36d63-533">在可以取得通知之前所要等待的時間長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-533">The length of time to wait before a notification status can be obtained.</span>
          </span>
          <span data-ttu-id="36d63-534">指定 -1 會無限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-534">Specify -1 to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="36d63-535">在指定的逾時期間傳回註冊通知的狀態，以判斷 Common Language Runtime 是否已完成完整的封鎖記憶體回收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-535">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="36d63-536">已註冊記憶體回收通知的狀態。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-536">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-537">使用<xref:System.GCNotificationStatus>列舉型別，這個方法來判斷目前記憶體回收通知，使用已註冊狀態傳回<xref:System.GC.RegisterForFullGCNotification%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-537">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="36d63-538">您也可以使用<xref:System.GC.WaitForFullGCApproach%2A>方法，以判斷是否即將完整記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-538">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="36d63-539">請注意，這個方法傳回時要取得記憶體回收集合通知狀態，不論所指定的值，請立即`millisecondsTimeout`。</span><span class="sxs-lookup"><span data-stu-id="36d63-539">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="36d63-540">如果之前未取得記憶體回收集合通知狀態`millisecondsTimeout`次，這個方法會傳回<xref:System.GCNotificationStatus.NotApplicable>。</span><span class="sxs-lookup"><span data-stu-id="36d63-540">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="36d63-541">當此列舉會傳回<xref:System.GCNotificationStatus.Succeeded>，您可以執行工作，例如繼續執行的工作，並取得與集合計數<xref:System.GC.CollectionCount%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="36d63-541">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="36d63-542">您可以呼叫<xref:System.GC.CancelFullGCNotification%2A>方法時您不能等候逾時週期過後。</span><span class="sxs-lookup"><span data-stu-id="36d63-542">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="36d63-543">這個方法呼叫應該在前面加上呼叫<xref:System.GC.WaitForFullGCApproach%2A>方法以確定您已完整記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="36d63-543">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="36d63-544">單獨呼叫這個方法可能會產生未定的結果。</span><span class="sxs-lookup"><span data-stu-id="36d63-544">Calling this method alone can produce indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="36d63-545">
            <paramref name="millisecondsTimeout" /> 必須為非負數，或是小於或等於 <see cref="F:System.Int32.MaxValue" /> 或 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-545">
              <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="36d63-546">針對完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-546">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-547">這個成員無法供部分信任的程式碼使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-547">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="36d63-548">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-548">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="36d63-549">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-549">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="36d63-550">記憶體回收告知</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-550">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="36d63-551">暫止目前的執行緒，直到處理完成項佇列的執行緒已經清空該佇列為止。</span>
          <span class="sxs-lookup">
            <span data-stu-id="36d63-551">Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36d63-552">當記憶體回收行程會發現可以回收的物件時，它會檢查每個物件，以判斷物件的最終處理需求。</span><span class="sxs-lookup"><span data-stu-id="36d63-552">When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</span></span> <span data-ttu-id="36d63-553">如果物件會實作完成項，並且具有未停用完成項呼叫<xref:System.GC.SuppressFinalize%2A>，該物件位於標示為準備進行最終處理的物件清單。</span><span class="sxs-lookup"><span data-stu-id="36d63-553">If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization.</span></span> <span data-ttu-id="36d63-554">記憶體回收行程呼叫<xref:System.Object.Finalize%2A>這個清單並移除的項目從清單中物件的方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-554">The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list.</span></span> <span data-ttu-id="36d63-555">這個方法會封鎖直到所有的完成項已執行到完成為止。</span><span class="sxs-lookup"><span data-stu-id="36d63-555">This method blocks until all finalizers have run to completion.</span></span>  
  
 <span data-ttu-id="36d63-556">在其執行完成項執行緒未指定，因此這個方法會終止不保證。</span><span class="sxs-lookup"><span data-stu-id="36d63-556">The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</span></span> <span data-ttu-id="36d63-557">不過，這個執行緒可以中斷時的另一個執行緒<xref:System.GC.WaitForPendingFinalizers%2A>方法正在進行中。</span><span class="sxs-lookup"><span data-stu-id="36d63-557">However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress.</span></span> <span data-ttu-id="36d63-558">例如，您可以啟動另一個執行緒等候一段時間，然後中斷這個執行緒，如果仍然已暫止這個執行緒。</span><span class="sxs-lookup"><span data-stu-id="36d63-558">For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36d63-559">下列範例示範如何使用<xref:System.GC.WaitForPendingFinalizers%2A>暫停目前的執行緒，直到最終處理的所有收集到的物件已完成的方法。</span><span class="sxs-lookup"><span data-stu-id="36d63-559">The following example demonstrates how to use the <xref:System.GC.WaitForPendingFinalizers%2A> method to suspend the current thread until finalization of all the collected objects is complete.</span></span>  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>