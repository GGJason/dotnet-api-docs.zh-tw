<Type Name="GC" FullName="System.GC">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6c38b21659aa141b32c988dfe140585d7feda29b" /><Meta Name="ms.sourcegitcommit" Value="9d1bf7e4c6d697123f26c810c1a049a755634634" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/06/2018" /><Meta Name="ms.locfileid" Value="52982016" /></Metadata><TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>控制系統記憶體回收行程，它是自動回收未使用之記憶體的服務。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 記憶體回收行程是控制項的配置和釋放的 managed 記憶體 common language runtime 元件。 物件上並釋放物件所配置的資源執行記憶體回收時，就會影響此類別中的方法。 此類別中的屬性系統和年齡類別目錄或產生，配置給物件的記憶體中提供可用的記憶體總數量的相關資訊。  
  
 記憶體回收行程會追蹤，並回收在受管理的記憶體中配置的物件。 會定期記憶體回收行程執行回收來回收記憶體配置給物件的有無有效的參考。 使用提供的可用記憶體無法滿足記憶體要求時，會自動發生記憶體回收。 或者，應用程式可以強制記憶體回收集合使用<xref:System.GC.Collect%2A>方法。  
  
 記憶體回收是由下列步驟所組成：  
  
1.  記憶體回收行程會搜尋在 managed 程式碼中參考的 managed 物件。  
  
2.  記憶體回收行程會嘗試將完成未參考的物件。  
  
3.  記憶體回收行程釋放未參考的物件，並回收其記憶體。  
  
 本主題包含下列章節：  
  
 [記憶體回收行程和 unmanaged 的資源](#unmanaged)   
 [物件的過時和層代](#generations)   
 [不允許記憶體回收](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a>記憶體回收行程和 unmanaged 的資源  
 在回收期間，記憶體回收行程不會釋放物件如果 managed 程式碼中找到一或多個物件的參考。 不過，記憶體回收行程無法辨識從 unmanaged 程式碼，一個物件的參考，而且可能釋放物件，除非明確地防止這種方式使用 unmanaged 程式碼中以獨佔方式。 <xref:System.GC.KeepAlive%2A>方法提供一種機制，防止記憶體回收行程收集是仍在使用 unmanaged 程式碼中的物件。  
  
 除了 managed 的記憶體配置的記憶體回收行程的實作不會維護物件，例如檔案控制代碼或資料庫連線所持有的資源的相關資訊。 當型別會使用型別的執行個體，會回收之前，必須先釋放的 unmanaged 的資源時，類型可以實作完成項。  
  
 在大部分情況下，完成項會實作藉由覆寫<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法; 不過，C# 或 c + + 撰寫的類型會實作解構函式的編譯器轉換成的覆寫<xref:System.Object.Finalize%2A?displayProperty=nameWithType>。 在大部分情況下，如果物件具有完成項，記憶體回收行程會呼叫它之前釋放物件。 不過，記憶體回收行程並不需要在所有情況下，呼叫完成項比方說，<xref:System.GC.SuppressFinalize%2A>方法明確地防止物件的完成項呼叫。 此外，記憶體回收行程不需要使用特定的執行緒完成物件，或是保證彼此參考，但可進行記憶體回收的物件呼叫完成項的順序。  
  
 在指定的時間必須釋放資源的情況下，類別可以實作<xref:System.IDisposable>介面，其中包含<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>方法，以執行資源管理和清除工作。 類別實作<xref:System.IDisposable.Dispose%2A>必須指定，其類別合約是否以及何時類別的取用者呼叫方法，以清除物件。 記憶體回收行程不會根據預設，呼叫<xref:System.IDisposable.Dispose%2A>方法; 不過，實作<xref:System.IDisposable.Dispose%2A>方法可以呼叫方法中<xref:System.GC>類別來自訂記憶體回收行程的最終處理行為。  
  
 如需有關物件最終處理和 dispose 模式的詳細資訊，請參閱[清除 Unmanaged 資源總](~/docs/standard/garbage-collection/unmanaged.md)。  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a>物件的過時和層代  
 Common language runtime 在記憶體回收行程會支援使用層代物件過時。 層代是測量的記憶體中物件的相對存在時間單位。 層代編號或年齡，物件表示物件所屬的產生。 建立多個物件最近屬於較新的層代，而且必須小於物件稍早建立的應用程式生命週期的層代編號。 最新的層代中的物件是在層代 0。 記憶體回收行程的這項實作支援之物件的三個層代，這些層代 0、 1 和 2。 您可以擷取的值<xref:System.GC.MaxGeneration%2A>屬性，以判斷系統所支援的最大層代編號。  
  
 物件的時效性會允許目標回收應用程式在一組特定的層代，而不需要評估所有層代記憶體回收行程。 多載<xref:System.GC.Collect%2A>方法，包括`generation`參數可讓您指定要進行記憶體回收的最舊層代。  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a>不允許記憶體回收  
 從開始[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，記憶體回收行程支援無 GC 區域延遲模式可在記憶體回收的集合可能會影響應用程式效能的關鍵路徑期間。 無 GC 區域延遲模式會要求您指定可從記憶體回收行程配置不受干擾的記憶體數量。 如果執行階段可以配置的記憶體，執行階段不會執行回收時執行的關鍵路徑中的程式碼。  
  
 您藉由呼叫其中一個多載定義的無 GC 區域的關鍵路徑的開頭<xref:System.GC.TryStartNoGCRegion%2A>。 您可以指定其關鍵路徑的結尾呼叫<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。 換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），而且不應會呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功的第一次呼叫時，就算<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
   
  
## Examples  
 下列範例會使用數個 GC 方法來取得產生和記憶體區塊的未使用物件的相關的資訊，並列印到主控台。 然後回收未使用的物件，並會顯示產生的記憶體總計。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md">記憶體回收</related>
    <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">記憶體回收的基本概念</related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">已配置的 Unmanaged 記憶體累加數量。</param>
        <summary>告知執行階段，在排定記憶體回收時應考慮的大量 Unmanaged 記憶體配置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在決定何時要排定記憶體回收時，執行階段會考慮到配置的受管理的記憶體。 如果小型的 managed 的物件會配置大量 unmanaged 記憶體，執行階段會考量只受管理的記憶體，並因此低估排定記憶體回收的急迫性。 <xref:System.GC.AddMemoryPressure%2A>方法告知執行階段，此額外系統記憶體不足的壓力。  
  
 在最簡單的使用方式模式中，受管理的物件配置建構函式中的 unmanaged 的記憶體和釋放它在`Dispose`或`Finalize`方法。 呼叫<xref:System.GC.AddMemoryPressure%2A>方法之後配置 unmanaged 的記憶體中，並呼叫<xref:System.GC.RemoveMemoryPressure%2A>之後釋放它的方法。  
  
 在更複雜的案例，其中的 unmanaged 的記憶體配置的 managed 物件的存留期間變更本質上，您可以呼叫<xref:System.GC.AddMemoryPressure%2A>和<xref:System.GC.RemoveMemoryPressure%2A>通訊這些執行階段的累加變更的方法。  
  
> [!CAUTION]
>  您必須確定您移除完全您新增的壓力總量。 不這麼做的話，可能會影響在系統中的長時間執行的應用程式的效能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bytesAllocated" /> 小於或等於 0。  
  
-或- 
在 32 位元電腦上，<paramref name="bytesAllocated" /> 大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供管理回收優先順序時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消註冊記憶體回收通知。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會取消所註冊的使用記憶體回收通知<xref:System.GC.RegisterForFullGCNotification%2A>方法。 您不需要調整臨界值參數值，在後續呼叫之前呼叫這個方法<xref:System.GC.RegisterForFullGCNotification%2A>方法。  
  
   
  
## Examples  
 下列範例會先取消記憶體回收註冊。 這個範例是針對提供之較大範例的一部分[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)主題。  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">啟用並行記憶體回收時，無法使用這個成員。 如需如何停用並行記憶體回收的資訊，請參閱 [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) 執行階段設定。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">記憶體回收告知</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>強制記憶體回收。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>強制立即執行所有層代的記憶體回收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法，嘗試回收所有無法存取的記憶體。 它會執行封鎖記憶體回收所有層代。  
  
 所有的物件，不論時間已在記憶體中，會被視為集合;不過，不會收集在 managed 程式碼中參考的物件。 您可以使用此方法，強制系統將嘗試回收的最大可用記憶體數量。  
  
 開頭[!INCLUDE[net_v451](~/includes/net-v451-md.md)]，您可以藉由設定壓縮大型物件堆積 (LOH)<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>屬性設<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>再呼叫<xref:System.GC.Collect%2A>方法，如下列範例會示範。  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.GC.Collect%2A>執行回收所有層代的記憶體上的方法。 程式碼會產生多個未使用的物件，然後再呼叫<xref:System.GC.Collect%2A>方法，以從記憶體清除它們。  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">引發的集合</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">要進行記憶體回收的最舊層代數目。</param>
        <summary>強制立即執行層代 0 至指定層代的記憶體回收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 嘗試以回收記憶體而無法使用這個方法。 不過，使用此方法不保證會回收所有存取的記憶體中指定的層代。  
  
 如果實作物件過時，記憶體回收行程不會收集物件以產生數字大於指定層代。 如果未實作物件過時，記憶體回收行程會考慮所有物件在記憶體回收期間。  
  
 使用<xref:System.GC.MaxGeneration%2A>屬性來判斷的最大有效值`generation`參數。  
  
 若要考慮所有的物件，不論其層代記憶體回收行程，請使用這個方法不採用參數的版本。 若要將記憶體回收行程回收物件根據<xref:System.GCCollectionMode>設定，使用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType>方法多載。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.GC.Collect%2A>執行回收記憶體的個別圖層上的方法。 程式碼會產生多個未使用的物件，然後再呼叫<xref:System.GC.Collect%2A>方法，以從記憶體清除它們。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" /> 無效。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">引發的集合</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">要進行記憶體回收的最舊層代數目。</param>
        <param name="mode">列舉值，指定是要強制記憶體回收 (<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />) 還是進行最佳化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</param>
        <summary>在 <see cref="T:System.GCCollectionMode" /> 值所指定的時間，強制執行層代 0 至指定層代的記憶體回收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`mode`參數來指定是否發生記憶體回收應該立刻] 或 [僅時間是否最適合回收物件。 使用此方法不保證會回收所有存取的記憶體中指定的層代。  
  
 若要調整的應用程式中的重要期間回收干擾程度，請設定<xref:System.Runtime.GCSettings.LatencyMode%2A>屬性。  
  
 記憶體回收行程不會收集物件與比所指定更高的層代編號`generation`參數。 使用<xref:System.GC.MaxGeneration%2A>屬性來判斷的最大有效值`generation`。  
  
 若要考慮所有的物件，不論其層代記憶體回收行程，請使用這個方法不採用參數的版本。  
  
 若要將記憶體回收行程回收物件到指定的層代的物件，請使用<xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType>方法多載。 當您指定最大層代時，則會收集所有物件。  
  
   
  
## Examples  
 下列範例會強制記憶體回收層代 2 物件<xref:System.GCCollectionMode.Optimized>設定。  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" /> 無效。  
  
-或- 
 <paramref name="mode" /> 不是其中一個 <see cref="T:System.GCCollectionMode" /> 值。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">引發的集合</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">要進行記憶體回收的最舊層代數目。</param>
        <param name="mode">列舉值，指定是要強制記憶體回收 (<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />) 還是進行最佳化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</param>
        <param name="blocking"><see langword="true" /> 表示要執行封鎖記憶體回收，<see langword="false" /> 表示要盡可能執行背景記憶體回收。</param>
        <summary>在 <see cref="T:System.GCCollectionMode" /> 值 (含有指定是否應該封鎖回收作業的值) 所指定的時間，強制執行從層代 0 到指定之層代的記憶體回收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表摘要說明的互動`mode`和`blocking`參數：  
  
|`mode`|`blocking` 是 `true`|`blocking` 是 `false`|  
|-|-|-|  
|<xref:System.GCCollectionMode.Forced> 或 <xref:System.GCCollectionMode.Default>|會盡快執行封鎖回收。 如果正在進行背景回收並`generation`是 0 或 1，<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>方法立即觸發封鎖回收，並在回收完成時傳回。 如果正在進行背景回收和`generation`為 2，方法會等到背景回收完成時，觸發封鎖層代 2 回收，，然後傳回。|會盡快執行回收。 <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> 方法會要求背景集合，但不保證可取得。視情況而定，可能仍會執行封鎖集合。 如果已在進行背景回收，則這個方法會立即返回。|  
|<xref:System.GCCollectionMode.Optimized>|可能會因記憶體回收行程和 `generation` 參數的狀態而執行封鎖集合。 記憶體回收行程會嘗試提供最佳效能。|根據記憶體回收行程的狀態，可能會執行回收。 <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> 方法會要求背景集合，但不保證可取得。視情況而定，可能仍會執行封鎖集合。 記憶體回收行程會嘗試提供最佳效能。 如果已在進行背景回收，則這個方法會立即返回。|  
  
 如果呼叫<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>方法會執行完全封鎖記憶體回收，您也可以藉由設定壓縮大型物件堆積<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>屬性設<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>再呼叫<xref:System.GC.Collect%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" /> 無效。  
  
-或- 
 <paramref name="mode" /> 不是其中一個 <see cref="T:System.GCCollectionMode" /> 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">要進行記憶體回收的最舊層代數目。</param>
        <param name="mode">列舉值，指定是要強制記憶體回收 (<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />) 還是進行最佳化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</param>
        <param name="blocking"><see langword="true" /> 表示要執行封鎖記憶體回收，<see langword="false" /> 表示要盡可能執行背景記憶體回收。</param>
        <param name="compacting"><see langword="true" /> 表示壓縮小型物件堆積；<see langword="false" /> 表示僅整理。</param>
        <summary>在 <see cref="T:System.GCCollectionMode" /> 值 (含有指定是否應該封鎖及壓縮回收作業的值) 所指定的時間，強制執行從層代 0 到指定之層代的記憶體回收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`blocking`是`false`，GC 會決定是否要執行為背景或封鎖記憶體回收。 如果`compacting`是`true`，它會執行封鎖記憶體回收。  
  
 如果`compacting`是`true`，執行階段會壓縮小型物件堆積 (SOH)。 大型物件堆積 (LOH) 不會壓縮，除非<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>屬性設定為<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>。 請注意，這也包含所有封鎖記憶體回收，不只是完整封鎖記憶體回收。  
  
 您可以呼叫<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法，以減少大小最小，managed 的堆積，如下列程式碼片段所示。  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 指定`true`針對`compacting`引數可保證壓縮、 完整封鎖記憶體回收。 設定<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>屬性設<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>可確保會壓縮 LOH 和 SOH。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">要判斷記憶體回收計數的物件層代。</param>
        <summary>傳回指定物件層代已發生記憶體回收的次數。</summary>
        <returns>自從啟動處理程序之後，指定層代已發生記憶體回收的次數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您實作您自己的資源管理，您可能需要強制執行記憶體回收會定期呼叫<xref:System.GC.Collect%2A>方法。 因為這是成本高昂的作業，您可以略過進行記憶體回收發生最近的呼叫來改善效能。 儲存所傳回的值<xref:System.GC.CollectionCount%2A>後立即呼叫<xref:System.GC.Collect%2A>。 您必須呼叫在下一次<xref:System.GC.Collect%2A>，所傳回的目前值相比較<xref:System.GC.CollectionCount%2A>已儲存的值。 如果兩個值相等，在此過渡期間發生任何集合，而它可合理地呼叫<xref:System.GC.Collect%2A>一次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" /> 小於 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>結束無 GC 區域延遲模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.EndNoGCRegion%2A>方法會擲回<xref:System.InvalidOperationException>如果記憶體回收行程不處於無 GC 區域延遲模式。 發生這種情況下任何下列條件：  
  
-   <xref:System.GC.TryStartNoGCRegion%2A>不先前呼叫方法。  
  
-   若要在呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法會傳回`false`。  
  
-   若要呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法會擲回例外狀況。  
  
 您可以使用如下所示的程式碼的下列任何一個原因的檔案，以避免例外狀況：  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">記憶體回收行程不在無 GC 區域延遲模式下。  
  
-或- 
無 GC 區域延遲模式之前已結束，因為已包含記憶體回收。  
  
-或- 
記憶體配置超過 <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> 方法呼叫中所指定的數量。</exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">延遲模式</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得自目前執行緒的存留期開始，已配置給該執行緒的位元組總數。</summary>
        <returns>自目前執行緒的存留期開始，已配置給該執行緒的位元組總數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`GetAllocatedBytesForCurrentThread`方法傳回的執行緒，而不的未被記憶體回收的位元組總數的存留期間，managed 堆積上配置的位元組總數。 傳回的值也不包括任何原生的配置。

這個方法是在監視案例來測量時間間隔或事件之間的記憶體配置差異最有用的。

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回物件的目前層代編號。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要為其擷取層代資訊的物件。</param>
        <summary>傳回指定物件的目前層代編號。</summary>
        <returns><paramref name="obj" /> 的目前層代編號。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來判斷物件的時間，並接著使用該項資訊與<xref:System.GC.Collect%2A>相同的層代中的方法，以強制記憶體回收行程回收物件。 例如，當您有一組群組所建立的並且在此同時，變成無法存取的物件時，才使用這個方法。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.GC.GetGeneration%2A>方法，以判斷物件的存留期。 此範例接著會執行廢棄項目集合，來清除記憶體並比較前張貼集合在主控台中的記憶體總計。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo"><see cref="T:System.WeakReference" />，參考要判斷層代編號的目標物件。</param>
        <summary>傳回指定弱式參考之目標的目前層代編號。</summary>
        <returns><paramref name="wo" /> 之目標的目前層代編號。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何使用<xref:System.GC.GetGeneration%2A>方法，以判斷弱式參考物件的存留期。  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">在 <paramref name="wo" /> 上已執行記憶體回收。</exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">如果這個方法可以等待記憶體回收發生後再傳回則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>擷取目前被視為已配置的位元組數。 參數會指出這個方法是否可以先等待短暫間隔後再傳回，以便讓系統回收記憶體和最終處理物件。</summary>
        <returns>數目，為目前配置於 Managed 記憶體中位元組的最佳可用近似數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`forceFullCollection`參數是`true`，這個方法會等候傳回之前在短時間內時，系統會收集記憶體回收，並終結物件。 在內部指定的限制，取決於完成記憶體回收週期數目和復原循環之間的記憶體變更間隔的持續時間。 記憶體回收行程並不保證會收集所有存取的記憶體。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.GC.GetTotalMemory%2A>方法來取得並顯示目前在受管理的記憶體中配置的位元組數目。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要參考的物件。</param>
        <summary>參考指定的物件，使它從目前常式的開始至呼叫這個方法時都不適合記憶體回收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目的<xref:System.GC.KeepAlive%2A>方法可確保有風險的不當記憶體回收行程回收物件的參考是否存在。 這可能發生的常見案例是當沒有物件參考，在 managed 程式碼或資料，但物件仍在使用處於未受管理的程式碼，例如 Win32 Api，unmanaged 的 Dll，或使用 COM 方法  
  
 這個方法所參考`obj`參數，使該物件進行記憶體回收不適合從常式的開始點，以執行順序，會呼叫這個方法。 在結束時，不，範圍的開頭的指示，此方法的程式碼位置`obj`必須可供使用。  
  
 <xref:System.GC.KeepAlive%2A>方法會執行任何作業，並產生非擴充做為參數傳入的物件的存留期沒有副作用。  
  
   
  
## Examples  
 下列程式碼範例會建立物件的開頭及其`Main`方法並不是指的物件直到結束時時,<xref:System.GC.KeepAlive%2A>方法呼叫。 30 秒期間持續存在的物件`Main`方法，呼叫儘管<xref:System.GC.Collect%2A>和<xref:System.GC.WaitForPendingFinalizers%2A>方法。  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得系統目前支援的最大層代編號。</summary>
        <value>範圍從零至所支援最大層代編號的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 層代編號或年齡，物件是實作定義相對量值物件的存留時間。 最近建立的物件層代 0 中，而且舊的物件是小於或等於產生傳回的層代中<xref:System.GC.MaxGeneration%2A>屬性。  
  
 記憶體回收行程假設較新的記憶體是更有可能是比較舊的記憶體回收。 因此，記憶體回收行程回收記憶體，每次調整產生數字中改善其效能和<xref:System.GC.MaxGeneration%2A>屬性值可以隨著時間成長。  
  
 如果實作物件過時，<xref:System.GC.MaxGeneration%2A>屬性會傳回系統所使用的最大層代編號; 否則這個屬性會傳回零。  
  
   
  
## Examples  
 下列範例示範如何使用 MaxGeneration 屬性來顯示目前使用的最大的層代編號。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此實作中，傳回的值由<see cref="P:System.GC.MaxGeneration" />屬性一定會執行的應用程式的存留期內保持不變。  
  
使用<see cref="P:System.GC.MaxGeneration" />屬性來判斷呼叫時，您可以指定的最大值<see cref="M:System.GC.Collect(System.Int32)" />採用 generation 參數的方法。</para></block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">範圍從 1 到 99 的數字，指定何時應根據層代 2 中所配置的物件加以引發通知。</param>
        <param name="largeObjectHeapThreshold">範圍從 1 到 99 的數字，指定何時根據大型物件堆積中所配置的物件加以引發通知。</param>
        <summary>指定當情況需要完整記憶體回收時和回收完成時，應引發記憶體回收通知。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對每個層代，記憶體回收行程會設定配置到該層代的臨界值。 當配置的記憶體大小超過此臨界值時，該層代上觸發記憶體回收。 如範例中，如果層代 2 的臨界值是 20 MB （亦即 20 MB 不受影響的層代 1 回收和提升至層代 2），以及超過 20 MB 尚未被第 1 代，而且會提示輸入至層代 2，將會嘗試下一個記憶體回收為層代 2 回收。 同樣地，如果大型物件堆積 (LOH) 的臨界值為 20 MB 和您的應用程式已配置超過 20 MB 的大型物件下, 一個記憶體回收也會嘗試為層代 2 集合 （因為 gen2 回收中，才會收集 LOH）。  
  
 `maxGenerationThreshold`和`largeObjectHeapThreshold`臨界值可讓您控制多少事先通知您發生完整記憶體回收之前。 大於臨界值，可能會發生通知與下一個完整記憶體回收之間的多個配置。  
  
 如果您已在其中完整記憶體回收的 common language runtime 會效能產生負面影響您的應用程式的情況下，您可以要求在執行階段即將執行完整記憶體回收，並對讓該集合時收到通知自行引發集合 (使用<xref:System.GC.Collect%2A>方法) 時仍有利於條件。 除了自行變更廢棄項目集合排程，完整的 GC 通知是用於下列案例：  
  
-   您完整記憶體回收的方法進行監視，並當系統通知您即將達到其中一個，您即時資料的大小縮減 （比方說，釋出一些快取項目）。 如此一來，當記憶體回收發生時，它就能夠以回收更多的記憶體。  
  
-   您完整記憶體回收完成監視，而您可以收集一些統計資料。  比方說，您可能想要測量 GC 完成在堆積的大小，好讓您知道即時資料的大小。 （在完整的 GC 之後, 堆積是以其最小的大小）。  
  
 如需有關所代表的意義完整記憶體回收的詳細資訊，請參閱[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)。  
  
 當您註冊記憶體回收通知時，您就可以收到已接近完整記憶體回收時，並在完成時。 此模式類似於作業系統如何監視記憶體不足的通知。  
  
 使用下列指導方針來指定`maxGenerationThreshold`和`largeObjectHeapThreshold`參數：  
  
-   臨界值越大，更多的配置會通知與完整記憶體回收之間發生。  
  
     較大的臨界值會提供更多的機會，讓執行階段檢查即將進行的回收。 這會增加您會收到通知的可能性。 不過，您不應該設定的臨界值太高，因為這會導致更多的配置之前執行階段引發的下一步 的集合。  
  
     當您自行引發回收通知使用高臨界值時，較少的物件會回收比原本回收的執行階段的下一步 的集合。  
  
-   較小的臨界值，較少通知與完整記憶體回收之間配置。  
  
   
  
## Examples  
 下列範例示範如何註冊記憶體回收通知，並啟動執行緒來監視記憶體回收通知的狀態。 此程式碼範例是針對提供之較大範例的一部分[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)主題。  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxGenerationThreshold" /> 或 <paramref name="largeObjectHeapThreshold" /> 未介於 1 和 99 之間。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">記憶體回收告知</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">已釋放的 Unmanaged 記憶體數量。</param>
        <summary>告知執行階段，Unmanaged 記憶體已釋放，所以排定記憶體回收時不需要再考慮它。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在決定何時要排定記憶體回收時，執行階段會考慮到配置的受管理的記憶體。 如果小型的 managed 的物件會配置大量 unmanaged 記憶體，執行階段會考量只受管理的記憶體，並因此低估排定記憶體回收的急迫性。 <xref:System.GC.AddMemoryPressure%2A>方法會通知執行階段的系統記憶體，造成此額外的壓力和<xref:System.GC.RemoveMemoryPressure%2A>方法會通知執行階段造成額外的壓力，已發行。  
  
 在最簡單的使用方式模式中，受管理的物件配置建構函式中的 unmanaged 的記憶體和釋放它在`Dispose`或`Finalize`方法。 呼叫<xref:System.GC.AddMemoryPressure%2A>方法之後配置 unmanaged 的記憶體中，並呼叫<xref:System.GC.RemoveMemoryPressure%2A>之後釋放它的方法。  
  
 在更複雜的案例，其中的 unmanaged 的記憶體配置的 managed 物件的存留期間變更本質上，您可以呼叫<xref:System.GC.AddMemoryPressure%2A>和<xref:System.GC.RemoveMemoryPressure%2A>通訊這些執行階段的累加變更的方法。  
  
> [!CAUTION]
>  您必須確定您移除完全您新增的壓力總量。 不這麼做的話，可能會影響在系統中的長時間執行的應用程式的效能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bytesAllocated" /> 小於或等於 0。  
  
-或- 
在 32 位元電腦上，<paramref name="bytesAllocated" /> 大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供管理回收優先順序時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">必須呼叫完成項的物件。</param>
        <summary>要求系統為指定物件 (先前已經為其呼叫 <see cref="M:System.GC.SuppressFinalize(System.Object)" />) 呼叫完成項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.ReRegisterForFinalize%2A>方法會將`obj`參數的記憶體回收行程釋放物件之前，要求最終處理的物件清單。 `obj`參數必須是這個方法的呼叫端。  
  
 呼叫<xref:System.GC.ReRegisterForFinalize%2A>方法不保證記憶體回收行程會呼叫物件的完成項。  
  
 根據預設，會實作完成項的所有物件都加入到需要結束; 的物件清單不過，物件可能已經結束，或可能已停用完成項呼叫<xref:System.GC.SuppressFinalize%2A>方法。  
  
 完成項可以使用這個方法，重新恢復它本身或它所參考的物件。  
  
   
  
## Examples  
 下列範例示範如何使用 ReRegisterForFinalize; 方法來完成第二個物件回收之後的時間。  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">完成項不得執行的物件。</param>
        <summary>要求 Common Language Runtime 不要為指定之物件呼叫完成項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的物件標頭中設定一個位元`obj`，當呼叫完成項，執行階段檢查。 完成項，由表示<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法，用來物件被記憶體回收前釋放 unmanaged 的資源。 如果`obj`沒有完成項，呼叫<xref:System.GC.SuppressFinalize%2A>方法沒有任何作用。  
  
 物件，實作<xref:System.IDisposable>介面可以從物件的呼叫此方法<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>實作，以防止記憶體回收行程呼叫<xref:System.Object.Finalize%2A?displayProperty=nameWithType>上不需要的物件。 一般而言，這為了釋放已由釋放的 unmanaged 的資源時，防止完成項<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>實作。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.GC.SuppressFinalize%2A>中的資源類別，以避免重複回收，呼叫的方法。 此範例會使用[處置模式](~/docs/standard/design-guidelines/dispose-pattern.md)同時釋放 managed 資源 (也就是物件實作<xref:System.IDisposable>) 與 unmanaged 資源。  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="https://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb">Dispose 模式</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>嘗試在執行關鍵路徑期間，禁止記憶體回收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。 換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），而且不應會呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功的第一次呼叫時，就算<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">在不觸發記憶體回收的情況下，要配置的記憶體數量 (以位元組為單位)。 該值必須小於或等於暫時區段的大小。 如需暫時區段大小的資訊，請參閱[記憶體回收的基本概念](~/docs/standard/garbage-collection/fundamentals.md)一文中的＜暫時層代和區段＞一節。</param>
        <summary>嘗試在有指定數量記憶體可用時，於執行關鍵路徑期間，禁止記憶體回收。</summary>
        <returns>如果執行階段可以認可所需的記憶體數量且記憶體回收行程可以進入無 GC 區域延遲模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%29>方法會嘗試將記憶體回收行程放在應用程式執行的程式碼的關鍵區域時，不允許記憶體回收無 GC 區域延遲模式。  如果執行階段無法一開始配置要求的記憶體數量，記憶體回收行程會執行完全封鎖記憶體回收，嘗試釋放其他記憶體。 記憶體回收行程會進入無 GC 區域延遲模式，如果無法配置所需的數量的記憶體，在此情況下為實際 2 *`totalSize`位元組 (它會嘗試配置`totalSize`小型物件堆積位元組和`totalSize`的位元組數大型物件堆積）。  
  
 `totalSize` 必須夠大，無法處理發生的關鍵路徑中的所有記憶體配置。 這包括應用程式時，所配置，以及執行階段可讓應用程式的名義的配置。  
  
> [!IMPORTANT]
>  您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。 換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），而且不應會呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功的第一次呼叫時，就算<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 您藉由呼叫結束無 GC 區域延遲模式<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> 超過暫時區段的大小。</exception>
        <exception cref="T:System.InvalidOperationException">處理序處於無 GC 區域延遲模式。</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">記憶體回收的基本概念</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">延遲模式</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">在不觸發記憶體回收的情況下，要配置的記憶體數量 (以位元組為單位)。 該值必須小於或等於暫時區段的大小。 如需暫時區段大小的資訊，請參閱[記憶體回收的基本概念](~/docs/standard/garbage-collection/fundamentals.md)一文中的＜暫時層代和區段＞一節。</param>
        <param name="disallowFullBlockingGC"><see langword="true" /> 表示如果記憶體回收行程最初無法配置 <paramref name="totalSize" /> 個位元組，則省略完全封鎖記憶體回收；否則為 <see langword="false" />。</param>
        <summary>嘗試在有指定數量記憶體可用時，於執行關鍵路徑期間，禁止記憶體回收，並控制在最初沒有足夠的記憶體可用時，記憶體回收行程是否執行完全封鎖記憶體回收。</summary>
        <returns>如果執行階段可以認可所需的記憶體數量且記憶體回收行程可以進入無 GC 區域延遲模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29>方法會嘗試將記憶體回收行程放在應用程式執行的程式碼的關鍵區域時，不允許記憶體回收無 GC 區域延遲模式。  執行階段是否無法一開始配置要求的記憶體數量和`disallowFullBlockingGC`引數是`false`，記憶體回收行程執行完全封鎖記憶體回收，嘗試釋放其他記憶體; 否則配置失敗，而且方法會傳回`false`。 記憶體回收行程會進入無 GC 區域延遲模式，如果無法配置所需的數量的記憶體，在此情況下為實際 2 * `totalSize` (它會嘗試配置`totalSize`針對小物件堆積和`totalSize`大型物件堆積）。  
  
 `totalSize` 必須夠大，無法處理發生的關鍵路徑中的所有記憶體配置。 這包括應用程式時，所配置，以及執行階段可讓應用程式的名義的配置。  
  
 設定`disallowFullBlockingGC`至`true`為了避免完整封鎖記憶體回收集合，如果沒有足夠的記憶體可用的一開始是在負載平衡案例中最有用： 一個系統呼叫這個方法，並準備好接受要求，如果它傳回為報表本身`true`，如果它傳回，將要求重新導向至其他系統的負載平衡器和`false`。 它不藉由呼叫來處理要求時，它可以再執行完全封鎖記憶體回收<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法。  
  
> [!IMPORTANT]
>  您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。 換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），而且不應會呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功的第一次呼叫時，就算<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 您藉由呼叫結束無 GC 區域延遲模式<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> 超過暫時區段的大小。</exception>
        <exception cref="T:System.InvalidOperationException">處理序處於無 GC 區域延遲模式。</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">記憶體回收的基本概念</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">延遲模式</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">在不觸發記憶體回收的情況下，要配置的記憶體數量 (以位元組為單位)。 <paramref name="totalSize" /> - <paramref name="lohSize" /> 必須小於或等於暫時區段的大小。 如需暫時區段大小的資訊，請參閱[記憶體回收的基本概念](~/docs/standard/garbage-collection/fundamentals.md)一文中的＜暫時層代和區段＞一節。</param>
        <param name="lohSize"><paramref name="totalSize" /> 中要用於大型物件堆積 (LOH) 配置的位元組數目。</param>
        <summary>嘗試在大型物件堆積與小型物件堆積有指定數量記憶體可用時，於執行關鍵路徑期間，禁止記憶體回收。</summary>
        <returns>如果執行階段可以認可所需的記憶體數量且記憶體回收行程可以進入無 GC 區域延遲模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29>方法會嘗試將記憶體回收行程放在應用程式執行的程式碼的關鍵區域時，不允許記憶體回收無 GC 區域延遲模式。  如果執行階段無法一開始配置要求的記憶體數量，記憶體回收行程會執行完全封鎖記憶體回收，嘗試釋放其他記憶體。 記憶體回收行程會進入無 GC 區域延遲模式，它是否能夠配置`lohSize`loh 與`totalSize`–`lohSize`針對小物件堆積 (SOH)。  
  
 `lohSize` 必須要夠大，無法處理對於 LOH 來說發生的關鍵路徑中的所有記憶體配置和`totalSize`–`lohSize`必須夠大，無法都處理的 SOH 中發生的關鍵路徑中的所有記憶體配置。 這包括應用程式時，所配置，以及執行階段可讓應用程式的名義的配置。  
  
> [!IMPORTANT]
>  您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。 換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），而且不應會呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功的第一次呼叫時，就算<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 您藉由呼叫結束無 GC 區域延遲模式<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> - <paramref name="lohSize" /> 超過暫時區段大小。</exception>
        <exception cref="T:System.InvalidOperationException">處理序處於無 GC 區域延遲模式。</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">記憶體回收的基本概念</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">延遲模式</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">在不觸發記憶體回收的情況下，要配置的記憶體數量 (以位元組為單位)。 <paramref name="totalSize" /> - <paramref name="lohSize" /> 必須小於或等於暫時區段的大小。 如需暫時區段大小的資訊，請參閱[記憶體回收的基本概念](~/docs/standard/garbage-collection/fundamentals.md)一文中的＜暫時層代和區段＞一節。</param>
        <param name="lohSize"><paramref name="totalSize" /> 中要用於大型物件堆積 (LOH) 配置的位元組數目。</param>
        <param name="disallowFullBlockingGC"><see langword="true" /> 表示如果記憶體回收行程最初無法在小型物件堆積 (SOH) 及 LOH 上配置指定的記憶體，則省略完全封鎖記憶體回收；否則為 <see langword="false" />。</param>
        <summary>嘗試在大型物件堆積與小型物件堆積有指定數量記憶體可用時，於執行關鍵路徑期間，禁止記憶體回收，並控制在最初沒有足夠的記憶體可用時，記憶體回收行程是否執行完全封鎖記憶體回收。</summary>
        <returns>如果執行階段可以認可所需的記憶體數量且記憶體回收行程可以進入無 GC 區域延遲模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29>方法會嘗試將記憶體回收行程放在應用程式執行的程式碼的關鍵區域時，不允許記憶體回收無 GC 區域延遲模式。  執行階段是否無法一開始配置要求的記憶體數量和`disallowFullBlockingGC`引數是`false`，記憶體回收行程執行完全封鎖記憶體回收，嘗試釋放其他記憶體; 否則配置失敗，而且方法會傳回`false`。 記憶體回收行程會進入無 GC 區域延遲模式，它是否能夠配置`lohSize`loh 與`totalSize`–`lohSize`針對小物件堆積 (SOH)。  
  
 `lohSize` 必須要夠大，無法處理對於 LOH 來說發生的關鍵路徑中的所有記憶體配置和`totalSize`–`lohSize`必須夠大，無法都處理的 SOH 中發生的關鍵路徑中的所有記憶體配置。 這包括應用程式時，所配置，以及執行階段可讓應用程式的名義的配置。  
  
 設定`disallowFullBlockingGC`至`true`為了避免完整封鎖記憶體回收集合，如果沒有足夠的記憶體可用的一開始是在負載平衡案例中最有用： 一個系統呼叫這個方法，並準備好接受要求，如果它傳回為報表本身`true`，如果它傳回，將要求重新導向至其他系統的負載平衡器和`false`。 它不藉由呼叫來處理要求時，它可以再執行完全封鎖記憶體回收<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法。  
  
> [!IMPORTANT]
>  您無法巢狀呼叫<xref:System.GC.TryStartNoGCRegion%2A>方法，而且您應該只呼叫<xref:System.GC.EndNoGCRegion%2A>方法，如果執行階段目前處於無 GC 區域延遲模式。 換句話說，您不應該呼叫<xref:System.GC.TryStartNoGCRegion%2A>多次 （第一個方法呼叫之後，後續呼叫將不會成功），而且不應會呼叫<xref:System.GC.EndNoGCRegion%2A>才會成功的第一次呼叫時，就算<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 您藉由呼叫結束無 GC 區域延遲模式<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> - <paramref name="lohSize" /> 超過暫時區段大小。</exception>
        <exception cref="T:System.InvalidOperationException">處理序處於無 GC 區域延遲模式。</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">記憶體回收的基本概念</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">延遲模式</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回註冊通知的狀態，以判斷 Common Language Runtime 是否即將執行完整的封鎖記憶體回收。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回註冊通知的狀態，以判斷 Common Language Runtime 是否即將執行完整的封鎖記憶體回收。</summary>
        <returns>已註冊記憶體回收通知的狀態。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.GCNotificationStatus>列舉型別，這個方法來判斷目前記憶體回收通知，使用已註冊狀態傳回<xref:System.GC.RegisterForFullGCNotification%2A>方法。 您也可以使用<xref:System.GC.WaitForFullGCComplete%2A>方法，以判斷是否已完成完整記憶體回收。  
  
 當此列舉會傳回<xref:System.GCNotificationStatus.Succeeded>，您可以執行工作，例如防止其他物件配置，並使用您自己誘導集合<xref:System.GC.Collect%2A>方法。 請注意，通知並不保證，完整記憶體回收，就會發生只有該條件已達到是負責進行完整記憶體回收的臨界值。  
  
 這個方法會無限期地等候取得記憶體回收通知。 如果您想要指定這個方法傳回 如果無法取得通知的逾時期間，使用<xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>方法多載。 如果您未指定逾時呼叫這個方法，您可以呼叫<xref:System.GC.CancelFullGCNotification%2A>方法，如果您在慣用的內容超過等候。  
  
 您應該遵循藉由呼叫這個方法<xref:System.GC.WaitForFullGCComplete%2A>方法以確定您已完整記憶體回收。 呼叫這個方法只會造成未定的結果。  
  
   
  
## Examples  
 下列範例示範如何使用此方法來判斷是否已接近完整的封鎖記憶體回收。 通知的狀態是每當<xref:System.GCNotificationStatus.Succeeded>，將使用者方法`OnFullGCApproachNotify`呼叫以執行動作以回應到接近的集合。 此程式碼範例是針對提供之較大範例的一部分[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)主題。  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">記憶體回收告知</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">在可以取得通知之前所要等待的時間長度。 指定 -1 會無限期等待。</param>
        <summary>在指定的逾時期間傳回註冊通知的狀態，以判斷 Common Language Runtime 是否即將執行完整的封鎖記憶體回收。</summary>
        <returns>已註冊記憶體回收通知的狀態。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.GCNotificationStatus>列舉型別，這個方法來判斷目前記憶體回收通知，使用已註冊狀態傳回<xref:System.GC.RegisterForFullGCNotification%2A>方法。 您也可以使用<xref:System.GC.WaitForFullGCComplete%2A>方法，以判斷是否已完成完整記憶體回收。  
  
 請注意，這個方法傳回時要取得記憶體回收集合通知狀態，不論所指定的值，請立即`millisecondsTimeout`。 如果之前未取得記憶體回收集合通知狀態`millisecondsTimeout`次，這個方法會傳回<xref:System.GCNotificationStatus.NotApplicable>。  
  
 當此列舉會傳回<xref:System.GCNotificationStatus.Succeeded>，您可以執行工作，例如防止其他物件配置，並使用您自己誘導集合<xref:System.GC.Collect%2A>方法。 請注意，通知並不保證，完整記憶體回收，就會發生只有該條件已達到是負責進行完整記憶體回收的臨界值。  
  
 您可以呼叫<xref:System.GC.CancelFullGCNotification%2A>方法時您不能等候逾時週期過後。  
  
 您應該遵循藉由呼叫這個方法<xref:System.GC.WaitForFullGCComplete%2A>方法以確定您已完整記憶體回收。 呼叫這個方法只會造成未定的結果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 必須為非負數，或是小於或等於 <see cref="F:System.Int32.MaxValue" /> 或 -1。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">記憶體回收告知</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回註冊通知的狀態，以判斷 Common Language Runtime 是否已完成完整的封鎖記憶體回收。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回註冊通知的狀態，以判斷 Common Language Runtime 是否已完成完整的封鎖記憶體回收。</summary>
        <returns>已註冊記憶體回收通知的狀態。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.GCNotificationStatus>列舉型別，這個方法來判斷目前記憶體回收通知，使用已註冊狀態傳回<xref:System.GC.RegisterForFullGCNotification%2A>方法。 您也可以使用<xref:System.GC.WaitForFullGCApproach%2A>方法，以判斷是否即將完整記憶體回收。  
  
 當此列舉會傳回<xref:System.GCNotificationStatus.Succeeded>，您可以執行工作，例如繼續執行的工作，並取得與集合計數<xref:System.GC.CollectionCount%2A>屬性。  
  
 這個方法會無限期地等候取得記憶體回收通知。 如果您想要指定這個方法傳回 如果無法取得通知的逾時期間，使用<xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>方法多載。 如果您未指定逾時呼叫這個方法，您可以呼叫<xref:System.GC.CancelFullGCNotification%2A>方法，如果您在慣用的內容超過等候。  
  
 這個方法呼叫應該在前面加上呼叫<xref:System.GC.WaitForFullGCApproach%2A>方法以確定您已完整記憶體回收。 單獨呼叫這個方法可能會產生未定的結果。  
  
   
  
## Examples  
 下列範例示範如何使用這個方法來判斷是否已完成完整記憶體回收。 通知的狀態是每當<xref:System.GCNotificationStatus.Succeeded>，將使用者方法`OnFullGCCompletedNotify`呼叫以執行動作以回應已完成的集合。 此程式碼範例是針對提供之較大範例的一部分[記憶體回收通知](~/docs/standard/garbage-collection/notifications.md)主題。  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">記憶體回收告知</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">在可以取得通知之前所要等待的時間長度。 指定 -1 會無限期等待。</param>
        <summary>在指定的逾時期間傳回註冊通知的狀態，以判斷 Common Language Runtime 是否已完成完整的封鎖記憶體回收。</summary>
        <returns>已註冊記憶體回收通知的狀態。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.GCNotificationStatus>列舉型別，這個方法來判斷目前記憶體回收通知，使用已註冊狀態傳回<xref:System.GC.RegisterForFullGCNotification%2A>方法。 您也可以使用<xref:System.GC.WaitForFullGCApproach%2A>方法，以判斷是否即將完整記憶體回收。  
  
 請注意，這個方法傳回時要取得記憶體回收集合通知狀態，不論所指定的值，請立即`millisecondsTimeout`。 如果之前未取得記憶體回收集合通知狀態`millisecondsTimeout`次，這個方法會傳回<xref:System.GCNotificationStatus.NotApplicable>。  
  
 當此列舉會傳回<xref:System.GCNotificationStatus.Succeeded>，您可以執行工作，例如繼續執行的工作，並取得與集合計數<xref:System.GC.CollectionCount%2A>屬性。  
  
 您可以呼叫<xref:System.GC.CancelFullGCNotification%2A>方法時您不能等候逾時週期過後。  
  
 這個方法呼叫應該在前面加上呼叫<xref:System.GC.WaitForFullGCApproach%2A>方法以確定您已完整記憶體回收。 單獨呼叫這個方法可能會產生未定的結果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="millisecondsTimeout" /> 必須為非負數，或是小於或等於 <see cref="F:System.Int32.MaxValue" /> 或 -1。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">記憶體回收告知</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>暫止目前的執行緒，直到處理完成項佇列的執行緒已經清空該佇列為止。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當記憶體回收行程會發現可以回收的物件時，它會檢查每個物件，以判斷物件的最終處理需求。 如果物件會實作完成項，並且具有未停用完成項呼叫<xref:System.GC.SuppressFinalize%2A>，該物件位於標示為準備進行最終處理的物件清單。 記憶體回收行程呼叫<xref:System.Object.Finalize%2A>這個清單並移除的項目從清單中物件的方法。 這個方法會封鎖直到所有的完成項已執行到完成為止。  
  
 在其執行完成項執行緒未指定，因此這個方法會終止不保證。 不過，這個執行緒可以中斷時的另一個執行緒<xref:System.GC.WaitForPendingFinalizers%2A>方法正在進行中。 例如，您可以啟動另一個執行緒等候一段時間，然後中斷這個執行緒，如果仍然已暫止這個執行緒。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.GC.WaitForPendingFinalizers%2A>暫停目前的執行緒，直到最終處理的所有收集到的物件已完成的方法。  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>