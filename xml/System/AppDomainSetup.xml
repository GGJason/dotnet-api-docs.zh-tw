<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1f05dce13542dbb9caf55c70a48dd0b48580cdc9" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37481692" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents assembly binding information that can be added to an instance of <see cref="T:System.AppDomain" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 變更的屬性<xref:System.AppDomainSetup>執行個體不會影響任何現有<xref:System.AppDomain>。 它可能會影響建立的新<xref:System.AppDomain>，當<xref:System.AppDomain.CreateDomain%2A>方法呼叫<xref:System.AppDomainSetup>做為參數的執行個體。  
  
 這個類別會實作 <xref:System.IAppDomainSetup> 介面。  
  
> [!CAUTION]
>  預設值為<xref:System.AppDomainSetup.DisallowCodeDownload%2A>屬性為 false。 此設定是不安全的服務。 為了防止服務下載部分信任程式碼，此屬性設定為 true  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.AppDomainSetup" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.AppDomainSetup" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">The activation context to be used for an application domain.</param>
        <summary>Initializes a new instance of the <see cref="T:System.AppDomainSetup" /> class with the specified activation context to use for manifest-based activation of an application domain.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ActivationContext>針對指定的物件`activationContext`用來產生<xref:System.Runtime.Hosting.ActivationArguments>物件，包含啟動新的應用程式定義域所需的資訊。 這<xref:System.Runtime.Hosting.ActivationArguments>可存取物件，請使用<xref:System.AppDomainSetup.ActivationArguments%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationContext" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" />
      </Parameters>
      <Docs>
        <param name="activationArguments">An object that specifies information required for the manifest-based activation of a new application domain.</param>
        <summary>Initializes a new instance of the <see cref="T:System.AppDomainSetup" /> class with the specified activation arguments required for manifest-based activation of an application domain.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的物件`activationArguments`可以使用來存取<xref:System.AppDomainSetup.ActivationArguments%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationArguments" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets data about the activation of an application domain.</summary>
        <value>物件，包含與應用程式定義域之啟動有關的資料。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性設定為將會擲回任何例外狀況`null`。  
  
 所提供的資訊<xref:System.Runtime.Hosting.ActivationArguments>物件支援資訊清單型啟用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The property is set to an <see cref="T:System.Runtime.Hosting.ActivationArguments" /> object whose application identity does not match the application identity of the <see cref="T:System.Security.Policy.ApplicationTrust" /> object returned by the <see cref="P:System.AppDomainSetup.ApplicationTrust" /> property. No exception is thrown if the <see cref="P:System.AppDomainSetup.ApplicationTrust" /> property is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.AppDomainInitializer" /> delegate, which represents a callback method that is invoked when the application domain is initialized.</summary>
        <value>表示回呼方法的委派，在應用程式定義域初始化時會叫用此方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要將資訊傳遞至回呼方法，將指派的字串陣列<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>屬性。 陣列傳遞至回呼方法，每次<xref:System.AppDomain>初始化。  
  
 新建立的應用程式定義域的內容中執行的回呼方法。  
  
   
  
## Examples  
 下列範例會建立名為的子應用程式定義域`ChildDomain`，並使用<xref:System.AppDomainSetup>物件和從預設應用程式定義域的辨識項。 <xref:System.AppDomainSetup.AppDomainInitializer%2A>屬性設為回呼方法`AppDomainInit`，叫用所在的子定義域初始化時。 回呼方法的引數會放在字串指派給陣列<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>屬性。 建立子網域時，回呼方法只會列印字串。  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the arguments passed to the callback method represented by the <see cref="T:System.AppDomainInitializer" /> delegate. The callback method is invoked when the application domain is initialized.</summary>
        <value>傳遞至回呼方法所表示的字串陣列<see cref="T:System.AppDomainInitializer" />期間叫用回呼方法的委派<see cref="T:System.AppDomain" />初始化。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.AppDomainSetup.AppDomainInitializer%2A>屬性來指定期間叫用的回呼方法<xref:System.AppDomain>初始化。 如果<xref:System.AppDomainSetup.AppDomainInitializer%2A>屬性未設定時，不會使用指派給這個屬性的陣列。  
  
 新建立的應用程式定義域的內容中執行的回呼方法。  
  
   
  
## Examples  
 下列程式碼範例會建立名為的子應用程式定義域`ChildDomain`，並使用<xref:System.AppDomainSetup>物件和從預設應用程式定義域的辨識項。 <xref:System.AppDomainSetup.AppDomainInitializer%2A>屬性設為回呼方法`AppDomainInit`，叫用所在的子定義域初始化時。 回呼方法的引數會放在字串指派給陣列<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>屬性。 建立子網域時，回呼方法只會列印字串。  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the display name of the assembly that provides the type of the application domain manager for application domains created using this <see cref="T:System.AppDomainSetup" /> object.</summary>
        <value>提供的組件的顯示名稱<see cref="T:System.Type" />應用程式定義域管理員。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要指定的應用程式定義域管理員類型，設定這個屬性和<xref:System.AppDomainSetup.AppDomainManagerType%2A>屬性。 如果未設定這些屬性的其中一個項目，則會忽略其他。  
  
 如果未不提供任何型別，則應用程式定義域管理員會建立從父系應用程式網域相同的型別 (也就是應用程式定義域從中<xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>方法呼叫)。  
  
 載入應用程式定義域時，<xref:System.TypeLoadException>組件不存在，則組件不包含所指定的型別會擲回<xref:System.AppDomainSetup.AppDomainManagerType%2A>屬性。 <xref:System.IO.FileLoadException> 如果找到組件，但不是符合的版本資訊，會擲回。  
  
 若要設定預設應用程式定義域的應用程式網域管理員，使用[ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md)並[ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md)中的項目[\<執行階段 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)應用程式組態檔或使用環境變數中所述的區段<xref:System.AppDomainManager>。  
  
 這項功能需要有完全信任應用程式。 （例如，在桌面上執行的應用程式有完全信任）。如果應用程式並沒有完全信任，<xref:System.TypeLoadException>就會擲回。  
  
 組件顯示名稱的格式由指定<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the full name of the type that provides the application domain manager for application domains created using this <see cref="T:System.AppDomainSetup" /> object.</summary>
        <value>類型的完整名稱，包含命名空間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要指定的應用程式定義域管理員類型，設定這個屬性和<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>屬性。 如果未設定這些屬性的其中一個項目，則會忽略其他。  
  
 如果未不提供任何型別，則應用程式定義域管理員會建立從父系應用程式網域相同的型別 (也就是應用程式定義域從中<xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>方法呼叫)。  
  
 載入應用程式定義域時，<xref:System.TypeLoadException>所指定的組件便會擲回<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>屬性不包含這個屬性所指定的型別。  
  
 若要設定預設應用程式定義域的應用程式網域管理員，使用[ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md)並[ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md)中的項目[\<執行階段 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)應用程式組態檔或使用環境變數中所述的區段<xref:System.AppDomainManager>。  
  
 這項功能需要有完全信任應用程式。 （例如，在桌面上執行的應用程式有完全信任）。如果應用程式並沒有完全信任，<xref:System.TypeLoadException>就會擲回。  
  
 型別的完整名稱的格式由指定<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the directory containing the application.</summary>
        <value>應用程式基底目錄的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式基底目錄是組件管理員開始探查組件。  
  
 <xref:System.AppDomainSetup.ApplicationBase%2A>屬性可能會影響哪些權限會授與應用程式定義域。 比方說，通常來自本機電腦的應用程式定義域會接收依據其原始位置的完全信任。 不過，如果<xref:System.AppDomainSetup.ApplicationBase%2A>屬性<xref:System.AppDomain>設定為內部網路目錄的完整名稱<xref:System.AppDomainSetup.ApplicationBase%2A>設定會限制授與 LocalIntranet 授與應用程式定義域即使應用程式定義域的權限確實來自本機電腦。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.AppDomainSetup.ApplicationBase%2A>屬性來設定組件載入器開始探查組件載入到新的應用程式定義域的位置。  
  
> [!NOTE]
>  您必須確定您指定的資料夾存在。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取的路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the application.</summary>
        <value>應用程式的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何設定<xref:System.AppDomainSetup.ApplicationName%2A>當您建立新的應用程式定義域的屬性。  
  
 此範例會建立新的應用程式定義域，然後呼叫<xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>方法來載入新的應用程式定義域中的範例組件，並建立的執行個體`Worker`類別。 `Worker`類別會繼承<xref:System.MarshalByRefObject>，所以此範例可以使用所傳回的 proxy<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>呼叫`TestLoad`方法。  
  
 `TestLoad`方法載入組件，您所指定。 您必須指定有效的、 完整的組件的名稱，或取消註解<xref:System.Reflection.Assembly.Load%28System.String%29>方法。 `TestLoad`方法列出的組件載入至新的應用程式定義域中，顯示您指定的組件和範例組件會載入。  
  
 此範例會使用<xref:System.LoaderOptimizationAttribute>告知如何應用程式時，會跨應用程式定義域共用程式碼的組件載入器的屬性。  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an object containing security and trust information.</summary>
        <value>包含安全性和信任資訊的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性就`null`當<xref:System.AppDomainSetup>建立。 變更後，無法重設為 null 參考。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The property is set to an <see cref="T:System.Security.Policy.ApplicationTrust" /> object whose application identity does not match the application identity of the <see cref="T:System.Runtime.Hosting.ActivationArguments" /> object returned by the <see cref="P:System.AppDomainSetup.ActivationArguments" /> property. No exception is thrown if the <see cref="P:System.AppDomainSetup.ActivationArguments" /> property is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">The property is set to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of an area specific to the application where files are shadow copied.</summary>
        <value>陰影複製之檔案的目錄路徑與檔案名稱的完整限定名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 為了讓這個屬性，以造成的影響，<xref:System.AppDomainSetup.ApplicationName%2A>也必須設定屬性。 如果<xref:System.AppDomainSetup.ApplicationName%2A>未設定屬性，<xref:System.AppDomainSetup.CachePath%2A>屬性會被忽略，且預設為下載快取的陰影複本快取位置。  
  
 如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取的路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the configuration file for an application domain.</summary>
        <value>組態檔的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組態檔會描述應用程式定義域的組態資料與搜尋規則。 建立應用程式定義域主機負責提供這項資料，因為有意義的值不同的狀況。  
  
 比方說，ASP.NET 應用程式的組態資料儲存為每個應用程式、 網站和電腦，而可執行檔的組態資料會儲存每個應用程式、 使用者和電腦。 主應用程式知道特定的一種情況的組態資料的細節。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取的路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the application base path and private binary path are probed when searching for assemblies to load.</summary>
        <value>如果不允許探查，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>屬性是`true`，值<xref:System.AppDomainSetup.ApplicationBase%2A>屬性會被忽略。 也就是任何組件會探查如中所指定的目錄<xref:System.AppDomainSetup.ApplicationBase%2A>屬性。 此外，值<xref:System.AppDomainSetup.PrivateBinPath%2A>屬性和<xref:System.AppDomainSetup.PrivateBinPathProbe%2A>屬性會被忽略。 任何組件會針對所指定的目錄中探查<xref:System.AppDomainSetup.PrivateBinPath%2A>屬性。  
  
 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>屬性會提供一層額外的載入程序的控制權。 標準的組件載入順序時，應用程式基底會探查之前<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>就會引發事件。 不過，某些應用程式可能需要從 OLE 複合檔案的文件，或不在全域組件快取中，也不在所指定的目錄中唯一的已知位置載入組件<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>屬性。 這類應用程式可以使用<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>屬性，以避免一般的探查時，所造成的延遲，並避免載入必要的組件可能會位於一般探查路徑的複本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether an application domain allows assembly binding redirection.</summary>
        <value>如果不允許組件重新導向，則為 <see langword="true" />；如果允許，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowBindingRedirects%2A>屬性設計用於服務和伺服器應用程式組件繫結重新導向不是屬於應用程式案例。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether HTTP download of assemblies is allowed for an application domain.</summary>
        <value>如果不允許以 HTTP 下載組件，則為 <see langword="true" />；如果允許，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowCodeDownload%2A>屬性設計用於服務和伺服器應用程式，從內部網路或網際網路下載的程式碼不是應用程式案例的一部分。  
  
> [!CAUTION]
>  預設值<xref:System.AppDomainSetup.DisallowCodeDownload%2A>屬性是`false`。 此設定是不安全的服務。 為了防止服務下載部分信任程式碼，請將此屬性設定為`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) section of the configuration file is applied to an application domain.</summary>
        <value>如果忽略應用程式定義域之組態檔的 <see langword="&lt;publisherPolicy&gt;" /> 區段，則為 <see langword="true" />；如果遵循所宣告的發行者原則，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A>屬性特別適用於在本機載入的 Web 應用程式。 使用這個屬性來協助防止惡意嘗試在安全模式中執行的不安全的 Web 應用程式。  
  
 如需有關如何略過發行者原則的詳細資訊，請參閱[重新導向組件版本](~/docs/framework/configure-apps/redirect-assembly-versions.md)主題。 如需安全模式的詳細資訊，請參閱 「 檢查組態檔 > 一節[執行階段如何找出組件](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)主題。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the base directory where the directory for dynamically generated files is located.</summary>
        <value>
          <see cref="P:System.AppDomain.DynamicDirectory" /> 所在的目錄。  
 <block subset="none" type="note"><para> 這個屬性的傳回值是不同於指派的值。 </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 若要設定的基底目錄即將放置新的應用程式定義域的動態目錄中使用這個屬性。 當新的應用程式定義域中的程式碼會載入組件、 組件解析會尋找在一般探查路徑中第一個。 如果找不到組件，它會尋找在動態的目錄中，由<xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType>屬性。 會載入並執行新的應用程式定義域的動態組件可以放在該處。  
  
 當您將指派的路徑<xref:System.AppDomainSetup.DynamicBase%2A>屬性，加入額外的子目錄，這個子目錄的名稱是指派給值的雜湊碼<xref:System.AppDomainSetup.ApplicationName%2A>屬性。 因此，後續傳回這個屬性的基底目錄是永遠不同於指派的值。  
  
> [!IMPORTANT]
>  將值指派給這個屬性不會建立任何目錄。 必須建立或使用它們的程式碼所經過的目錄。  
  
 動態的目錄是子目錄的<xref:System.AppDomainSetup.DynamicBase%2A>。 其簡單的名稱是所傳回的值<xref:System.AppDomainSetup.ApplicationName%2A>屬性，因此它的格式*原始路徑*\\*雜湊碼*\\*應用程式名稱*.  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.AppDomainSetup.DynamicBase%2A>載入動態組件時，探查路徑設為應用程式定義域的屬性。  
  
 此範例會建立<xref:System.AppDomainSetup>物件以及設定其<xref:System.AppDomainSetup.ApplicationName%2A>"Example"的屬性並將其<xref:System.AppDomainSetup.DynamicBase%2A>"C:\DynamicAssemblyDir"的屬性。 此範例接著會顯示<xref:System.AppDomainSetup.DynamicBase%2A>屬性，以顯示應用程式名稱的雜湊碼，已附加為原本指派路徑的子目錄。  
  
> [!NOTE]
>  在此範例中的基底目錄就是要探查路徑外部的範例應用程式。 請務必在編譯中的不同位置的範例。 刪除的基底目錄及其所有子目錄每次執行此範例的資訊。  
  
 此範例會建立新的應用程式網域使用<xref:System.AppDomainSetup>物件。 如果不存在，這個範例會建立動態的目錄。 雖然此範例會使用應用程式定義域的<xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType>屬性來取得動態的目錄中，名稱就可輕鬆地建立目錄事先藉由串連的原始路徑，應用程式名稱的雜湊碼，應用程式名稱。  
  
 此範例包含 `GenerateDynamicAssembly`方法，會發出名為組件`DynamicHelloWorld.dll`並將它儲存在新的應用程式定義域的動態目錄中。 動態組件包含一種類型， `HelloWorld`，，有一個靜態方法 (`Shared`方法，在 Visual Basic 中的) 名為`HelloFromAD`。 呼叫這個方法會顯示應用程式定義域的名稱。  
  
 `Example`類別衍生自<xref:System.MarshalByRefObject>，因此範例可以建立類別的執行個體，在新的應用程式定義域，並呼叫其`Test`方法。 `Test`方法會依其顯示名稱載入的動態組件，並呼叫靜態`HelloFromAD`方法。  
  
 您可以顯示的動態目錄搜尋一般探查路徑之後，撰寫程式碼組件名為`DynamicHelloWorld.dll`和編譯此範例中的相同目錄中。 組件必須具有一個名為類別`HelloWorld`靜態方法，名為`HelloFromAD`。 這個方法不需要有相同的功能與在範例中，它只可以在主控台中顯示的字串。 組件也必須<xref:System.Reflection.AssemblyVersionAttribute>將它的版本設定為 1.0.0.0 的屬性。 當您執行範例時，才能動態的目錄中搜尋找到您編譯目前目錄中的組件。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">This property cannot be set because the application name on the application domain is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取的路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the XML configuration information set by the <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> method, which overrides the application's XML configuration information.</summary>
        <returns>An array that contains the XML configuration information that was set by the <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> method, or <see langword="null" /> if the <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> method has not been called.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法可用來覆寫的應用程式，建立新的應用程式定義域的組態資訊。 中的設定檔資訊`value`覆寫應用程式的設定檔資訊。 例如，當 Example.exe 應用程式建立新的應用程式定義域時，它可以覆寫原先取自 Example.exe.config 檔案的組態資訊。  
  
> [!IMPORTANT]
>  部分的設定檔資訊的取用者不會使用儲存的資訊<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法。 執行階段不會強制這。 若要確保新的應用程式定義域中遭到覆寫所有的設定檔資訊，請使用<xref:System.AppDomainSetup.ConfigurationFile%2A>屬性來指定組態檔。 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法，並會影響組件繫結。  
  
 中的 XML`value`等同於在一般組態檔中，XML 不同之處在於它會儲存為<xref:System.Byte>陣列。  
  
 若要存取應用程式定義域的組態位元組，使用<xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType>屬性來取得<xref:System.AppDomainSetup>物件的應用程式定義域，然後使用<xref:System.AppDomainSetup.GetConfigurationBytes%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the location of the license file associated with this domain.</summary>
        <value>授權檔的位置和名稱。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取的路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies the optimization policy used to load an executable.</summary>
        <value>列舉的常數，可搭配<see cref="T:System.LoaderOptimizationAttribute" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建立動態組件，並將它儲存到磁碟，然後再使用<xref:System.AppDomainSetup.LoaderOptimization%2A>屬性來設定用來將組件載入應用程式定義域的最佳化原則。  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a list of assemblies marked with the <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> flag that are made visible to partial-trust code running in a sandboxed application domain.</summary>
        <value>部分組件名稱的陣列，其中每一個部分名稱都是由簡易組件名稱和公開金鑰組成。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.Security.AllowPartiallyTrustedCallersAttribute>(APTCA) 屬性可條件式藉由設定其<xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A>屬性設<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>。 APTCA 組件標記為<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>除非主應用程式可讓它無法由部分信任程式碼。  
  
 沙箱應用程式定義域的主應用程式可讓應用程式定義域，以搭配條件式 APTCA 屬性中的組件，藉由建立陣列，其中包含公開金鑰的每個組件，與簡單的名稱，並將陣列指派給這個屬性中的程式碼。 例如，陣列項目可能如下所示:"MyAssembly，PublicKey =0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9"。  
  
> [!IMPORTANT]
>  如果您使用的子類別<xref:System.AppDomainManager>，並定義它的組件相依於以條件式 APTCA 屬性標記的組件，您必須包含這些組件的清單中，您將傳遞給<xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A>屬性<xref:System.AppDomainSetup>您用來建立應用程式定義域。 否則將會停用條件式 APTCA 屬性標記的組件。  
  
> [!NOTE]
>  當您偵錯的應用程式，在沙箱應用程式網域中，執行某些<xref:System.Security.SecurityException>訊息可能會產生誤導。 例如，訊息可能狀態，您完全信任的組件的其中一個只能進行有限的權限，當實際問題的原因是超過沙箱應用程式定義域的授權集的安全性要求，傳播到的界限沙箱應用程式定義域但失敗。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the list of directories under the application base directory that are probed for private assemblies.</summary>
        <value>以分號分隔的目錄名稱清單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 私用組件會部署在相同的目錄結構與應用程式。 如果針對指定的目錄<xref:System.AppDomainSetup.PrivateBinPath%2A>不是下方<xref:System.AppDomainSetup.ApplicationBase%2A>，則會予以忽略。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a string value that includes or excludes <see cref="P:System.AppDomainSetup.ApplicationBase" /> from the search path for the application, and searches only <see cref="P:System.AppDomainSetup.PrivateBinPath" />.</summary>
        <value>Null 參考 (<see langword="Nothing" /> Visual Basic 中) 以包含搜尋組件時的應用程式基底路徑; 任何非 null 字串值的路徑排除。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將此屬性設定為任何非 null 字串值，包括<xref:System.String.Empty?displayProperty=nameWithType>("")，若要排除的應用程式的目錄路徑，也就是<xref:System.AppDomainSetup.ApplicationBase%2A>— 應用程式，以及要搜尋的組件的搜尋路徑中只在<xref:System.AppDomainSetup.PrivateBinPath%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether interface caching is disabled for interop calls in the application domain, so that a <c>QueryInterface</c> is performed on each call.</summary>
        <value>
          <see langword="true" /> 如果與目前所建立的應用程式定義域中 interop 呼叫介面快取已停用<see cref="T:System.AppDomainSetup" />物件; 否則<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 停用介面快取的 interop 呼叫的效能有重大影響。  
  
 這個成員在引進[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="switches">An enumerable set of string values that specify compatibility switches, or <see langword="null" /> to erase the existing compatibility switches.</param>
        <summary>Sets the specified switches, making the application domain compatible with previous versions of the .NET Framework for the specified issues.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 的主要版本有時候會引進重大變更來自舊版本。 例如，[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]導入了少數的重大變更[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。 使用<xref:System.AppDomainSetup.SetCompatibilitySwitches%2A>方法，以指定的一或多個這些重大變更將會回復應用程式定義域，以讓其行為與舊版的.NET Framework 相容。  
  
 每次呼叫此方法，它會取代現有的交換器設定。 若要清除的設定值，指定`null`針對`switches`參數。  
  
 為所提供的字串值的集合`switches`可以是簡單的字串陣列，因為陣列實作<xref:System.Collections.IEnumerable>介面。  
  
 下表提供可以設定以還原舊版的.NET framework 的行為的相容性參數的範例。  
  
|參數|意義|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|程式碼存取安全性 (CAS)[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]啟用此應用程式定義域中。 請參閱[ &lt;NetFx40_LegacySecurityPolicy&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)。|  
|"NetFx40_Legacy20SortingBehavior"|排序的預設值的字串[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]這個應用程式定義域中已啟用。 已成功還原舊版排序行為也需要在本機系統上提供的 sort00001000.dll 動態連結程式庫。 請參閱[ &lt;CompatSortNLSVersion&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)。|  
|"NetFx40_Legacy40SortingBehavior"|排序的預設值的字串[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和 Unicode 5.0 會啟用此應用程式定義域中。 已成功還原舊版排序行為時，也會需要 sort00060101.dll 動態連結程式庫，可在本機系統上。|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> 格式化行為的[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]啟用此應用程式定義域中。 請參閱[ &lt;TimeSpan_LegacyFormatMode&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)和 「 還原舊版 TimeSpan 格式化 」 一節的<xref:System.TimeSpan>主題。|  
|"UseRandomizedStringHashAlgorithm"|執行階段計算字串的雜湊碼在每個應用程式定義域為基準，而不是使用單一的雜湊演算法可跨應用程式定義域產生一致雜湊碼。 請參閱[ &lt;UseRandomizedStringHashAlgorithm&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">An array that contains the XML configuration information to be used for the application domain.</param>
        <summary>Provides XML configuration information for the application domain, replacing the application's XML configuration information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法可用來取代建立新的應用程式定義域的應用程式的組態資訊。 中的設定檔資訊`value`取代應用程式的設定檔資訊。 比方說，當 Example.exe 應用程式建立新的應用程式定義域時，它可以取代原本取自 Example.exe.config 檔案的組態資訊。  
  
> [!IMPORTANT]
>  部分的設定檔資訊的取用者不會使用儲存的資訊<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法。 執行階段不會強制這。 若要確保所有的設定檔資訊會取代新的應用程式定義域中，使用<xref:System.AppDomainSetup.ConfigurationFile%2A>屬性來指定組態檔。 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法，並會影響組件繫結。  
  
 中的 XML`value`等同於在一般組態檔中，XML 不同之處在於它會儲存為<xref:System.Byte>陣列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="functionVersion" Type="System.Int32" />
        <Parameter Name="functionPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="functionName">The name of the string comparison function to override.</param>
        <param name="functionVersion">The function version. For [!INCLUDE[net_v45](~/includes/net-v45-md.md)], its value must be 1 or greater.</param>
        <param name="functionPointer">A pointer to the function that overrides <c>functionName</c>.</param>
        <summary>Provides the common language runtime with an alternate implementation of a string comparison function.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下列的字串比較和排序方法可以覆寫<xref:System.AppDomainSetup.SetNativeFunction%2A>方法：  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 如需這些函式的詳細資訊，請參閱[國家語言支援函式](http://go.microsoft.com/fwlink/?LinkId=228134)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionVersion" /> is not 1 or greater.  -or-  <paramref name="functionPointer" /> is <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the names of the directories containing assemblies to be shadow copied.</summary>
        <value>以分號分隔的目錄名稱清單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 啟用陰影複製時，預設值是要透過探查; 找到的所有組件的陰影複製也就是指定的目錄中由<xref:System.AppDomainSetup.PrivateBinPath%2A>和<xref:System.AppDomainSetup.ApplicationBase%2A>屬性。 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>屬性會限制所指定的目錄中的組件陰影複製<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>。  
  
 如果您不指派字串給 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> 屬性，或如果您將這個屬性設定為 `null`，則會陰影複製 <xref:System.AppDomainSetup.ApplicationBase%2A> 和 <xref:System.AppDomainSetup.PrivateBinPath%2A> 屬性所指定目錄中的所有組件。  
  
> [!IMPORTANT]
>  目錄路徑不可包含分號，因為分號是分隔符號字元。 分號沒有逸出字元。  
  
 當陰影複製作用中時，組件檔會複製到另一個位置之前載入的組件。 原始的組件檔未鎖定，因此可以更新。 如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取的路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a string that indicates whether shadow copying is turned on or off.</summary>
        <value>字串值 "true" 表示陰影複製為開啟，"false" 表示陰影複製為關閉。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a string that specifies the target version and profile of the .NET Framework for the application domain, in a format that can be parsed by the <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> constructor.</summary>
        <value>.NET Framework 的目標版本和設定檔。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性，以告知目前執行版本的.NET Framework 應用程式定義域會用以載入和執行目標版本和設定檔的已編譯的組件。 如果目前執行版本的.NET Framework 有選擇性的行為會影響使用目標版本所編譯的程式碼的相容性，它可以啟用或停用這些行為，視需要以提高相容性。 當應用程式支援增益集的個別應用程式定義域中執行它們來使用多個版本的.NET framework 編譯時，這非常有用。  
  
 用戶端應用程式，windows 7<xref:System.AppDomainSetup.TargetFrameworkName%2A>屬性會從推斷<xref:System.Runtime.Versioning.TargetFrameworkAttribute>屬性。 在 [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)]和更新版本中，這個屬性會加入至組件會根據專案的設定，自動**目標 Framework**屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>