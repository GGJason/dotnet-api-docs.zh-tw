<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="de1a8d1ecd07f9f8d0291eb6d18e2d042042a9b2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30730032" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示可加入至 <see cref="T:System.AppDomain" /> 的執行個體的組件 (Assembly) 繫結資訊。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 變更的屬性<xref:System.AppDomainSetup>執行個體不會影響任何現有<xref:System.AppDomain>。 它可能會影響建立新的<xref:System.AppDomain>，當<xref:System.AppDomain.CreateDomain%2A>方法呼叫<xref:System.AppDomainSetup>做為參數的執行個體。  
  
 這個類別會實作 <xref:System.IAppDomainSetup> 介面。  
  
> [!CAUTION]
>  預設值為<xref:System.AppDomainSetup.DisallowCodeDownload%2A>屬性為 false。 這項設定是不安全的服務。 為了避免服務下載部分信任程式碼，將此屬性設定為 true  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.AppDomainSetup" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.AppDomainSetup" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">用於應用程式定義域的啟動內容。</param>
        <summary>使用指定之啟動內容初始化 <see cref="T:System.AppDomainSetup" /> 類別的新執行個體 (此啟動內容是用於應用程式定義域之資訊清單為主的啟動作業)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ActivationContext>物件指定`activationContext`用來產生<xref:System.Runtime.Hosting.ActivationArguments>物件，其中包含啟動新的應用程式定義域所需的資訊。 這<xref:System.Runtime.Hosting.ActivationArguments>物件可以使用來存取<xref:System.AppDomainSetup.ActivationArguments%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationContext" /> 為 <see langword="null" />。</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" />
      </Parameters>
      <Docs>
        <param name="activationArguments">物件，可指定新應用程式定義域之資訊清單為主的啟動作業所需的資訊。</param>
        <summary>使用應用程式定義域之資訊清單為主的啟動作業所需的指定之啟動引數，初始化 <see cref="T:System.AppDomainSetup" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的物件`activationArguments`可以使用來存取<xref:System.AppDomainSetup.ActivationArguments%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationArguments" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與應用程式定義域的啟動有關的資料。</summary>
        <value>物件，包含與應用程式定義域之啟動有關的資料。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性設定為將會擲回任何例外狀況`null`。  
  
 所提供的資訊<xref:System.Runtime.Hosting.ActivationArguments>物件支援資訊清單型啟用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此屬性會設定為 <see cref="T:System.Runtime.Hosting.ActivationArguments" /> 物件，而此物件的應用程式識別不符合 <see cref="T:System.Security.Policy.ApplicationTrust" /> 屬性傳回的 <see cref="P:System.AppDomainSetup.ApplicationTrust" /> 物件之應用程式識別。 如果 <see cref="P:System.AppDomainSetup.ApplicationTrust" /> 屬性為 <see langword="null" />，則不會擲回例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.AppDomainInitializer" /> 委派，其表示當初始化應用程式定義域時所叫用的回呼方法。</summary>
        <value>表示回呼方法的委派，在應用程式定義域初始化時會叫用此方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要將資訊傳遞至回呼方法，將指定的字串陣列<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>屬性。 的陣列傳遞至回呼方法，每次<xref:System.AppDomain>已初始化。  
  
 新建立的應用程式定義域的內容中執行的回呼方法。  
  
   
  
## Examples  
 下列範例會建立名為的子應用程式定義域`ChildDomain`，並使用<xref:System.AppDomainSetup>物件和來自預設應用程式定義域的辨識項。 <xref:System.AppDomainSetup.AppDomainInitializer%2A>屬性設定為回呼方法`AppDomainInit`，子定義域初始化時會叫用。 回呼方法的引數會放在字串指派給陣列<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>屬性。 建立子網域時，回呼方法只會列印字串。  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定傳遞給 <see cref="T:System.AppDomainInitializer" /> 委派表示的回呼方法之引數。 當初始化應用程式定義域時，會叫用此回呼方法。</summary>
        <value>在 <see cref="T:System.AppDomainInitializer" /> 初始化期間叫用此回呼方法時，傳遞給 <see cref="T:System.AppDomain" /> 委派表示的回呼方法之字串陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.AppDomainSetup.AppDomainInitializer%2A>屬性來指定期間所叫用的回呼方法<xref:System.AppDomain>初始化。 如果<xref:System.AppDomainSetup.AppDomainInitializer%2A>屬性未設定，表示未使用指派給這個屬性的陣列。  
  
 新建立的應用程式定義域的內容中執行的回呼方法。  
  
   
  
## Examples  
 下列程式碼範例會建立名為的子應用程式定義域`ChildDomain`，並使用<xref:System.AppDomainSetup>物件和來自預設應用程式定義域的辨識項。 <xref:System.AppDomainSetup.AppDomainInitializer%2A>屬性設定為回呼方法`AppDomainInit`，子定義域初始化時會叫用。 回呼方法的引數會放在字串指派給陣列<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>屬性。 建立子網域時，回呼方法只會列印字串。  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定組件的顯示名稱，這個組件可為使用這個 <see cref="T:System.AppDomainSetup" /> 物件建立的應用程式定義域，提供應用程式定義域管理員型別。</summary>
        <value>組件的顯示名稱，這個組件可提供應用程式定義域管理員的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的應用程式定義域管理員類型，請設定這個屬性與<xref:System.AppDomainSetup.AppDomainManagerType%2A>屬性。 如果上述任一個屬性未設定，其他則忽略。  
  
 如果未不提供任何型別，則應用程式定義域管理員來建立父應用程式定義域相同的型別 (也就是應用程式定義域從中<xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>方法呼叫)。  
  
 載入應用程式定義域時，<xref:System.TypeLoadException>如果組件不存在，或組件不包含所指定的型別，會擲回<xref:System.AppDomainSetup.AppDomainManagerType%2A>屬性。 <xref:System.IO.FileLoadException> 如果找到組件，但版本資訊不符合，會擲回。  
  
 若要設定的預設應用程式定義域的應用程式定義域管理員，使用[ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md)和[ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md)中的項目[\<執行階段 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)應用程式組態檔或使用環境變數中所述的區段<xref:System.AppDomainManager>。  
  
 此功能需要具有完全信任應用程式。 （例如，在桌面上執行的應用程式有完全信任）。如果應用程式並沒有完全信任，<xref:System.TypeLoadException>就會擲回。  
  
 組件顯示名稱的格式由提供<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定型別的完整名稱，這個型別可為使用這個 <see cref="T:System.AppDomainSetup" /> 物件建立的應用程式定義域，提供應用程式定義域管理員。</summary>
        <value>類型的完整名稱，包含命名空間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的應用程式定義域管理員類型，請設定這個屬性與<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>屬性。 如果上述任一個屬性未設定，其他則忽略。  
  
 如果未不提供任何型別，則應用程式定義域管理員來建立父應用程式定義域相同的型別 (也就是應用程式定義域從中<xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>方法呼叫)。  
  
 載入應用程式定義域時，<xref:System.TypeLoadException>如果所指定的組件，會擲回<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>屬性不包含這個屬性所指定的型別。  
  
 若要設定的預設應用程式定義域的應用程式定義域管理員，使用[ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md)和[ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md)中的項目[\<執行階段 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)應用程式組態檔或使用環境變數中所述的區段<xref:System.AppDomainManager>。  
  
 此功能需要具有完全信任應用程式。 （例如，在桌面上執行的應用程式有完全信任）。如果應用程式並沒有完全信任，<xref:System.TypeLoadException>就會擲回。  
  
 類型的完整名稱的格式由提供<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定包含應用程式的目錄名稱。</summary>
        <value>應用程式基底目錄的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式基底目錄是組件管理員開始探查組件。  
  
 <xref:System.AppDomainSetup.ApplicationBase%2A>屬性可能會影響應用程式定義域授與的權限。 例如，通常來自本機電腦的應用程式定義域收到完全信任的來源的位置。 不過，如果<xref:System.AppDomainSetup.ApplicationBase%2A>屬性，<xref:System.AppDomain>設定內部網路目錄的完整名稱為<xref:System.AppDomainSetup.ApplicationBase%2A>設定會限制授與權限 LocalIntranet 授與應用程式定義域即使應用程式定義域確實來自本機電腦。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.AppDomainSetup.ApplicationBase%2A>屬性來設定組件載入器開始探查組件載入到新的應用程式定義域的位置。  
  
> [!NOTE]
>  您必須確定您指定的資料夾存在。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定應用程式的名稱。</summary>
        <value>應用程式的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何設定<xref:System.AppDomainSetup.ApplicationName%2A>當您建立新的應用程式定義域的屬性。  
  
 此範例會建立新的應用程式定義域，然後呼叫<xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>方法範例組件載入到新的應用程式定義域，並建立的執行個體`Worker`類別。 `Worker`類別會繼承<xref:System.MarshalByRefObject>，所以此範例可以使用所傳回的 proxy<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>呼叫`TestLoad`方法。  
  
 `TestLoad`方法載入組件，您所指定。 您必須指定有效、 完整的組件名稱，或標記為註解<xref:System.Reflection.Assembly.Load%28System.String%29>方法。 `TestLoad`方法列出載入新的應用程式定義域，顯示您指定的組件和範例組件會載入的組件。  
  
 此範例會使用<xref:System.LoaderOptimizationAttribute>告知如何應用程式時，將應用程式定義域之間共用程式碼的組件載入器的屬性。  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定包含安全性和信任資訊的物件。</summary>
        <value>包含安全性和信任資訊的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性是`null`時<xref:System.AppDomainSetup>建立。 一旦變更，無法重設為 null 參考。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此屬性會設定為 <see cref="T:System.Security.Policy.ApplicationTrust" /> 物件，而此物件的應用程式識別不符合 <see cref="T:System.Runtime.Hosting.ActivationArguments" /> 屬性傳回的 <see cref="P:System.AppDomainSetup.ActivationArguments" /> 物件之應用程式識別。 如果 <see cref="P:System.AppDomainSetup.ActivationArguments" /> 屬性為 <see langword="null" />，則不會擲回例外狀況。</exception>
        <exception cref="T:System.ArgumentNullException">該屬性設定為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得和設定其中的檔案已陰影複製的應用程式特定區域的名稱。</summary>
        <value>陰影複製之檔案的目錄路徑與檔案名稱的完整限定名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 為了讓此屬性，讓效果，請<xref:System.AppDomainSetup.ApplicationName%2A>也必須設定屬性。 如果<xref:System.AppDomainSetup.ApplicationName%2A>未設定屬性，<xref:System.AppDomainSetup.CachePath%2A>屬性會被忽略，且陰影複本快取位置的預設值為下載快取。  
  
 如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得和設定應用程式定義域的組態檔名稱。</summary>
        <value>組態檔的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組態檔會描述應用程式定義域的組態資料與搜尋規則。 建立應用程式定義域的主機會負責提供這項資料，因為有意義的值不同的狀況。  
  
 例如，ASP.NET 應用程式的組態資料會儲存為每個應用程式、 網站和電腦，而可執行檔的組態資料會儲存每個應用程式、 使用者及電腦。 只有主機才會知道組態資料的詳細資訊，為特定狀況。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定當搜尋要載入的組件時，是否要探查應用程式基底路徑和私用二進位路徑。</summary>
        <value>
          如果不允許探查，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>屬性是`true`，值<xref:System.AppDomainSetup.ApplicationBase%2A>屬性會被忽略。 也就是任何組件會探查如中所指定目錄<xref:System.AppDomainSetup.ApplicationBase%2A>屬性。 此外，值<xref:System.AppDomainSetup.PrivateBinPath%2A>屬性和<xref:System.AppDomainSetup.PrivateBinPathProbe%2A>屬性會被忽略。 所指定之目錄中任何組件探查的<xref:System.AppDomainSetup.PrivateBinPath%2A>屬性。  
  
 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>屬性會提供額外的控制載入程序。 標準的組件載入順序時，應用程式基底會探查之前<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>就會引發事件。 不過，某些應用程式可能需要從 OLE 複合檔案的文件，或從唯一的已知位置不在全域組件快取和所指定之目錄中載入的組件<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>屬性。 這類應用程式可以使用<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>屬性以避免一般探查時，所造成的延遲，並避免載入必要可能位在一般的探查路徑中的組件的複本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示應用程式定義域是否允許組件繫結重新導向。</summary>
        <value>
          如果不允許組件重新導向，則為 <see langword="true" />；如果允許，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowBindingRedirects%2A>屬性設計用於服務和伺服器應用程式組件繫結重新導向不是屬於應用程式的情況。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示應用程式定義域是否允許以 HTTP 下載組件。</summary>
        <value>
          如果不允許以 HTTP 下載組件，則為 <see langword="true" />；如果允許，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowCodeDownload%2A>屬性設計用於服務和伺服器應用程式從內部網路或網際網路下載的程式碼不是屬於應用程式的情況。  
  
> [!CAUTION]
>  預設值為<xref:System.AppDomainSetup.DisallowCodeDownload%2A>屬性是`false`。 這項設定是不安全的服務。 為了避免服務下載部分信任程式碼，將此屬性設定為`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出組態檔的 [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) 區段是否套用至應用程式定義域。</summary>
        <value>
          如果忽略應用程式定義域之組態檔的 <see langword="&lt;publisherPolicy&gt;" /> 區段，則為 <see langword="true" />；如果遵循所宣告的發行者原則，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A>屬性特別適用於在本機載入 Web 應用程式。 使用這個屬性來協助防止惡意嘗試在安全模式中執行不安全的 Web 應用程式。  
  
 如需略過發行者原則的詳細資訊，請參閱[重新導向組件版本](~/docs/framework/configure-apps/redirect-assembly-versions.md)主題。 如需安全模式的詳細資訊，請參閱的 < 檢查組態檔案 > 一節[執行階段如何找出組件](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)主題。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定動態產生的檔案之目錄所在的基底目錄。</summary>
        <value>
          <see cref="P:System.AppDomain.DynamicDirectory" /> 所在的目錄。  
 <block subset="none" type="note"><para>  
 這個屬性的傳回值不同於指派的值。
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 使用這個屬性來設定基底目錄即將放置新的應用程式定義域的動態目錄。 當新的應用程式定義域中的程式碼會載入組件、 組件解析看起來正常的探查路徑中的第一個。 如果找不到組件，它會尋找在動態的目錄中，由<xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType>屬性。 動態組件會載入並執行新的應用程式定義域可以放在該處。  
  
 當您指派的路徑<xref:System.AppDomainSetup.DynamicBase%2A>屬性，就會加入額外的子目錄，則這個子目錄的名稱是指派給值的雜湊碼<xref:System.AppDomainSetup.ApplicationName%2A>屬性。 因此，之後這個屬性所傳回的基底目錄一定是不同於指派的值。  
  
> [!IMPORTANT]
>  將值指派給這個屬性不會建立任何目錄。 目錄必須建立或驗證的程式碼使用它們。  
  
 動態的目錄是子目錄的<xref:System.AppDomainSetup.DynamicBase%2A>。 其簡單的名稱是所傳回的值<xref:System.AppDomainSetup.ApplicationName%2A>屬性，因此其格式是*原始路徑*\\*雜湊碼*\\*應用程式名稱*.  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.AppDomainSetup.DynamicBase%2A>載入動態組件時，探查路徑設為應用程式定義域的屬性。  
  
 此範例會建立<xref:System.AppDomainSetup>物件，然後設定其<xref:System.AppDomainSetup.ApplicationName%2A>「 範例 」 的屬性和其<xref:System.AppDomainSetup.DynamicBase%2A>"C:\DynamicAssemblyDir"的屬性。 此範例接著會顯示<xref:System.AppDomainSetup.DynamicBase%2A>屬性，以顯示應用程式名稱的雜湊碼，做為原本指派路徑的子目錄已附加。  
  
> [!NOTE]
>  在此範例中的基底目錄就是要外之探查路徑中的範例應用程式。 請務必編譯此範例中不同的位置。 刪除基底目錄和其所有子目錄每次您執行範例。  
  
 此範例會建立新的應用程式網域使用<xref:System.AppDomainSetup>物件。 這個範例會建立動態的目錄，如果不存在。 雖然此範例會使用應用程式定義域的<xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType>屬性，即可取得動態目錄的名稱就可輕鬆地建立目錄事先藉由串連的原始路徑，雜湊程式碼的應用程式名稱，而應用程式名稱。  
  
 此範例包含`GenerateDynamicAssembly`方法發出的組件名為`DynamicHelloWorld.dll`並將它儲存在新的應用程式定義域動態目錄中。 動態組件包含一種類型， `HelloWorld`，具有靜態方法 (`Shared`在 Visual Basic 中的方法) 名為`HelloFromAD`。 呼叫這個方法會顯示應用程式網域的名稱。  
  
 `Example`類別衍生自<xref:System.MarshalByRefObject>，因此此範例可以建立類別的執行個體中的新應用程式定義域和呼叫其`Test`方法。 `Test`方法會依其顯示名稱載入的動態組件，並呼叫靜態`HelloFromAD`方法。  
  
 您可以顯示動態目錄搜尋一般探查路徑之後，撰寫程式碼組件名為`DynamicHelloWorld.dll`及編譯此範例中的相同目錄中。 組件必須具有名為類別`HelloWorld`的靜態方法，名為`HelloFromAD`。 這個方法不需要具有相同的功能與在範例中。它只可以在主控台中顯示字串。 組件也必須<xref:System.Reflection.AssemblyVersionAttribute>其版本設定為 1.0.0.0 設定的屬性。 當您執行範例時，才能動態目錄中搜尋找到您目前的目錄中編譯的組件。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">無法設定這個屬性，因為應用程式定義域中的應用程式名稱為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 方法設定的 XML 組態資訊，此方法會覆寫應用程式的 XML 組態資訊。</summary>
        <returns>包含 <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 方法所設定之 XML 組態資訊的陣列；如果尚未呼叫 <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 方法，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法可用來建立新的應用程式定義域的應用程式的組態資訊會覆寫。 中的設定檔資訊`value`覆寫應用程式的組態檔資訊。 例如，當 Example.exe 應用程式建立新的應用程式定義域時，它可以覆寫原先取自 Example.exe.config 檔案的組態資訊。  
  
> [!IMPORTANT]
>  部分的設定檔資訊的取用者不會使用儲存的資訊<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法。 執行階段不會強制這個屬性。 若要確保新的應用程式定義域中會覆寫所有的設定檔資訊，請使用<xref:System.AppDomainSetup.ConfigurationFile%2A>屬性來指定組態檔。 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法，並會影響組件繫結。  
  
 中的 XML`value`等同於一般的組態檔中的 XML 之處在於它會儲存為<xref:System.Byte>陣列。  
  
 若要存取應用程式定義域的組態位元組，請使用<xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType>屬性來取得<xref:System.AppDomainSetup>物件的應用程式定義域，然後使用<xref:System.AppDomainSetup.GetConfigurationBytes%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與這個定義域相關聯的使用權檔案的位置。</summary>
        <value>授權檔的位置和名稱。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定用來載入可執行檔的最佳化原則。</summary>
        <value>和 <see cref="T:System.LoaderOptimizationAttribute" /> 一起使用的列舉常數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建立動態組件，並將它儲存至磁碟，然後使用<xref:System.AppDomainSetup.LoaderOptimization%2A>屬性來設定用來將應用程式定義域載入組件的最佳化原則。  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定標記有 <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> 旗標之組件的清單，這些組件設成對沙箱應用程式定義域中執行的部分信任程式碼為可見的。</summary>
        <value>部分組件名稱的陣列，其中每一個部分名稱都是由簡易組件名稱和公開金鑰組成。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、 <xref:System.Security.AllowPartiallyTrustedCallersAttribute> (APTCA) 屬性才能進行條件式藉由設定其<xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A>屬性<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>。 已標記 APTCA 組件<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>除非主應用程式可讓它無法供部分信任程式碼。  
  
 沙箱化應用程式定義域的主機可允許使用條件式 APTCA 屬性中的組件，藉由建立陣列，其中包含的簡單名稱和公開金鑰的每個組件，並將陣列指派給這個屬性的應用程式定義域中的程式碼。 例如，陣列項目看起來可能如下所示:"MyAssembly，PublicKey =0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9"。  
  
> [!IMPORTANT]
>  如果您使用的子類別<xref:System.AppDomainManager>，並定義它的組件相依於以條件式 APTCA 屬性標記的組件時，您必須包含這些組件的清單中，您將傳遞給<xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A>屬性<xref:System.AppDomainSetup>您用於建立應用程式定義域。 否則會使用條件式 APTCA 屬性標示組件將會停用。  
  
> [!NOTE]
>  當您偵錯的應用程式，在沙箱化應用程式網域中，執行某些<xref:System.Security.SecurityException>訊息可能會產生誤導。 例如，訊息可能狀態，您完全信任組件的其中一個只具有有限的權限，當實際問題的原因是超過沙箱化應用程式網域的授權集的安全性要求已傳播至的界限沙箱應用程式定義域但失敗。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定在應用程式基底目錄之下用於探查私用組件的目錄清單。</summary>
        <value>以分號分隔的目錄名稱清單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 私用組件會部署在相同的目錄結構與應用程式。 如果針對指定的目錄<xref:System.AppDomainSetup.PrivateBinPath%2A>底下不<xref:System.AppDomainSetup.ApplicationBase%2A>，便會予以忽略。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定字串值，此字串值會在應用程式的搜尋路徑中加入或排除 <see cref="P:System.AppDomainSetup.ApplicationBase" />，並僅搜尋 <see cref="P:System.AppDomainSetup.PrivateBinPath" />。</summary>
        <value>Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />) 表示要在搜尋組件時包含應用程式基底路徑。任何非 Null 字串值則表示不包含路徑。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將此屬性設定為任何非 null 字串值，包括<xref:System.String.Empty?displayProperty=nameWithType>("")，若要排除的應用程式的目錄路徑，也就是<xref:System.AppDomainSetup.ApplicationBase%2A>— 應用程式，並搜尋組件的搜尋路徑中只能在<xref:System.AppDomainSetup.PrivateBinPath%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否已停用應用程式定義域中 Interop 呼叫的介面快取，以便在每個呼叫上執行 <c>QueryInterface</c>。</summary>
        <value>
          如果停用應用程式定義域中使用目前 <see cref="T:System.AppDomainSetup" /> 物件建立之 Interop 呼叫的介面快取則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 停用介面快取 interop 呼叫的效能有重大影響。  
  
 這個成員在引進[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="switches">可用來指定相容性參數的字串值可列舉集，或 <see langword="null" /> 以清除現有的相容性參數。</param>
        <summary>針對指定的問題來設定指定的參數，讓應用程式定義域與舊版 .NET Framework 相容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 主要版本的.NET framework 有時會引進重大變更來自舊版本。 例如，[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]導入的重大變更的少數[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。 使用<xref:System.AppDomainSetup.SetCompatibilitySwitches%2A>方法，以指定的一或多個這些重大變更將會回復要讓其行為與舊版的.NET Framework 相容的應用程式定義域。  
  
 每次呼叫這個方法，它會取代現有參數設定。 若要清除的設定值，指定`null`如`switches`參數。  
  
 為所提供的字串值組`switches`可以是簡單的字串陣列，因為陣列實作<xref:System.Collections.IEnumerable>介面。  
  
 下表提供可以還原舊版.NET Framework 的行為設定的相容性參數的範例。  
  
|參數|意義|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|程式碼存取安全性 (CAS)[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]啟用這個應用程式定義域中。 請參閱[ &lt;NetFx40_LegacySecurityPolicy&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)。|  
|"NetFx40_Legacy20SortingBehavior"|排序的預設值的字串[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]這個應用程式定義域中已啟用。 已成功還原舊版的排序行為也需要 sort00001000.dll 動態連結程式庫，可在本機系統上。 請參閱[ &lt;CompatSortNLSVersion&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)。|  
|"NetFx40_Legacy40SortingBehavior"|排序的預設值的字串[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]而且 Unicode 5.0 已啟用這個應用程式定義域中。 已成功還原舊版的排序行為也需要 sort00060101.dll 動態連結程式庫，可在本機系統上。|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> 格式化行為[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]啟用這個應用程式定義域中。 請參閱[ &lt;TimeSpan_LegacyFormatMode&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)和 「 還原舊版 TimeSpan 格式 」 的區段<xref:System.TimeSpan>主題。|  
|"UseRandomizedStringHashAlgorithm"|執行階段計算字串的雜湊程式碼上每個應用程式網域為基礎，而不是使用單一的雜湊演算法產生一致的雜湊程式碼在應用程式定義域。 請參閱[ &lt;UseRandomizedStringHashAlgorithm&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">包含用於應用程式定義域之 XML 組態資訊的陣列。</param>
        <summary>為應用程式定義域提供 XML 組態資訊，以取代應用程式的 XML 組態資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法可用來取代建立新的應用程式定義域的應用程式的組態資訊。 中的設定檔資訊`value`取代應用程式的設定檔資訊。 例如，當 Example.exe 應用程式建立新的應用程式定義域時，它可以取代原本取自 Example.exe.config 檔案的組態資訊。  
  
> [!IMPORTANT]
>  部分的設定檔資訊的取用者不會使用儲存的資訊<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法。 執行階段不會強制這個屬性。 若要確保所有的設定檔資訊會取代新的應用程式定義域中，使用<xref:System.AppDomainSetup.ConfigurationFile%2A>屬性來指定組態檔。 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法，並會影響組件繫結。  
  
 中的 XML`value`等同於一般的組態檔中的 XML 之處在於它會儲存為<xref:System.Byte>陣列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="functionVersion" Type="System.Int32" />
        <Parameter Name="functionPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="functionName">要覆寫的字串比較函式的名稱。</param>
        <param name="functionVersion">函式版本。 若是 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]，其值必須為 1 或更大。</param>
        <param name="functionPointer">覆寫 <c>functionName</c> 之函式的指標。</param>
        <summary>為 Common Language Runtime 提供字串比較函式的替代實作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下列的字串比較和排序方法可以覆寫<xref:System.AppDomainSetup.SetNativeFunction%2A>方法：  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 如需這些函數的資訊，請參閱[國家語言支援函式](http://go.microsoft.com/fwlink/?LinkId=228134)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionVersion" /> 不是 1 或更大數字。  
  
 -或-  
  
 <paramref name="functionPointer" /> 為 <see cref="F:System.IntPtr.Zero" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定包含要陰影複製的組件的目錄名稱。</summary>
        <value>以分號分隔的目錄名稱清單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 啟用陰影複製時，預設值是要透過探查; 找到的所有組件的陰影複製也就是所指定目錄中<xref:System.AppDomainSetup.PrivateBinPath%2A>和<xref:System.AppDomainSetup.ApplicationBase%2A>屬性。 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>屬性會限制所指定目錄中的組件的陰影複製<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>。  
  
 如果您不指派字串給 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> 屬性，或如果您將這個屬性設定為 `null`，則會陰影複製 <xref:System.AppDomainSetup.ApplicationBase%2A> 和 <xref:System.AppDomainSetup.PrivateBinPath%2A> 屬性所指定目錄中的所有組件。  
  
> [!IMPORTANT]
>  目錄路徑不可包含分號，因為分號是分隔符號字元。 分號沒有逸出字元。  
  
 作用時，陰影複製，組件檔會複製到另一個位置載入組件之前。 原始的組件檔未鎖定，因此可以更新。 如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定指示陰影複製是開啟或關閉的字串。</summary>
        <value>字串值 "true" 表示陰影複製為開啟，"false" 表示陰影複製為關閉。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定字串，以 <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> 建構函式可剖析的格式，為應用程式定義域指定 .NET Framework 的目標版本和設定檔。</summary>
        <value>.NET Framework 的目標版本和設定檔。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性，以判斷目前正在執行版本的.NET framework 應用程式定義域，可用來載入及執行的目標版本和設定檔的已編譯的組件。 如果目前執行的.NET framework 版本有選擇性的行為會影響相容性的目標版本編譯的程式碼，它可以啟用或停用這些行為，視需要以提高相容性。 當應用程式支援增益集由在個別的應用程式定義域中執行它們使用多個版本的.NET framework 編譯時，這非常有用。  
  
 用戶端應用程式，值<xref:System.AppDomainSetup.TargetFrameworkName%2A>屬性會從推斷<xref:System.Runtime.Versioning.TargetFrameworkAttribute>屬性。 在[!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)]和更新版本中，這個屬性會加入至組件會自動根據專案設定**目標 Framework**屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>