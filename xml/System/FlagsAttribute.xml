<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b4a43daf94141e166fdacae6f0ba6f4be584c7b5" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="cae96-101">指出可將列舉視為位元欄位，也就是一組旗標。</span>
      <span class="sxs-lookup">
        <span data-stu-id="cae96-101">Indicates that an enumeration can be treated as a bit field; that is, a set of flags.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cae96-102">位元欄位通常用於的組合，可能會發生的項目清單而列舉常數通常用於互斥元素的 list。</span><span class="sxs-lookup"><span data-stu-id="cae96-102">Bit fields are generally used for lists of elements that might occur in combination, whereas enumeration constants are generally used for lists of mutually exclusive elements.</span></span> <span data-ttu-id="cae96-103">因此，位元欄位的設計而不是列舉的常數結合以產生未命名的值的位元 OR 運算。</span><span class="sxs-lookup"><span data-stu-id="cae96-103">Therefore, bit fields are designed to be combined with a bitwise OR operation to generate unnamed values, whereas enumerated constants are not.</span></span> <span data-ttu-id="cae96-104">語言使用不同的位元欄位相較於列舉常數的使用。</span><span class="sxs-lookup"><span data-stu-id="cae96-104">Languages vary in their use of bit fields compared to enumeration constants.</span></span>  
  
## <a name="attributes-of-the-flagsattribute"></a><span data-ttu-id="cae96-105">FlagsAttribute 屬性</span><span class="sxs-lookup"><span data-stu-id="cae96-105">Attributes of the FlagsAttribute</span></span>  
 <span data-ttu-id="cae96-106"><xref:System.AttributeUsageAttribute> 套用至這個類別，並將其<xref:System.AttributeUsageAttribute.Inherited%2A>屬性會指定`false`。</span><span class="sxs-lookup"><span data-stu-id="cae96-106"><xref:System.AttributeUsageAttribute> is applied to this class, and its <xref:System.AttributeUsageAttribute.Inherited%2A> property specifies `false`.</span></span> <span data-ttu-id="cae96-107">這個屬性只能套用至列舉。</span><span class="sxs-lookup"><span data-stu-id="cae96-107">This attribute can only be applied to enumerations.</span></span>  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a><span data-ttu-id="cae96-108">FlagsAttribute 和列舉的指導方針</span><span class="sxs-lookup"><span data-stu-id="cae96-108">Guidelines for FlagsAttribute and Enum</span></span>  
  
-   <span data-ttu-id="cae96-109">使用<xref:System.FlagsAttribute>列舉型別只有位元運算 (AND、 OR、 互斥 OR) 是一個數字值上執行的自訂屬性。</span><span class="sxs-lookup"><span data-stu-id="cae96-109">Use the <xref:System.FlagsAttribute> custom attribute for an enumeration only if a bitwise operation (AND, OR, EXCLUSIVE OR) is to be performed on a numeric value.</span></span>  
  
-   <span data-ttu-id="cae96-110">定義列舉常數的 2 乘冪，也就是 1、 2、 4、 8 等等。</span><span class="sxs-lookup"><span data-stu-id="cae96-110">Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on.</span></span> <span data-ttu-id="cae96-111">這表示中結合的列舉常數的個別旗標不會重疊。</span><span class="sxs-lookup"><span data-stu-id="cae96-111">This means the individual flags in combined enumeration constants do not overlap.</span></span>  
  
-   <span data-ttu-id="cae96-112">請考慮建立列舉的常數的常用的旗標組合。</span><span class="sxs-lookup"><span data-stu-id="cae96-112">Consider creating an enumerated constant for commonly used flag combinations.</span></span> <span data-ttu-id="cae96-113">例如，如果您有檔案 I/O 作業所使用的列舉，包含列舉的常數`Read = 1`和`Write = 2`，請考慮建立列舉的常數`ReadWrite = Read OR Write`，哪些結合`Read`和`Write`旗標。</span><span class="sxs-lookup"><span data-stu-id="cae96-113">For example, if you have an enumeration used for file I/O operations that contains the enumerated constants `Read = 1` and `Write = 2`, consider creating the enumerated constant `ReadWrite = Read OR Write`, which combines the `Read` and `Write` flags.</span></span> <span data-ttu-id="cae96-114">此外，用來結合旗標位元 OR 運算可能會視為一種進階的概念在某些情況下，應該不需要簡單的工作。</span><span class="sxs-lookup"><span data-stu-id="cae96-114">In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.</span></span>  
  
-   <span data-ttu-id="cae96-115">如果您將定義是負數值為旗標的列舉常數，因為許多旗標位置可能會設定為 1，這可能會讓程式碼會造成混淆，並且鼓勵大家編碼錯誤，請務必小心。</span><span class="sxs-lookup"><span data-stu-id="cae96-115">Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.</span></span>  
  
-   <span data-ttu-id="cae96-116">便利的方式來測試是否在數值中設定旗標是執行之間的數值和旗標列舉的常數，設定所有位元中的數字的值為零未對應至旗標的位元 AND 運算然後測試該作業的結果是否等於旗標列舉的常數。</span><span class="sxs-lookup"><span data-stu-id="cae96-116">A convenient way to test whether a flag is set in a numeric value is to perform a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, then test whether the result of that operation is equal to the flag enumerated constant.</span></span>  
  
-   <span data-ttu-id="cae96-117">使用`None`所旗標名稱列舉的常數，其值為零。</span><span class="sxs-lookup"><span data-stu-id="cae96-117">Use `None` as the name of the flag enumerated constant whose value is zero.</span></span> <span data-ttu-id="cae96-118">您無法使用`None`中的位元 AND 運算，以測試是否旗標，因為結果永遠為零的列舉的常數。</span><span class="sxs-lookup"><span data-stu-id="cae96-118">You cannot use the `None` enumerated constant in a bitwise AND operation to test for a flag because the result is always zero.</span></span> <span data-ttu-id="cae96-119">不過，您可以執行的邏輯不之間的數字值的位元運算、 比較和`None`列舉的常數，以判斷是否會設定數字的值中的任何位元。</span><span class="sxs-lookup"><span data-stu-id="cae96-119">However, you can perform a logical, not a bitwise, comparison between the numeric value and the `None` enumerated constant to determine whether any bits in the numeric value are set.</span></span>  
  
     <span data-ttu-id="cae96-120">如果您建立的 value 列舉，而不是旗標列舉，是建立還是值得`None`列舉的常數。</span><span class="sxs-lookup"><span data-stu-id="cae96-120">If you create a value enumeration instead of a flags enumeration, it is still worthwhile to create a `None` enumerated constant.</span></span> <span data-ttu-id="cae96-121">依預設初始化的列舉型別使用的記憶體是為零的原因是由 common language runtime。</span><span class="sxs-lookup"><span data-stu-id="cae96-121">The reason is that by default the memory used for the enumeration is initialized to zero by the common language runtime.</span></span> <span data-ttu-id="cae96-122">因此，如果您未定義其值為零的常數，列舉型別會包含不合法的值在建立時。</span><span class="sxs-lookup"><span data-stu-id="cae96-122">Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.</span></span>  
  
     <span data-ttu-id="cae96-123">如果您的應用程式需要代表的明顯預設案例，請考慮使用的列舉的常數，其值為零，表示預設值。</span><span class="sxs-lookup"><span data-stu-id="cae96-123">If there is an obvious default case your application needs to represent, consider using an enumerated constant whose value is zero to represent the default.</span></span> <span data-ttu-id="cae96-124">如果沒有任何預設的情況，請考慮使用其值為零的列舉的常數代表不由任何其他列舉常數的情況。</span><span class="sxs-lookup"><span data-stu-id="cae96-124">If there is no default case, consider using an enumerated constant whose value is zero that means the case that is not represented by any of the other enumerated constants.</span></span>  
  
-   <span data-ttu-id="cae96-125">未定義的列舉值，只是要鏡像的列舉型別本身的狀態。</span><span class="sxs-lookup"><span data-stu-id="cae96-125">Do not define an enumeration value solely to mirror the state of the enumeration itself.</span></span> <span data-ttu-id="cae96-126">例如，未定義列舉的常數，只會標記列舉結尾。</span><span class="sxs-lookup"><span data-stu-id="cae96-126">For example, do not define an enumerated constant that merely marks the end of the enumeration.</span></span> <span data-ttu-id="cae96-127">如果您需要判斷列舉的最後一個值，請明確檢查該值。</span><span class="sxs-lookup"><span data-stu-id="cae96-127">If you need to determine the last value of the enumeration, check for that value explicitly.</span></span> <span data-ttu-id="cae96-128">此外，您可以執行進行範圍檢查的第一個和最後一個列舉常數的範圍內的所有值都是有效。</span><span class="sxs-lookup"><span data-stu-id="cae96-128">In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.</span></span>  
  
-   <span data-ttu-id="cae96-129">請勿指定保留供未來使用的列舉的常數。</span><span class="sxs-lookup"><span data-stu-id="cae96-129">Do not specify enumerated constants that are reserved for future use.</span></span>  
  
-   <span data-ttu-id="cae96-130">當您定義的方法或將做為值的列舉常數的屬性時，請考慮驗證此值。</span><span class="sxs-lookup"><span data-stu-id="cae96-130">When you define a method or property that takes an enumerated constant as a value, consider validating the value.</span></span> <span data-ttu-id="cae96-131">原因是即使在列舉中未定義該數字的值可以轉換為列舉類型的數值。</span><span class="sxs-lookup"><span data-stu-id="cae96-131">The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cae96-132">下列範例說明使用`FlagsAttribute`屬性，並且顯示效果<xref:System.Enum.ToString%2A>方法使用`FlagsAttribute`上<xref:System.Enum>宣告。</span><span class="sxs-lookup"><span data-stu-id="cae96-132">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 <span data-ttu-id="cae96-133">下列範例會定義兩個色彩相關列舉`SingleHue`和`MultiHue`。</span><span class="sxs-lookup"><span data-stu-id="cae96-133">The following example defines two color-related enumerations, `SingleHue` and `MultiHue`.</span></span> <span data-ttu-id="cae96-134">後者有`FlagsAttribute`屬性; 前者則否。</span><span class="sxs-lookup"><span data-stu-id="cae96-134">The latter has the `FlagsAttribute` attribute; the former does not.</span></span> <span data-ttu-id="cae96-135">此範例顯示行為的差異時範圍的整數，包括不代表基礎值的列舉型別，則會轉換為列舉類型和其顯示的字串表示法。</span><span class="sxs-lookup"><span data-stu-id="cae96-135">The example shows the difference in behavior when a range of integers, including integers that do not represent underlying values of the enumeration type, are cast to the enumeration type and their string representations displayed.</span></span>   <span data-ttu-id="cae96-136">例如，附註 3，無法表示為`SingleHue`值，因為 3 不是基礎值的任何`SingleHue`成員，而`FlagsAttribute`屬性讓您能夠為 3 表示`MultiHue`值`Black, Red`。</span><span class="sxs-lookup"><span data-stu-id="cae96-136">For example, note that 3 cannot be represented as a `SingleHue` value because 3 is not the underlying value of any `SingleHue` member, whereas the `FlagsAttribute` attribute makes it possible to represent 3 as a `MultiHue` value of `Black, Red`.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="cae96-137">初始化 <see cref="T:System.FlagsAttribute" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="cae96-137">Initializes a new instance of the <see cref="T:System.FlagsAttribute" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="cae96-138">下列範例會定義`PhoneService`列舉，代表表單的電話公司所提供的通訊。</span><span class="sxs-lookup"><span data-stu-id="cae96-138">The following example defines a `PhoneService` enumeration that represents forms of communication provided by a telephone company.</span></span> <span data-ttu-id="cae96-139">它會初始化三個變數，表示服務提供給三個不同的住家，並再指示哪些住家的住家有只有行動電話服務，而哪些住家有行動電話和土地列服務沒有服務。</span><span class="sxs-lookup"><span data-stu-id="cae96-139">It initializes three variables representing the service provided to three different households, and then indicates which households have no service, which households have only cell phone service, and which households have both cell phone and land line service.</span></span> <span data-ttu-id="cae96-140">最後，它會隱含呼叫<xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType>方法，以顯示服務提供給每個家庭成員的類型。</span><span class="sxs-lookup"><span data-stu-id="cae96-140">Finally, it implicitly calls the <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> method to display the types of service provided to each household.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 <span data-ttu-id="cae96-141">下列範例說明使用`FlagsAttribute`屬性，並且顯示效果<xref:System.Enum.ToString%2A>方法使用`FlagsAttribute`上<xref:System.Enum>宣告。</span><span class="sxs-lookup"><span data-stu-id="cae96-141">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>