<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="97615c0cc55673df4c0518c94f836c20ffcbede4" /><Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="11/27/2018" /><Meta Name="ms.locfileid" Value="52376266" /></Metadata><TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <TypeSignature Language="F#" Value="type FlagsAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="cfac2-101">指出可將列舉視為位元欄位，也就是一組旗標。</span><span class="sxs-lookup"><span data-stu-id="cfac2-101">Indicates that an enumeration can be treated as a bit field; that is, a set of flags.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cfac2-102">位元欄位通常用於清單的項目可能會出現在組合，而列舉常數通常用於互斥項目的清單。</span><span class="sxs-lookup"><span data-stu-id="cfac2-102">Bit fields are generally used for lists of elements that might occur in combination, whereas enumeration constants are generally used for lists of mutually exclusive elements.</span></span> <span data-ttu-id="cfac2-103">因此，位元欄位的設計而不是列舉的常數結合以產生未命名的值的位元 OR 運算。</span><span class="sxs-lookup"><span data-stu-id="cfac2-103">Therefore, bit fields are designed to be combined with a bitwise OR operation to generate unnamed values, whereas enumerated constants are not.</span></span> <span data-ttu-id="cfac2-104">語言差異在相較於列舉常數的位元欄位使用。</span><span class="sxs-lookup"><span data-stu-id="cfac2-104">Languages vary in their use of bit fields compared to enumeration constants.</span></span>  
  
## <a name="attributes-of-the-flagsattribute"></a><span data-ttu-id="cfac2-105">FlagsAttribute 屬性</span><span class="sxs-lookup"><span data-stu-id="cfac2-105">Attributes of the FlagsAttribute</span></span>  
 <span data-ttu-id="cfac2-106"><xref:System.AttributeUsageAttribute> 套用至這個類別中，並將其<xref:System.AttributeUsageAttribute.Inherited%2A>屬性會指定`false`。</span><span class="sxs-lookup"><span data-stu-id="cfac2-106"><xref:System.AttributeUsageAttribute> is applied to this class, and its <xref:System.AttributeUsageAttribute.Inherited%2A> property specifies `false`.</span></span> <span data-ttu-id="cfac2-107">這個屬性只能套用至列舉。</span><span class="sxs-lookup"><span data-stu-id="cfac2-107">This attribute can only be applied to enumerations.</span></span>  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a><span data-ttu-id="cfac2-108">Flagsattribute 標記列舉和列舉的指導方針</span><span class="sxs-lookup"><span data-stu-id="cfac2-108">Guidelines for FlagsAttribute and Enum</span></span>  
  
-   <span data-ttu-id="cfac2-109">使用<xref:System.FlagsAttribute>列舉只有位元運算 (AND、 OR、 互斥 OR) 是一個數字值上執行的自訂屬性。</span><span class="sxs-lookup"><span data-stu-id="cfac2-109">Use the <xref:System.FlagsAttribute> custom attribute for an enumeration only if a bitwise operation (AND, OR, EXCLUSIVE OR) is to be performed on a numeric value.</span></span>  
  
-   <span data-ttu-id="cfac2-110">定義列舉常數乘冪數，也就是 1、 2、 4、 8 和等等。</span><span class="sxs-lookup"><span data-stu-id="cfac2-110">Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on.</span></span> <span data-ttu-id="cfac2-111">這表示在結合的列舉常數的個別旗標不會重疊。</span><span class="sxs-lookup"><span data-stu-id="cfac2-111">This means the individual flags in combined enumeration constants do not overlap.</span></span>  
  
-   <span data-ttu-id="cfac2-112">請考慮建立列舉的常數常使用的旗標組合。</span><span class="sxs-lookup"><span data-stu-id="cfac2-112">Consider creating an enumerated constant for commonly used flag combinations.</span></span> <span data-ttu-id="cfac2-113">比方說，如果您有用於檔案 I/O 作業的列舉，包含列舉的常數`Read = 1`並`Write = 2`，請考慮建立的列舉的常數`ReadWrite = Read OR Write`，哪一個結合`Read`和`Write`旗標。</span><span class="sxs-lookup"><span data-stu-id="cfac2-113">For example, if you have an enumeration used for file I/O operations that contains the enumerated constants `Read = 1` and `Write = 2`, consider creating the enumerated constant `ReadWrite = Read OR Write`, which combines the `Read` and `Write` flags.</span></span> <span data-ttu-id="cfac2-114">此外，用來結合旗標的位元 OR 運算可能被視為一個進階的概念，在某些情況下，應該不需要簡單的工作。</span><span class="sxs-lookup"><span data-stu-id="cfac2-114">In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.</span></span>  
  
-   <span data-ttu-id="cfac2-115">如果您將定義為負數為旗標的列舉常數，因為許多旗標的位置可能會設定為 1，這可能會讓人混淆的程式碼，並鼓勵編碼錯誤，請務必小心。</span><span class="sxs-lookup"><span data-stu-id="cfac2-115">Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.</span></span>  
  
-   <span data-ttu-id="cfac2-116">便利的方式來測試是否已設定旗標的數值是執行之間的數值和旗標列舉的常數，可設定為零的旗標未對應的數字值的所有位元的位元 AND 運算然後測試該作業的結果是否等於旗標的列舉常數。</span><span class="sxs-lookup"><span data-stu-id="cfac2-116">A convenient way to test whether a flag is set in a numeric value is to perform a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, then test whether the result of that operation is equal to the flag enumerated constant.</span></span>  
  
-   <span data-ttu-id="cfac2-117">使用`None`旗標名稱列舉其值為零的常數。</span><span class="sxs-lookup"><span data-stu-id="cfac2-117">Use `None` as the name of the flag enumerated constant whose value is zero.</span></span> <span data-ttu-id="cfac2-118">您無法使用`None`中來測試旗標，因為結果一律為零的位元 AND 運算的列舉的常數。</span><span class="sxs-lookup"><span data-stu-id="cfac2-118">You cannot use the `None` enumerated constant in a bitwise AND operation to test for a flag because the result is always zero.</span></span> <span data-ttu-id="cfac2-119">不過，您可以執行的邏輯不數值之間的位元、 比較和`None`列舉的常數，以判斷是否已設定在數值中的任何位元。</span><span class="sxs-lookup"><span data-stu-id="cfac2-119">However, you can perform a logical, not a bitwise, comparison between the numeric value and the `None` enumerated constant to determine whether any bits in the numeric value are set.</span></span>  
  
     <span data-ttu-id="cfac2-120">如果您建立而不是旗標列舉值列舉型別，它是值得建立`None`列舉的常數。</span><span class="sxs-lookup"><span data-stu-id="cfac2-120">If you create a value enumeration instead of a flags enumeration, it is still worthwhile to create a `None` enumerated constant.</span></span> <span data-ttu-id="cfac2-121">原因是預設的列舉型別所使用的記憶體初始化為零的通用語言執行平台。</span><span class="sxs-lookup"><span data-stu-id="cfac2-121">The reason is that by default the memory used for the enumeration is initialized to zero by the common language runtime.</span></span> <span data-ttu-id="cfac2-122">因此，如果您沒有定義其值為零的常數，列舉會包含不合法的值建立時。</span><span class="sxs-lookup"><span data-stu-id="cfac2-122">Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.</span></span>  
  
     <span data-ttu-id="cfac2-123">如果您的應用程式需要代表的明顯的預設案例，請考慮使用其值為零表示預設值的列舉的常數。</span><span class="sxs-lookup"><span data-stu-id="cfac2-123">If there is an obvious default case your application needs to represent, consider using an enumerated constant whose value is zero to represent the default.</span></span> <span data-ttu-id="cfac2-124">如果沒有任何預設的情況，請考慮使用其值為零的列舉的常數表示的情況下，未表示的任何其他的列舉常數。</span><span class="sxs-lookup"><span data-stu-id="cfac2-124">If there is no default case, consider using an enumerated constant whose value is zero that means the case that is not represented by any of the other enumerated constants.</span></span>  
  
-   <span data-ttu-id="cfac2-125">未定義的列舉值，只是要鏡像的列舉型別本身的狀態。</span><span class="sxs-lookup"><span data-stu-id="cfac2-125">Do not define an enumeration value solely to mirror the state of the enumeration itself.</span></span> <span data-ttu-id="cfac2-126">例如，未定義列舉的常數，只是標記的列舉結尾。</span><span class="sxs-lookup"><span data-stu-id="cfac2-126">For example, do not define an enumerated constant that merely marks the end of the enumeration.</span></span> <span data-ttu-id="cfac2-127">如果您需要判斷列舉的最後一個值，請明確檢查該值。</span><span class="sxs-lookup"><span data-stu-id="cfac2-127">If you need to determine the last value of the enumeration, check for that value explicitly.</span></span> <span data-ttu-id="cfac2-128">此外，您可以執行進行範圍檢查的第一個和最後一個列舉的常數，如果範圍內的所有值都都有效。</span><span class="sxs-lookup"><span data-stu-id="cfac2-128">In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.</span></span>  
  
-   <span data-ttu-id="cfac2-129">未指定保留供未來使用的列舉的常數。</span><span class="sxs-lookup"><span data-stu-id="cfac2-129">Do not specify enumerated constants that are reserved for future use.</span></span>  
  
-   <span data-ttu-id="cfac2-130">當您定義的方法或屬性會做為值的列舉的常數時，請考慮驗證此值。</span><span class="sxs-lookup"><span data-stu-id="cfac2-130">When you define a method or property that takes an enumerated constant as a value, consider validating the value.</span></span> <span data-ttu-id="cfac2-131">原因是，您就可以轉換數值列舉類型，即使在列舉中未定義該數字的值。</span><span class="sxs-lookup"><span data-stu-id="cfac2-131">The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cfac2-132">下列範例示範如何將`FlagsAttribute`屬性，並顯示上的作用<xref:System.Enum.ToString%2A>方法使用`FlagsAttribute`上<xref:System.Enum>宣告。</span><span class="sxs-lookup"><span data-stu-id="cfac2-132">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 <span data-ttu-id="cfac2-133">下列範例會定義兩個色彩相關的列舉`SingleHue`和`MultiHue`。</span><span class="sxs-lookup"><span data-stu-id="cfac2-133">The following example defines two color-related enumerations, `SingleHue` and `MultiHue`.</span></span> <span data-ttu-id="cfac2-134">而後者則擁有`FlagsAttribute`屬性; 前者則否。</span><span class="sxs-lookup"><span data-stu-id="cfac2-134">The latter has the `FlagsAttribute` attribute; the former does not.</span></span> <span data-ttu-id="cfac2-135">當範圍的整數，包括不代表基礎值的列舉型別，則會轉換為列舉型別和其顯示的字串表示法時，範例會示範行為的差異。</span><span class="sxs-lookup"><span data-stu-id="cfac2-135">The example shows the difference in behavior when a range of integers, including integers that do not represent underlying values of the enumeration type, are cast to the enumeration type and their string representations displayed.</span></span>   <span data-ttu-id="cfac2-136">比方說，請注意，無法做為以 3`SingleHue`值，因為 3 不是基礎值的任何`SingleHue`成員，而`FlagsAttribute`屬性可讓您為 3 表示`MultiHue`的值`Black, Red`。</span><span class="sxs-lookup"><span data-stu-id="cfac2-136">For example, note that 3 cannot be represented as a `SingleHue` value because 3 is not the underlying value of any `SingleHue` member, whereas the `FlagsAttribute` attribute makes it possible to represent 3 as a `MultiHue` value of `Black, Red`.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="cfac2-137">初始化 <see cref="T:System.FlagsAttribute" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="cfac2-137">Initializes a new instance of the <see cref="T:System.FlagsAttribute" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="cfac2-138">下列範例會定義`PhoneService`列舉，代表表單的電話公司所提供的通訊。</span><span class="sxs-lookup"><span data-stu-id="cfac2-138">The following example defines a `PhoneService` enumeration that represents forms of communication provided by a telephone company.</span></span> <span data-ttu-id="cfac2-139">它初始化三個變數，表示服務提供給三個不同的家庭，那麼會指出哪一個家庭有沒有服務時，哪一個家庭有只有行動電話服務，而哪些家庭有行動電話和 land 行服務。</span><span class="sxs-lookup"><span data-stu-id="cfac2-139">It initializes three variables representing the service provided to three different households, and then indicates which households have no service, which households have only cell phone service, and which households have both cell phone and land line service.</span></span> <span data-ttu-id="cfac2-140">最後，它會隱含呼叫<xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType>方法，以顯示服務提供給每個家庭成員的類型。</span><span class="sxs-lookup"><span data-stu-id="cfac2-140">Finally, it implicitly calls the <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> method to display the types of service provided to each household.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 <span data-ttu-id="cfac2-141">下列範例示範如何將`FlagsAttribute`屬性，並顯示上的作用<xref:System.Enum.ToString%2A>方法使用`FlagsAttribute`上<xref:System.Enum>宣告。</span><span class="sxs-lookup"><span data-stu-id="cfac2-141">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>