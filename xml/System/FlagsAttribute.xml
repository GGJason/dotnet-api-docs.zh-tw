<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FlagsAttribute.xml" source-language="en-US" target-language="zh-TW">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b4a43daf94141e166fdacae6f0ba6f4be584c7b5.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b4a43daf94141e166fdacae6f0ba6f4be584c7b5</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.FlagsAttribute">
          <source>Indicates that an enumeration can be treated as a bit field; that is, a set of flags.</source>
          <target state="translated">指出可將列舉視為位元欄位，也就是一組旗標。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Bit fields are generally used for lists of elements that might occur in combination, whereas enumeration constants are generally used for lists of mutually exclusive elements.</source>
          <target state="translated">位元欄位通常用於的組合，可能會發生的項目清單而列舉常數通常用於互斥元素的 list。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Therefore, bit fields are designed to be combined with a bitwise OR operation to generate unnamed values, whereas enumerated constants are not.</source>
          <target state="translated">因此，位元欄位的設計而不是列舉的常數結合以產生未命名的值的位元 OR 運算。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Languages vary in their use of bit fields compared to enumeration constants.</source>
          <target state="translated">語言使用不同的位元欄位相較於列舉常數的使用。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Attributes of the FlagsAttribute</source>
          <target state="translated">FlagsAttribute 屬性</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source><ph id="ph1">&lt;xref:System.AttributeUsageAttribute&gt;</ph> is applied to this class, and its <ph id="ph2">&lt;xref:System.AttributeUsageAttribute.Inherited%2A&gt;</ph> property specifies <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AttributeUsageAttribute&gt;</ph> 套用至這個類別，並將其<ph id="ph2">&lt;xref:System.AttributeUsageAttribute.Inherited%2A&gt;</ph>屬性會指定<ph id="ph3">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>This attribute can only be applied to enumerations.</source>
          <target state="translated">這個屬性只能套用至列舉。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Guidelines for FlagsAttribute and Enum</source>
          <target state="translated">FlagsAttribute 和列舉的指導方針</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use the <ph id="ph1">&lt;xref:System.FlagsAttribute&gt;</ph> custom attribute for an enumeration only if a bitwise operation (AND, OR, EXCLUSIVE OR) is to be performed on a numeric value.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.FlagsAttribute&gt;</ph>列舉型別只有位元運算 (AND、 OR、 互斥 OR) 是一個數字值上執行的自訂屬性。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on.</source>
          <target state="translated">定義列舉常數的 2 乘冪，也就是 1、 2、 4、 8 等等。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>This means the individual flags in combined enumeration constants do not overlap.</source>
          <target state="translated">這表示中結合的列舉常數的個別旗標不會重疊。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Consider creating an enumerated constant for commonly used flag combinations.</source>
          <target state="translated">請考慮建立列舉的常數的常用的旗標組合。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, if you have an enumeration used for file I/O operations that contains the enumerated constants <ph id="ph1">`Read = 1`</ph> and <ph id="ph2">`Write = 2`</ph>, consider creating the enumerated constant <ph id="ph3">`ReadWrite = Read OR Write`</ph>, which combines the <ph id="ph4">`Read`</ph> and <ph id="ph5">`Write`</ph> flags.</source>
          <target state="translated">例如，如果您有檔案 I/O 作業所使用的列舉，包含列舉的常數<ph id="ph1">`Read = 1`</ph>和<ph id="ph2">`Write = 2`</ph>，請考慮建立列舉的常數<ph id="ph3">`ReadWrite = Read OR Write`</ph>，哪些結合<ph id="ph4">`Read`</ph>和<ph id="ph5">`Write`</ph>旗標。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.</source>
          <target state="translated">此外，用來結合旗標位元 OR 運算可能會視為一種進階的概念在某些情況下，應該不需要簡單的工作。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.</source>
          <target state="translated">如果您將定義是負數值為旗標的列舉常數，因為許多旗標位置可能會設定為 1，這可能會讓程式碼會造成混淆，並且鼓勵大家編碼錯誤，請務必小心。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>A convenient way to test whether a flag is set in a numeric value is to perform a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, then test whether the result of that operation is equal to the flag enumerated constant.</source>
          <target state="translated">便利的方式來測試是否在數值中設定旗標是執行之間的數值和旗標列舉的常數，設定所有位元中的數字的值為零未對應至旗標的位元 AND 運算然後測試該作業的結果是否等於旗標列舉的常數。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use <ph id="ph1">`None`</ph> as the name of the flag enumerated constant whose value is zero.</source>
          <target state="translated">使用<ph id="ph1">`None`</ph>所旗標名稱列舉的常數，其值為零。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>You cannot use the <ph id="ph1">`None`</ph> enumerated constant in a bitwise AND operation to test for a flag because the result is always zero.</source>
          <target state="translated">您無法使用<ph id="ph1">`None`</ph>中的位元 AND 運算，以測試是否旗標，因為結果永遠為零的列舉的常數。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>However, you can perform a logical, not a bitwise, comparison between the numeric value and the <ph id="ph1">`None`</ph> enumerated constant to determine whether any bits in the numeric value are set.</source>
          <target state="translated">不過，您可以執行的邏輯不之間的數字值的位元運算、 比較和<ph id="ph1">`None`</ph>列舉的常數，以判斷是否會設定數字的值中的任何位元。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If you create a value enumeration instead of a flags enumeration, it is still worthwhile to create a <ph id="ph1">`None`</ph> enumerated constant.</source>
          <target state="translated">如果您建立的 value 列舉，而不是旗標列舉，是建立還是值得<ph id="ph1">`None`</ph>列舉的常數。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The reason is that by default the memory used for the enumeration is initialized to zero by the common language runtime.</source>
          <target state="translated">依預設初始化的列舉型別使用的記憶體是為零的原因是由 common language runtime。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.</source>
          <target state="translated">因此，如果您未定義其值為零的常數，列舉型別會包含不合法的值在建立時。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If there is an obvious default case your application needs to represent, consider using an enumerated constant whose value is zero to represent the default.</source>
          <target state="translated">如果您的應用程式需要代表的明顯預設案例，請考慮使用的列舉的常數，其值為零，表示預設值。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If there is no default case, consider using an enumerated constant whose value is zero that means the case that is not represented by any of the other enumerated constants.</source>
          <target state="translated">如果沒有任何預設的情況，請考慮使用其值為零的列舉的常數代表不由任何其他列舉常數的情況。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Do not define an enumeration value solely to mirror the state of the enumeration itself.</source>
          <target state="translated">未定義的列舉值，只是要鏡像的列舉型別本身的狀態。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, do not define an enumerated constant that merely marks the end of the enumeration.</source>
          <target state="translated">例如，未定義列舉的常數，只會標記列舉結尾。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If you need to determine the last value of the enumeration, check for that value explicitly.</source>
          <target state="translated">如果您需要判斷列舉的最後一個值，請明確檢查該值。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.</source>
          <target state="translated">此外，您可以執行進行範圍檢查的第一個和最後一個列舉常數的範圍內的所有值都是有效。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Do not specify enumerated constants that are reserved for future use.</source>
          <target state="translated">請勿指定保留供未來使用的列舉的常數。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>When you define a method or property that takes an enumerated constant as a value, consider validating the value.</source>
          <target state="translated">當您定義的方法或將做為值的列舉常數的屬性時，請考慮驗證此值。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.</source>
          <target state="translated">原因是即使在列舉中未定義該數字的值可以轉換為列舉類型的數值。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The following example illustrates the use of the <ph id="ph1">`FlagsAttribute`</ph> attribute and shows the effect on the <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> method of using <ph id="ph3">`FlagsAttribute`</ph> on an <ph id="ph4">&lt;xref:System.Enum&gt;</ph> declaration.</source>
          <target state="translated">下列範例說明使用<ph id="ph1">`FlagsAttribute`</ph>屬性，並且顯示效果<ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph>方法使用<ph id="ph3">`FlagsAttribute`</ph>上<ph id="ph4">&lt;xref:System.Enum&gt;</ph>宣告。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The following example defines two color-related enumerations, <ph id="ph1">`SingleHue`</ph> and <ph id="ph2">`MultiHue`</ph>.</source>
          <target state="translated">下列範例會定義兩個色彩相關列舉<ph id="ph1">`SingleHue`</ph>和<ph id="ph2">`MultiHue`</ph>。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The latter has the <ph id="ph1">`FlagsAttribute`</ph> attribute; the former does not.</source>
          <target state="translated">後者有<ph id="ph1">`FlagsAttribute`</ph>屬性; 前者則否。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The example shows the difference in behavior when a range of integers, including integers that do not represent underlying values of the enumeration type, are cast to the enumeration type and their string representations displayed.</source>
          <target state="translated">此範例顯示行為的差異時範圍的整數，包括不代表基礎值的列舉型別，則會轉換為列舉類型和其顯示的字串表示法。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, note that 3 cannot be represented as a <ph id="ph1">`SingleHue`</ph> value because 3 is not the underlying value of any <ph id="ph2">`SingleHue`</ph> member, whereas the <ph id="ph3">`FlagsAttribute`</ph> attribute makes it possible to represent 3 as a <ph id="ph4">`MultiHue`</ph> value of <ph id="ph5">`Black, Red`</ph>.</source>
          <target state="translated">例如，附註 3，無法表示為<ph id="ph1">`SingleHue`</ph>值，因為 3 不是基礎值的任何<ph id="ph2">`SingleHue`</ph>成員，而<ph id="ph3">`FlagsAttribute`</ph>屬性讓您能夠為 3 表示<ph id="ph4">`MultiHue`</ph>值<ph id="ph5">`Black, Red`</ph>。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.FlagsAttribute.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.FlagsAttribute" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.FlagsAttribute" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>The following example defines a <ph id="ph1">`PhoneService`</ph> enumeration that represents forms of communication provided by a telephone company.</source>
          <target state="translated">下列範例會定義<ph id="ph1">`PhoneService`</ph>列舉，代表表單的電話公司所提供的通訊。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>It initializes three variables representing the service provided to three different households, and then indicates which households have no service, which households have only cell phone service, and which households have both cell phone and land line service.</source>
          <target state="translated">它會初始化三個變數，表示服務提供給三個不同的住家，並再指示哪些住家的住家有只有行動電話服務，而哪些住家有行動電話和土地列服務沒有服務。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>Finally, it implicitly calls the <ph id="ph1">&lt;xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method to display the types of service provided to each household.</source>
          <target state="translated">最後，它會隱含呼叫<ph id="ph1">&lt;xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph>方法，以顯示服務提供給每個家庭成員的類型。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>The following example illustrates the use of the <ph id="ph1">`FlagsAttribute`</ph> attribute and shows the effect on the <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> method of using <ph id="ph3">`FlagsAttribute`</ph> on an <ph id="ph4">&lt;xref:System.Enum&gt;</ph> declaration.</source>
          <target state="translated">下列範例說明使用<ph id="ph1">`FlagsAttribute`</ph>屬性，並且顯示效果<ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph>方法使用<ph id="ph3">`FlagsAttribute`</ph>上<ph id="ph4">&lt;xref:System.Enum&gt;</ph>宣告。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>