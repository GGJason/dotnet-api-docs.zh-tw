<Type Name="IntPtr" FullName="System.IntPtr">
  <TypeSignature Language="C#" Value="public struct IntPtr : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit native int extends System.ValueType implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.IntPtr" />
  <TypeSignature Language="VB.NET" Value="Public Structure IntPtr&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public value class IntPtr : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ee7cf-101">平台專用的類型，用以代表指標或控點。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-101">A platform-specific type that is used to represent a pointer or a handle.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee7cf-102"><xref:System.IntPtr>類型的設計是其大小為平台特定的整數。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-102">The <xref:System.IntPtr> type is designed to be an integer whose size is platform-specific.</span></span> <span data-ttu-id="ee7cf-103">也就是說，此類型的執行個體必須是在 32 位元硬體和作業系統上的 32 位元和 64 位元硬體和作業系統上的 64 位元。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-103">That is, an instance of this type is expected to be 32-bits on 32-bit hardware and operating systems, and 64-bits on 64-bit hardware and operating systems.</span></span>  
  
 <span data-ttu-id="ee7cf-104"><xref:System.IntPtr>類型可以使用這些語言的支援指標，以及參考資料而且不支援指標的語言之間通用的方法。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-104">The <xref:System.IntPtr> type can be used by languages that support pointers, and as a common means of referring to data between languages that do and do not support pointers.</span></span>  
  
 <span data-ttu-id="ee7cf-105"><xref:System.IntPtr> 物件也可用來保存控點。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-105"><xref:System.IntPtr> objects can also be used to hold handles.</span></span> <span data-ttu-id="ee7cf-106">例如，執行個體的<xref:System.IntPtr>廣泛用於<xref:System.IO.FileStream?displayProperty=nameWithType>類別來保存檔案控制代碼。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-106">For example, instances of <xref:System.IntPtr> are used extensively in the <xref:System.IO.FileStream?displayProperty=nameWithType> class to hold file handles.</span></span>  
  
 <span data-ttu-id="ee7cf-107"><xref:System.IntPtr>型別是符合 CLS 標準，而<xref:System.UIntPtr>類型不是。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-107">The <xref:System.IntPtr> type is CLS-compliant, while the <xref:System.UIntPtr> type is not.</span></span> <span data-ttu-id="ee7cf-108">只有<xref:System.IntPtr>類型用於 common language runtime。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-108">Only the <xref:System.IntPtr> type is used in the common language runtime.</span></span> <span data-ttu-id="ee7cf-109"><xref:System.UIntPtr>提供大部分都是為了維持與架構對稱的型別<xref:System.IntPtr>型別。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-109">The <xref:System.UIntPtr> type is provided mostly to maintain architectural symmetry with the <xref:System.IntPtr> type.</span></span>  
  
 <span data-ttu-id="ee7cf-110">此類型會實作<xref:System.Runtime.Serialization.ISerializable>介面。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-110">This type implements the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee7cf-111">下列範例會使用 managed 的指標来反轉陣列中的字元。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-111">The following example uses managed pointers to reverse the characters in an array.</span></span> <span data-ttu-id="ee7cf-112">它會初始化之後<xref:System.String>物件，並取得它的長度，它會進行下列作業：</span><span class="sxs-lookup"><span data-stu-id="ee7cf-112">After it initializes a <xref:System.String> object and gets its length, it does the following:</span></span>  
  
1.  <span data-ttu-id="ee7cf-113">呼叫<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType>方法，將 Unicode 字串複製到 unmanaged 記憶體為 ANSI （1 個位元組） 字元。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-113">Calls the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> method to copy the Unicode string to unmanaged memory as an ANSI (one-byte) character.</span></span> <span data-ttu-id="ee7cf-114">方法會傳回<xref:System.IntPtr>unmanaged 字串的開頭所指向的物件。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-114">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged string.</span></span> <span data-ttu-id="ee7cf-115">Visual Basic 範例會使用此指標直接;在 c + + 和 C# 範例中，它會轉換為位元組的指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-115">The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</span></span>  
  
2.  <span data-ttu-id="ee7cf-116">呼叫<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType>unmanaged 的字串佔用配置的位元組數目相同的方法。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-116">Calls the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> method to allocate the same number of bytes as the unmanaged string occupies.</span></span> <span data-ttu-id="ee7cf-117">方法會傳回<xref:System.IntPtr>指向 unmanaged 記憶體區塊開頭的物件。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-117">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged block of memory.</span></span> <span data-ttu-id="ee7cf-118">Visual Basic 範例會使用此指標直接;在 c + + 和 C# 範例中，它會轉換為位元組的指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-118">The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</span></span>  
  
3.  <span data-ttu-id="ee7cf-119">Visual Basic 範例定義名為的變數`offset`等於 ANSI 字串的長度。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-119">The Visual Basic example defines a variable named `offset` that is equal to the length of the ANSI string.</span></span> <span data-ttu-id="ee7cf-120">它用來判斷其位移寫入 unmanaged 記憶體中的 ANSI 字串下一步的許可複製到其中。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-120">It is used to determine the offset into unmanaged memory to which the next charter in the ANSI string is copied.</span></span> <span data-ttu-id="ee7cf-121">由於其起始值是字串的長度，複製作業會將複製的字元從字串開頭之記憶體區塊的結尾。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-121">Because its starting value is the length of the string, the copy operation will copy a character from the start of the string to the end of the memory block.</span></span>  
  
     <span data-ttu-id="ee7cf-122">C# 和 c + + 範例呼叫<xref:System.IntPtr.ToPointer%2A>方法來取得之 unmanaged 的指標的起始位址的字串和 unmanaged 的記憶體區塊的它們加入一個字串的起始位址的 ANSI 字串的長度大於或等於。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-122">The C# and C++ examples call the <xref:System.IntPtr.ToPointer%2A> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and they add one less than the length of the string to the starting address of the ANSI string.</span></span> <span data-ttu-id="ee7cf-123">由於現在的 unmanaged 的字串指標會指向字串結尾，複製作業將會複製字元字串的結尾的記憶體區塊開頭。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-123">Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</span></span>  
  
4.  <span data-ttu-id="ee7cf-124">若要將每個字元字串複製到 unmanaged 記憶體區塊，會使用迴圈。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-124">Uses a loop to copy each character from the string to the unmanaged block of memory.</span></span>  
  
     <span data-ttu-id="ee7cf-125">Visual Basic 範例會呼叫<xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType>ANSI 字串從 managed 指標指定位移處讀取的位元組 （或位元組字元） 的方法。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-125">The Visual Basic example calls the <xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType> method to read the byte (or one-byte character) at a specified offset from the managed pointer to the ANSI string.</span></span> <span data-ttu-id="ee7cf-126">位移會隨著迴圈的每個反覆項目。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-126">The offset is incremented with each iteration of the loop.</span></span> <span data-ttu-id="ee7cf-127">然後它會呼叫<xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType>unmanaged 記憶體區塊的加號的起始位址所定義的方法，將位元組寫入的記憶體位址`offset`。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-127">It then calls the <xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType> method to write the byte to the memory address defined by the starting address of the unmanaged block of memory plus `offset`.</span></span> <span data-ttu-id="ee7cf-128">接著，它會遞減`offset`。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-128">It then decrements `offset`.</span></span>  
  
     <span data-ttu-id="ee7cf-129">C# 和 c + + 範例執行複製作業，然後遞減 unmanaged ANSI 字串中的下一個位置的位址指標並遞增未受管理的區塊中的下一個位址的指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-129">The C# and C++ examples perform the copy operation, then decrement the pointer to the address of the next location in the unmanaged ANSI string and increment the pointer to the next address in the unmanaged block.</span></span>  
  
5.  <span data-ttu-id="ee7cf-130">所有範例都呼叫<xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>要轉換之 unmanaged 的記憶體區塊，其中包含所複製的 ANSI 字串為受管理的 unicode<xref:System.String>物件。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-130">All examples call the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref:System.String> object.</span></span>  
  
6.  <span data-ttu-id="ee7cf-131">顯示原始和反轉的字串之後, 的所有範例都呼叫<xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>方法來釋放 unmanaged 的 ANSI 字串和 unmanaged 的記憶體區塊配置的記憶體。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-131">After displaying the original and reversed strings, all examples call the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</span></span>  
  
 [!code-cpp[System.IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.intptr/cpp/topointer.cpp#1)]
 [!code-csharp[System.IntPtr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr/cs/topointer.cs#1)]
 [!code-vb[System.IntPtr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr/vb/topointer.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="ee7cf-132">此型別具備執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-132">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.UIntPtr" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee7cf-133">初始化 <see cref="T:System.IntPtr" /> 的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-133">Initializes a new instance of <see cref="T:System.IntPtr" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(int value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee7cf-134">包含在 32 位元帶正負號整數中的指標或控點。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-134">A pointer or handle contained in a 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="ee7cf-135">使用指定的 32 位元指標或控點，初始化 <see cref="T:System.IntPtr" /> 的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-135">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified 32-bit pointer or handle.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(long value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee7cf-136">包含在 64 位元帶正負號整數中的指標或控點。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-136">A pointer or handle contained in a 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="ee7cf-137">使用指定的 64 位元指標，初始化 <see cref="T:System.IntPtr" /> 的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-137">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified 64-bit pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee7cf-138">例外狀況才會擲回的值`value`需要比目前的平台支援更多的位元。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-138">An exception is only thrown if the value of `value` requires more bits than the current platform supports.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee7cf-139">在 32 位元的平台上，<paramref name="value" /> 太大或太小，以致於無法表示為 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-139">On a 32-bit platform, <paramref name="value" /> is too large or too small to represent as an <see cref="T:System.IntPtr" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Void*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(void* value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee7cf-140">未指定的類型之指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-140">A pointer to an unspecified type.</span></span></param>
        <summary><span data-ttu-id="ee7cf-141">對未指定的類型使用指定的指標，初始化 <see cref="T:System.IntPtr" /> 的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-141">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified pointer to an unspecified type.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ee7cf-142">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-142">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ee7cf-143">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-143">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Void" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static IntPtr Add (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Add(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Add(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Add(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="ee7cf-144">要加上位移的指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-144">The pointer to add the offset to.</span></span></param>
        <param name="offset"><span data-ttu-id="ee7cf-145">要加上的位移。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-145">The offset to add.</span></span></param>
        <summary><span data-ttu-id="ee7cf-146">將指標的值加上位移。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-146">Adds an offset to the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-147">新的指標，其可反映將 <paramref name="offset" /> 加至 <paramref name="pointer" /> 的結果。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-147">A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee7cf-148"><xref:System.IntPtr.Add%2A>方法不會擲回例外狀況，如果結果太大而無法表示為指定的平台上的指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-148">The <xref:System.IntPtr.Add%2A> method does not throw an exception if the result is too large to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="ee7cf-149">相反地，在 unchecked 內容中執行加法運算。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-149">Instead, the addition operation is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="ee7cf-150">不支援運算子多載或自訂運算子的語言可以使用這個方法將位移加入至指標的值。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-150">Languages that do not support operator overloading or custom operators can use this method to add an offset to the value of a pointer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee7cf-151">下列範例會具現化<xref:System.IntPtr>物件，指向十個元素陣列的開頭，然後呼叫<xref:System.IntPtr.Add%2A>方法來逐一查看陣列中的項目。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-151">The following example instantiates an <xref:System.IntPtr> object that points to the beginning of a ten-element array, and then calls the <xref:System.IntPtr.Add%2A> method to iterate the elements in the array.</span></span>  
  
 [!code-csharp[System.IntPtr.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.add/cs/add1.cs#1)]
 [!code-vb[System.IntPtr.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ee7cf-152">與這個執行個體或 <see langword="null" /> 相比較的物件。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-152">An object to compare with this instance or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ee7cf-153">傳回值，指出這個執行個體 (Instance) 是否和指定的物件相等。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-153">Returns a value indicating whether this instance is equal to a specified object.</span></span></summary>
        <returns>
          <span data-ttu-id="ee7cf-154">如果 <see langword="true" /> 是 <paramref name="obj" /> 的執行個體，並且等於這個執行個體的值，則為 <see cref="T:System.IntPtr" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-154"><see langword="true" /> if <paramref name="obj" /> is an instance of <see cref="T:System.IntPtr" /> and equals the value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ee7cf-155">傳回這個執行個體的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-155">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-156">32 位元帶正負號的整數雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-156">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static IntPtr operator + (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Addition(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr operator +(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="ee7cf-157">要加上位移的指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-157">The pointer to add the offset to.</span></span></param>
        <param name="offset"><span data-ttu-id="ee7cf-158">要加上的位移。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-158">The offset to add.</span></span></param>
        <summary><span data-ttu-id="ee7cf-159">將指標的值加上位移。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-159">Adds an offset to the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-160">新的指標，其可反映將 <paramref name="offset" /> 加至 <paramref name="pointer" /> 的結果。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-160">A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee7cf-161"><xref:System.IntPtr.op_Addition%2A>方法定義加法運算，如<xref:System.IntPtr>物件。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-161">The <xref:System.IntPtr.op_Addition%2A> method defines the addition operation for <xref:System.IntPtr> objects.</span></span> <span data-ttu-id="ee7cf-162">它可讓程式碼如下所示。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-162">It enables code such as the following.</span></span>  
  
 [!code-csharp[System.IntPtr.op_Addition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.op_addition/cs/addition1.cs#1)]
 [!code-vb[System.IntPtr.op_Addition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.op_addition/vb/addition1.vb#1)]  
  
 <span data-ttu-id="ee7cf-163">不支援自訂運算子的語言可以呼叫<xref:System.IntPtr.Add%2A>方法改為。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-163">Languages that do not support custom operators can call the <xref:System.IntPtr.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="ee7cf-164">如果結果太大而無法表示為指定的平台上的指標，加法運算就不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-164">The addition operation does not throw an exception if the result is too large to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="ee7cf-165">相反地，它會在 unchecked 內容中執行。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-165">Instead, it is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="ee7cf-166">這個運算子的對等方法是 <xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ee7cf-166">The equivalent method for this operator is <xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.Add(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(native int value1, native int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (value1 As IntPtr, value2 As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(IntPtr value1, IntPtr value2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.IntPtr" />
        <Parameter Name="value2" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value1"><span data-ttu-id="ee7cf-167">要比較的第一個指標或控點。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-167">The first pointer or handle to compare.</span></span></param>
        <param name="value2"><span data-ttu-id="ee7cf-168">要比較的第二個指標或控點。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-168">The second pointer or handle to compare.</span></span></param>
        <summary><span data-ttu-id="ee7cf-169">判斷 <see cref="T:System.IntPtr" /> 的兩個指定執行個體是否相等。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-169">Determines whether two specified instances of <see cref="T:System.IntPtr" /> are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="ee7cf-170">如果 <paramref name="value1" /> 等於 <paramref name="value2" /> 則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-170"><see langword="true" /> if <paramref name="value1" /> equals <paramref name="value2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="ee7cf-171">這個運算子的對等方法是 <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ee7cf-171">The equivalent method for this operator is <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee7cf-172">將指定的資料類型轉換為 <see cref="T:System.IntPtr" /> 值，或將 <see cref="T:System.IntPtr" /> 值轉換為指定的資料類型。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-172">Converts a specified data type to an <see cref="T:System.IntPtr" /> value, or an <see cref="T:System.IntPtr" /> value to a specified data type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Int32)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee7cf-173">32 位元帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-173">A 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="ee7cf-174">將 32 位元帶正負號整數的值轉換為 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-174">Converts the value of a 32-bit signed integer to an <see cref="T:System.IntPtr" />.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-175">初始化為 <paramref name="value" /> 的 <see cref="T:System.IntPtr" /> 的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-175">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Long) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee7cf-176">64 位元帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-176">A 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="ee7cf-177">將 64 位元帶正負號整數的值轉換為 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-177">Converts the value of a 64-bit signed integer to an <see cref="T:System.IntPtr" />.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-178">初始化為 <paramref name="value" /> 的 <see cref="T:System.IntPtr" /> 的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-178">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee7cf-179">在 32 位元的平台上，<paramref name="value" /> 太大，以致於無法代表 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-179">On a 32-bit platform, <paramref name="value" /> is too large to represent as an <see cref="T:System.IntPtr" />.</span></span></exception>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee7cf-180">要轉換的指標或控點。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-180">The pointer or handle to convert.</span></span></param>
        <summary><span data-ttu-id="ee7cf-181">將指定的 <see cref="T:System.IntPtr" /> 值轉換為 32 位元帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-181">Converts the value of the specified <see cref="T:System.IntPtr" /> to a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-182"><paramref name="value" /> 的內容。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-182">The contents of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee7cf-183">例外狀況才會擲回的值`value`需要比目前的平台支援更多的位元。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-183">An exception is only thrown if the value of `value` requires more bits than the current platform supports.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee7cf-184">在 64 位元的平台上，<paramref name="value" /> 的值太大，以致於無法表示為 32 位元帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-184">On a 64-bit platform, the value of <paramref name="value" /> is too large to represent as a 32-bit signed integer.</span></span></exception>
        <altmember cref="M:System.IntPtr.ToInt32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee7cf-185">要轉換的指標或控點。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-185">The pointer or handle to convert.</span></span></param>
        <summary><span data-ttu-id="ee7cf-186">將指定的 <see cref="T:System.IntPtr" /> 值轉換為 64 位元帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-186">Converts the value of the specified <see cref="T:System.IntPtr" /> to a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-187"><paramref name="value" /> 的內容。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-187">The contents of <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="M:System.IntPtr.ToInt64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator void* (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname void* op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator void*(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee7cf-188">要轉換的指標或控點。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-188">The pointer or handle to convert.</span></span></param>
        <summary><span data-ttu-id="ee7cf-189">將指定的 <see cref="T:System.IntPtr" /> 值轉換為未指定的類型指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-189">Converts the value of the specified <see cref="T:System.IntPtr" /> to a pointer to an unspecified type.</span></span>  
  
 <span data-ttu-id="ee7cf-190">此應用程式開發介面不符合 CLS 標準。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-190">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-191"><paramref name="value" /> 的內容。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-191">The contents of <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="M:System.IntPtr.ToPointer" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(void* value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee7cf-192">未指定的類型之指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-192">A pointer to an unspecified type.</span></span></param>
        <summary><span data-ttu-id="ee7cf-193">將指定的指標轉換為 <see cref="T:System.IntPtr" /> 的未指定類型。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-193">Converts the specified pointer to an unspecified type to an <see cref="T:System.IntPtr" />.</span></span>  
  
 <span data-ttu-id="ee7cf-194">此應用程式開發介面不符合 CLS 標準。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-194">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-195">初始化為 <paramref name="value" /> 的 <see cref="T:System.IntPtr" /> 的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-195">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ee7cf-196">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-196">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ee7cf-197">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-197">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(native int value1, native int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (value1 As IntPtr, value2 As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(IntPtr value1, IntPtr value2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.IntPtr" />
        <Parameter Name="value2" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value1"><span data-ttu-id="ee7cf-198">要比較的第一個指標或控點。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-198">The first pointer or handle to compare.</span></span></param>
        <param name="value2"><span data-ttu-id="ee7cf-199">要比較的第二個指標或控點。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-199">The second pointer or handle to compare.</span></span></param>
        <summary><span data-ttu-id="ee7cf-200">判斷 <see cref="T:System.IntPtr" /> 的兩個指定執行個體是否不相等。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-200">Determines whether two specified instances of <see cref="T:System.IntPtr" /> are not equal.</span></span></summary>
        <returns>
          <span data-ttu-id="ee7cf-201">如果 <paramref name="value1" /> 不等於 <paramref name="value2" />，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-201"><see langword="true" /> if <paramref name="value1" /> does not equal <paramref name="value2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="ee7cf-202">這個運算子的對等方法是 <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ee7cf-202">The equivalent method for this operator is <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static IntPtr operator - (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Subtraction(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr operator -(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="ee7cf-203">要減去位移的指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-203">The pointer to subtract the offset from.</span></span></param>
        <param name="offset"><span data-ttu-id="ee7cf-204">要減去的位移。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-204">The offset to subtract.</span></span></param>
        <summary><span data-ttu-id="ee7cf-205">將指標值減去移位。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-205">Subtracts an offset from the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-206">新的指標，其可反映從 <paramref name="pointer" /> 減去 <paramref name="offset" />  的結果。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-206">A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee7cf-207"><xref:System.IntPtr.op_Subtraction%2A>方法定義的減法運算<xref:System.IntPtr>物件。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-207">The <xref:System.IntPtr.op_Subtraction%2A> method defines the subtraction operation for <xref:System.IntPtr> objects.</span></span> <span data-ttu-id="ee7cf-208">它可讓程式碼如下所示。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-208">It enables code such as the following.</span></span>  
  
 [!code-csharp[System.IntPtr.op_Addition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.op_addition/cs/op_subtraction1.cs#2)]
 [!code-vb[System.IntPtr.op_Addition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.op_addition/vb/op_subtraction1.vb#2)]  
  
 <span data-ttu-id="ee7cf-209">不支援自訂運算子的語言可以呼叫<xref:System.IntPtr.Subtract%2A>方法改為。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-209">Languages that do not support custom operators can call the <xref:System.IntPtr.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="ee7cf-210">如果結果太小而無法表示為指定的平台上的指標，減法運算就不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-210">The subtraction operation does not throw an exception if the result is too small to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="ee7cf-211">相反地，它會在 unchecked 內容中執行。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-211">Instead, it is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="ee7cf-212">這個運算子的對等方法是 <xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ee7cf-212">The equivalent method for this operator is <xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public static int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.IntPtr.Size" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int Size { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ee7cf-213">取得這個執行個體的大小。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-213">Gets the size of this instance.</span></span></summary>
        <value><span data-ttu-id="ee7cf-214">這個處理序中指標或控點的大小，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-214">The size of a pointer or handle in this process, measured in bytes.</span></span> <span data-ttu-id="ee7cf-215">這個屬性的值在 32 位元處理序中為 4，而在 64 位元處理序中為 8。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-215">The value of this property is 4 in a 32-bit process, and 8 in a 64-bit process.</span></span> <span data-ttu-id="ee7cf-216">您可以定義程序類型，方法是在使用 C# 和 Visual Basic 編譯器編譯程式碼時，設定 <see langword="/platform" /> 參數。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-216">You can define the process type by setting the <see langword="/platform" /> switch when you compile your code with the C# and Visual Basic compilers.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static IntPtr Subtract (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Subtract(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Subtract(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="ee7cf-217">要減去位移的指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-217">The pointer to subtract the offset from.</span></span></param>
        <param name="offset"><span data-ttu-id="ee7cf-218">要減去的位移。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-218">The offset to subtract.</span></span></param>
        <summary><span data-ttu-id="ee7cf-219">將指標值減去移位。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-219">Subtracts an offset from the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-220">新的指標，其可反映從 <paramref name="pointer" /> 減去 <paramref name="offset" />  的結果。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-220">A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee7cf-221"><xref:System.IntPtr.Subtract%2A>方法不會擲回例外狀況，如果結果太小而無法表示為指定的平台上的指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-221">The <xref:System.IntPtr.Subtract%2A> method does not throw an exception if the result is too small to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="ee7cf-222">相反地，在 unchecked 內容中執行減法運算。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-222">Instead, the subtraction operation is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="ee7cf-223">要減去的位移值的指標值，不支援運算子多載或自訂運算子的語言可以使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-223">Languages that do not support operator overloading or custom operators can use this method to subtract an offset from the value of a pointer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee7cf-224">下列範例會具現化<xref:System.IntPtr>物件，指向陣列結尾的十個項目，然後再撥打<xref:System.IntPtr.Subtract%2A>方法，以反向順序逐一查看陣列中的項目。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-224">The following example instantiates an <xref:System.IntPtr> object that points to the end of a ten-element array, and then calls the <xref:System.IntPtr.Subtract%2A> method to iterate the elements in the array in reverse order.</span></span>  
  
 [!code-csharp[System.IntPtr.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.IntPtr.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.IEquatable&lt;System.IntPtr&gt;.Equals">
      <MemberSignature Language="C#" Value="bool IEquatable&lt;IntPtr&gt;.Equals (IntPtr other);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IEquatable&lt;System.IntPtr&gt;.Equals(native int other) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.System#IEquatable&lt;System#IntPtr&gt;#Equals(System.IntPtr)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As IntPtr) As Boolean Implements IEquatable(Of IntPtr).Equals" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IEquatable&lt;System.IntPtr&gt;.Equals(IntPtr other) = IEquatable&lt;IntPtr&gt;::Equals;" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="ee7cf-225">要填入資料的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-225">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to populate with data.</span></span></param>
        <param name="context"><span data-ttu-id="ee7cf-226">這個序列化的目的端。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-226">The destination for this serialization.</span></span> <span data-ttu-id="ee7cf-227">(不使用這個參數；請指定 <see langword="null" />)。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-227">(This parameter is not used; specify <see langword="null" />.)</span></span></param>
        <summary><span data-ttu-id="ee7cf-228">使用序列化目前 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 物件所需的資料，填入 <see cref="T:System.IntPtr" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-228">Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data needed to serialize the current <see cref="T:System.IntPtr" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee7cf-229">這個方法會填入`info`參數的目前值與<xref:System.IntPtr>物件。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-229">This method populates the `info` parameter with the value of the current <xref:System.IntPtr> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ee7cf-230"><paramref name="info" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-230"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ee7cf-231">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-231">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ee7cf-232">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-232">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public int ToInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ToInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function ToInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ToInt32();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ee7cf-233">將這個執行個體的值轉換為 32 位元帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-233">Converts the value of this instance to a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-234">等於這個執行個體值的 32 位元帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-234">A 32-bit signed integer equal to the value of this instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee7cf-235">在 64 位元的平台上，這個執行個體的值太大或太小，以致於無法表示為 32 位元帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-235">On a 64-bit platform, the value of this instance is too large or too small to represent as a 32-bit signed integer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public long ToInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function ToInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToInt64();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ee7cf-236">將這個執行個體的值轉換為 64 位元帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-236">Converts the value of this instance to a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-237">等於這個執行個體的 64 位元帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-237">A 64-bit signed integer equal to the value of this instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToPointer">
      <MemberSignature Language="C#" Value="public void* ToPointer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void* ToPointer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void* ToPointer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ee7cf-238">將這個執行個體的值轉換為未指定類型的指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-238">Converts the value of this instance to a pointer to an unspecified type.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-239"><see cref="T:System.Void" /> 的指標，也就是包含未指定類型資料的記憶體指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-239">A pointer to <see cref="T:System.Void" />; that is, a pointer to memory containing data of an unspecified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ee7cf-240">下列範例會使用 managed 的指標来反轉陣列中的字元。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-240">The following example uses managed pointers to reverse the characters in an array.</span></span> <span data-ttu-id="ee7cf-241">它會初始化之後<xref:System.String>物件，並取得它的長度，它會進行下列作業：</span><span class="sxs-lookup"><span data-stu-id="ee7cf-241">After it initializes a <xref:System.String> object and gets its length, it does the following:</span></span>  
  
-   <span data-ttu-id="ee7cf-242">呼叫<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType>方法，將 Unicode 字串複製到 unmanaged 記憶體中，為 ANSI （1 個位元組） 字元。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-242">Calls the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> method to copy the Unicode string to unmanaged memory as ANSI (one-byte) characters.</span></span> <span data-ttu-id="ee7cf-243">方法會傳回<xref:System.IntPtr>unmanaged 字串的開頭所指向的物件。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-243">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged string.</span></span>  
  
-   <span data-ttu-id="ee7cf-244">呼叫<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType>unmanaged 的字串佔用配置的位元組數目相同的方法。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-244">Calls the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> method to allocate the same number of bytes as the unmanaged string occupies.</span></span> <span data-ttu-id="ee7cf-245">方法會傳回<xref:System.IntPtr>指向 unmanaged 記憶體區塊開頭的物件。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-245">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged block of memory.</span></span>  
  
-   <span data-ttu-id="ee7cf-246">呼叫<xref:System.IntPtr.ToPointer%2A>方法來取得之 unmanaged 的指標的起始位址的字串和 unmanaged 的記憶體區塊，並將其中一個字串的起始位址的 ANSI 字串的長度大於或等於。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-246">Calls the <xref:System.IntPtr.ToPointer%2A> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and adds one less than the length of the string to the starting address of the ANSI string.</span></span> <span data-ttu-id="ee7cf-247">由於現在的 unmanaged 的字串指標會指向字串結尾，複製作業將會複製字元字串的結尾的記憶體區塊開頭。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-247">Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</span></span>  
  
-   <span data-ttu-id="ee7cf-248">若要將每個字元字串複製到 unmanaged 記憶體區塊，會使用迴圈。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-248">Uses a loop to copy each character from the string to the unmanaged block of memory.</span></span> <span data-ttu-id="ee7cf-249">每個複製作業之後，它遞減 unmanaged ANSI 字串中的下一個位置的位址指標，並且累加未受管理的區塊中的下一個位址的指標。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-249">After each copy operation, it decrements the pointer to the address of the next location in the unmanaged ANSI string and increments the pointer to the next address in the unmanaged block.</span></span>  
  
-   <span data-ttu-id="ee7cf-250">呼叫<xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>要轉換之 unmanaged 的記憶體區塊，其中包含所複製的 ANSI 字串為受管理的 unicode<xref:System.String>物件。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-250">Calls the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref:System.String> object.</span></span>  
  
-   <span data-ttu-id="ee7cf-251">顯示原始和反轉的字串之後, 會呼叫<xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>方法來釋放 unmanaged 的 ANSI 字串和 unmanaged 的記憶體區塊配置的記憶體。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-251">After displaying the original and reversed strings, calls the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</span></span>  
  
 [!code-cpp[System.IntPtr.ToPointer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.IntPtr.ToPointer/cpp/topointer.cpp#1)]
 [!code-csharp[System.IntPtr.ToPointer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.IntPtr.ToPointer/cs/topointer.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee7cf-252">將目前 <see cref="T:System.IntPtr" /> 物件的數值，轉換為其相等的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-252">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ee7cf-253">將目前 <see cref="T:System.IntPtr" /> 物件的數值，轉換為其相等的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-253">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-254">這個執行個體值的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-254">The string representation of the value of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee7cf-255">如果值<xref:System.IntPtr.Size%2A>這個執行個體的屬性為 4，則這個方法相當於<xref:System.Int32.ToString%2A?displayProperty=nameWithType>，否則這個方法相當於<xref:System.Int64.ToString%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-255">If the value of the <xref:System.IntPtr.Size%2A> property for this instance is 4, then this method is equivalent to <xref:System.Int32.ToString%2A?displayProperty=nameWithType>; otherwise, this method is equivalent to <xref:System.Int64.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ee7cf-256">格式的規格，其管理如何轉換目前的 <see cref="T:System.IntPtr" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-256">A format specification that governs how the current <see cref="T:System.IntPtr" /> object is converted.</span></span></param>
        <summary><span data-ttu-id="ee7cf-257">將目前 <see cref="T:System.IntPtr" /> 物件的數值，轉換為其相等的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-257">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span></span></summary>
        <returns><span data-ttu-id="ee7cf-258">目前 <see cref="T:System.IntPtr" /> 物件值的字串表示。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-258">The string representation of the value of the current <see cref="T:System.IntPtr" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee7cf-259">如果`format`參數是`null`或空字串 ("")，傳回的值以一般格式規範 ("G") 的格式。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-259">If the `format` parameter is `null` or an empty string (""), the return value is formatted with the general format specifier ("G").</span></span> <span data-ttu-id="ee7cf-260">如需有關數值格式規範的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)主題。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-260">For more information about numeric format specifiers, see the [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) topic.</span></span>  
  
 <span data-ttu-id="ee7cf-261">傳回值會使用而異的文化特性來格式化。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-261">The return value is formatted using the invariant culture.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly IntPtr Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly native int Zero" />
      <MemberSignature Language="DocId" Value="F:System.IntPtr.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly IntPtr Zero;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ee7cf-262">表示已經初始化為零的指標或控點之唯讀欄位。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-262">A read-only field that represents a pointer or handle that has been initialized to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee7cf-263">這個欄位的值不等於`null`。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-263">The value of this field is not equivalent to `null`.</span></span> <span data-ttu-id="ee7cf-264">使用此欄位來有效率地判斷執行個體是否<xref:System.IntPtr>已設定為非零的值。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-264">Use this field to efficiently determine whether an instance of <xref:System.IntPtr> has been set to a value other than zero.</span></span>  
  
 <span data-ttu-id="ee7cf-265">例如，假設 ip，變數是的執行個體<xref:System.IntPtr>。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-265">For example, assume the variable, ip, is an instance of <xref:System.IntPtr>.</span></span> <span data-ttu-id="ee7cf-266">您可以判斷是否它已設定和比較，例如建構函式，所傳回的值:" `if ip != new IntPtr(0)...` "。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-266">You can determine if it has been set by comparing it to the value returned by a constructor, for example: " `if ip != new IntPtr(0)...` ".</span></span> <span data-ttu-id="ee7cf-267">不過，叫用的建構函式，若要取得未初始化的指標是沒有效率。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-267">However, invoking a constructor to get an unintialized pointer is inefficient.</span></span> <span data-ttu-id="ee7cf-268">最好是碼" `if ip != IntPtr.Zero...` "，或 「 `if !IntPtr.Zero.Equals(ip)...` "。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-268">It is better to code either " `if ip != IntPtr.Zero...` ", or " `if !IntPtr.Zero.Equals(ip)...` ".</span></span>  
  
 <span data-ttu-id="ee7cf-269">當從 managed 程式碼呼叫 Windows API，您可以傳遞<xref:System.IntPtr.Zero?displayProperty=nameWithType>而不是`null`如果引數必須是指標或`null`。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-269">When calling the Windows API from managed code, you can pass <xref:System.IntPtr.Zero?displayProperty=nameWithType> instead of `null` if an argument is expected to be either a pointer or a `null`.</span></span> <span data-ttu-id="ee7cf-270">例如，下列呼叫 windows`CreateFile`函式提供<xref:System.IntPtr.Zero?displayProperty=nameWithType>如`pSecurityAttributes`和`hTemplateFile`引數值。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-270">For example, the following call to the Windows `CreateFile` function supplies <xref:System.IntPtr.Zero?displayProperty=nameWithType> for the `pSecurityAttributes` and `hTemplateFile` argument values.</span></span>  
  
 [!code-csharp[System.IntPtr.Zero#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.zero/cs/zero4.cs#2)]
 [!code-vb[System.IntPtr.Zero#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.zero/vb/zero4.vb#2)]  
  
> [!NOTE]
>  <span data-ttu-id="ee7cf-271">雖然<xref:System.IntPtr.Zero>相當於`null`Windows API 函式使用的參數或傳回值可以是任一個指標，或`null`，<xref:System.IntPtr.Zero>不等同於`null`。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-271">Although <xref:System.IntPtr.Zero> is equivalent to `null` for Windows API functions with parameters or return values that can be either pointers or `null`, <xref:System.IntPtr.Zero> is not equivalent to `null`.</span></span> <span data-ttu-id="ee7cf-272">傳遞`null`至`IntPtr.Zero.Equals`方法一律會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-272">Passing `null` to the `IntPtr.Zero.Equals` method always returns `false`.</span></span>  
  
 <span data-ttu-id="ee7cf-273">您也可以針對測試`null`從傳回指標的 Windows API 函式呼叫傳回值或`null`藉由比較傳回的值與<xref:System.IntPtr.Zero?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-273">You can also test for a `null` return value from Windows API function calls that return either a pointer or a `null` by comparing the returned value with <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ee7cf-274">例如，若要呼叫`GetWindow`函式，在下列範例會嘗試擷取不存在的視窗控制代碼。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-274">For example, the call to the `GetWindow` function in the following example tries to retrieve the handle of a non-existent window.</span></span> <span data-ttu-id="ee7cf-275">如果它所呼叫從 unmanaged 程式碼，函式會傳回`null`，但從 managed 程式碼呼叫它時，它會傳回<xref:System.IntPtr.Zero?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ee7cf-275">If it were called from unmanaged code, the function would return `null`, but when it is called from managed code, it returns <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.IntPtr.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.zero/cs/zero2.cs#1)]
 [!code-vb[System.IntPtr.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.zero/vb/zero2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>