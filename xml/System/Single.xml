<Type Name="Single" FullName="System.Single">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9f007d292930e5a2ba386c8f1b0546f60463ecec" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34452396" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IConvertible, IEquatable(Of Single), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示單精確度浮點數。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single>實值類型代表單精確度 32 位元數字值範圍是從負 3.402823 e 38 到正 3.402823 e 38，因為正或負 0、 <xref:System.Single.PositiveInfinity>， <xref:System.Single.NegativeInfinity>，並不是數字 (<xref:System.Single.NaN>)。 它被用來表示為極大 （例如行星或個之間的距離） 或極小 （例如在公斤進展屬於分子大量），而且通常不精確 （例如另一個太陽系地球距離的值). <xref:System.Single>符合 IEC 60559:1989 (IEEE 754) 標準二進位浮點算術類型。  
  
 本主題包含下列章節：  
  
-   [浮點表示和有效位數](#Precision)  
  
-   [測試相等](#Equality)  
  
-   [浮點值和例外狀況](#Exceptions)  
  
-   [型別轉換和單一結構](#Conversion)  
  
-   [浮點數的功能](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType> 提供方法來比較此類型的執行個體值轉換為其字串表示，並將數字的字串表示轉換成此類型的執行個體的執行個體。 格式規格的程式碼控制實值類型的字串表示方式的相關資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)，[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)，和[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>浮點表示和有效位數  
 <xref:System.Single>資料型別會儲存單精確度浮點值的 32 位元的二進位格式下, 表所示：  
  
|組件|位元|  
|----------|----------|  
|有效數字或尾數|0-22|  
|指數|23-30|  
|符號 (0 = 正數、 1 = 負數)|31|  
  
 就像小數是無法精確地表示某些小數值 (例如 1/3 或<xref:System.Math.PI?displayProperty=nameWithType>)，二進位分數是無法表示某些小數的值。 例如，2/10，精確地.2 以小數表示，會以.0011111001001100 為二進位分數，與模式 」 1100"重複為無限大。 在此情況下，浮點值提供它所代表的數字不精確表示法。 經常執行的原始浮點數的值，其他數學運算，會增加其缺少的有效位數。 例如，如果比較結果乘以.3 10，新增至.3.3 9 次，您會看到該加法會產生較不精確的結果，因為它牽涉到比乘法八個更多的作業。 請注意，此差異是只有當您顯示兩個明顯<xref:System.Single>藉由使用"R"[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)，而如果有必要時，會顯示所有 9 位有效位數支援<xref:System.Single>型別。  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 小數的二進位值無法完全代表一些數字，因為浮點數可以只近似實際數字。  
  
 所有的浮點數數目有限制有效位數，其中也會決定如何精確的浮點值近似實際數字。 A<xref:System.Single>值具有最多 7 的有效位數的十進位數字，雖然內部維護最多 9 位數。 這表示某些浮點運算可能缺少變更浮點值的有效位數。 下列範例定義大的單精確度浮點值，並將產品的<xref:System.Single.Epsilon?displayProperty=nameWithType>和它超過了一千兆。 不過，產品是太小，無法修改原始的浮點值。 而在產品中的最大有效位數為 1，其最小顯著性數字是千分之一，<sup>-312</sup>。  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 浮點數限制有效位數有數個結果：  
  
-   因為其最小有效位數不同，對特定有效位數的兩個浮點數可能不比較相等。 在下列範例中，一系列的數字加在一起，並與其預期的總計進行比較，其總和。 雖然兩個值會出現相同，呼叫`Equals`方法表示不會。  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     如果您變更中的格式項目<xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType>陳述式從`{0}`和`{1}`至`{0:R}`和`{1:R}`顯示全部有效位數的兩個<xref:System.Single>很明顯的兩個值相等的值，因為失去了在加法作業期間的有效位數。 在此情況下，解決問題，藉由呼叫<xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType>方法要捨入<xref:System.Single>執行比較之前所需的有效位數的值。  
  
-   使用浮點數的數學或比較作業可能不會產生相同的結果使用十進位數字時，如果因為二進位的浮點數可能不等於的十進位數字。 前一個範例會說明這藉由顯示乘以.3 10 和加入到.3.3 9 次的結果。  
  
     重要的數字的操作，帶小數值的精確度時，請使用<xref:System.Decimal>型別而非<xref:System.Single>型別。 當數字的操作，具有超過範圍的整數值的精確度<xref:System.Int64>或<xref:System.UInt64>類型非常重要，使用<xref:System.Numerics.BigInteger>型別。  
  
-   值可能不會反覆存取如果牽涉到浮點數。 如果作業會將原始浮點數轉換成另一種形式，反運算將轉換回浮點數，轉換的形式，而且最終浮點數等於原始值，即稱為往返浮點數。 來回行程可能會失敗，因為一個或多個最小有效位數遺失或變更在轉換中。 在下列範例中，三個<xref:System.Single>值會轉換成字串並儲存於檔案中。 如輸出所示，雖然會出現相同的值，則還原的值不等於原始值。  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     在此情況下，值可以成功地反覆使用"G9"[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)保留完整的有效位數的<xref:System.Single>值，如下列範例所示。  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single> 值有較少精確度卻高於<xref:System.Double>值。 A<xref:System.Single>值轉換成看似相等<xref:System.Double>通常不等於<xref:System.Double>稍微有效位數的值。 在下列範例中，相同的除法運算的結果指派給<xref:System.Double>值和<xref:System.Single>值。 之後<xref:System.Single>值轉換成<xref:System.Double>，比較兩個值會顯示不相等。  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     若要避免這個問題，請使用<xref:System.Double>資料型別以取代<xref:System.Single>資料型別或使用<xref:System.Math.Round%2A>方法，讓這兩個值具有相同的有效位數。  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>測試相等  
 被視為相等，兩個<xref:System.Single>值必須代表相同的值。 不過，因為精確度值之間的差異，或因為遺失有效位數，由一或兩個值，都必須通常是相同的浮點值變得不相等，因為其最小有效位數的差異。 如此一來，呼叫<xref:System.Single.Equals%2A>方法，以判斷兩個值是否相等或呼叫<xref:System.Single.CompareTo%2A>方法，以判斷兩個之間的關聯性<xref:System.Single>值，通常會產生非預期的結果。 這明顯是在下列範例中，其中兩個明顯等於<xref:System.Single>值變得不相等，因為第一個值會有 7 位有效位數，而第二個值具有 9。  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 導出的值，遵循不同的程式碼路徑，和，通常操作不同的方式證明不相等。 在下列範例中，一個<xref:System.Single>平方值，並計算然後還原為原始值的平方根。 第二個<xref:System.Single>乘以 3.51 且平方之前 3.51 還原原始值除以結果的平方根。 雖然兩個值變成完全相同，呼叫<xref:System.Single.Equals%28System.Single%29>方法指出它們是否不相等。 使用 「 G9"標準格式字串傳回結果字串，其中顯示每個的所有有效位數<xref:System.Single>值顯示第二個值.0000000000001 小於第一個。  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 在失去有效位數很可能會影響比較的結果的情況下，您可以使用下列技巧，而不是呼叫<xref:System.Single.Equals%2A>或<xref:System.Single.CompareTo%2A>方法：  
  
-   呼叫<xref:System.Math.Round%2A?displayProperty=nameWithType>方法，以確保這兩個值都有相同的精確度。 下列範例會修改上一個範例為使用這種方法，使兩個小數值相等。  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     請注意，精確度的問題仍適用於的中點值捨入。 如需詳細資訊，請參閱 <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType> 方法。  
  
-   近似相等，而不是等號比較測試。 這項技術會要求您定義是絕對數量的兩個值可以不同，但仍視為相等，或您定義從較大的值較小的值可以分離的相對量。  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType> 有時候會為絕對的量值的兩個距離<xref:System.Single>值在等號比較測試。  不過，<xref:System.Single.Epsilon?displayProperty=nameWithType>測量的最小的可能值，可以加入或減去，<xref:System.Single>其值為零。 大部分的正數和負數<xref:System.Single>值、 值<xref:System.Single.Epsilon?displayProperty=nameWithType>太小，無法偵測到。 因此，除了為零的值，我們不建議用於測試相等。  
  
     下列範例會使用第二種方法來定義`IsApproximatelyEqual`方法來測試兩個值之間的相對差異。 它也會對照的呼叫結果`IsApproximatelyEqual`方法和<xref:System.Single.Equals%28System.Single%29>方法。  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>浮點值和例外狀況  
 具有浮點值的作業不會擲回例外狀況，不同於整數類資料類型，在不合法的作業，例如除法的情況下擲回例外狀況，由零或溢位的作業。  相反地，在這些情況下，浮點運算的結果是零，正無限大、 負無限大或不是數字 (NaN):  
  
-   如果浮點運算的結果太小，目的格式，則結果為零。 發生這個問題相乘兩個非常小的浮點數，如下列範例所示。  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   浮點運算的結果大小超出目的格式的範圍，運算的結果是否<xref:System.Single.PositiveInfinity>或<xref:System.Single.NegativeInfinity>視結果的正負號。 作業的溢位結果<xref:System.Single.MaxValue?displayProperty=nameWithType>是<xref:System.Single.PositiveInfinity>，和作業的溢位結果<xref:System.Single.MinValue?displayProperty=nameWithType>是<xref:System.Single.NegativeInfinity>，如下列範例所示。  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity> 也會產生從分區與正被除數為零和<xref:System.Single.NegativeInfinity>除法運算會產生與負被除數為零。  
  
-   如果是無效的浮點運算，作業的結果會是<xref:System.Single.NaN>。 例如，<xref:System.Single.NaN>天時，下列作業：  
  
    -   除數為零與被除數為零。 注意除法的其他案例中零個結果<xref:System.Single.PositiveInfinity>或<xref:System.Single.NegativeInfinity>。  
  
    -   無效的輸入與任何浮點運算。 例如，嘗試尋找負數值的平方根傳回<xref:System.Single.NaN>。  
  
    -   引數，其值的任何作業<xref:System.Single.NaN?displayProperty=nameWithType>。  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>類型轉換和單一結構  
 <xref:System.Single>結構並未定義任何明確或隱含的轉換運算子; 相反地，由編譯器所實作的轉換。  
  
 下表列出可能值的其他基本數值類型的轉換<xref:System.Single>值，它也會指出是否擴展或縮小轉換，以及是否產生<xref:System.Single>可能會有較少精確度卻高於原始值。  
  
|從|擴展/縮小|可能會遺失有效位數|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|否|  
|<xref:System.Decimal>|Widening<br /><br /> 請注意，C# 需要轉型運算子。|可以。 <xref:System.Decimal> 支援有效位數; 29 十進位數的字<xref:System.Single>支援 9。|  
|<xref:System.Double>|縮小。超出範圍的值會轉換成<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>或<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>。|可以。 <xref:System.Double> 支援有效位數; 17 十進位數的字<xref:System.Single>支援 9。|  
|<xref:System.Int16>|Widening|否|  
|<xref:System.Int32>|Widening|可以。 <xref:System.Int32> 支援有效位數; 10 個十進位數的字<xref:System.Single>支援 9。|  
|<xref:System.Int64>|Widening|可以。 <xref:System.Int64> 支援有效位數; 19 十進位數的字<xref:System.Single>支援 9。|  
|<xref:System.SByte>|Widening|否|  
|<xref:System.UInt16>|Widening|否|  
|<xref:System.UInt32>|Widening|可以。 <xref:System.UInt32> 支援有效位數; 10 個十進位數的字<xref:System.Single>支援 9。|  
|<xref:System.UInt64>|Widening|可以。 <xref:System.Int64> 支援有效位數; 20 十進位數的字<xref:System.Single>支援 9。|  
  
 下列範例會將轉換至其他基本數值類型的最小值或最大值<xref:System.Single>值。  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 此外，<xref:System.Double>值<xref:System.Double.NaN?displayProperty=nameWithType>， <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>，和<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>轉換至<xref:System.Single.NaN?displayProperty=nameWithType>， <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>，和<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>分別。  
  
 請注意，某些數值類型的值轉換<xref:System.Single>值可能會涉及遺失有效位數。 如範例所示，遺失有效位數時，可能轉換<xref:System.Decimal>， <xref:System.Double>， <xref:System.Int32>， <xref:System.Int64>， <xref:System.UInt32>，和<xref:System.UInt64>值<xref:System.Single>值。  
  
 轉換<xref:System.Single>值設定為<xref:System.Double>擴展轉換。 轉換可能會導致失去精確度如果<xref:System.Double>類型沒有的精確表示<xref:System.Single>值。  
  
 轉換<xref:System.Single>以外值的任何基本數值資料類型值<xref:System.Double>是縮小轉換，而且需要轉換運算子 （C# 中） 或轉換方法 （在 Visual Basic)。 值超出範圍的目標資料類型由目標類型的定義`MinValue`和`MaxValue`屬性下, 表所示的行為。  
  
|目標類型|結果|  
|-----------------|------------|  
|任何整數類資料類型|<xref:System.OverflowException>例外狀況，如果該轉換是發生在檢查的內容。<br /><br /> 如果該轉換是發生在 unchecked 內容中 （C# 中的預設值），轉換作業會成功，但值溢位。|  
|<xref:System.Decimal>|<xref:System.OverflowException>例外狀況，|  
  
 此外， <xref:System.Single.NaN?displayProperty=nameWithType>， <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>，和<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>擲回<xref:System.OverflowException>checked 的內容中，但這些值溢位時未檢查的內容中轉換為整數的整數的轉換。 轉換<xref:System.Decimal>，它們一定會擲回<xref:System.OverflowException>。 轉換<xref:System.Double>，它們會轉換成<xref:System.Double.NaN?displayProperty=nameWithType>， <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>，和<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>分別。  
  
 附註的精確度的喪失可能會導致從轉換<xref:System.Single>另一個數字類型的值。 如果是轉換非整數<xref:System.Single>值，如範例輸出所示，小數部分為時遺失<xref:System.Single>值 （如同在 Visual Basic) 四捨五入或截斷 （如同在 C# 中)。 轉換<xref:System.Decimal>值<xref:System.Single>值不能精確的表示法中的目標資料類型。  
  
 下列範例會將轉換的數字的<xref:System.Single>數個其他數值類型的值。 在 Visual Basic （預設值） 和 C# 中檢查的內容中發生的轉換 (因為[檢查](~/docs/csharp/language-reference/keywords/checked.md)關鍵字)。 範例輸出顯示轉換的結果中這兩個核取 unchecked 的內容中。 您也可以使用編譯 Visual Basic 中未檢查的內容中執行轉換`/removeintchecks+`編譯器參數和 C# 註解`checked`陳述式。  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 如需有關轉換的數字類型的詳細資訊，請參閱[.NET Framework 中的型別轉換](~/docs/standard/base-types/type-conversion.md)和[類型轉換表](~/docs/standard/base-types/conversion-tables.md)。  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>浮點數的功能  
 <xref:System.Single>結構以及相關的類型提供方法來執行下列作業的類別：  
  
-   **值的比較**。 您可以呼叫<xref:System.Single.Equals%2A>方法，以判斷兩個<xref:System.Single>值是否相等，或<xref:System.Single.CompareTo%2A>方法，以判斷兩個值之間的關聯性。  
  
     <xref:System.Single>結構也支援一組完整的比較運算子。 例如，您可以測試相等或不等，或判斷某個值是否大於或等於另一個值。 如果其中一個運算元是<xref:System.Double>、<xref:System.Single>值轉換成<xref:System.Double>之前執行的比較。 如果其中一個運算元是整數類資料類型，它會轉換成<xref:System.Single>之前執行的比較。 雖然這些擴展轉換，但是它們可能會遺失有效位數。  
  
    > [!WARNING]
    >  有效位數，因此兩個<xref:System.Single>您希望為相等的值可能會變得不相等，這會影響比較的結果。 請參閱[測試是否相等](#Equality)> 一節，如需有關比較兩個<xref:System.Single>值。  
  
     您也可以呼叫<xref:System.Single.IsNaN%2A>， <xref:System.Single.IsInfinity%2A>， <xref:System.Single.IsPositiveInfinity%2A>，和<xref:System.Single.IsNegativeInfinity%2A>方法來測試這些特殊值。  
  
-   **數學運算**。 由語言編譯器和通用中繼語言 (CIL) 的指示，而不是由實作常用的算術運算，例如加法、 減法、 乘法和除法<xref:System.Single>方法。 如果在數學運算中的另一個運算元是<xref:System.Double>、<xref:System.Single>轉換成<xref:System.Double>之前執行此作業，以及作業的結果也是<xref:System.Double>值。 如果另一個運算元為整數類型，它會轉換成<xref:System.Single>之前執行此作業，以及作業的結果也是<xref:System.Single>值。  
  
     您可以執行其他數學運算，藉由呼叫`static`(`Shared`在 Visual Basic 中) 中的方法<xref:System.Math?displayProperty=nameWithType>類別。 其中包括常用的算術運算的其他方法 (例如<xref:System.Math.Abs%2A?displayProperty=nameWithType>， <xref:System.Math.Sign%2A?displayProperty=nameWithType>，和<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>)，幾何 (例如<xref:System.Math.Cos%2A?displayProperty=nameWithType>和<xref:System.Math.Sin%2A?displayProperty=nameWithType>)，和微積分 (例如<xref:System.Math.Log%2A?displayProperty=nameWithType>)。  在所有情況下，<xref:System.Single>值轉換成<xref:System.Double>。  
  
     您也可以使用操作中的個別位元<xref:System.Single>值。 <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType>方法會傳回其位元模式中的位元組陣列。  藉由傳遞至該位元組陣列<xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType>方法，您可以也保留<xref:System.Single>值的位元模式中的 32 位元整數。  
  
-   **捨入**。 捨入通常用於一種技術以降低的浮點表示和精確度的問題所導致的值之間的差異的影響。 您可以藉由四捨五入<xref:System.Single>藉由呼叫值<xref:System.Math.Round%2A?displayProperty=nameWithType>方法。 但請注意，<xref:System.Single>值轉換成<xref:System.Double>呼叫方法時，並可能失去有效位數的轉換是之前。  
  
-   **格式化**。 您可以將轉換<xref:System.Single>值至它的字串表示，藉由呼叫<xref:System.Single.ToString%2A>方法或使用[複合格式化](~/docs/standard/base-types/composite-formatting.md)功能。 格式字串控制浮點值的字串表示方式的相關資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)主題。  
  
-   **剖析字串**。 您可以將浮點值的字串表示轉換<xref:System.Single>藉由呼叫值<xref:System.Single.Parse%2A>或<xref:System.Single.TryParse%2A>方法。 如果剖析作業失敗，<xref:System.Single.Parse%2A>方法會擲回例外狀況，而<xref:System.Single.TryParse%2A>方法會傳回`false`。  
  
-   **類型轉換**。 <xref:System.Single>結構提供的明確介面實作<xref:System.IConvertible>介面，支援任何兩個的標準.NET Framework 資料型別之間的轉換。 語言編譯器也支援隱含轉換的值以外的所有其他標準數值類型的轉換<xref:System.Double>至<xref:System.Single>值。 以外的任何標準數值類型的值轉換<xref:System.Double>至<xref:System.Single>擴展轉換，而且不需要轉型運算子或轉換方法的用法。  
  
     不過，轉換的 32 位元和 64 位元整數值可以包括遺失有效位數。 下表列出的 32 位元、 64 位元、 有效位數的差異和<xref:System.Double>類型：  
  
    |類型|最大有效位數 （以十進位數字）|內部的有效位數 （以十進位數字）|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> 和 <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> 和 <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|9|  
  
     有效位數問題通常會影響<xref:System.Single>值轉換成<xref:System.Double>值。 在下列範例中，兩個相同的除法作業所產生的值不相等，因為其中一個值是單精確度浮點數值轉換成<xref:System.Double>。  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>這個型別的所有成員都是安全執行緒。 修改執行個體狀態會顯示的成員實際上會傳回新的值初始化的新執行個體。 做為任何其他類型，以讀取和寫入至共用的變數，其中包含此類型的執行個體必須受到鎖定來保證的執行緒安全。</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Double" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>比較這個執行個體和指定的物件或另一個 <see cref="T:System.Single" /> 執行個體，並且傳回整數，這個整數表示這個執行個體的值小於、等於或大於所指定之物件或另一個 <see cref="T:System.Single" /> 執行個體的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要比較的物件或 <see langword="null" />。</param>
        <summary>比較這個執行個體與特定物件，並且傳回一個整數，指出這個執行個體的值是小於、等於或大於特定物件的值。</summary>
        <returns>帶正負號的數字，指出這個執行個體與 <paramref name="value" /> 的相對值。  
  
 <list type="table"><listheader><term> 傳回值  </term><description> 描述  </description></listheader><item><term> 小於零  </term><description> 這個執行個體小於 <paramref name="value" />。-或-  這個執行個體是非數字 (<see cref="F:System.Single.NaN" />)，而且 <paramref name="value" /> 是數字。</description></item><item><term> 零  </term><description> 這個執行個體等於 <paramref name="value" />。-或-  這個執行個體和 value 同時為非數字 (<see cref="F:System.Single.NaN" />)、<see cref="F:System.Single.PositiveInfinity" /> 或 <see cref="F:System.Single.NegativeInfinity" />。</description></item><item><term> 大於零  </term><description> 這個執行個體大於 <paramref name="value" />。-或-  這個執行個體是數字，而且 <paramref name="value" /> 為非數字 (<see cref="F:System.Single.NaN" />).  -或-  <paramref name="value" /> 為 <see langword="null" />。</description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`參數必須是`null`或執行個體<xref:System.Single>，否則會擲回例外狀況。 任何執行個體<xref:System.Single>，不論其值會被視為大於`null`。  
  
 值必須相同才會被視為相等。 特別是當浮點數的值相依於多個數學作業時，常會遺失有效位數和其值為幾乎完全相同，除了其最小有效位數。 因為這個緣故，傳回值<xref:System.Single.CompareTo%2A>方法有時可能覺得意外。 例如，乘法依特定值後面接著除法由相同的值應該會產生原始值，但在下列範例中，計算的值會變成大於原始值。 顯示兩個值的所有有效位數使用"R"[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)表示計算的值，不同於其最小有效位數的原始值。 如需處理這類比較的詳細資訊，請參閱的 < 備註 > 一節<xref:System.Single.Equals%28System.Single%29>方法。  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 這個方法實作以支援<xref:System.IComparable>介面。 請注意，雖然<xref:System.Single.NaN>不被視為等於另一個<xref:System.Single.NaN>（甚至本身），<xref:System.IComparable>介面需要`A.CompareTo(A)`傳回零。  
  
## <a name="precision-in-comparisons"></a>在比較中的有效位數  
 超過記載的精確度的浮點數的精確度是特定實作] 和 [.NET Framework 版本。 因此，比較兩個特定的數字可能會變更.NET Framework 版本之間的有效位數的數字的內部表示法可能會變更。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Single.CompareTo%2A>方法。  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 不是 <see cref="T:System.Single" />。</exception>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(float value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">要比較的單精確度浮點數。</param>
        <summary>比較這個執行個體與指定的單精確度浮點數，並且傳回整數，這個整數表示這個執行個體的值是小於、等於或大於指定的單精確度浮點數。</summary>
        <returns>帶正負號的數字，指出這個執行個體與 <paramref name="value" /> 的相對值。  
  
 <list type="table"><listheader><term> 傳回值  </term><description> 描述  </description></listheader><item><term> 小於零  </term><description> 這個執行個體小於 <paramref name="value" />。-或-  這個執行個體是非數字 (<see cref="F:System.Single.NaN" />)，而且 <paramref name="value" /> 是數字。</description></item><item><term> 零  </term><description> 這個執行個體等於 <paramref name="value" />。-或-  這個執行個體和 <paramref name="value" /> 同時為非數字 (<see cref="F:System.Single.NaN" />)、<see cref="F:System.Single.PositiveInfinity" /> 或 <see cref="F:System.Single.NegativeInfinity" />。</description></item><item><term> 大於零  </term><description> 這個執行個體大於 <paramref name="value" />。-或-  這個執行個體是數字，而且 <paramref name="value" /> 為非數字 (<see cref="F:System.Single.NaN" />)。</description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值必須相同才會被視為相等。 通常會遺失有效位數和變成幾乎完全相同，除了其最小的有效位數，尤其是當相依於多個的數學運算之值的浮點值。 因為這個緣故，傳回值<xref:System.Single.CompareTo%2A>方法有時可能看起來很令人意外。 例如，乘法的任何值，後面接著除法由相同的值應該會產生原始值。 不過，在下列範例中，計算的值結果必須大於原始值。 顯示兩個值的所有有效位數使用"R"[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)表示計算的值，不同於其最小有效位數的原始值。 如需處理這類比較的詳細資訊，請參閱的 < 備註 > 一節<xref:System.Single.Equals%28System.Single%29>方法。  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 這個方法會實作<xref:System.IComparable%601?displayProperty=nameWithType>介面並執行稍微優於<xref:System.Single.CompareTo%2A?displayProperty=nameWithType>方法因為並沒有轉換`value`參數物件。  
  
 請注意，雖然物件，其值為<xref:System.Single.NaN>不會視為等於另一個物件，其值為<xref:System.Single.NaN>（甚至本身），<xref:System.IComparable%601>介面需要`A.CompareTo(A)`傳回零。  
  
## <a name="widening-conversions"></a>擴展轉換  
 根據您的程式語言，可能會以程式碼<xref:System.Single.CompareTo%2A>方法的參數型別具有較少的位元的位置 （較窄） 與執行個體類型。 這可能是因為有些程式語言會執行隱含擴展轉換，表示參數為型別與相同位元數與執行個體。  
  
 例如，假設執行個體類型是<xref:System.Single>和參數類型是<xref:System.Int32>。 Microsoft C# 編譯器會產生代表做為參數的值指示<xref:System.Single>物件，然後產生<xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType>比較執行個體的值與參數擴大的表示的方法。  
  
 請參閱您的程式語言的文件，以判斷其編譯器是否會執行隱含的擴展轉換的數字類型。 如需詳細資訊，請參閱[類型轉換表](~/docs/standard/base-types/conversion-tables.md)主題。  
  
## <a name="precision-in-comparisons"></a>在比較中的有效位數  
 超過記載的精確度的浮點數的精確度是特定實作] 和 [.NET Framework 版本。 因此，比較兩個特定的數字可能會變更.NET Framework 版本之間的有效位數的數字的內部表示法可能會變更。  
  
   
  
## Examples  
 下列程式碼範例示範泛型和非泛型版本<xref:System.Single.CompareTo%2A>的數個值和參考類型的方法。  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Single  = 1.401298E-45" />
      <MemberSignature Language="C++ CLI" Value="public: float Epsilon = 1.401298E-45;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>代表大於零的最小正 <see cref="T:System.Single" /> 值。 這個欄位是常數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Single.Epsilon>屬性會反映最小正<xref:System.Single>非常重要數字的操作或比較的值時的值<xref:System.Single>執行個體是零。 例如，下列程式碼所示的零和<xref:System.Single.Epsilon>會被視為不相等的值，而零和一半的值<xref:System.Single.Epsilon>會被視為相等。  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 更明確地說，單精確度浮點格式包含正負號、 23 位元尾數或有效數字和 8 位元的指數。 如下列範例所示，零會有-126 指數和尾數為 0。 <xref:System.Single.Epsilon> 具有-126 指數和尾數的 1。 這表示<xref:System.Single.Epsilon?displayProperty=nameWithType>最小正數<xref:System.Single>值是小於或等於零，表示可能的最小值和最小可能增量<xref:System.Single>的指數，是-126。  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 不過，<xref:System.Single.Epsilon>屬性不是一般量值的有效位數<xref:System.Single>輸入; 它只適用於<xref:System.Single>具有零值的執行個體。  
  
> [!NOTE]
>  值<xref:System.Single.Epsilon>屬性不等於機器 epsilon，表示相對的錯誤，因為浮點算術中的捨入的上限。  
  
 這個常數的值為 1.4 e-45。  
  
 兩個明顯的對等的浮點數進行比較時可能並不相等，這是因為在其最小有效位數的差異。 例如，C# 運算式`(float)1/3 == (float)0.33333`，不會比較相等因為左邊算起的除法運算子具有最大有效位數，而右邊的常數只能精確到指定的數字。 如果您建立自訂的演算法會決定是否可以視為兩個浮點數相等，您必須使用的值大於<xref:System.Single.Epsilon>常數，以建立可接受的絕對邊界的兩個值的差異被視為相等。 (一般而言，該邊界的差異大於多次<xref:System.Single.Epsilon>。)  
  
## <a name="platform-notes"></a>平台注意事項  
 在 ARM 系統上，值<xref:System.Single.Epsilon>常數是被偵測太小，因此它等同於零。 您可以定義等於 1.175494351E 替代 epsilon 值-38 改為。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回數值，指示 <see cref="T:System.Single" /> 的兩個執行個體是否表示相同的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">與這個執行個體相互比較的物件。</param>
        <summary>傳回值，指出這個執行個體 (Instance) 是否和指定的物件相等。</summary>
        <returns>如果 <see langword="true" /> 是 <paramref name="obj" /> 的執行個體，並且等於這個執行個體的值，則為 <see cref="T:System.Single" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.Equals%2A>方法應小心，因為看起來相等的兩個值可能會因不同的有效位數的兩個值不相等。 下列範例會報告<xref:System.Single>值.3333 和<xref:System.Single>傳回除以 1 3 不相等。  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 而不是比較是否相等，其中一個建議的技術定義可接受範圍的兩個值之間的差異 (例如。 01%的其中一個值)。 如果兩個值之間的差異的絕對值小於或等於該邊界，差異很可能是因為有效位數的差異並且，因此，值可能會相等。 下列範例會使用這項技術來比較.33333 和 1/3，這兩個<xref:System.Single>先前的程式碼範例所找到不相等的值。  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 在此情況下，值相等。  
  
> [!NOTE]
>  因為<xref:System.Single.Epsilon>定義的最小的運算式的正數值，其範圍是幾乎為零，邊界的差異必須大於<xref:System.Single.Epsilon>。 一般來說，這是多次大於<xref:System.Single.Epsilon>。  
  
 超過記載的精確度的浮點數的精確度是特定實作] 和 [.NET Framework 版本。 因此，比較兩個特定的數字可能會變更.NET Framework 版本之間的有效位數的數字的內部表示法可能會變更。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Single.Equals%2A>方法。  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>編譯器的多載解析可能會說明行為中的兩個明顯的差別<see cref="M:System.Single.Equals(System.Object)" />方法多載。如果之間的隱含轉換<paramref name="obj" />引數和<see cref="T:System.Single" />定義及引數未當做輸入<see cref="T:System.Object" />，編譯器可能會執行隱含轉換以及呼叫<see cref="M:System.Single.Equals(System.Single)" />方法。否則，呼叫<see cref="M:System.Single.Equals(System.Object)" />方法，它一定會傳回<see langword="false" />如果其<paramref name="obj" />引數不是<see cref="T:System.Single" />值。下列範例說明這兩個方法多載之間的行為差異。在除外的所有基本數值類型的情況下<see cref="T:System.Double" />在 Visual Basic 中，除了<see cref="T:System.Decimal" />和<see cref="T:System.Double" />在 C# 中，傳回第一個比較<see langword="true" />因為編譯器會自動執行擴展轉換和呼叫<see cref="M:System.Single.Equals(System.Single)" />方法，而第二個比較傳回<see langword="false" />因為編譯器會呼叫<see cref="M:System.Single.Equals(System.Object)" />方法。 [！ code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)][！ code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Single.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(float obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="obj">與這個執行個體相互比較的物件。</param>
        <summary>傳回數值，指示這個執行個體和指定的 <see cref="T:System.Single" /> 物件是否表示相同的值。</summary>
        <returns>如果 <paramref name="obj" /> 等於這個執行個體則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會實作<xref:System.IEquatable%601?displayProperty=nameWithType>介面，並執行稍微優於<xref:System.Single.Equals%2A>因為並沒有轉換`obj`參數物件。  
  
## <a name="widening-conversions"></a>擴展轉換  
 根據您的程式語言，可能會以程式碼<xref:System.Single.Equals%2A>方法的參數型別具有較少的位元的位置 （較窄） 與執行個體類型。 這可能是因為有些程式語言會執行隱含擴展轉換，表示參數為型別與相同位元數與執行個體。  
  
 例如，假設執行個體類型是<xref:System.Single>和參數類型是<xref:System.Int32>。 Microsoft C# 編譯器會產生代表做為參數的值指示<xref:System.Single>物件，並接著會產生<xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType>比較執行個體的值與參數擴大的表示的方法。  
  
 請參閱您的程式語言的文件，以判斷其編譯器是否會執行隱含的擴展轉換的數字類型。 如需詳細資訊，請參閱[類型轉換表](~/docs/standard/base-types/conversion-tables.md)主題。  
  
## <a name="precision-in-comparisons"></a>在比較中的有效位數  
 <xref:System.Single.Equals%2A>方法應小心，因為兩個看起來相等的值可能會因為不同的有效位數的兩個值不相等。 下列範例會報告<xref:System.Single>值.3333 和<xref:System.Single>傳回除以 1 3 不相等。  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 一個比較技術，可避免與比較相等需要定義可接受範圍的兩個值之間差異的相關的問題 (例如。 01%的其中一個值)。 如果兩個值之間的差異的絕對值小於或等於該邊界，差異很可能是結果的有效位數的差異並且，因此，值可能會相等。 下列範例會使用這項技術來比較.33333 和 1/3，也就是兩個<xref:System.Single>先前的程式碼範例所找到不相等的值。  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 在此情況下，值相等。  
  
> [!NOTE]
>  因為<xref:System.Single.Epsilon>定義的最小的運算式的正數值，其範圍是幾乎為零，邊界的差異必須大於<xref:System.Single.Epsilon>。 一般來說，這是多次大於<xref:System.Single.Epsilon>。 因此，我們建議您不要使用<xref:System.Double.Epsilon>比較時<xref:System.Double>值是否相等。  
  
 第二個的技術，可避免與之相等比較相關的問題包含比較兩個浮點數，與某些絕對值之間的差異。 差別在於小於或等於該絕對值的數字相等。 如果較大，則數字不相等。 方法之一是任意選取絕對值。 不過，這是有問題，因為可接受範圍的差異而定的量級<xref:System.Single>值。 第二種方式利用浮點格式的設計功能： 尾數中的元件之間的整數表示兩個浮點值的差異表示用來分隔可能的浮點值的數目兩個值。 例如，0.0 之間的差異和<xref:System.Single.Epsilon>為 1，因為<xref:System.Single.Epsilon>是可顯示的最小值，當使用<xref:System.Single>其值為零。 下列範例會使用這項技術來比較.33333 和 1/3，也就是兩個<xref:System.Double>值先前的程式碼範例，但<xref:System.Single.Equals%28System.Single%29>方法所找到不相等。 請注意，此範例會使用<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>和<xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType>方法，將單精確度浮點值轉換為其整數表示。  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 超過記載的精確度的浮點數的精確度是特定實作] 和 [.NET Framework 版本。 因此，兩個數字的比較可能會產生不同的結果，根據.NET framework 版本，因為可能會變更的有效位數的數字的內部表示法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>編譯器的多載解析可能會說明行為中的兩個明顯的差別<see cref="M:System.Single.Equals(System.Object)" />方法多載。如果之間的隱含轉換<paramref name="obj" />引數和<see cref="T:System.Single" />定義及引數未當做輸入<see cref="T:System.Object" />，編譯器可能會執行隱含轉換以及呼叫<see cref="M:System.Single.Equals(System.Single)" />方法。否則，呼叫<see cref="M:System.Single.Equals(System.Object)" />方法，它一定會傳回<see langword="false" />如果其<paramref name="obj" />引數不是<see cref="T:System.Single" />值。下列範例說明這兩個方法多載之間的行為差異。在除外的所有基本數值類型的情況下<see cref="T:System.Double" />在 Visual Basic 中，除了<see cref="T:System.Decimal" />和<see cref="T:System.Double" />在 C# 中，傳回第一個比較<see langword="true" />因為編譯器會自動執行擴展轉換和呼叫<see cref="M:System.Single.Equals(System.Single)" />方法，而第二個比較傳回<see langword="false" />因為編譯器會呼叫<see cref="M:System.Single.Equals(System.Object)" />方法。 [！ code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)][！ code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Single.Equals(System.Object)" />
        <altmember cref="Overload:System.Single.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個執行個體的雜湊碼。</summary>
        <returns>32 位元帶正負號的整數雜湊碼。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回實值類型 <see cref="T:System.TypeCode" /> 的 <see cref="T:System.Single" />。</summary>
        <returns>列舉常數 <see cref="F:System.TypeCode.Single" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsFinite(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(float f);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(float f);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">單精確度浮點數。</param>
        <summary>傳回值，指出指定的數字是否計算結果為負或正的無限大。</summary>
        <returns>如果 <paramref name="f" /> 計算結果為 <see cref="F:System.Single.PositiveInfinity" /> 或 <see cref="F:System.Single.NegativeInfinity" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮點運算傳回<xref:System.Single.PositiveInfinity>或<xref:System.Single.NegativeInfinity>發出信號的溢位狀況。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Single.IsInfinity%2A>方法。  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(float f);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">單精確度浮點數。</param>
        <summary>傳回值，這個值表示指定的值是否不是數字 (<see cref="F:System.Single.NaN" />)。</summary>
        <returns>如果 <paramref name="f" /> 的計算結果為非數值 (<see cref="F:System.Single.NaN" />)，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮點運算傳回<xref:System.Single.NaN>來表示該作業的結果是未定義。 例如，除以 0.0 的 0.0 導致<xref:System.Single.NaN>。  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A> 傳回`false`如果<xref:System.Single>值<xref:System.Single.PositiveInfinity>或<xref:System.Single.NegativeInfinity>。 若要測試，這些值，請使用<xref:System.Single.IsInfinity%2A>， <xref:System.Single.IsPositiveInfinity%2A>，和<xref:System.Single.IsNegativeInfinity%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Single.IsNaN%2A>方法。  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegative(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(float f);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(float f);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">單精確度浮點數。</param>
        <summary>傳回值，指出指定的數字是否計算結果為負的無限大。</summary>
        <returns>如果 <paramref name="f" /> 計算結果為 <see cref="F:System.Single.NegativeInfinity" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮點運算傳回<xref:System.Single.NegativeInfinity>發出信號的溢位狀況。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Single.IsNegativeInfinity%2A>方法。  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(float f);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(float f);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">單精確度浮點數。</param>
        <summary>傳回值，指出指定數字是否計算結果為正的無限大。</summary>
        <returns>如果 <paramref name="f" /> 計算結果為 <see cref="F:System.Single.PositiveInfinity" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮點運算傳回<xref:System.Single.PositiveInfinity>發出信號的溢位狀況。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Single.IsPositiveInfinity%2A>方法。  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsSubnormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(float f);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Single  = 3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MaxValue = 3.402823E+38;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.402823E+38</MemberValue>
      <Docs>
        <summary>代表 <see cref="T:System.Single" /> 最大的可能值。 這個欄位是常數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個常數的值是正數 3.40282347 e + 38。  
  
 超過運算的結果<xref:System.Single.MaxValue?displayProperty=nameWithType>是<xref:System.Single.PositiveInfinity?displayProperty=nameWithType>。 在下列範例中，<xref:System.Single.PositiveInfinity?displayProperty=nameWithType>時結果超出加法、 乘法和乘冪運算的結果<xref:System.Single.MaxValue?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Single.MaxValue>常數。  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Single  = -3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MinValue = -3.402823E+38;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.402823E+38</MemberValue>
      <Docs>
        <summary>代表 <see cref="T:System.Single" /> 最小的可能值。 這個欄位是常數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個常數的值是負 3.402823 e 38。  
  
 是作業的結果小於<xref:System.Single.MinValue?displayProperty=nameWithType>是<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>。 在下列範例中，<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>時的結果是減法和乘法的運算的結果小於<xref:System.Single.MinValue?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Single.MinValue>常數。  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Single  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: float NaN = NaN;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>代表非數值 (<see langword="NaN" />)。 這個欄位是常數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法或運算子傳回<xref:System.Single.NaN>時未定義作業的結果。 例如，零除以零的結果是<xref:System.Single.NaN>，如下列範例所示。 (但請注意，除以零的非零的數字傳回<xref:System.Single.PositiveInfinity>或<xref:System.Single.NegativeInfinity>，端視除數的正負號。)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 此外，方法會呼叫具有<xref:System.Single.NaN>值或在作業<xref:System.Single.NaN>值傳回<xref:System.Single.NaN>，如下列範例所示。  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 使用<xref:System.Single.IsNaN%2A>方法來判斷值是否不是數字。 一般情況下，<xref:System.Single>運算子不能用來比較<xref:System.Single.NaN?displayProperty=nameWithType>與其他<xref:System.Single>值，雖然比較方法 (例如<xref:System.Single.Equals%2A>和<xref:System.Single.CompareTo%2A>) 可以。 下列範例說明行為之間的差異<xref:System.Single>比較運算子和方法。  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 下列範例會示範<xref:System.Single.NaN>常數。  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNaN(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Single  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float NegativeInfinity = -Infinity;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>表示負無限大。 這個欄位是常數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個常數的值是負的數字除以零的結果。  
  
 作業的結果時，會傳回這個常數小於<xref:System.Single.MinValue>。  
  
 使用<xref:System.Single.IsNegativeInfinity%2A>來判斷值是否計算結果為負的無限大。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Single.NegativeInfinity>常數。  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(float left, float right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示兩個指定的 <see cref="T:System.Single" /> 值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 相等，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_Equality%2A>方法所定義的等號比較運算子<xref:System.Single>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(float left, float right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示指定的 <see cref="T:System.Single" /> 值是否大於另一個指定的 <see cref="T:System.Single" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大於 <paramref name="left" /> 則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_GreaterThan%2A>方法定義了較大的作業-運算子比<xref:System.Single>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(float left, float right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示指定的 <see cref="T:System.Single" /> 值是否大於或等於另一個指定的 <see cref="T:System.Single" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 大於或等於 <paramref name="right" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_GreaterThanOrEqual%2A>方法定義的大於或等於 」 運算子的作業<xref:System.Single>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(float left, float right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示兩個指定的 <see cref="T:System.Single" /> 值是否不相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_Inequality%2A>方法所定義的不等比較運算子<xref:System.Single>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(float left, float right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示指定的 <see cref="T:System.Single" /> 值是否小於另一個指定的 <see cref="T:System.Single" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_LessThan%2A>方法定義的 less 作業-運算子比<xref:System.Single>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(float left, float right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示指定的 <see cref="T:System.Single" /> 值是否小於或等於另一個指定的 <see cref="T:System.Single" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小於或等於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_LessThanOrEqual%2A>方法定義的無比-less-than-or-equal 運算子的作業<xref:System.Single>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將數字的字串表示轉換為其對等的單精確度浮點數。</summary>
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">字串，包含要轉換的數字。</param>
        <summary>將數字的字串表示轉換為其對等的單精確度浮點數。</summary>
        <returns>單精確度浮點數，相當於 <paramref name="s" /> 中指定的數值或符號。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `s`參數可以包含目前的文化特性<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或格式的字串：  
  
 [*ws*] [*登*] [*整數位數*[*，*]]*整數位數*[*。*[*小數點後數字*]] [e [*登*]*指數數字*] [*ws*]  
  
 在方括號 ([ 和 ]) 中的項目是選擇性的項目。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列的空格字元。|  
|*簽署*|為負號或正號。 有效的符號字元由<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>目前文化特性的屬性。 可以使用前置正負號。|  
|*整數數字*|一連串的數字，範圍從 0 到 9 的指定數目的整數部分。 執行*整數位數*可以由群組分隔符號分割。 例如，在某些文化特性逗號 （，） 分隔千分位群組。 *整數位數*項目可以是若字串包含*小數點後數字*項目。|  
|*、*|特定文化特性的千分位分隔符號。|  
|*.*|特定文化特性的小數點符號。|  
|*fractional-digits*|一系列的範圍從 0 到指定的數字的小數部分的 9 位數。|  
|E|"E"或者"E"字元，表示此值會表示指數 （科學記號） 表示法。|  
|*指數數字*|一系列的範圍從 0 到 9 的指定指數的數字。|  
  
 `s`參數會使用的組合來解譯<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標。 這表示泛空白字元和千位分隔符號所允許但不是貨幣符號。 若要明確定義的項目 (例如貨幣符號、 千位分隔符號和空白字元) 可以出現在`s`，使用<xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>方法多載。  
  
 `s`參數使用的格式設定資訊中會剖析<xref:System.Globalization.NumberFormatInfo>初始化目前的系統文化特性的物件。 如需詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>。 若要將字串剖析所使用之特定文化特性格式資訊，請使用<xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29>或<xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法。  
  
 一般情況下，如果您要傳入<xref:System.Single.Parse%2A>方法透過呼叫建立的字串<xref:System.Single.ToString%2A>方法、 原始<xref:System.Single>會傳回值。 不過，由於遺失有效位數，值可能不相等。  
  
 如果發現中分隔符號`s`期間剖析作業，以及適用的貨幣或十進位數的參數和群組分隔符號都相同，剖析作業會假設分隔符號是十進位的分隔符號，而不是群組分隔符號。 如需分隔符號的詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Single.Parse%28System.String%29>方法，將字串的陣列轉換為對等用法<xref:System.Single>值。  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> 並不代表有效格式的數字。</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> 表示小於 <see cref="F:System.Single.MinValue" /> 或大於 <see cref="F:System.Single.MaxValue" /> 的數字。</exception>
        <altmember cref="M:System.Single.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">字串，包含要轉換的數字。</param>
        <param name="style">列舉值的位元組合，表示 <c>s</c> 中可以存在的樣式元素。 要指定的一般值為 <see cref="F:System.Globalization.NumberStyles.Float" /> 和 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的組合。</param>
        <summary>將數字的字串表示 (使用指定樣式) 轉換為其對等的單精確度浮點數。</summary>
        <returns>單精確度浮點數，相當於 <paramref name="s" /> 中指定的數值或符號。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style`參數定義的樣式項目 (例如泛空白字元，千位分隔符號和貨幣符號) 中允許`s`剖析作業成功的參數。 它必須從位元旗標的組合<xref:System.Globalization.NumberStyles>列舉型別。 下列<xref:System.Globalization.NumberStyles>不支援的成員：  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s`參數可以包含目前的文化特性<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>。 值而定`style`，它也可採用的形式：  
  
 [*ws*] [*$*] [*登*] [*整數位數*[*，*]]*整數位數*[*。*[*小數點後數字*]] [E [*登*]*指數數字*] [*ws*]  
  
 在方括號 ([ 和 ]) 中的項目是選擇性的項目。 下表說明每個元素。  
  
 *ws*  
 一系列的空格字元。 空白字元可以出現在開頭`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>旗標，而且可以出現在結尾`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>旗標。  
  
 $  
 特定文化特性的貨幣符號。 在字串中的位置由定義<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>目前文化特性的屬性。 目前文化特性的貨幣符號可以出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>旗標。  
  
 *簽署*  
 負號符號 （-） 或正號符號 （+）。 符號可以出現在開頭`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>旗標，而且可以出現在結尾`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>旗標。 括號可用於`s`來表示負數的值，如果`style`包含<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>旗標。  
  
 *整數數字*  
 一連串的數字，範圍從 0 到 9 的指定數目的整數部分。 *整數位數*項目可以是若字串包含*小數點後數字*項目。  
  
 ,  
 特定文化特性的群組分隔符號。 目前的文化特性群組分隔符號可出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標  
  
 。  
 特定文化特性的小數點符號。 目前的文化特性小數點符號可以出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。  
  
 *fractional-digits*  
 一系列的範圍從 0 到指定的數字的小數部分的 9 位數。 小數點後數字才會出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。  
  
 E  
 "E"或者"E"字元，表示此值會表示指數 （科學記號） 表示法。 `value`參數可代表指數標記法之數字，如果`style`包含<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>旗標。  
  
 *指數數字*  
 一系列的範圍從 0 到 9 的指定指數的數字。  
  
 只有數字的字串 (對應於<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>樣式) 一律會成功剖析。 其餘<xref:System.Globalization.NumberStyles?displayProperty=nameWithType>成員控制可能存在，但不一定要出現在輸入字串中的項目。 下表指出如何個別<xref:System.Globalization.NumberStyles>旗標會影響的項目可能會出現在`s`。  
  
|NumberStyles 值|在允許的項目`s`除了數字|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整數位數*只有項目。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小數點 (*。*) 和*小數點後數字*項目。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"或者"E"字元，表示指數標記法中。 單獨使用這個旗標的形式支援值*位數*E*位數*; 其他旗標才能成功剖析項目像是正負號和小數點符號的字串。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*開頭的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*結尾處的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*登*開頭的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*登*結尾處的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*登*括住的數字值的形式的項目。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|千分位 （，） 分隔項目。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|貨幣 （$） 項目。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有項目。 不過，`s`無法表示的十六進位數字或指數標記法之數字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*開頭或結尾的項目`s`，*登*開頭`s`，和小數點 （.） 符號。 `s`參數也可以使用指數標記法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`， `sign`，千位分隔符號 （，） 和小數點 （.） 項目。|  
|<xref:System.Globalization.NumberStyles.Any>|所有項目。 不過，`s`無法表示的十六進位數字。|  
  
 一些範例`s`是"100"、"-123,456,789"、"123.45 e + 6"、"+ 500""5e2"，"3.1416"，"600。"，"-。 123" 和"-Infinity"。  
  
 `s`參數會剖析使用的格式設定資訊中<xref:System.Globalization.NumberFormatInfo>初始化目前的系統文化特性的物件。 若要指定的文化特性，剖析作業使用的格式資訊，請呼叫<xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>多載。  
  
 一般情況下，如果您要傳入<xref:System.Single.Parse%2A>方法透過呼叫建立的字串<xref:System.Single.ToString%2A>方法、 原始<xref:System.Single>會傳回值。 不過，由於遺失有效位數，值可能不相等。  
  
 如果發現中分隔符號`s`期間剖析作業，以及適用的貨幣或十進位數的參數和群組分隔符號都相同，剖析作業會假設分隔符號是十進位的分隔符號，而不是群組分隔符號。 如需分隔符號的詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>方法來剖析的字串表示<xref:System.Single>值。 此範例會使用 EN-US 文化特性格式資訊。  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> 不是有效格式的數字。</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> 代表小於 <see cref="F:System.Single.MinValue" /> 或大於 <see cref="F:System.Single.MaxValue" /> 的數字。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  -或-  <paramref name="style" /> 包含 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 值。</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">字串，包含要轉換的數字。</param>
        <param name="provider">物件，提供關於 <c>s</c> 的文化特性特定格式資訊。</param>
        <summary>將數字的字串表示 (使用指定的特定文化特性格式) 轉換為其對等的單精確度浮點數。</summary>
        <returns>單精確度浮點數，相當於 <paramref name="s" /> 中指定的數值或符號。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載通常用來將各種不同的方式來格式化的文字轉換<xref:System.Single>值。 例如，它可以用來將由使用者 HTML 文字方塊中輸入數值的文字轉換。  
  
 `s`參數會使用的組合來解譯<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標。 `s`參數可以包含<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>，或<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>所指定的文化特性`provider`，或者也可以包含格式的字串：  
  
 [*ws*][*sign*]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 選擇性的項目包覆以方括號 （[和]）。 包含 「 數字"一詞的項目是由一系列的範圍從 0 到 9 的數字字元。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列的空格字元。|  
|*簽署*|負號符號 （-） 或正號符號 （+）。|  
|*整數數字*|一連串的數字，範圍從 0 到 9 的指定數目的整數部分。 執行*整數位數*可以由群組分隔符號分割。 例如，在某些文化特性逗號 （，） 分隔千分位群組。 *整數位數*項目可以是若字串包含*小數點後數字*項目。|  
|。|特定文化特性的小數點符號。|  
|*fractional-digits*|一系列的範圍從 0 到指定的數字的小數部分的 9 位數。|  
|E|"E"或者"E"字元，表示此值會表示指數 （科學記號） 表示法。|  
|*指數數字*|一系列的範圍從 0 到 9 的指定指數的數字。|  
  
 如需數字格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)主題。  
  
 `provider`參數是<xref:System.IFormatProvider>實作其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>物件，提供特定文化特性格式資訊。 當<xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29>叫用方法時，它會呼叫`provider`參數的<xref:System.IFormatProvider.GetFormat%2A>方法並將其傳遞<xref:System.Type>物件，代表<xref:System.Globalization.NumberFormatInfo>型別。 <xref:System.IFormatProvider.GetFormat%2A>方法接著會傳回<xref:System.Globalization.NumberFormatInfo>物件，提供格式的相關資訊`s`參數。 若要使用的三種方式`provider`參數來提供自訂的格式設定資訊給剖析作業：  
  
-   您可以傳遞<xref:System.Globalization.CultureInfo>代表的文化特性，提供格式設定資訊的物件。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供該文化特性的數值格式設定資訊的物件。  
  
-   您可以傳遞的實際<xref:System.Globalization.NumberFormatInfo>提供數值格式設定資訊的物件。 (它的實作<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>只會傳回本身。)  
  
-   您可以將自訂物件實作<xref:System.IFormatProvider>。 其<xref:System.IFormatProvider.GetFormat%2A>方法具現化，並傳回<xref:System.Globalization.NumberFormatInfo>提供格式設定資訊的物件。  
  
 如果`provider`是`null`或<xref:System.Globalization.NumberFormatInfo>無法取得的格式設定資訊會使用目前的系統文化特性。  
  
 如果發現中分隔符號`s`期間剖析作業，以及適用的貨幣或十進位數的參數和群組分隔符號都相同，剖析作業會假設分隔符號是十進位的分隔符號，而不是群組分隔符號。 如需分隔符號的詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
 一些範例`s`是"100"、"-123,456,789"、"123.45 e + 6"、"+ 500""5e2"，"3.1416"，"600。"，"-。 123" 和"-Infinity"。  
  
   
  
## Examples  
 下列範例是按鈕 click 事件處理常式的 Web 表單。 它會使用所傳回的陣列<xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType>屬性來判斷使用者的地區設定。 它接著會執行個體化<xref:System.Globalization.CultureInfo>對應至該地區設定的物件。 <xref:System.Globalization.NumberFormatInfo>所屬的物件<xref:System.Globalization.CultureInfo>物件隨後會傳遞至<xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29>方法，將使用者轉換的輸入來<xref:System.Single>值。  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> 並不代表有效格式的數字。</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> 表示小於 <see cref="F:System.Single.MinValue" /> 或大於 <see cref="F:System.Single.MaxValue" /> 的數字。</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Single" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">字串，包含要轉換的數字。</param>
        <param name="style">列舉值的位元組合，表示 <c>s</c> 中可以存在的樣式元素。 要指定的一般值為 <see cref="F:System.Globalization.NumberStyles.Float" /> 和 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的組合。</param>
        <param name="provider">物件，提供關於 <c>s</c> 的文化特性特定格式資訊。</param>
        <summary>將數字的字串表示 (使用指定樣式和的特定文化特性格式) 轉換為其對等的單精確度浮點數。</summary>
        <returns>單精確度浮點數，相當於 <paramref name="s" /> 中指定的數值或符號。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style`參數定義的樣式項目 (例如泛空白字元，千位分隔符號和貨幣符號) 中允許`s`剖析作業成功的參數。 它必須從位元旗標的組合<xref:System.Globalization.NumberStyles>列舉型別。 下列<xref:System.Globalization.NumberStyles>不支援的成員：  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s`參數可以包含<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>，或<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>所指定的文化特性`provider`。 值而定`style`，它也可採用的形式：  
  
 [*ws*] [*$*] [*登*] [*整數位數*，]*整數位數*[。 [*小數點後數字*]][E [*登*]*指數數字*] [*ws*]  
  
 在方括號 （[和]） 是選擇性項目。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列的空格字元。 空白字元可以出現在開頭`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>旗標，而且可以出現在結尾`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>旗標。|  
|$|特定文化特性的貨幣符號。 在字串中的位置由定義<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>目前文化特性的屬性。 目前文化特性的貨幣符號可以出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>旗標。|  
|*簽署*|負號符號 （-） 或正號符號 （+）。 符號可以出現在開頭`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>旗標，而且可以出現在結尾`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>旗標。 括號可用於`s`來表示負數的值，如果`style`包含<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>旗標。|  
|*整數數字*|一連串的數字，範圍從 0 到 9 的指定數目的整數部分。 *整數位數*項目可以是若字串包含*小數點後數字*項目。|  
|,|特定文化特性的群組分隔符號。 目前的文化特性群組分隔符號可出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標|  
|。|特定文化特性的小數點符號。 目前的文化特性小數點符號可以出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。|  
|*fractional-digits*|一系列的範圍從 0 到指定的數字的小數部分的 9 位數。 小數點後數字才會出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。|  
|E|"E"或者"E"字元，表示此值會表示指數 （科學記號） 表示法。 `s`參數可代表指數標記法之數字，如果`style`包含<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>旗標。|  
|*指數數字*|一系列的範圍從 0 到 9 的指定指數的數字。|  
  
 只有數字的字串 (對應於<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>樣式) 一律會成功剖析。 其餘<xref:System.Globalization.NumberStyles?displayProperty=nameWithType>成員控制可能存在，但不一定要出現在輸入字串中的項目。 下表指出如何個別<xref:System.Globalization.NumberStyles>旗標會影響的項目可能會出現在`s`。  
  
|NumberStyles 值|在允許的項目`s`除了數字|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整數位數*只有項目。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小數點 (*。*) 和*小數點後數字*項目。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"或者"E"字元，表示指數標記法中。 單獨使用這個旗標的形式支援值*位數*E*位數*; 其他旗標才能成功剖析項目像是正負號和小數點符號的字串。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*開頭的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*結尾處的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*登*開頭的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*登*結尾處的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*登*括住的數字值的形式的項目。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|千分位 （，） 分隔項目。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|貨幣 （$） 項目。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有項目。 不過，`s`無法表示的十六進位數字或指數標記法之數字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*開頭或結尾的項目`s`，*登*開頭`s`，和小數點 （.） 符號。 `s`參數也可以使用指數標記法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`， `sign`，千位分隔符號 （，） 和小數點 （.） 項目。|  
|<xref:System.Globalization.NumberStyles.Any>|所有項目。 不過，`s`無法表示的十六進位數字。|  
  
 `provider`參數是<xref:System.IFormatProvider>實作。 其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>物件，提供特定文化特性格式資訊`value`。 一般而言，`provider`可以是下列其中一個：  
  
-   A<xref:System.Globalization.CultureInfo>代表提供數值格式設定資訊的文化特性的物件。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供數值格式設定資訊的物件。  
  
-   A<xref:System.Globalization.NumberFormatInfo>提供格式設定資訊的物件。 (它的實作<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>只會傳回本身。)  
  
-   自訂物件實作<xref:System.IFormatProvider>並用<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>方法來具現化，並傳回<xref:System.Globalization.NumberFormatInfo>提供格式設定資訊的物件。  
  
 如果`provider`是`null`、<xref:System.Globalization.NumberFormatInfo>物件會使用目前文化特性。  
  
 如果發現中分隔符號`s`期間剖析作業，以及適用的貨幣或十進位數的參數和群組分隔符號都相同，剖析作業會假設分隔符號是十進位的分隔符號，而不是群組分隔符號。 如需分隔符號的詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法來剖析的字串表示<xref:System.Single>值。 陣列中的每個字串會剖析使用 EN-US、 NL-NL，和自訂的文化特性的格式化慣例。 自訂文化特性會定義群組大小做為兩個底線 ("_") 以及其群組分隔符號。  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> 不表示為數值。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  -或-  <paramref name="style" /> 為 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 值。</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> 代表小於 <see cref="F:System.Single.MinValue" /> 或大於 <see cref="F:System.Single.MaxValue" /> 的數字。</exception>
        <altmember cref="M:System.Single.ToString" />
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Single  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float PositiveInfinity = Infinity;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>表示正無限大。 這個欄位是常數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個常數的值是正數值除以零的結果。  
  
 大於運算的結果時，會傳回這個常數<xref:System.Single.MaxValue>。  
  
 使用<xref:System.Single.IsPositiveInfinity%2A>來判斷值是否計算結果為正的無限大。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Single.PositiveInfinity>常數。  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />。</summary>
        <returns>如果目前執行個體的值不是零則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Single> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代方式是呼叫<xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.Byte" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Single> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代方式是呼叫<xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>不支援這個轉換。 嘗試使用這個方法會擲回 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>不支援這個轉換。 沒有傳回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情況下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>不支援這個轉換。 嘗試使用這個方法會擲回 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>不支援這個轉換。 沒有傳回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情況下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.Decimal" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Single> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代方式是呼叫<xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.Double" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Single> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代方式是呼叫<xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.Int16" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Single> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代方式是呼叫<xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.Int32" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Single> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代方式是呼叫<xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.Int64" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Single> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代方式是呼叫<xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.SByte" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Single> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代方式是呼叫<xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，未變更。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Single> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">此 <see cref="T:System.Single" /> 值轉換所得的類型。</param>
        <param name="provider">物件，可提供傳回值格式的相關資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <paramref name="type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Single> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代方式是呼叫`static`(`Shared`在 Visual Basic 中)<xref:System.Convert.ChangeType%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.UInt16" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Single> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代方式是呼叫<xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.UInt32" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Single> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代方式是呼叫<xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.UInt64" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Single> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代方式是呼叫<xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將這個執行個體的數值轉換為它的相等字串表示。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將這個執行個體的數值轉換為它的相等字串表示。</summary>
        <returns>這個執行個體值的字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString>方法格式<xref:System.Single>值預設值 （"G"或一般） 目前的文化特性的格式。 如果您想要指定不同的格式或文化特性，使用的其他多載<xref:System.Single.ToString%2A>方法，如下所示：  
  
|若要使用格式|文化特性|使用的多載|  
|-------------------|-----------------|----------------------|  
|預設值 ("G") 格式|特定文化特性|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|以特定格式|預設值 （目前） 的文化特性|<xref:System.Single.ToString%28System.String%29>|  
|以特定格式|特定文化特性|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 傳回值可以是<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或格式的字串：  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 選擇性的項目包覆以方括號 （[和]）。 包含 「 數字"一詞的項目是由一系列的範圍從 0 到 9 的數字字元。 下表列出每個項目：  
  
|元素|描述|  
|-------------|-----------------|  
|*簽署*|負號或正號。|  
|*整數數字*|指定數字的數字的整數部分。 整數數字，可不存在有小數點後數字。|  
|'.'|特定文化特性的小數點符號。|  
|*fractional-digits*|指定數字的數字的小數部分。|  
|' e'|小寫字元 'e'，表示指數 （科學記號）。|  
|*指數數字*|指定數字的指數。|  
  
 傳回值的一些範例包括"100"、"-123,456,789"，"123.45 e + 6"、"500"、"3.1416"、"600"、"-0.123"和"-Infinity"。  
  
 .NET Framework 提供廣泛的格式化支援，下列格式的主題中的更詳細地說明：  
  
-   如需有關數值格式規範的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   如需格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。  
  
   
  
## Examples  
 下列範例會使用預設<xref:System.Single.ToString%2A?displayProperty=nameWithType>方法顯示的數字的字串表示<xref:System.Single>值。  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 下列程式碼範例說明使用<xref:System.Single.Parse%28System.String%29>連同方法<xref:System.Single.ToString>方法。  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>使用指定的特定文化特性格式資訊，將這個執行個體的數值轉換成它的相等字串表示。</summary>
        <returns>這個執行個體值的字串表示，如同 <paramref name="provider" /> 所指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.IFormatProvider%29>方法格式<xref:System.Single>值預設值 （"G"或一般） 中指定的文化特性的格式。 如果您想要指定不同的格式或目前的文化特性，使用的其他多載<xref:System.Single.ToString%2A>方法，如下所示：  
  
|若要使用格式|文化特性|使用的多載|  
|-------------------|-----------------|----------------------|  
|預設值 ("G") 格式|預設值 （目前） 的文化特性|<xref:System.Single.ToString>|  
|以特定格式|預設值 （目前） 的文化特性|<xref:System.Single.ToString%28System.String%29>|  
|以特定格式|特定文化特性|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 傳回值可以是<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或格式的字串：  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 選擇性的項目包覆以方括號 （[和]）。 包含 「 數字 」 詞彙項目是由一系列的範圍從 0 到 9 的數字字元所組成。 下表列出每個項目。  
  
|元素|描述|  
|-------------|-----------------|  
|Sign|負號或正號。|  
|整數數字|指定數字的數字的整數部分。 整數數字，可不存在有小數點後數字。|  
|'.'|特定文化特性的小數點符號。|  
|小數點後數字|指定數字的數字的小數部分。|  
|' e'|小寫字元 'e'，表示指數 （科學記號）。|  
|指數數字|指定數字的指數。|  
  
 傳回值的一些範例包括"100"、"-123,456,789"，"123.45 e + 6"、"500"、"3.1416"、"600"、"-0.123"和"-Infinity"。  
  
 .NET Framework 提供廣泛的格式化支援，下列格式的主題中的更詳細地說明：  
  
-   如需有關數值格式規範的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   如需格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。  
  
 `provider`參數是<xref:System.IFormatProvider>實作其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>物件。 一般而言，`provider`是<xref:System.Globalization.CultureInfo>物件或<xref:System.Globalization.NumberFormatInfo>物件。 `provider`參數提供特定文化特性的格式化使用的資訊。 如果`provider`是`null`，傳回值的格式使用<xref:System.Globalization.NumberFormatInfo>目前的文化特性的資料。  
  
 要轉換<xref:System.Single>值為其字串表示，使用指定的文化特性和特定的格式字串，呼叫<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例顯示兩個字串表示<xref:System.Single>使用值<xref:System.Globalization.CultureInfo>代表數個不同的文化特性的物件。  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">數值格式字串。</param>
        <summary>使用指定格式，將這個執行個體的數值轉換成它的相等字串表示。</summary>
        <returns>這個執行個體值的字串表示，如同 <paramref name="format" /> 所指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.String%29>方法格式<xref:System.Single>使用目前文化特性的慣例來指定格式的值。 如果您想要使用預設值 （"G"或一般） 格式或指定不同的文化特性，使用的其他多載<xref:System.Single.ToString%2A>方法，如下所示：  
  
|若要使用格式|文化特性|使用的多載|  
|-------------------|-----------------|----------------------|  
|預設值 ("G") 格式|預設值 （目前） 的文化特性|<xref:System.Single.ToString>|  
|預設值 ("G") 格式|特定文化特性|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|以特定格式|特定文化特性|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 傳回值可以是<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或目前的執行個體，所指定的值的字串表示`format`。  
  
 `format`參數可以是任何有效的標準數值格式規範，除了 D 和 X，以及自訂數值格式規範的任何組合。 如果格式為`null`或空字串，傳回值會格式化為具有一般數值格式規範 ("G")。  
  
 .NET Framework 提供廣泛的格式化支援，下列格式的主題中的更詳細地說明：  
  
-   如需有關數值格式規範的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   如需格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。  
  
 根據預設，傳回的值只包含 7 位有效位數雖然內部維護最多 9 位數。 如果這個執行個體的值有大於 7 的數字、<xref:System.Single.ToString%28System.String%29>傳回<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>或<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>而不是預期的數目。 如果您需要更多有效位數時，指定`format`"G9"格式規格，它一定會傳回 9 位有效位數或"R"，它會傳回 7 位數如果數可以使用 9 位數來表示，如果只表示，數字與最大有效位數。  
  
   
  
## Examples  
 下列範例定義的數值，並將其格式化為貨幣值使用"C"標準數值格式字串和三個小數位數以數值形式使用"N"標準數值格式字串。 結果字串會使用 EN-US 文化特性的慣例來格式化。 如需有關數值格式字串的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 下列範例會顯示數個<xref:System.Single>使用每個支援標準數值格式規範，以及兩個自訂數值格式字串值。 這些自訂格式字串的其中一個說明如何填補<xref:System.Single>加上前置零的值。 將數字的值轉換成字串，此範例會使用 EN-US 文化特性的格式設定慣例。  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 無效。</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">數值格式字串。</param>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>使用指定的格式和特定文化特性格式資訊，將這個執行個體的數值轉換成它的相等字串表示。</summary>
        <returns>這個執行個體值的字串表示，如同 <paramref name="format" /> 和 <paramref name="provider" /> 所指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>方法格式<xref:System.Single>中指定的格式指定文化特性值。 如果您想要使用預設格式或文化特性設定，請使用其他多載的<xref:System.Single.ToString%2A>方法，如下所示：  
  
|若要使用格式|文化特性|使用的多載|  
|-------------------|-----------------|----------------------|  
|預設值 ("G") 格式|預設值 （目前） 的文化特性|<xref:System.Single.ToString>|  
|預設值 ("G") 格式|特定文化特性|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|以特定格式|預設值 （目前） 的文化特性|<xref:System.Single.ToString%28System.String%29>|  
  
 傳回值可以是<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或目前的執行個體，所指定的值的字串表示`format`。  
  
 `format`參數可以是任何有效的標準數值格式規範，除了 D 和 X，以及自訂數值格式規範的任何組合。 如果`format`是`null`或空字串，這個執行個體傳回的值會格式化為具有一般數值格式規範 ("G")。  
  
 .NET Framework 提供廣泛的格式化支援，下列格式的主題中的更詳細地說明：  
  
-   如需有關數值格式規範的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   如需格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。  
  
 `provider`參數是<xref:System.IFormatProvider>實作其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>物件。 一般而言，`provider`是<xref:System.Globalization.CultureInfo>物件或<xref:System.Globalization.NumberFormatInfo>物件。 `provider`參數提供特定文化特性的格式化使用的資訊。 如果`provider`是`null`，傳回值會以格式化<xref:System.Globalization.NumberFormatInfo>目前的文化特性的物件。  
  
 根據預設，傳回的值只包含 7 位有效位數雖然內部維護最多 9 位數。 如果這個執行個體的值有大於 7 的數字、<xref:System.Single.ToString%2A>傳回<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>或<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>而不是預期的數目。 如果您需要更多有效位數時，指定`format`"G9"格式規格，它一定會傳回 9 位有效位數或"R"，它會傳回 7 位數如果數可以使用 9 位數來表示，如果只表示，數字與最大有效位數。  
  
   
  
## Examples  
 下列範例會顯示<xref:System.Single>值使用每個支援標準數值格式規範的數個不同的文化特性。  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將數字的字串表示轉換為其對等的單精確度浮點數。 傳回值會指出轉換成功或失敗。</summary>
        <altmember cref="Overload:System.Single.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] float % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] float % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">字串，表示要轉換的數字。</param>
        <param name="result">當這個方法傳回時，如果轉換成功，則包含相當於 <c>s</c> 中所包含之數值或符號的單精確度浮點數；如果轉換失敗，則為零。 如果 <c>s</c> 參數為 <see langword="null" /> 或 <see cref="F:System.String.Empty" />、不是有效格式的數字，或代表小於 <see cref="F:System.Single.MinValue" /> 或者大於 <see cref="F:System.Single.MaxValue" /> 的數字，這項轉換就會失敗。 此參數會以未初始化的狀態來傳遞，並會覆寫任何原本在 <c>result</c> 中提供的值。</param>
        <summary>將數字的字串表示轉換為其對等的單精確度浮點數。 傳回值會指出轉換成功或失敗。</summary>
        <returns>如果 <see langword="true" /> 轉換成功，則為 <paramref name="s" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載不同於<xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType>藉由傳回布林值，指出是否剖析作業成功而不是傳回的已剖析的數字值的方法。 它不需要使用例外狀況處理來測試<xref:System.FormatException>的`s`無效，無法成功剖析。  
  
 `s`參數可以包含<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> （字串比較是區分大小寫），或格式的字串：  
  
 [ws][sign][integral-digits,]integral-digits[.[fractional-digits]][e[sign]exponential-digits][ws]  
  
 在方括號中的元素是選擇性的元素。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列的空格字元。|  
|*簽署*|負號或正號。|  
|*整數數字*|一連串的數字字元範圍從 0 到 9 的指定數目的整數部分。 整數數字，可不存在有小數點後數字。|  
|*、*|特定文化特性的群組分隔符號。|  
|*.*|特定文化特性的小數點符號。|  
|*fractional-digits*|一連串的範圍從 0 到指定的數字的小數部分的 9 的數字字元。|  
|*E*|大寫或小寫字元 'e'，表示指數 （科學記號）。|  
|*指數數字*|一連串的範圍從 0 到 9 的指定指數的數字字元。|  
  
 `s`參數會使用的組合來解譯<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標。 這表示泛空白字元和千位分隔符號所允許但不是貨幣符號。 若要明確定義的項目 (例如貨幣符號、 千位分隔符號和空白字元) 可以出現在`s`，使用<xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29>方法多載。  
  
 `s`參數會剖析使用的格式設定資訊中<xref:System.Globalization.NumberFormatInfo>初始化目前的系統文化特性的物件。 如需詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>。 若要剖析字串以使用其他的格式設定資訊指定文化特性，請使用<xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29>方法多載。  
  
 一般情況下，如果您要傳入<xref:System.Single.TryParse%2A?displayProperty=nameWithType>方法透過呼叫建立的字串<xref:System.Single.ToString%2A?displayProperty=nameWithType>方法、 原始<xref:System.Single>會傳回值。 不過，由於遺失有效位數，值可能不相等。  
  
 如果發現中分隔符號`s`期間剖析作業，以及適用的貨幣或十進位數的參數和群組分隔符號都相同，剖析作業會假設分隔符號是十進位的分隔符號，而不是群組分隔符號。 如需分隔符號的詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29>方法，將數值的字串表示轉換<xref:System.Single>值。 它會假設該 EN-US 是目前的文化特性。  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">字串，表示要轉換的數字。</param>
        <param name="style">列舉值的位元組合，表示允許的 <c>s</c> 格式。 要指定的一般值為 <see cref="F:System.Globalization.NumberStyles.Float" /> 和 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的組合。</param>
        <param name="provider">物件，提供關於 <c>s</c> 的文化特性特定格式資訊。</param>
        <param name="result">當這個方法傳回時，如果轉換成功，則包含相當於 <c>s</c> 中所包含之數值或符號的單精確度浮點數；如果轉換失敗，則為零。 轉換失敗的狀況包括：如果 <c>s</c> 參數是 <see langword="null" /> 或 <see cref="F:System.String.Empty" />、不是符合 <c>style</c> 的格式、代表小於 <see cref="F:System.Single.MinValue" /> 或大於 <see cref="F:System.Single.MaxValue" /> 的數字，或 <c>style</c> 不是 <see cref="T:System.Globalization.NumberStyles" /> 列舉常數的有效組合。 此參數會以未初始化的狀態來傳遞，並會覆寫任何原本在 <c>result</c> 中提供的值。</param>
        <summary>將數字的字串表示 (使用指定樣式和的特定文化特性格式) 轉換為其對等的單精確度浮點數。 傳回值會指出轉換成功或失敗。</summary>
        <returns>如果 <see langword="true" /> 轉換成功，則為 <paramref name="s" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載不同於<xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>藉由傳回布林值，指出是否剖析作業成功而不是傳回的已剖析的數字值的方法。 它不需要使用例外狀況處理來測試<xref:System.FormatException>的`s`無效，無法成功剖析。  
  
 `style`參數定義的允許格式`s`剖析作業成功的參數。 它必須從位元旗標的組合<xref:System.Globalization.NumberStyles>列舉型別。 下列<xref:System.Globalization.NumberStyles>不支援的成員：  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 `s`參數可以包含<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>，<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>所指定的文化特性`provider`。 此外，根據的值`style`、`s`參數可以包含下列項目：  
  
 [ws][$][符號][整數位數]，整數數字 [.小數數字] [e [符號] 指數數字] [ws]  
  
 在方括號 ([ 和 ]) 中的項目是選擇性的項目。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|選擇性的泛空白字元。 空白字元可以出現在開頭`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>旗標。 它可以出現在結尾`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>旗標。|  
|*$*|特定文化特性的貨幣符號。 在字串中的位置由定義<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>或<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>屬性<xref:System.Globalization.NumberFormatInfo>所傳回物件<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>方法`provider`參數。 貨幣符號可以出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>旗標。|  
|*簽署*|選擇性的符號。 符號可以出現在開頭`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>旗標，而且可以出現在結尾`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>旗標。 括號可用於`s`來表示負數的值，如果`style`包含<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>旗標。|  
|*整數數字*|一連串的數字，範圍從 0 到 9 的指定數目的整數部分。 整數數字，可不存在有小數點後數字。|  
|*、*|特定文化特性的千分位分隔符號。 目前文化特性的千分位分隔符號可出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標。|  
|*.*|特定文化特性的小數點符號。 目前的文化特性小數點符號可以出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。|  
|*fractional-digits*|一系列的範圍從 0 到指定的數字的小數部分的 9 位數。 小數點後數字才會出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。|  
|*e*|E 或 E 字元，這表示`s`可以代表使用指數標記法的數字。 `s`參數可代表指數標記法之數字，如果樣式包含<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>旗標。|  
|*指數數字*|一系列的範圍從 0 到 9 的指定指數的數字。|  
  
 只有數字的字串 (對應於<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>樣式) 一律會成功剖析。 其餘<xref:System.Globalization.NumberStyles?displayProperty=nameWithType>成員控制可能，但是不一定要在輸入字串中出現的項目。 下表指出如何個別<xref:System.Globalization.NumberStyles>旗標會影響的項目可能會出現在`s`。  
  
|NumberStyles 值|允許 s 除了數字中的項目|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整數位數*只有項目。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|*.* 和*小數點後數字*項目。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s`參數也可以使用指數標記法。 單獨使用這個旗標的形式支援值*整數位數*E*指數數字*; 其他旗標才能成功剖析字串中使用這類項目做為指數標記法正或負號和小數點符號。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*開頭的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*結尾處的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*登*開頭的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*登*結尾處的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*登*括住的數字值的形式的項目。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|*，* 項目。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|* $ *項目。|  
|<xref:System.Globalization.NumberStyles.Currency>|全部。 `s`參數無法表示的十六進位數字或指數標記法之數字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*開頭或結尾的項目`s`，*登*開頭`s`，而 *。* 符號。 `s`參數也可以使用指數標記法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`， `sign`，千位分隔符號 (*，)，* 和小數點 (*。*) 項目。|  
|<xref:System.Globalization.NumberStyles.Any>|所有的樣式，除了`s`無法表示的十六進位數字。|  
  
 `provider`參數是<xref:System.IFormatProvider>實作其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>物件，提供特定文化特性格式資訊。 當<xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29>叫用方法時，它會呼叫`provider`參數的<xref:System.IFormatProvider.GetFormat%2A>方法並將其傳遞<xref:System.Type>物件，代表<xref:System.Globalization.NumberFormatInfo>型別。 <xref:System.IFormatProvider.GetFormat%2A>方法接著會傳回<xref:System.Globalization.NumberFormatInfo>物件，提供格式的相關資訊`s`參數。 若要使用的三種方式`provider`參數來提供自訂的格式設定資訊給剖析作業：  
  
-   您可以傳遞<xref:System.Globalization.CultureInfo>代表的文化特性，提供格式設定資訊的物件。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供該文化特性的數值格式設定資訊的物件。  
  
-   您可以傳遞的實際<xref:System.Globalization.NumberFormatInfo>提供數值格式設定資訊的物件。 (它的實作<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>只會傳回本身。)  
  
-   您可以將自訂物件實作<xref:System.IFormatProvider>。 其<xref:System.IFormatProvider.GetFormat%2A>方法具現化，並傳回<xref:System.Globalization.NumberFormatInfo>提供格式設定資訊的物件。  
  
 如果`provider`是`null`，格式化的`s`解譯根據<xref:System.Globalization.NumberFormatInfo>目前文化特性的物件。  
  
 如果發現中分隔符號`s`期間剖析作業，以及適用的貨幣或十進位數的參數和群組分隔符號都相同，剖析作業會假設分隔符號是十進位的分隔符號，而不是群組分隔符號。 如需分隔符號的詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType>方法來剖析具有特定樣式，並會使用特定文化特性的慣例來格式化數字的字串表示。  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  -或-  <paramref name="style" /> 為 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 值。</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
      </Docs>
    </Member>
  </Members>
</Type>