<Type Name="Activator" FullName="System.Activator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="653dee04e0aeaaf8b5bb35be34df72ee8bf2dfa1" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52255415" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Activator : System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Activator extends System.Object implements class System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="DocId" Value="T:System.Activator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Activator&#xA;Implements _Activator" />
  <TypeSignature Language="C++ CLI" Value="public ref class Activator sealed : System::Runtime::InteropServices::_Activator" />
  <TypeSignature Language="F#" Value="type Activator = class&#xA;    interface _Activator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Activator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Activator))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>包含本機或遠端建立物件類型的方法，或者取得對現有遠端物件的參考。 這個類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activator.CreateInstance%2A>方法建立的組件中定義叫用建構函式最符合的型別執行個體指定的引數。 如果未不指定任何參數，不接受任何參數，也就是預設建構函式的建構函式會叫用。  
  
 您必須擁有足夠的權限，以搜尋與呼叫建構函式否則，會擲回例外狀況。 根據預設，只有公用的建構函式會被視為建構函式搜尋期間。 如果可以找到任何建構函式或預設建構函式，則會擲回例外狀況。  
  
 繫結器參數會指定適當的建構函式組件中搜尋的物件。 您可以指定您自己的繫結器和搜尋準則。 如果未不指定任何繫結器，則會使用預設繫結器。 如需詳細資訊，請參閱 <xref:System.Reflection.Binder?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 類別。  
  
 辨識項參數會影響安全性原則和建構函式的權限。 如需詳細資訊，請參閱 <xref:System.Security.Policy.Evidence?displayProperty=nameWithType> 類別。  
  
 在本機或遠端站台，可以建立型別的執行個體。 如果從遠端建立型別，則啟用屬性參數會指定遠端站台的 URI。 到達遠端站台之前，建立執行個體的呼叫可能會通過中間的站台。 其他啟動屬性可以修改的環境中或在其中呼叫則是在遠端和中間的站台運作的內容。  
  
 如果在本機建立的執行個體，則會傳回該物件的參考。 如果從遠端建立執行個體，則會傳回 proxy 的參考。 遠端物件是透過 proxy 操作，如同它是本機物件。  
  
 <xref:System.Activator.GetObject%2A>方法會建立目前執行的遠端物件、 伺服器啟動已知物件或 XML Web service 的 proxy。 您可以指定連接媒體，也就是通道。 如需詳細資訊，請參閱 <xref:System.Runtime.Remoting.Channels.ChannelServices?displayProperty=nameWithType> 類別。  
  
 組件包含型別定義。 <xref:System.Activator.CreateInstance%2A>方法會從目前正在執行的組件來建立型別的執行個體。 <xref:System.Activator.CreateInstanceFrom%2A>方法從檔案包含的組件中建立執行個體。 <xref:System.Activator.CreateComInstanceFrom%2A>方法從檔案包含的組件建立 COM 物件的執行個體。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Activator>以動態方式建構物件，在執行階段類別。  
  
 [!code-cpp[ActivatorX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#1)]
 [!code-csharp[ActivatorX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#1)]
 [!code-vb[ActivatorX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立已具有指定名稱之 COM 物件的執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">檔案的名稱，該檔案包含要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件。</param>
        <param name="typeName">慣用類型的名稱。</param>
        <summary>使用具名組件檔案和預設建構函式 (Constructor)，建立已具有指定名稱之 COM 物件的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值的方法。  
  
 A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>屬性的值`true`必須為 COM 型別套用明確或預設所以<xref:System.Activator.CreateComInstanceFrom%2A>方法可建立該類型的執行個體，否則<xref:System.TypeLoadException>就會擲回。  
  
 如需其他可能會叫用方法所擲回的例外狀況資訊，請參閱例外狀況區段<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>和<xref:System.Activator.CreateInstance%2A>方法。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來建立非公用型別，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，以及包含非公用類型的組件的授權集是否限制為呼叫者的授與設定或其子集。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 或 <paramref name="assemblyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException">無法透過 COM 建立執行個體。  
  
-或- 
 在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />，或您想載入的模組並未指定檔案的副檔名。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體。  
  
-或- 
這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> 為空字串 ("")。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型，不論其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyName">檔案的名稱，該檔案包含要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件。</param>
        <param name="typeName">慣用類型的名稱。</param>
        <param name="hashValue">計算的雜湊碼值。</param>
        <param name="hashAlgorithm">雜湊演算法，用於雜湊檔案並產生強式名稱 (Strong Name)。</param>
        <summary>使用具名組件檔案和預設建構函式 (Constructor)，建立已具有指定名稱之 COM 物件的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值的方法。  
  
 A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>屬性的值`true`必須為 COM 型別套用明確或預設所以<xref:System.Activator.CreateComInstanceFrom%2A>方法可建立該類型的執行個體，否則<xref:System.TypeLoadException>就會擲回。  
  
 如需其他可能會叫用方法所擲回的例外狀況資訊，請參閱例外狀況區段<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>和<xref:System.Activator.CreateInstance%2A>方法。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來建立非公用型別，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，以及包含非公用類型的組件的授權集是否限制為呼叫者的授與設定或其子集。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 或 <paramref name="assemblyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> 為空字串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">使用兩個不同的辨識項載入組件或模組兩次。
        
-或- 
 <paramref name="assemblyName" /> 超過系統定義的長度上限。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />，或您想載入的模組並未指定檔案的副檔名。</exception>
        <exception cref="T:System.IO.FileLoadException">找到 <paramref name="assemblyName" />，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。</exception>
        <exception cref="T:System.Security.SecurityException">指定了並非以 "file://" 開頭的程式碼基底，且沒有必要的 <see langword="WebPermission" />。</exception>
        <exception cref="T:System.TypeLoadException">無法透過 COM 建立執行個體。  
  
-或- 
 在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體。  
  
-或- 
這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型，不論其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取以"file:// 開頭的 URI。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用最符合指定參數的建構函式，建立指定類型的執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance activationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">啟動內容物件，指定要建立的物件。</param>
        <summary>建立類型的執行個體，這個類型是由指定的 <see cref="T:System.ActivationContext" /> 物件所指派。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值的方法。  
  
 啟用內容可在資訊清單架構啟動過程中，若要設定網域原則，並提供應用程式為基礎的安全性模型。 <xref:System.ActivationContext>類別包含<xref:System.ApplicationIdentity>提供存取權的應用程式資訊清單的物件。 如需詳細資訊，請參閱 <xref:System.Security.Policy.ApplicationSecurityManager> 類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type -&gt; obj" Usage="System.Activator.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">要建立的物件類型。</param>
        <summary>使用指定之類型的預設建構函式，建立該類型的執行個體。</summary>
        <returns>新建立物件的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要叫用建構函式必須是可存取。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用型別，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，以及包含非公用類型的組件的授權集是否限制為呼叫者的授與設定或其子集。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列程式碼範例示範如何呼叫<xref:System.Activator.CreateInstance%28System.Type%29>方法。 會建立許多不同類型的執行個體，並顯示其預設值。  
  
 [!code-cpp[ActivatorX#4](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/source2.cpp#4)]
 [!code-csharp[ActivatorX#4](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/source2.cs#4)]
 [!code-vb[ActivatorX#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/source2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不是 <see langword="RuntimeType" />。  
  
-或- 
 <paramref name="type" /> 是開放式泛型類型 (也就是 <see cref="P:System.Type.ContainsGenericParameters" /> 屬性會傳回 <see langword="true" />)。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> 不可以是 <see cref="T:System.Reflection.Emit.TypeBuilder" />。  
  
-或- 
不支援建立 <see cref="T:System.TypedReference" />、<see cref="T:System.ArgIterator" />、<see cref="T:System.Void" /> 和 <see cref="T:System.RuntimeArgumentHandle" /> 類型或這些類型的陣列。  
  
-或- 
包含 <paramref name="type" /> 的組件是以 <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" /> 建立的動態組件。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">正在呼叫的建構函式擲回例外狀況。</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況 <see cref="T:System.MemberAccessException" />。  
  
</para>
          </block>  
  
 呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">COM 類型不是透過 <see cref="Overload:System.Type.GetTypeFromProgID" /> 或 <see cref="Overload:System.Type.GetTypeFromCLSID" /> 取得。</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況 <see cref="T:System.MissingMemberException" />。  
  
</para>
          </block>  
  
 找不到相符的公用建構函式。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> 是 COM 物件，但用來取得類型的類別識別項無效，或已識別的類別未經登錄。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> 不是有效的類型。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型，不論其授與集合。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext, string[] activationCustomData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext, string[] activationCustomData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext, cli::array &lt;System::String ^&gt; ^ activationCustomData);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext * string[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (activationContext, activationCustomData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
        <Parameter Name="activationCustomData" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="activationContext">啟動內容物件，指定要建立的物件。</param>
        <param name="activationCustomData">Unicode 字串的陣列，包含自訂啟動資料。</param>
        <summary>建立類型的執行個體，這個類型是由指定的 <see cref="T:System.ActivationContext" /> 物件所指派，並且是以指定的自訂啟動資料所啟動。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值的方法。  
  
 啟用內容可在資訊清單架構啟動過程中，若要設定網域原則，並提供應用程式為基礎的安全性模型。 <xref:System.ActivationContext>類別包含<xref:System.ApplicationIdentity>提供存取權的應用程式資訊清單的物件。 如需詳細資訊，請參閱 <xref:System.Security.Policy.ApplicationSecurityManager> 類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件名稱。 如果 <paramref name="assemblyName" /> 為 <see langword="null" />，則會搜尋執行中的組件。</param>
        <param name="typeName">慣用類型的完整名稱。</param>
        <summary>使用具名組件和預設建構函式，建立已具有指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值。  
  
 `assemblyName` 可以是下列其中一項：  
  
-   組件，而它的路徑或檔案的副檔名不簡單名稱。 例如，您會指定`TypeExtensions`其路徑和名稱是.\bin\TypeExtensions.dll 組件。  
  
-   帶正負號的組件，其中包含其簡單名稱、 版本、 文化特性和公開金鑰語彙基元; 的完整名稱例如，"TypeExtensions，version=1.0.0.0，Culture = neutral，PublicKeyToken = 181869f2f7435b51"。  
  
 如需有關 common language runtime 如何識別及載入組件的詳細資訊，請參閱 <<c0> [ 執行階段如何找出組件](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)。 如需使用應用程式組態檔來定義組件位置的資訊，請參閱[指定組件的位置](~/docs/framework/configure-apps/specify-assembly-location.md)。 如果`assemblyName`找到，它會載入預設內容中。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來建立非公用型別，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，以及包含非公用類型的組件的授權集是否限制為呼叫者的授與設定或其子集。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例會定義名為類別`Person`名為組件中`PersonInfo`。 請注意，`Person`類別有兩個建構函式，其中之一就是無參數。  
  
 [!code-csharp[System.Activator.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/personinfo.cs#1)]
 [!code-vb[System.Activator.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/personinfo.vb#1)]  
  
 下列範例會呼叫<xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29>方法具現化`Person`類別。 它需要 PersonInfo.dll 可以加入至專案的參考。 因為<xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29>方法呼叫`Person`類別預設建構函式，此範例將值指派給其`Name`屬性。  
  
 [!code-csharp[System.Activator.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1.cs#2)]
 [!code-vb[System.Activator.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1.vb#2)]  
  
 不過，<xref:System.Activator.CreateInstance%2A>常被稱為型別，在跨電腦界限或在設計階段不知道，具現化。 在此情況下，您不能包含在專案中的組件的參考，並不能進行型別之成員的早期繫結呼叫。 若要解決這項限制，下列範例會使用<xref:System.Activator.CreateInstance%2A>方法，以及將值指派給反映`Person`物件的`Name`屬性，並顯示其值。  
  
 [!code-csharp[System.Activator.CreateInstance#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1a.cs#3)]
 [!code-vb[System.Activator.CreateInstance#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1a.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">您無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">透過反映叫用並擲回例外狀況的建構函式。</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">COM 類型不是透過 <see cref="Overload:System.Type.GetTypeFromProgID" /> 或 <see cref="Overload:System.Type.GetTypeFromCLSID" /> 取得。</exception>
        <exception cref="T:System.NotSupportedException">不支援建立 <see cref="T:System.TypedReference" />、<see cref="T:System.ArgIterator" />、<see cref="T:System.Void" /> 和 <see cref="T:System.RuntimeArgumentHandle" /> 類型或這些類型的陣列。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime (CLR) 2.0 版或更新版本，且已使用比目前載入之版本更新的 CLR 版本來編譯 <paramref name="assemblyName" />。 請注意，.NET Framework 2.0、3.0 和 3.5 版全部都會使用 CLR 2.0 版。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。  
  
-或- 
組件名稱或程式碼基底無效。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型，不論其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, bool nonPublic);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * bool -&gt; obj" Usage="System.Activator.CreateInstance (type, nonPublic)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要建立的物件類型。</param>
        <param name="nonPublic">如果公用或非公用預設建構函式可相符，則為 <see langword="true" />；如果只有公用預設建構函式可相符，則為 <see langword="false" />。</param>
        <summary>使用指定之類型的預設建構函式，建立該類型的執行個體。</summary>
        <returns>新建立物件的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用類型和成員，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，以及包含非公用類型和成員的組件的授權集是否限制若要將呼叫者的授與集或子集。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不是 <see langword="RuntimeType" />。  
  
-或- 
 <paramref name="type" /> 是開放式泛型類型 (也就是 <see cref="P:System.Type.ContainsGenericParameters" /> 屬性會傳回 <see langword="true" />)。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> 不可以是 <see cref="T:System.Reflection.Emit.TypeBuilder" />。  
  
-或- 
不支援建立 <see cref="T:System.TypedReference" />、<see cref="T:System.ArgIterator" />、<see cref="T:System.Void" /> 和 <see cref="T:System.RuntimeArgumentHandle" /> 類型或這些類型的陣列。  
  
-或- 
包含 <paramref name="type" /> 的組件是以 <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" /> 建立的動態組件。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">正在呼叫的建構函式擲回例外狀況。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">COM 類型不是透過 <see cref="Overload:System.Type.GetTypeFromProgID" /> 或 <see cref="Overload:System.Type.GetTypeFromCLSID" /> 取得。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> 是 COM 物件，但用來取得類型的類別識別項無效，或已識別的類別未經登錄。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> 不是有效的類型。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型和成員而不論是否其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">要建立的物件類型。</param>
        <param name="args">引數的陣列，此引數在數目、順序和類型上符合要叫用的建構函式的參數。 如果 <paramref name="args" /> 是空陣列或 <see langword="null" />，會叫用未採用參數的建構函式 (預設的建構函式)。</param>
        <summary>使用最符合指定參數的建構函式，建立指定類型的執行個體。</summary>
        <returns>新建立物件的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要叫用建構函式必須是可存取，而且必須提供指定的引數清單最特定的相符項目。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用型別，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，以及包含非公用類型的組件的授權集是否限制為呼叫者的授與設定或其子集。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29>方法用來建立<xref:System.String>物件。 它會呼叫<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>建構函式來具現化字串，包含十個項目，從字元陣列的第十四個位置開始。  
  
 [!code-csharp[System.Activator.CreateInstance#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/CreateInstance5.cs#5)]
 [!code-vb[System.Activator.CreateInstance#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/CreateInstance5.vb#5)]  
  
 下列範例會建立不規則的陣列，其項目是引數傳遞至<xref:System.String>建構函式。 範例接著會傳遞至每個陣列<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29>方法來叫用適當的字串建構函式。  
  
 [!code-csharp[System.Activator.CreateInstance#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstance2.cs#4)]
 [!code-vb[System.Activator.CreateInstance#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstance2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不是 <see langword="RuntimeType" />。  
  
-或- 
 <paramref name="type" /> 是開放式泛型類型 (也就是 <see cref="P:System.Type.ContainsGenericParameters" /> 屬性會傳回 <see langword="true" />)。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> 不可以是 <see cref="T:System.Reflection.Emit.TypeBuilder" />。  
  
-或- 
不支援建立 <see cref="T:System.TypedReference" />、<see cref="T:System.ArgIterator" />、<see cref="T:System.Void" /> 和 <see cref="T:System.RuntimeArgumentHandle" /> 類型或這些類型的陣列。  
  
-或- 
包含 <paramref name="type" /> 的組件是以 <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" /> 建立的動態組件。  
  
-或- 
最符合 <paramref name="args" /> 的建構函式有 <see langword="varargs" /> 引數。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">正在呼叫的建構函式擲回例外狀況。</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況 <see cref="T:System.MemberAccessException" />。  
  
</para>
          </block>  
  
 呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">COM 類型不是透過 <see cref="Overload:System.Type.GetTypeFromProgID" /> 或 <see cref="Overload:System.Type.GetTypeFromCLSID" /> 取得。</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況 <see cref="T:System.MissingMemberException" />。  
  
</para>
          </block>  
  
 找不到相符的公用建構函式。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> 是 COM 物件，但用來取得類型的類別識別項無效，或已識別的類別未經登錄。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> 不是有效的類型。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型，不論其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (domain As AppDomain, assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">建立名稱為 <paramref name="typeName" /> 之類型的遠端網域。</param>
        <param name="assemblyName">要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件名稱。 如果 <paramref name="assemblyName" /> 為 <see langword="null" />，則會搜尋執行中的組件。</param>
        <param name="typeName">慣用類型的完整名稱。</param>
        <summary>使用具名組件和預設建構函式，建立已在指定遠端網域中具有指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Activator.CreateInstance%2A>主機需要具有限制的安全性權限的應用程式定義域中執行程式碼。  
  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值。  
  
> [!NOTE]
>  這個方法會使用<xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType>要求必須受到完全信任立即呼叫端。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 或 <paramref name="domain" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象型別的執行個體 (Instance)。  
  
-或- 
這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">透過反映叫用並擲回例外狀況的建構函式。</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">COM 類型不是透過 <see cref="Overload:System.Type.GetTypeFromProgID" /> 或 <see cref="Overload:System.Type.GetTypeFromCLSID" /> 取得。</exception>
        <exception cref="T:System.NotSupportedException">不支援建立 <see cref="T:System.TypedReference" />、<see cref="T:System.ArgIterator" />、<see cref="T:System.Void" /> 和 <see cref="T:System.RuntimeArgumentHandle" /> 類型或這些類型的陣列。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime (CLR) 2.0 版或更新版本，且已使用比目前載入之版本更新的 CLR 版本來編譯 <paramref name="assemblyName" />。 請注意，.NET Framework 2.0、3.0 和 3.5 版全部都會使用 CLR 2.0 版。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。  
  
-或- 
組件名稱或程式碼基底無效。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件名稱。 如果 <paramref name="assemblyName" /> 為 <see langword="null" />，則會搜尋執行中的組件。</param>
        <param name="typeName">慣用類型的完整名稱。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>使用具名組件和預設建構函式，建立已具有指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來建立非公用型別，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標和非公用類型的授權集是否限制為呼叫端的授權集或子集。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">COM 類型不是透過 <see cref="Overload:System.Type.GetTypeFromProgID" /> 或 <see cref="Overload:System.Type.GetTypeFromCLSID" /> 取得。</exception>
        <exception cref="T:System.NotSupportedException">不支援建立 <see cref="T:System.TypedReference" />、<see cref="T:System.ArgIterator" />、<see cref="T:System.Void" /> 和 <see cref="T:System.RuntimeArgumentHandle" /> 類型或這些類型的陣列。  
  
-或- 
 <paramref name="activationAttributes" /> 不是空的陣列，而建立中的類型不是衍生自 <see cref="T:System.MarshalByRefObject" />。  
  
-或- 
 <paramref name="activationAttributes" /> 不是 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />。  
  
陣列。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime (CLR) 2.0 版或更新版本，且已使用比目前載入之版本更新的 CLR 版本來編譯 <paramref name="assemblyName" />。 請注意，.NET Framework 2.0、3.0 和 3.5 版全部都會使用 CLR 2.0 版。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。  
  
-或- 
組件名稱或程式碼基底無效。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">嘗試在 <paramref name="activationAttributes" /> 所指定之目標中進行遠端啟動時發生錯誤。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型，不論其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, object[] args, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[],System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">要建立的物件類型。</param>
        <param name="args">引數的陣列，此引數在數目、順序和類型上符合要叫用的建構函式的參數。 如果 <paramref name="args" /> 是空陣列或 <see langword="null" />，會叫用未採用參數的建構函式 (預設的建構函式)。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>使用最符合指定參數的建構函式，建立指定類型的執行個體。</summary>
        <returns>新建立物件的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要叫用建構函式必須是可存取，而且必須提供指定的引數清單最特定的相符項目。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用型別，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，以及包含非公用類型的組件的授權集是否限制為呼叫者的授與設定或其子集。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不是 <see langword="RuntimeType" />。  
  
-或- 
 <paramref name="type" /> 是開放式泛型類型 (也就是 <see cref="P:System.Type.ContainsGenericParameters" /> 屬性會傳回 <see langword="true" />)。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> 不可以是 <see cref="T:System.Reflection.Emit.TypeBuilder" />。  
  
-或- 
不支援建立 <see cref="T:System.TypedReference" />、<see cref="T:System.ArgIterator" />、<see cref="T:System.Void" /> 和 <see cref="T:System.RuntimeArgumentHandle" /> 類型或這些類型的陣列。  
  
-或- 
 <paramref name="activationAttributes" /> 不是空的陣列，而建立中的類型不是衍生自 <see cref="T:System.MarshalByRefObject" />。  
  
-或- 
包含 <paramref name="type" /> 的組件是以 <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" /> 建立的動態組件。  
  
-或- 
最符合 <paramref name="args" /> 的建構函式有 <see langword="varargs" /> 引數。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">正在呼叫的建構函式擲回例外狀況。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">COM 類型不是透過 <see cref="Overload:System.Type.GetTypeFromProgID" /> 或 <see cref="Overload:System.Type.GetTypeFromCLSID" /> 取得。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> 是 COM 物件，但用來取得類型的類別識別項無效，或已識別的類別未經登錄。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> 不是有效的類型。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型，不論其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="type">要建立的物件類型。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="type" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">物件，使用 <paramref name="bindingAttr" /> 和 <paramref name="args" /> 來搜尋及識別 <paramref name="type" /> 建構函式。 如果 <paramref name="binder" /> 為 <see langword="null" />，則會使用預設繫結器。</param>
        <param name="args">引數的陣列，此引數在數目、順序和類型上符合要叫用的建構函式的參數。 如果 <paramref name="args" /> 是空陣列或 <see langword="null" />，會叫用未採用參數的建構函式 (預設的建構函式)。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="type" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <summary>使用最符合指定參數的建構函式，建立指定類型的執行個體。</summary>
        <returns>新建立物件的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要叫用建構函式必須提供最符合指定繫結和繫結屬性的限制下指定的引數清單。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用類型和成員，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，以及包含非公用類型和成員的組件的授權集是否限制若要將呼叫者的授與集或子集。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不是 <see langword="RuntimeType" />。  
  
-或- 
 <paramref name="type" /> 是開放式泛型類型 (也就是 <see cref="P:System.Type.ContainsGenericParameters" /> 屬性會傳回 <see langword="true" />)。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> 不可以是 <see cref="T:System.Reflection.Emit.TypeBuilder" />。  
  
-或- 
不支援建立 <see cref="T:System.TypedReference" />、<see cref="T:System.ArgIterator" />、<see cref="T:System.Void" /> 和 <see cref="T:System.RuntimeArgumentHandle" /> 類型或這些類型的陣列。  
  
-或- 
包含 <paramref name="type" /> 的組件是以 <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" /> 建立的動態組件。  
  
-或- 
最符合 <paramref name="args" /> 的建構函式有 <see langword="varargs" /> 引數。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">正在呼叫的建構函式擲回例外狀況。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">COM 類型不是透過 <see cref="Overload:System.Type.GetTypeFromProgID" /> 或 <see cref="Overload:System.Type.GetTypeFromCLSID" /> 取得。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> 是 COM 物件，但用來取得類型的類別識別項無效，或已識別的類別未經登錄。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> 不是有效的類型。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型和成員而不論是否其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">要建立的物件類型。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="type" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">物件，使用 <paramref name="bindingAttr" /> 和 <paramref name="args" /> 來搜尋及識別 <paramref name="type" /> 建構函式。 如果 <paramref name="binder" /> 為 <see langword="null" />，則會使用預設繫結器。</param>
        <param name="args">引數的陣列，此引數在數目、順序和類型上符合要叫用的建構函式的參數。 如果 <paramref name="args" /> 是空陣列或 <see langword="null" />，會叫用未採用參數的建構函式 (預設的建構函式)。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="type" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>使用最符合指定參數的建構函式，建立指定類型的執行個體。</summary>
        <returns>新建立物件的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要叫用建構函式必須提供最符合指定繫結和繫結屬性的限制下指定的引數清單。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來存取非公用類型和成員，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標和非公用類型和成員的授權集是否限制呼叫端的授權集或子集。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不是 <see langword="RuntimeType" />。  
  
-或- 
 <paramref name="type" /> 是開放式泛型類型 (也就是 <see cref="P:System.Type.ContainsGenericParameters" /> 屬性會傳回 <see langword="true" />)。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> 不可以是 <see cref="T:System.Reflection.Emit.TypeBuilder" />。  
  
-或- 
不支援建立 <see cref="T:System.TypedReference" />、<see cref="T:System.ArgIterator" />、<see cref="T:System.Void" /> 和 <see cref="T:System.RuntimeArgumentHandle" /> 類型或這些類型的陣列。  
  
-或- 
 <paramref name="activationAttributes" /> 不是空的陣列，而建立中的類型不是衍生自 <see cref="T:System.MarshalByRefObject" />。  
  
-或- 
包含 <paramref name="type" /> 的組件是以 <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" /> 建立的動態組件。  
  
-或- 
最符合 <paramref name="args" /> 的建構函式有 <see langword="varargs" /> 引數。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">正在呼叫的建構函式擲回例外狀況。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">COM 類型不是透過 <see cref="Overload:System.Type.GetTypeFromProgID" /> 或 <see cref="Overload:System.Type.GetTypeFromCLSID" /> 取得。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> 是 COM 物件，但用來取得類型的類別識別項無效，或已識別的類別未經登錄。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> 不是有效的類型。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供辨識項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型和成員而不論是否其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件名稱。 如果 <paramref name="assemblyName" /> 為 <see langword="null" />，則會搜尋執行中的組件。</param>
        <param name="typeName">慣用類型的完整名稱。</param>
        <param name="ignoreCase">
          <see langword="true" /> 指定 <paramref name="typeName" /> 的搜尋不區分大小寫，<see langword="false" /> 指定搜尋區分大小寫。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">物件，使用 <paramref name="bindingAttr" /> 和 <paramref name="args" /> 來搜尋及識別 <paramref name="typeName" /> 建構函式。 如果 <paramref name="binder" /> 為 <see langword="null" />，則會使用預設繫結器。</param>
        <param name="args">引數的陣列，此引數在數目、順序和類型上符合要叫用的建構函式的參數。 如果 <paramref name="args" /> 是空陣列或 <see langword="null" />，會叫用未採用參數的建構函式 (預設的建構函式)。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>使用具名組件和最符合指定參數的建構函式，建立已具有指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來建立非公用類型和成員，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，以及包含非公用類型和成員的組件的授權集是否限制若要將呼叫者的授與集或子集。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">透過反映叫用並擲回例外狀況的建構函式。</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">COM 類型不是透過 <see cref="Overload:System.Type.GetTypeFromProgID" /> 或 <see cref="Overload:System.Type.GetTypeFromCLSID" /> 取得。</exception>
        <exception cref="T:System.NotSupportedException">不支援建立 <see cref="T:System.TypedReference" />、<see cref="T:System.ArgIterator" />、<see cref="T:System.Void" /> 和 <see cref="T:System.RuntimeArgumentHandle" /> 類型或這些類型的陣列。  
  
-或- 
 <paramref name="activationAttributes" /> 不是空的陣列，而建立中的類型不是衍生自 <see cref="T:System.MarshalByRefObject" />。  
  
-或- 
最符合 <paramref name="args" /> 的建構函式有 <see langword="varargs" /> 引數。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime (CLR) 2.0 版或更新版本，且已使用比目前載入之版本更新的 CLR 版本來編譯 <paramref name="assemblyName" />。 請注意，.NET Framework 2.0、3.0 和 3.5 版全部都會使用 CLR 2.0 版。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。  
  
-或- 
組件名稱或程式碼基底無效。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型和成員而不論是否其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">要在其中建立名稱為 <paramref name="typeName" /> 之類型的網域。</param>
        <param name="assemblyName">要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件名稱。 如果 <paramref name="assemblyName" /> 為 <see langword="null" />，則會搜尋執行中的組件。</param>
        <param name="typeName">慣用類型的完整名稱。</param>
        <param name="ignoreCase">
          <see langword="true" /> 指定 <paramref name="typeName" /> 的搜尋不區分大小寫，<see langword="false" /> 指定搜尋區分大小寫。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">物件，使用 <paramref name="bindingAttr" /> 和 <paramref name="args" /> 來搜尋及識別 <paramref name="typeName" /> 建構函式。 如果 <paramref name="binder" /> 為 <see langword="null" />，則會使用預設繫結器。</param>
        <param name="args">引數的陣列，此引數在數目、順序和類型上符合要叫用的建構函式的參數。 如果 <paramref name="args" /> 是空陣列或 <see langword="null" />，會叫用未採用參數的建構函式 (預設的建構函式)。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>使用最符合指定參數的具名組件和建構函式，建立已在指定遠端網域中具有指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Activator.CreateInstance%2A>主機需要具有限制的安全性權限的應用程式定義域中執行程式碼。  
  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值。  
  
> [!NOTE]
>  這個方法會使用<xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType>要求必須受到完全信任立即呼叫端。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">透過反映叫用並擲回例外狀況的建構函式。</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">COM 類型不是透過 <see cref="Overload:System.Type.GetTypeFromProgID" /> 或 <see cref="Overload:System.Type.GetTypeFromCLSID" /> 取得。</exception>
        <exception cref="T:System.NotSupportedException">不支援建立 <see cref="T:System.TypedReference" />、<see cref="T:System.ArgIterator" />、<see cref="T:System.Void" /> 和 <see cref="T:System.RuntimeArgumentHandle" /> 類型或這些類型的陣列。  
  
-或- 
 <paramref name="activationAttributes" /> 不是空的陣列，而建立中的類型不是衍生自 <see cref="T:System.MarshalByRefObject" />。  
  
-或- 
最符合 <paramref name="args" /> 的建構函式有 <see langword="varargs" /> 引數。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime (CLR) 2.0 版或更新版本，且已使用比目前載入之版本更新的 CLR 版本來編譯 <paramref name="assemblyName" />。 請注意，.NET Framework 2.0、3.0 和 3.5 版全部都會使用 CLR 2.0 版。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。  
  
-或- 
組件名稱或程式碼基底無效。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件名稱。 如果 <paramref name="assemblyName" /> 為 <see langword="null" />，則會搜尋執行中的組件。</param>
        <param name="typeName">慣用類型的完整名稱。</param>
        <param name="ignoreCase">
          <see langword="true" /> 指定 <paramref name="typeName" /> 的搜尋不區分大小寫，<see langword="false" /> 指定搜尋區分大小寫。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">物件，使用 <paramref name="bindingAttr" /> 和 <paramref name="args" /> 來搜尋及識別 <paramref name="typeName" /> 建構函式。 如果 <paramref name="binder" /> 為 <see langword="null" />，則會使用預設繫結器。</param>
        <param name="args">引數的陣列，此引數在數目、順序和類型上符合要叫用的建構函式的參數。 如果 <paramref name="args" /> 是空陣列或 <see langword="null" />，會叫用未採用參數的建構函式 (預設的建構函式)。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <param name="securityInfo">用來執行安全性原則決策和授權程式碼使用權限的資訊。</param>
        <summary>使用具名組件和最符合指定參數的建構函式，建立已具有指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可用來建立非公用類型和成員，如果呼叫者已授與<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，以及包含非公用類型和成員的組件的授權集是否限制若要將呼叫者的授與集或子集。 (請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">透過反映叫用並擲回例外狀況的建構函式。</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">COM 類型不是透過 <see cref="Overload:System.Type.GetTypeFromProgID" /> 或 <see cref="Overload:System.Type.GetTypeFromCLSID" /> 取得。</exception>
        <exception cref="T:System.NotSupportedException">不支援建立 <see cref="T:System.TypedReference" />、<see cref="T:System.ArgIterator" />、<see cref="T:System.Void" /> 和 <see cref="T:System.RuntimeArgumentHandle" /> 類型或這些類型的陣列。  
  
-或- 
 <paramref name="activationAttributes" /> 不是空的陣列，而建立中的類型不是衍生自 <see cref="T:System.MarshalByRefObject" />。  
  
-或- 
最符合 <paramref name="args" /> 的建構函式有 <see langword="varargs" /> 引數。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime (CLR) 2.0 版或更新版本，且已使用比目前載入之版本更新的 CLR 版本來編譯 <paramref name="assemblyName" />。 請注意，.NET Framework 2.0、3.0 和 3.5 版全部都會使用 CLR 2.0 版。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。  
  
-或- 
組件名稱或程式碼基底無效。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型和成員而不論是否其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">要在其中建立名稱為 <paramref name="typeName" /> 之類型的網域。</param>
        <param name="assemblyName">要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件名稱。 如果 <paramref name="assemblyName" /> 為 <see langword="null" />，則會搜尋執行中的組件。</param>
        <param name="typeName">慣用類型的完整名稱。</param>
        <param name="ignoreCase">
          <see langword="true" /> 指定 <paramref name="typeName" /> 的搜尋不區分大小寫，<see langword="false" /> 指定搜尋區分大小寫。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">物件，使用 <paramref name="bindingAttr" /> 和 <paramref name="args" /> 來搜尋及識別 <paramref name="typeName" /> 建構函式。 如果 <paramref name="binder" /> 為 <see langword="null" />，則會使用預設繫結器。</param>
        <param name="args">引數的陣列，此引數在數目、順序和類型上符合要叫用的建構函式的參數。 如果 <paramref name="args" /> 是空陣列或 <see langword="null" />，會叫用未採用參數的建構函式 (預設的建構函式)。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 這通常是包含單一 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件的陣列。 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 會指定啟動遠端物件所需的 URL。</param>
        <param name="securityAttributes">用來執行安全性原則決策和授權程式碼使用權限的資訊。</param>
        <summary>使用最符合指定參數的具名組件和建構函式，建立已在指定遠端網域中具有指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Activator.CreateInstance%2A>主機需要具有限制的安全性權限的應用程式定義域中執行程式碼。  
  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值。  
  
> [!NOTE]
>  這個方法會使用<xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType>要求必須受到完全信任立即呼叫端。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">透過反映叫用並擲回例外狀況的建構函式。</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">COM 類型不是透過 <see cref="Overload:System.Type.GetTypeFromProgID" /> 或 <see cref="Overload:System.Type.GetTypeFromCLSID" /> 取得。</exception>
        <exception cref="T:System.NotSupportedException">不支援建立 <see cref="T:System.TypedReference" />、<see cref="T:System.ArgIterator" />、<see cref="T:System.Void" /> 和 <see cref="T:System.RuntimeArgumentHandle" /> 類型或這些類型的陣列。  
  
-或- 
 <paramref name="activationAttributes" /> 不是空的陣列，而建立中的類型不是衍生自 <see cref="T:System.MarshalByRefObject" />。  
  
-或- 
最符合 <paramref name="args" /> 的建構函式有 <see langword="varargs" /> 引數。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime (CLR) 2.0 版或更新版本，且已使用比目前載入之版本更新的 CLR 版本來編譯 <paramref name="assemblyName" />。 請注意，.NET Framework 2.0、3.0 和 3.5 版全部都會使用 CLR 2.0 版。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。  
  
-或- 
組件名稱或程式碼基底無效。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CreateInstance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CreateInstance&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T CreateInstance();" />
      <MemberSignature Language="F#" Value="static member CreateInstance : unit -&gt; 'T" Usage="System.Activator.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">要建立的類型。</typeparam>
        <summary>使用無參數建構函式，建立由指定之泛型型別參數所指定之類型的執行個體。</summary>
        <returns>新建立物件的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activator.CreateInstance%60%601>編譯器會使用泛型的方法來實作型別參數所指定的型別具現化。 例如，在下列泛型方法的實作`new T()`(`gcnew T()` c + + 中) 會使用<xref:System.Activator.CreateInstance%60%601>泛型方法。  
  
 [!code-cpp[System.Activation.CreateInstance~~1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cpp/remarks.cpp#1)]
 [!code-csharp[System.Activation.CreateInstance~~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cs/remarks.cs#1)]
 [!code-vb[System.Activation.CreateInstance~~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activation.createinstance~~1/vb/remarks.vb#1)]  
  
 一般情況下，沒有任何適用於<xref:System.Activator.CreateInstance%60%601>應用程式中的泛型方法程式碼，因為必須在編譯時期已知的型別。 如果在編譯時期已知的類型，可以使用標準具現化語法 (`new`在 C# 中，運算子`New`Visual Basic 中`gcnew`c + + 中)。 如果在編譯時期不知道類型，您可以呼叫的非泛型多載<xref:System.Activator.CreateInstance%2A>。  
  
 沒有任何多載<xref:System.Activator.CreateInstance%60%601>泛型方法接受引數清單，因為非泛型多載的<xref:System.Activator.CreateInstance%2A>已經提供晚期繫結的建構函式解析。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況 <see cref="T:System.MissingMemberException" />。  
  
</para>
          </block>  
  
 針對 <paramref name="T" /> 指定的類型沒有無參數建構函式。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用具名組件檔案和最符合指定參數的建構函式，建立已具有指定名稱之類型的執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱，該檔案包含要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件。</param>
        <param name="typeName">慣用類型的名稱。</param>
        <summary>使用具名組件檔案和預設建構函式，建立已具有指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值的方法。  
  
 如需其他可能會叫用方法所擲回的例外狀況資訊，請參閱例外狀況區段<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>和<xref:System.Activator.CreateInstance%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何呼叫<xref:System.Activator.CreateInstanceFrom%2A>方法。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Activator>類別。  
  
 [!code-cpp[ActivatorX#3](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#3)]
 [!code-csharp[ActivatorX#3](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#3)]
 [!code-vb[ActivatorX#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">透過反映叫用並擲回例外狀況的建構函式。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端具有所要求的 <see cref="T:System.Security.Permissions.FileIOPermission" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime (CLR) 2.0 版或更新版本，且已使用比目前載入之版本更新的 CLR 版本來編譯 <paramref name="assemblyName" />。 請注意，.NET Framework 2.0、3.0 和 3.5 版全部都會使用 CLR 2.0 版。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">提供要搜尋的目錄路徑，並讀取其內容的能力。 相關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型，不論其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (domain As AppDomain, assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">建立名稱為 <paramref name="typeName" /> 之類型的遠端網域。</param>
        <param name="assemblyFile">檔案的名稱，該檔案包含要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件。</param>
        <param name="typeName">慣用類型的名稱。</param>
        <summary>使用具名組件檔案和預設建構函式，建立已在指定遠端網域中指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Activator.CreateInstanceFrom%2A>主機需要具有限制的安全性權限的應用程式定義域中執行程式碼。  
  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值的方法。  
  
> [!NOTE]
>  這個方法會使用<xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType>要求必須受到完全信任立即呼叫端。  
  
 如需其他可能會叫用方法所擲回的例外狀況資訊，請參閱例外狀況區段<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>和<xref:System.Activator.CreateInstance%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">透過反映叫用並擲回例外狀況的建構函式。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端具有所要求的 <see cref="T:System.Security.Permissions.FileIOPermission" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime (CLR) 2.0 版或更新版本，且已使用比目前載入之版本更新的 CLR 版本來編譯 <paramref name="assemblyName" />。 請注意，.NET Framework 2.0、3.0 和 3.5 版全部都會使用 CLR 2.0 版。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">提供要搜尋的目錄路徑，並讀取其內容的能力。 相關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱，該檔案包含要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件。</param>
        <param name="typeName">慣用類型的名稱。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>使用具名組件檔案和預設建構函式，建立已具有指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值的方法。  
  
 如需其他可能會叫用方法所擲回的例外狀況資訊，請參閱例外狀況區段<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>和<xref:System.Activator.CreateInstance%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">透過反映叫用並擲回例外狀況的建構函式。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> 不是空的陣列，而建立中的類型不是衍生自 <see cref="T:System.MarshalByRefObject" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端具有所要求的 <see cref="T:System.Security.Permissions.FileIOPermission" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime (CLR) 2.0 版或更新版本，且已使用比目前載入之版本更新的 CLR 版本來編譯 <paramref name="assemblyName" />。 請注意，.NET Framework 2.0、3.0 和 3.5 版全部都會使用 CLR 2.0 版。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">提供要搜尋的目錄路徑，並讀取其內容的能力。 相關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型，不論其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱，該檔案包含要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件。</param>
        <param name="typeName">慣用類型的名稱。</param>
        <param name="ignoreCase">
          <see langword="true" /> 指定 <paramref name="typeName" /> 的搜尋不區分大小寫，<see langword="false" /> 指定搜尋區分大小寫。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">物件，使用 <paramref name="bindingAttr" /> 和 <paramref name="args" /> 來搜尋及識別 <paramref name="typeName" /> 建構函式。 如果 <paramref name="binder" /> 為 <see langword="null" />，則會使用預設繫結器。</param>
        <param name="args">引數的陣列，此引數在數目、順序和類型上符合要叫用的建構函式的參數。 如果 <paramref name="args" /> 是空陣列或 <see langword="null" />，會叫用未採用參數的建構函式 (預設的建構函式)。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>使用具名組件檔案和最符合指定參數的建構函式，建立已具有指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值的方法。  
  
 如需其他可能會叫用方法所擲回的例外狀況資訊，請參閱例外狀況區段<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>和<xref:System.Activator.CreateInstance%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">透過反映叫用並擲回例外狀況的建構函式。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有所要求的 <see cref="T:System.Security.Permissions.FileIOPermission" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> 不是空的陣列，而建立中的類型不是衍生自 <see cref="T:System.MarshalByRefObject" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime (CLR) 2.0 版或更新版本，且已使用比目前載入之版本更新的 CLR 版本來編譯 <paramref name="assemblyName" />。 請注意，.NET Framework 2.0、3.0 和 3.5 版全部都會使用 CLR 2.0 版。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">提供要搜尋的目錄路徑，並讀取其內容的能力。 相關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型和成員而不論是否其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">建立名稱為 <paramref name="typeName" /> 之類型的遠端網域。</param>
        <param name="assemblyFile">檔案的名稱，該檔案包含要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件。</param>
        <param name="typeName">慣用類型的名稱。</param>
        <param name="ignoreCase">
          <see langword="true" /> 指定 <paramref name="typeName" /> 的搜尋不區分大小寫，<see langword="false" /> 指定搜尋區分大小寫。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">物件，使用 <paramref name="bindingAttr" /> 和 <paramref name="args" /> 來搜尋及識別 <paramref name="typeName" /> 建構函式。 如果 <paramref name="binder" /> 為 <see langword="null" />，則會使用預設繫結器。</param>
        <param name="args">引數的陣列，此引數在數目、順序和類型上符合要叫用的建構函式的參數。 如果 <paramref name="args" /> 是空陣列或 <see langword="null" />，會叫用未採用參數的建構函式 (預設的建構函式)。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>使用最符合指定參數的具名組件檔案和建構函式，建立已在指定遠端網域中指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Activator.CreateInstanceFrom%2A>主機需要具有限制的安全性權限的應用程式定義域中執行程式碼。  
  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值的方法。  
  
 如需其他可能會叫用方法所擲回的例外狀況資訊，請參閱例外狀況的章節<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>和<xref:System.Activator.CreateInstance%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">透過反映叫用並擲回例外狀況的建構函式。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端具有所要求的 <see cref="T:System.Security.Permissions.FileIOPermission" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> 不是空的陣列，而建立中的類型不是衍生自 <see cref="T:System.MarshalByRefObject" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
 <paramref name="assemblyName" /> 已針對比目前載入版本更新的 Common Language Runtime 進行編譯。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供辨識項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">提供要搜尋的目錄路徑，並讀取其內容的能力。 相關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型和成員而不論是否其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱，該檔案包含要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件。</param>
        <param name="typeName">慣用類型的名稱。</param>
        <param name="ignoreCase">
          <see langword="true" /> 指定 <paramref name="typeName" /> 的搜尋不區分大小寫，<see langword="false" /> 指定搜尋區分大小寫。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">物件，使用 <paramref name="bindingAttr" /> 和 <paramref name="args" /> 來搜尋及識別 <paramref name="typeName" /> 建構函式。 如果 <paramref name="binder" /> 為 <see langword="null" />，則會使用預設繫結器。</param>
        <param name="args">引數的陣列，此引數在數目、順序和類型上符合要叫用的建構函式的參數。 如果 <paramref name="args" /> 是空陣列或 <see langword="null" />，會叫用未採用參數的建構函式 (預設的建構函式)。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <param name="securityInfo">用來執行安全性原則決策和授權程式碼使用權限的資訊。</param>
        <summary>使用具名組件檔案和最符合指定參數的建構函式，建立已具有指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值的方法。  
  
 如需其他可能會叫用方法所擲回的例外狀況資訊，請參閱例外狀況區段<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>和<xref:System.Activator.CreateInstance%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">透過反映叫用並擲回例外狀況的建構函式。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有所要求的 <see cref="T:System.Security.Permissions.FileIOPermission" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> 不是空的陣列，而建立中的類型不是衍生自 <see cref="T:System.MarshalByRefObject" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime (CLR) 2.0 版或更新版本，且已使用比目前載入之版本更新的 CLR 版本來編譯 <paramref name="assemblyName" />。 請注意，.NET Framework 2.0、3.0 和 3.5 版全部都會使用 CLR 2.0 版。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">提供要搜尋的目錄路徑，並讀取其內容的能力。 相關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型和成員而不論是否其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">建立名稱為 <paramref name="typeName" /> 之類型的遠端網域。</param>
        <param name="assemblyFile">檔案的名稱，該檔案包含要在其中搜尋名稱為 <paramref name="typeName" /> 之類型的組件。</param>
        <param name="typeName">慣用類型的名稱。</param>
        <param name="ignoreCase">
          <see langword="true" /> 指定 <paramref name="typeName" /> 的搜尋不區分大小寫，<see langword="false" /> 指定搜尋區分大小寫。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">物件，使用 <paramref name="bindingAttr" /> 和 <paramref name="args" /> 來搜尋及識別 <paramref name="typeName" /> 建構函式。 如果 <paramref name="binder" /> 為 <see langword="null" />，則會使用預設繫結器。</param>
        <param name="args">引數的陣列，此引數在數目、順序和類型上符合要叫用的建構函式的參數。 如果 <paramref name="args" /> 是空陣列或 <see langword="null" />，會叫用未採用參數的建構函式 (預設的建構函式)。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <param name="securityAttributes">用來執行安全性原則決策和授權程式碼使用權限的資訊。</param>
        <summary>使用最符合指定參數的具名組件檔案和建構函式，建立已在指定遠端網域中指定名稱之類型的執行個體。</summary>
        <returns>必須解除包裝的控制代碼，用來存取新建立的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Activator.CreateInstanceFrom%2A>主機需要具有限制的安全性權限的應用程式定義域中執行程式碼。  
  
 使用<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>要未包裝的傳回值的方法。  
  
> [!NOTE]
>  這個方法會使用<xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType>要求必須受到完全信任立即呼叫端。  
  
 如需其他可能會叫用方法所擲回的例外狀況資訊，請參閱例外狀況區段<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>和<xref:System.Activator.CreateInstance%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MemberAccessException">無法建立抽象類別的執行個體，或者這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">透過反映叫用並擲回例外狀況的建構函式。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端具有所要求的 <see cref="T:System.Security.Permissions.FileIOPermission" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> 不是空的陣列，而建立中的類型不是衍生自 <see cref="T:System.MarshalByRefObject" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime (CLR) 2.0 版或更新版本，且已使用比目前載入之版本更新的 CLR 版本來編譯 <paramref name="assemblyName" />。 請注意，.NET Framework 2.0、3.0 和 3.5 版全部都會使用 CLR 2.0 版。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供辨識項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">提供要搜尋的目錄路徑，並讀取其內容的能力。 相關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用來存取非公用類型和成員而不論是否其授權集。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>為已知物件或 XML Web Service 建立 Proxy。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string -&gt; obj" Usage="System.Activator.GetObject (type, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">您要連接的已知物件類型。</param>
        <param name="url">已知物件的 URL。</param>
        <summary>為指定類型和 URL 所指示的已知物件建立 Proxy。</summary>
        <returns>Proxy，指向要求的已知物件所服務的端點。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫以將訊息傳送至遠端物件 proxy。 在 proxy 上呼叫方法之前，會透過網路不傳送任何訊息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 或 <paramref name="url" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> 不是以傳址方式封送處理，也不是介面。</exception>
        <exception cref="T:System.MemberAccessException">這個成員曾被晚期繫結機制叫用過。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string * obj -&gt; obj" Usage="System.Activator.GetObject (type, url, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">您要連接的已知物件類型。</param>
        <param name="url">已知物件的 URL。</param>
        <param name="state">通道特定資料或 <see langword="null" />。</param>
        <summary>為指定類型、URL 和通道資料所指示的已知物件建立 Proxy。</summary>
        <returns>Proxy，指向要求的已知物件所服務的端點。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫以將訊息傳送至遠端物件 proxy。 在 proxy 上呼叫方法之前，會透過網路不傳送任何訊息。  
  
 `state`參數會將資訊傳至通道，並傳遞給<xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 或 <paramref name="url" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> 不是以傳址方式封送處理，也不是介面。</exception>
        <exception cref="T:System.MemberAccessException">這個成員曾被晚期繫結機制叫用過。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Activator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Activator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Activator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="rgszNames">要對應的傳入名稱陣列。</param>
        <param name="cNames">要對應的名稱計數。</param>
        <param name="lcid">用於解譯名稱的地區設定內容。</param>
        <param name="rgDispId">呼叫端配置的陣列，可接收對應於名稱的 ID。</param>
        <summary>將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法用來從 unmanaged 程式碼，存取 managed 的類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Activator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要傳回的類型資訊。</param>
        <param name="lcid">類型資訊的地區設定識別項。</param>
        <param name="ppTInfo">物件，會接收指向所要求之類型資訊物件的指標。</param>
        <summary>擷取物件的類型資訊，可以用來取得介面的類型資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法用來從 unmanaged 程式碼，存取 managed 的類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetTypeInfo`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Activator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">當這個方法傳回時，包含接收物件提供的類型資訊介面數目的位置指標。 這個參數會以未初始化的狀態傳遞。</param>
        <summary>擷取物件提供的類型資訊介面數目 (0 或 1)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法用來從 unmanaged 程式碼，存取 managed 的類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.Invoke">
      <MemberSignature Language="C#" Value="void _Activator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Activator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Activator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">用來識別成員的分派識別項。</param>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="lcid">地區設定內容，用於解譯引數。</param>
        <param name="wFlags">描述呼叫之內容的旗標。</param>
        <param name="pDispParams">指向結構的指標，此結構包含引數陣列、用於具名引數的引數 DISPID 陣列，以及陣列所含項目數目的計數。</param>
        <param name="pVarResult">儲存結果的位置指標。</param>
        <param name="pExcepInfo">包含例外狀況資訊之結構的指標。</param>
        <param name="puArgErr">第一個有錯誤的引數索引。</param>
        <summary>提供物件所公開的屬性和方法的存取權。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法用來從 unmanaged 程式碼，存取 managed 的類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::Invoke`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
  </Members>
</Type>