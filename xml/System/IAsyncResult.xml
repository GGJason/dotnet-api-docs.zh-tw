<Type Name="IAsyncResult" FullName="System.IAsyncResult">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6d58c5d7d0755ba744adb0fc63e586f88a9bd828" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36430903" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IAsyncResult" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IAsyncResult" />
  <TypeSignature Language="DocId" Value="T:System.IAsyncResult" />
  <TypeSignature Language="VB.NET" Value="Public Interface IAsyncResult" />
  <TypeSignature Language="C++ CLI" Value="public interface class IAsyncResult" />
  <TypeSignature Language="F#" Value="type IAsyncResult = interface" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="d154e-101">代表非同步作業的狀態。</span>
      <span class="sxs-lookup">
        <span data-stu-id="d154e-101">Represents the status of an asynchronous operation.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d154e-102"><xref:System.IAsyncResult>介面由類別，其中包含可以以非同步方式運作的方法實作。</span><span class="sxs-lookup"><span data-stu-id="d154e-102">The <xref:System.IAsyncResult> interface is implemented by classes containing methods that can operate asynchronously.</span></span> <span data-ttu-id="d154e-103">它是啟始非同步作業，例如方法的傳回型別<xref:System.IO.FileStream.BeginRead%2A?displayProperty=nameWithType>，並將它傳遞至方法，結束非同步作業，例如<xref:System.IO.FileStream.EndRead%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d154e-103">It is the return type of methods that initiate an asynchronous operation, such as <xref:System.IO.FileStream.BeginRead%2A?displayProperty=nameWithType>, and it is passed to methods that conclude an asynchronous operation, such as <xref:System.IO.FileStream.EndRead%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d154e-104"><xref:System.IAsyncResult> 物件也會傳遞至所叫用方法<xref:System.AsyncCallback>委派的非同步作業完成時。</span><span class="sxs-lookup"><span data-stu-id="d154e-104"><xref:System.IAsyncResult> objects are also passed to methods invoked by <xref:System.AsyncCallback> delegates when an asynchronous operation completes.</span></span>  
  
 <span data-ttu-id="d154e-105">支援的物件<xref:System.IAsyncResult>介面會儲存為非同步作業的狀態資訊，並提供以允許執行緒在作業完成時收到訊號的同步處理物件。</span><span class="sxs-lookup"><span data-stu-id="d154e-105">An object that supports the <xref:System.IAsyncResult> interface stores state information for an asynchronous operation and provides a synchronization object to allow threads to be signaled when the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d154e-106"><xref:System.Runtime.Remoting.Messaging.AsyncResult>類別是實作<xref:System.IAsyncResult>所傳回`BeginInvoke`方法，當您使用委派來以非同步方式呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="d154e-106">The <xref:System.Runtime.Remoting.Messaging.AsyncResult> class is the implementation of <xref:System.IAsyncResult> that is returned by the `BeginInvoke` method when you use a delegate to call a method asynchronously.</span></span>  
  
 <span data-ttu-id="d154e-107">如需詳細的說明，如何<xref:System.IAsyncResult>介面時，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)主題。</span><span class="sxs-lookup"><span data-stu-id="d154e-107">For a detailed description of how the <xref:System.IAsyncResult> interface is used, see the [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) topic.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d154e-108">下列範例示範如何使用<xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A>屬性來取得<xref:System.Threading.WaitHandle>，以及如何等候非同步呼叫的委派。</span><span class="sxs-lookup"><span data-stu-id="d154e-108">The following example demonstrates how to use the <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> property to get a <xref:System.Threading.WaitHandle>, and how to wait for an asynchronous call on a delegate.</span></span> <span data-ttu-id="d154e-109">非同步呼叫完成時， <xref:System.Threading.WaitHandle> 會收到信號，且您可以呼叫 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法來等候它。</span><span class="sxs-lookup"><span data-stu-id="d154e-109">The <xref:System.Threading.WaitHandle> is signaled when the asynchronous call completes, and you can wait for it by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="d154e-110">此範例包含兩個類別： 包含非同步呼叫的方法和類別，其中包含的類別`Main`進行呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="d154e-110">The example consists of two classes: the class that contains the method that is called asynchronously, and the class that contains the `Main` method that makes the call.</span></span>  
  
 <span data-ttu-id="d154e-111">如需詳細資訊和使用委派來以非同步方式呼叫方法的更多範例，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="d154e-111">For more information and more examples of calling methods asynchronously by using delegates, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#3](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/waithandle.cpp#3)]
[!code-csharp[AsyncDelegateExamples#3](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/waithandle.cs#3)]
[!code-vb[AsyncDelegateExamples#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/WaitHandle.vb#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.IAsyncResult.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.IAsyncResult.AsyncState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d154e-112">取得使用者定義的物件，這個物件符合或包含非同步作業的相關資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-112">Gets a user-defined object that qualifies or contains information about an asynchronous operation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d154e-113">使用者定義的物件，這個物件符合或包含非同步作業的相關資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-113">A user-defined object that qualifies or contains information about an asynchronous operation.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d154e-114">這個屬性傳回的方法，來啟始非同步作業的最後一個參數的物件。</span><span class="sxs-lookup"><span data-stu-id="d154e-114">This property returns the object that is the last parameter of the method that initiates an asynchronous operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d154e-115">下列程式碼範例示範如何<xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncState%2A>屬性用來將資訊傳遞至回呼方法。</span><span class="sxs-lookup"><span data-stu-id="d154e-115">The following code example demonstrates how the <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncState%2A> property is used to pass information to a callback method.</span></span> <span data-ttu-id="d154e-116">最後一個參數`BeginInvoke`方法呼叫是格式字串，回呼方法會用它來格式化輸出訊息。</span><span class="sxs-lookup"><span data-stu-id="d154e-116">The last parameter of the `BeginInvoke` method call is a format string, which the callback method uses to format an output message.</span></span>  
  
 <span data-ttu-id="d154e-117">此範例包含兩個類別： 包含非同步呼叫的方法和類別，其中包含的類別`Main`進行呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="d154e-117">The example consists of two classes: the class that contains the method that is called asynchronously, and the class that contains the `Main` method that makes the call.</span></span>  
  
 <span data-ttu-id="d154e-118">此回呼 」 範例的運作方式的詳細資訊和使用委派來以非同步方式呼叫方法的更多範例，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="d154e-118">For more information about how this callback example works, and more examples of calling methods asynchronously by using delegates, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#5](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/callback.cpp#5)]
[!code-csharp[AsyncDelegateExamples#5](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/callback.cs#5)]
[!code-vb[AsyncDelegateExamples#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/callback.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d154e-119">
            <para>實作這個屬性可讓呼叫端，非同步作業的取得作業開始於指定的應用程式定義物件。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-119">
              <para>Implement this property to allow the caller of an asynchronous operation to obtain an application-defined object specified at the start of the operation.</para>
            </span>
          </span>
        </block>
        <block subset="none" type="usage">
          <span data-ttu-id="d154e-120">
            <para>這個物件可以用來將傳遞至非同步作業的狀態資訊<see cref="T:System.AsyncCallback" />您所提供。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-120">
              <para>This object can be used to pass state information for the asynchronous operation to an <see cref="T:System.AsyncCallback" /> that you provide.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.AsyncCallback" />
      </Docs>
    </Member>
    <Member MemberName="AsyncWaitHandle">
      <MemberSignature Language="C#" Value="public System.Threading.WaitHandle AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncWaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::WaitHandle ^ AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncWaitHandle : System.Threading.WaitHandle" Usage="System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d154e-121">取得 <see cref="T:System.Threading.WaitHandle" />，用來等候非同步作業完成。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-121">Gets a <see cref="T:System.Threading.WaitHandle" /> that is used to wait for an asynchronous operation to complete.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d154e-122">
            <see cref="T:System.Threading.WaitHandle" />，用來等候非同步作業完成。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-122">A <see cref="T:System.Threading.WaitHandle" /> that is used to wait for an asynchronous operation to complete.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d154e-123">傳回值可讓用戶端等候的非同步作業完成，而不是輪詢<xref:System.IAsyncResult.IsCompleted%2A>直到結束時，此作業。</span><span class="sxs-lookup"><span data-stu-id="d154e-123">The return value allows the client to wait for an asynchronous operation to complete instead of polling <xref:System.IAsyncResult.IsCompleted%2A> until the operation concludes.</span></span> <span data-ttu-id="d154e-124">傳回值可以用來執行<xref:System.Threading.WaitHandle.WaitOne%2A>， <xref:System.Threading.WaitHandle.WaitAny%2A>，或<xref:System.Threading.WaitHandle.WaitAll%2A>作業。</span><span class="sxs-lookup"><span data-stu-id="d154e-124">The return value can be used to perform a <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A> operation.</span></span>  
  
 <span data-ttu-id="d154e-125">Common language runtime 提供多個可等候物件，例如<xref:System.Threading.ManualResetEvent>， <xref:System.Threading.AutoResetEvent>，和<xref:System.Threading.Mutex>，全部都是鏡像 Win32 同步處理原始物件。</span><span class="sxs-lookup"><span data-stu-id="d154e-125">The common language runtime supplies a number of waitable objects, such as <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.Mutex>, all of which mirror Win32 synchronization primitives.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d154e-126">下列範例示範如何使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性來取得<xref:System.Threading.WaitHandle>，以及如何等候非同步呼叫的委派。</span><span class="sxs-lookup"><span data-stu-id="d154e-126">The following example demonstrates how to use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property to get a <xref:System.Threading.WaitHandle>, and how to wait for an asynchronous call on a delegate.</span></span> <span data-ttu-id="d154e-127">非同步呼叫完成時， <xref:System.Threading.WaitHandle> 會收到信號，且您可以呼叫 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法來等候它。</span><span class="sxs-lookup"><span data-stu-id="d154e-127">The <xref:System.Threading.WaitHandle> is signaled when the asynchronous call completes, and you can wait for it by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="d154e-128">此範例包含兩個類別： 包含非同步呼叫的方法和類別，其中包含的類別`Main`進行呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="d154e-128">The example consists of two classes: the class that contains the method that is called asynchronously, and the class that contains the `Main` method that makes the call.</span></span>  
  
 <span data-ttu-id="d154e-129">如需詳細資訊和使用委派來以非同步方式呼叫方法的更多範例，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="d154e-129">For more information and more examples of calling methods asynchronously by using delegates, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#3](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/waithandle.cpp#3)]
[!code-csharp[AsyncDelegateExamples#3](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/waithandle.cs#3)]
[!code-vb[AsyncDelegateExamples#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/WaitHandle.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d154e-130">
            <para>實作的物件<see cref="T:System.IAsyncResult" />不需要建立<see cref="T:System.Threading.WaitHandle" />直到<see cref="P:System.IAsyncResult.AsyncWaitHandle" />屬性唯讀。它是選擇<see cref="T:System.IAsyncResult" />實作者。不過，如果實作器建立<see cref="P:System.IAsyncResult.AsyncWaitHandle" />，它是實作器發出信號的責任<see cref="T:System.Threading.WaitHandle" />，將會終止在適當的時間等候。例如，<see cref="T:System.Runtime.Remoting.Messaging.AsyncResult" />會以非同步方式叫用的方法傳回時結束代表該呼叫者等候。一旦建立，<see cref="P:System.IAsyncResult.AsyncWaitHandle" />應該保持運作之前在使用者呼叫結束時，非同步作業的方法。時間之後的物件的 at<see cref="P:System.IAsyncResult.AsyncWaitHandle" />可以捨棄。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-130">
              <para>The object that implements <see cref="T:System.IAsyncResult" /> does not need to create the <see cref="T:System.Threading.WaitHandle" /> until the <see cref="P:System.IAsyncResult.AsyncWaitHandle" /> property is read. It is the choice of the <see cref="T:System.IAsyncResult" /> implementer. However, if the implementer creates <see cref="P:System.IAsyncResult.AsyncWaitHandle" />, it is the responsibility of the implementer to signal the <see cref="T:System.Threading.WaitHandle" /> that will terminate the wait at the appropriate time. For example, <see cref="T:System.Runtime.Remoting.Messaging.AsyncResult" /> terminates the wait on behalf of the caller when an asynchronously invoked method returns. Once created, <see cref="P:System.IAsyncResult.AsyncWaitHandle" /> should be kept alive until the user calls the method that concludes the asynchronous operation. At that time the object behind <see cref="P:System.IAsyncResult.AsyncWaitHandle" /> can be discarded.</para>
            </span>
          </span>
        </block>
        <block subset="none" type="usage">
          <span data-ttu-id="d154e-131">
            <para>等待作業完成 （相對於輪詢） 用戶端會使用這個屬性來取得等候同步處理物件。<block subset="none" type="note"><para> 當您使用<see langword="BeginInvoke" />方法的委派，以非同步方式呼叫的方法，並取得從產生的等候控制代碼<see cref="T:System.IAsyncResult" />，我們建議您關閉等候控制代碼，只要使用它，藉由呼叫完畢<see cref="M:System.Threading.WaitHandle.Close" />方法。如果您只需釋放所有等候控制代碼的參考，則會釋放系統資源，當記憶體回收收回等候控制代碼，但明確關閉或處置可處置的物件時，記憶體回收會更有效率。如需詳細資訊，請參閱<see cref="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle" />屬性。  </para></block></para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-131">
              <para>Clients that wait for the operation to complete (as opposed to polling) use this property to obtain a synchronization object to wait on.  <block subset="none" type="note"><para> When you use the <see langword="BeginInvoke" /> method of a delegate to call a method asynchronously and obtain a wait handle from the resulting <see cref="T:System.IAsyncResult" />, we recommend that you close the wait handle as soon as you are finished using it, by calling the <see cref="M:System.Threading.WaitHandle.Close" /> method. If you simply release all references to the wait handle, system resources are freed when garbage collection reclaims the wait handle, but garbage collection works more efficiently when disposable objects are explicitly closed or disposed. For more information, see the <see cref="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle" /> property.  </para></block></para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompletedSynchronously">
      <MemberSignature Language="C#" Value="public bool CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompletedSynchronously As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedSynchronously : bool" Usage="System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d154e-132">取得值，這個值表示非同步作業是否同步完成。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-132">Gets a value that indicates whether the asynchronous operation completed synchronously.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d154e-133">如果非同步作業同步完成，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-133">
              <see langword="true" /> if the asynchronous operation completed synchronously; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d154e-134">同步完成的呼叫中偵測到如果<xref:System.AsyncCallback>委派，它是可能性啟始非同步作業的執行緒目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="d154e-134">If the synchronous completion of the call is detected in the <xref:System.AsyncCallback> delegate, it is probable that the thread that initiated the asynchronous operation is the current thread.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d154e-135">
            <para>大部分的實作者<see cref="T:System.IAsyncResult" />介面不會使用這個屬性，並應該傳回<see langword="false" />。從 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，用來建立工作<see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)" />方法將不會完成未正確實作這個屬性。請參閱 [4.5](~/docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5.md) 中的應用程式相容性。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-135">
              <para>Most implementers of the <see cref="T:System.IAsyncResult" /> interface will not use this property and should return <see langword="false" />. Beginning with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], a task that is created with the <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)" /> method will not complete if this property is not implemented correctly. See [Application Compatibility in 4.5](~/docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5.md).</para>
            </span>
          </span>
        </block>
        <block subset="none" type="usage">
          <span data-ttu-id="d154e-136">
            <para>使用這個屬性來判斷非同步作業是否以同步方式完成。例如，這個屬性可以傳回<see langword="true" />如果這是小型的 I/O 要求的非同步 I/O 作業。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-136">
              <para>Use this property to determine if the asynchronous operation completed synchronously. For example, this property can return <see langword="true" /> for an asynchronous I/O operation if the I/O request was small.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.IAsyncResult.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.IAsyncResult.IsCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d154e-137">取得值，這個值表示非同步作業是否完成。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-137">Gets a value that indicates whether the asynchronous operation has completed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d154e-138">如果作業已完成，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-138">
              <see langword="true" /> if the operation is complete; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d154e-139">當這個屬性是`true`，您可以假設您可以放心捨棄非同步作業所配置使用的任何資源。</span><span class="sxs-lookup"><span data-stu-id="d154e-139">When this property is `true`, you can assume it is safe to discard any resources you allocate for use by the asynchronous operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d154e-140">下列範例示範如何使用<xref:System.IAsyncResult.IsCompleted%2A>屬性<xref:System.IAsyncResult>找出非同步呼叫完成時。</span><span class="sxs-lookup"><span data-stu-id="d154e-140">The following example shows how to use the <xref:System.IAsyncResult.IsCompleted%2A> property of the <xref:System.IAsyncResult> to discover when an asynchronous call completes.</span></span> <span data-ttu-id="d154e-141">在此情況下，非同步呼叫使用`BeginInvoke`委派的方法。</span><span class="sxs-lookup"><span data-stu-id="d154e-141">In this case, the asynchronous call is made by using the `BeginInvoke` method of a delegate.</span></span> <span data-ttu-id="d154e-142">您可能會使用<xref:System.IAsyncResult.IsCompleted%2A>輪詢完成時，進行非同步呼叫的執行緒服務的使用者介面的屬性。</span><span class="sxs-lookup"><span data-stu-id="d154e-142">You might use the <xref:System.IAsyncResult.IsCompleted%2A> property to poll for completion when making the asynchronous call from a thread that services the user interface.</span></span> <span data-ttu-id="d154e-143">輪詢完成這個動作，可在非同步呼叫於 <xref:System.Threading.ThreadPool> 執行緒上執行的同時，讓呼叫執行緒能夠繼續執行。</span><span class="sxs-lookup"><span data-stu-id="d154e-143">Polling for completion allows the calling thread to continue executing while the asynchronous call executes on a <xref:System.Threading.ThreadPool> thread.</span></span>  
  
 <span data-ttu-id="d154e-144">此範例包含兩個類別： 包含非同步呼叫的方法和類別，其中包含的類別`Main`進行呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="d154e-144">The example consists of two classes: the class that contains the method that is called asynchronously, and the class that contains the `Main` method that makes the call.</span></span>  
  
 <span data-ttu-id="d154e-145">如需詳細資訊和使用委派來以非同步方式呼叫方法的更多範例，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="d154e-145">For more information and more examples of calling methods asynchronously by using delegates, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#4](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/polling.cpp#4)]
[!code-csharp[AsyncDelegateExamples#4](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/polling.cs#4)]
[!code-vb[AsyncDelegateExamples#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/polling.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d154e-146">
            <para>實施者通常會傳回私用欄位或內部測試的值做為這個屬性的值。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-146">
              <para>Implementers will typically return the value of a private field or internal test as the value of this property.</para>
            </span>
          </span>
        </block>
        <block subset="none" type="usage">
          <span data-ttu-id="d154e-147">
            <para>輪詢作業狀態 （而不是等待同步處理物件） 的用戶端會使用這個屬性來判斷作業的狀態。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d154e-147">
              <para>Clients that poll for operation status (as opposed to waiting on a synchronization object) use this property to determine the status of the operation.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>