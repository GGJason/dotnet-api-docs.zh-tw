<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="81d3a8e6f1125a524e6327e997dd7eec6ba5840d" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51932501" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示應用程式定義域，也就是應用程式執行的獨立環境。 此類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式定義域，由<xref:System.AppDomain>物件，可協助提供隔離、 卸載和安全性界限執行 managed 程式碼。  
  
-   您可以使用應用程式定義域來隔離可能會使處理序的工作。 如果狀態<xref:System.AppDomain>，正在執行的工作變得不穩定，<xref:System.AppDomain>即可予以卸載而不會影響此程序。 當長時間執行的處理序，必須將它不需要重新啟動時，這很重要。 您也可以使用應用程式定義域來隔離不應共用資料的工作。  
  
-   如果組件載入至預設應用程式定義域時，它不能從記憶體卸載的情況，而處理序正在執行。 不過，如果您開啟以載入和執行組件的第二個應用程式定義域時，組件會卸載該應用程式定義域卸載時。 您可以使用這項技巧來減少有時候使用大型的 Dll 的長時間執行處理序的工作集。  
  
 多個應用程式定義域可以單一處理序中執行;不過，沒有應用程式定義域和執行緒之間的一對一關聯性。 數個執行緒可以隸屬於單一應用程式網域，而且雖然之給定的執行緒並不侷限於單一應用程式網域，在任何時候，執行緒會執行單一應用程式定義域中。  
  
 使用建立應用程式定義域<xref:System.AppDomain.CreateDomain%2A>方法。 <xref:System.AppDomain> 執行個體用來載入和執行組件 (<xref:System.Reflection.Assembly>)。 當<xref:System.AppDomain>已不再使用中，它可以卸載。  
  
 <xref:System.AppDomain>類別會實作一組可讓應用程式在載入組件，應用程式定義域將會卸載，或擲回未處理的例外狀況時回應的事件。  
  
 如需有關如何使用應用程式定義域的詳細資訊，請參閱 <<c0> [ 應用程式定義域](~/docs/framework/app-domains/application-domains.md)。  
  
 這個類別會實作<xref:System.MarshalByRefObject>， <xref:System._AppDomain>，和<xref:System.Security.IEvidenceFactory>介面。  
  
 您應該永遠不會建立可遠端處理包裝函式<xref:System.AppDomain>物件。 如此一來，無法發行的遠端參考<xref:System.AppDomain>，例如公開方法<xref:System.AppDomain.CreateInstance%2A>遠端存取並有效地終結該的 程式碼存取安全性<xref:System.AppDomain>。 惡意用戶端連接到遠端<xref:System.AppDomain>無法存取任何資源<xref:System.AppDomain>本身具有存取權。 不會建立可遠端處理的包裝函式延伸任何型別的<xref:System.MarshalByRefObject>和實作可能遭到惡意用戶端用來略過安全性系統的方法。  
  
> [!CAUTION]
>  預設值<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>屬性是`false`。 此設定是不安全的服務。 若要避免服務下載部分信任程式碼，請將此屬性設定為`true`。  
  
   
  
## Examples  
 此範例示範如何建立新<xref:System.AppDomain>，具現化型別中的新<xref:System.AppDomain>，並與該類型的物件。 此外，此範例示範如何卸載<xref:System.AppDomain>造成要進行記憶體回收的物件。  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">如何： 設定應用程式定義域</related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba">如何： 建立應用程式定義域</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9">如何：將組件載入應用程式定義域</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192">如何：卸載應用程式定義域</related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前應用程式定義域的啟動內容。</summary>
        <value>物件，表示目前應用程式定義域的啟動內容，如果此定義域沒有任何啟動內容，則為 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要附加到私用路徑的目錄名稱。</param>
        <summary>將指定的目錄名稱附加至私用 (Private) 路徑清單。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不建議使用這個屬性，因為它們已經被載入之後，它可能會針對組件變更探查的路徑。 請改用 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> 屬性。  
  
 私用的路徑或相對搜尋路徑是相對於組件解析程式其中探查私用組件的基底目錄路徑。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式定義域中的應用程式之識別。</summary>
        <value>物件，可識別應用程式定義域中的應用程式。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得資訊，以描述授與給應用程式的使用權限，以及該應用程式是否有允許其執行的信任層級。</summary>
        <value>物件，可針對應用程式定義域中的應用程式來封裝使用權限和信任資訊。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱，其格式為 <see cref="P:System.Reflection.Assembly.FullName" /> 屬性所提供。</param>
        <summary>在套用原則之後傳回組件的顯示名稱。</summary>
        <returns>一個字串，其中包含套用原則之後的組件之顯示名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ApplyPolicy%2A>方法會採用組件的顯示名稱，並傳回原則後顯示名稱。 這非常有用，如果您要載入組件使用 「 原則 」，因為僅限反映的內容不會套用原則。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於載入組件時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AssemblyLoadEventHandler>委派這個事件表示哪些組件已載入。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.AssemblyLoad>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於組件解析失敗時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它負責<xref:System.ResolveEventHandler>傳回組件中所指定此事件<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>屬性，或傳回 null，如果無法辨識的組件。 組件必須載入到執行內容;如果載入僅限反映的內容時，會引發這個事件的負載將會失敗。  
  
 如需使用這個事件的指引，請參閱 <<c0> [ 解析組件載入](~/docs/framework/app-domains/resolve-assembly-loads.md)。  
  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性會傳回要求無法解析組件載入的組件。 例如，載入器可能無法載入要求的組件的相依性，因為要求的組件和其相依性不在探查路徑。 了解要求的組件的識別可能有助於在尋找相依性，或找出正確的版本中，如果使用多個版本的相依性。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
> [!IMPORTANT]
>  開頭[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，則<xref:System.ResolveEventHandler>所有組件，包括資源組件都會引發事件。 在舊版中，資源組件不引發事件。 如果當地語系化的作業系統，可能會呼叫處理常式多次： 每個文化特性後援鏈結中的一次。  
  
 對於此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>套用原則之前，屬性會傳回組件名稱。  
  
> [!IMPORTANT]
>  如果此事件註冊一個以上的事件處理常式，事件 handlersarecalled，直到事件處理常式的傳回值的順序，不是`null`。 後續的事件處理常式會被忽略。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a">解析組件載入</related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得組件解析程式 (Resolver) 用來探查組件的基底目錄。</summary>
        <value>組件解析程式用來探查組件的基底目錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性會對應至<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>屬性。 它也可以擷取使用<xref:System.AppDomain.GetData%2A>與字串"APPBASE"的方法。  
  
   
  
## Examples  
 下列程式碼範例會建立新的應用程式定義域，指定要載入定義域時搜尋組件使用的基底目錄。 然後此範例使用<xref:System.AppDomain.BaseDirectory%2A>屬性取得的基底目錄路徑，顯示到主控台。  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑本身中的資訊，包括如果路徑的格式為"file:// 或\\\UNC\dir 或"c:\\"。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將指定私用組件位置的路徑重設為空字串 ("")。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 私用路徑是相對於 common language runtime 會搜尋來尋找私用組件的基底目錄路徑。  
  
 如需詳細資訊，請參閱<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.AppDomain.ClearPrivatePath%2A>方法，以從載入的組件時所要搜尋的私用路徑的清單中移除所有項目。  
  
 此方法現已淘汰，並不應該用於新的開發。  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將含有陰影複製的組件目錄清單重設為空字串 ("")。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 陰影複製路徑是儲存的陰影複製組件的所在的目錄清單。  
  
 如需詳細資訊，請參閱 <<c0> <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> 並[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">陰影複製組件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立指定 COM 型別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">檔案的名稱，此檔案包含定義要求型別的組件。</param>
        <param name="typeName">要求型別的名稱。</param>
        <summary>建立指定 COM 型別的新執行個體。 指定包含組件 (包含型別和型別名稱) 之檔案名稱的參數。</summary>
        <returns>物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法，從遠端建立物件，而不需要載入在本機的型別。  
  
 傳回的值必須解除包裝以存取實際物件。  
  
 A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>屬性的值`true`必須套用明確或預設為 COM 型別，此方法來建立該類型; 的執行個體，否則為<xref:System.TypeLoadException>就會擲回。  
  
   
  
## Examples  
 下列範例會示範  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException">無法載入該型別。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.MissingMethodException">找不到無參數的公用建構函式。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> 是抽象類別。  
  
-或- 
這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.NotSupportedException">呼叫端不可以提供不是繼承自 <see cref="T:System.MarshalByRefObject" /> 的啟動屬性。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" />為空字串 ("")。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.NullReferenceException">所要參考的 COM 物件為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱，此檔案包含定義要求型別的組件。</param>
        <param name="typeName">要求型別的名稱。</param>
        <param name="hashValue">表示計算出來的雜湊碼的值。</param>
        <param name="hashAlgorithm">表示組件資訊清單所使用的雜湊演算法。</param>
        <summary>建立指定 COM 型別的新執行個體。 指定包含組件 (包含型別和型別名稱) 之檔案名稱的參數。</summary>
        <returns>物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法，從遠端建立物件，而不需要載入在本機的型別。  
  
 傳回的值必須解除包裝以存取實際物件。  
  
 A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>屬性的值`true`必須套用明確或預設為 COM 型別，此方法來建立該類型; 的執行個體，否則為<xref:System.TypeLoadException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException">無法載入該型別。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.MissingMethodException">找不到無參數的公用建構函式。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> 是抽象類別。  
  
-或- 
這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.NotSupportedException">呼叫端不可以提供不是繼承自 <see cref="T:System.MarshalByRefObject" /> 的啟動屬性。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 為空字串 ("")。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.NullReferenceException">所要參考的 COM 物件為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新的應用程式定義域。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">定義域的易記名稱。</param>
        <summary>建立具有指定名稱的新應用程式定義域。</summary>
        <returns>新建立的應用程式定義域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `friendlyName`參數要識別網域是讓人有意義的方式。 此字串應該是適合在使用者介面中顯示。  
  
 這個方法多載會使用<xref:System.AppDomainSetup>從預設應用程式定義域的資訊。  
  
   
  
## Examples  
 下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">定義域的易記名稱。 這個易記名稱可以在使用者介面中顯示以識別該定義域。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.FriendlyName" />。</param>
        <param name="securityInfo">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。 傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</param>
        <summary>使用提供的辨識項，建立具有指定名稱的新應用程式定義域。</summary>
        <returns>新建立的應用程式定義域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載會使用<xref:System.AppDomainSetup>從預設應用程式定義域的資訊。  
  
 如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。  
  
> [!IMPORTANT]
>  請勿使用這個方法多載來建立沙箱應用程式定義域。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，所提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱應用程式定義域。  
  
   
  
## Examples  
 下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">定義域的易記名稱。 這個易記名稱可以在使用者介面中顯示以識別該定義域。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.FriendlyName" />。</param>
        <param name="securityInfo">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。 傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</param>
        <param name="info">物件，包含應用程式定義域初始化資訊。</param>
        <summary>使用指定名稱、辨識項和應用程式定義域安裝資訊，建立新的應用程式定義域。</summary>
        <returns>新建立的應用程式定義域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`info`是未提供，這個方法多載會使用<xref:System.AppDomainSetup>從預設應用程式定義域的資訊。  
  
 如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。  
  
> [!IMPORTANT]
>  請勿使用這個方法多載來建立沙箱應用程式定義域。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，所提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱應用程式定義域。  
  
   
  
## Examples  
 下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">定義域的易記名稱。 這個易記名稱可以在使用者介面中顯示以識別該定義域。 如需詳細資訊，請參閱 <see cref="P:System.AppDomain.FriendlyName" /> 的說明。</param>
        <param name="securityInfo">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。 傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</param>
        <param name="info">物件，包含應用程式定義域初始化資訊。</param>
        <param name="grantSet">預設使用權限集合，其授與給載入無特定授權的新應用程式定義域中的所有組件。</param>
        <param name="fullTrustAssemblies">強式名稱的陣列，表示在新的應用程式定義域中視為完全信任的組件。</param>
        <summary>使用指定之名稱、辨識項、應用程式定義域設定資訊、預設使用權限集合及完全信任的組件陣列，建立新的應用程式定義域。</summary>
        <returns>新建立的應用程式定義域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須設定<xref:System.AppDomainSetup.ApplicationBase%2A>的屬性<xref:System.AppDomainSetup>物件，為您提供`info`。 否則，會擲回例外狀況。  
  
 如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。  
  
 提供的資訊`grantSet`並`fullTrustAssemblies`用來建立<xref:System.Security.Policy.ApplicationTrust>新的應用程式定義域的物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">應用程式定義域為 <see langword="null" />。  
  
-或- 
未在提供給 <paramref name="info" /> 的 <see cref="P:System.AppDomainSetup.ApplicationBase" /> 物件上設定 <see cref="T:System.AppDomainSetup" /> 屬性。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立及管理應用程式定義域的能力。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">定義域的易記名稱。 這個易記名稱可以在使用者介面中顯示以識別該定義域。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.FriendlyName" />。</param>
        <param name="securityInfo">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。 傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</param>
        <param name="appBasePath">組件解析程式用來探查組件的基底目錄。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.BaseDirectory" />。</param>
        <param name="appRelativeSearchPath">相對於組件解析程式應該探查私用組件之基底目錄的路徑。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.RelativeSearchPath" />。</param>
        <param name="shadowCopyFiles">如果 <see langword="true" />，則會將組件的陰影複本載入至這個應用程式定義域中。</param>
        <summary>使用辨識項、應用程式基底路徑、相對搜尋路徑和指定是否要將組件的陰影複本載入至應用程式定義域的參數，建立具有指定名稱的新應用程式定義域。</summary>
        <returns>新建立的應用程式定義域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。  
  
 如需陰影複製的詳細資訊，請參閱<xref:System.AppDomain.ShadowCopyFiles%2A>並[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
> [!IMPORTANT]
>  請勿使用這個方法多載來建立沙箱應用程式定義域。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，所提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱應用程式定義域。  
  
   
  
## Examples  
 下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">定義域的易記名稱。 這個易記名稱可以在使用者介面中顯示以識別該定義域。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.FriendlyName" />。</param>
        <param name="securityInfo">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。 傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</param>
        <param name="appBasePath">組件解析程式用來探查組件的基底目錄。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.BaseDirectory" />。</param>
        <param name="appRelativeSearchPath">相對於組件解析程式應該探查私用組件之基底目錄的路徑。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.RelativeSearchPath" />。</param>
        <param name="shadowCopyFiles">
          <see langword="true" /> 表示將組件的陰影複本載入到應用程式定義域中。</param>
        <param name="adInit">
          <see cref="T:System.AppDomainInitializer" /> 委派，表示當初始化新的 <see cref="T:System.AppDomain" /> 物件時所叫用的回呼方法。</param>
        <param name="adInitArgs">當初始化新的 <see cref="T:System.AppDomain" /> 物件時，要傳遞給由 <paramref name="adInit" /> 表示的回呼之字串引數陣列。</param>
        <summary>使用辨識項、應用程式基底路徑、相對搜尋路徑和指定是否要將組件的陰影複本載入至應用程式定義域的參數，建立具有指定名稱的新應用程式定義域。 指定當初始化應用程式定義域時所叫用的回呼方法，以及要傳遞給該回呼方法的字串引數陣列。</summary>
        <returns>新建立的應用程式定義域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所表示之方法`adInit`新建立的應用程式定義域的內容中執行。  
  
 如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。  
  
 如需陰影複製的詳細資訊，請參閱<xref:System.AppDomain.ShadowCopyFiles%2A>並[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
> [!IMPORTANT]
>  請勿使用這個方法多載來建立沙箱應用程式定義域。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，所提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱應用程式定義域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立在指定組件中所定義指定型別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求型別之完整名稱 (包括命名空間，但不包括組件)。</param>
        <summary>建立指定組件中所定義的指定型別的新執行個體。</summary>
        <returns>物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫預設建構函式`typeName`。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。  
  
 嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標上，不是目前的應用程式定義域的應用程式定義域會導致成功的載入目標應用程式定義域中的組件。 由於<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>針對至目前的應用程式定義域載入的組件，common language runtime 會嘗試將組件載入目前的應用程式定義域和負載可能會失敗。 載入至目前的應用程式定義域的組件可能不同於已在不同的兩個應用程式定義域的路徑設定是否先載入的組件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有使用權限來呼叫這個建構函式。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typename" /> 中找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求型別之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="activationAttributes">一個或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>建立指定組件中所定義的指定型別的新執行個體。 參數會指定啟動屬性的陣列。</summary>
        <returns>物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫預設建構函式`typeName`。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。  
  
 嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標上，不是目前的應用程式定義域的應用程式定義域會導致成功的載入目標應用程式定義域中的組件。 由於<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>針對至目前的應用程式定義域載入的組件，common language runtime 會嘗試將組件載入目前的應用程式定義域和負載可能會失敗。 載入至目前的應用程式定義域的組件可能不同於已在不同的兩個應用程式定義域的路徑設定是否先載入的組件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有使用權限來呼叫這個建構函式。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.NotSupportedException">呼叫端不可以提供不是繼承自 <see cref="T:System.MarshalByRefObject" /> 的啟動屬性。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typename" /> 中找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一個或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>建立指定組件中所定義的指定型別的新執行個體。 參數會指定繫結器、繫結旗標、建構函式引數、用來解譯引數的文化特性特定資訊，以及選擇性的啟動屬性。</summary>
        <returns>物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。  
  
 嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標上，不是目前的應用程式定義域的應用程式定義域會導致成功的載入目標應用程式定義域中的組件。 由於<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>針對至目前的應用程式定義域載入的組件，common language runtime 會嘗試將組件載入目前的應用程式定義域和負載可能會失敗。 載入至目前的應用程式定義域的組件可能不同於已在不同的兩個應用程式定義域的路徑設定是否先載入的組件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
 用以編譯 <paramref name="assemblyName" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有使用權限來呼叫這個建構函式。</exception>
        <exception cref="T:System.MissingMethodException">未找到符合的建構函式。</exception>
        <exception cref="T:System.NotSupportedException">呼叫端不可以提供不是繼承自 <see cref="T:System.MarshalByRefObject" /> 的啟動屬性。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typename" /> 中找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一個或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <param name="securityAttributes">用來授權建立 <paramref name="typeName" /> 的資訊。</param>
        <summary>建立指定組件中所定義的指定型別的新執行個體。 參數會指定繫結器 (Binder)、繫結旗標、建構函式引數、用來解譯引數的特定文化特性的資訊、啟動屬性，以及建立型別的授權。</summary>
        <returns>物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。  
  
 嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標上，不是目前的應用程式定義域的應用程式定義域會導致成功的載入目標應用程式定義域中的組件。 由於<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>針對至目前的應用程式定義域載入的組件，common language runtime 會嘗試將組件載入目前的應用程式定義域和負載可能會失敗。 載入至目前的應用程式定義域的組件可能不同於已在不同的兩個應用程式定義域的路徑設定是否先載入的組件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有使用權限來呼叫這個建構函式。</exception>
        <exception cref="T:System.MissingMethodException">未找到符合的建構函式。</exception>
        <exception cref="T:System.NotSupportedException">呼叫端不可以提供不是繼承自 <see cref="T:System.MarshalByRefObject" /> 的啟動屬性。  
  
-或- 
 <paramref name="securityAttributes" /> 不是 <see langword="null" />。 不啟用舊版的 CAS 原則時，<paramref name="securityAttributes" /> 應該是 <see langword="null." />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typename" /> 中找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立指定型別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求型別之完整名稱 (包括命名空間，但不包括組件)。</param>
        <summary>建立指定型別的新執行個體。 參數會指定定義型別所在的組件和型別的名稱。</summary>
        <returns>
          <paramref name="typeName" /> 指定之物件的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 這個方法會呼叫預設建構函式`typeName`。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。 請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。  
  
> [!NOTE]
>  若要呼叫的方法的早期繫結`M`類型的物件`T1`所傳回的<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，方法會進行早期繫結呼叫的型別物件的方法和`T2`組件中`C`以外目前的組件或包含的組件`T1`，組件`C`載入目前的應用程式定義域。 即使早期繫結呼叫，就會發生此載入`T1.M()`的主體中所做<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。 如果目前的網域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的網域稍後嘗試載入組件`C`，負載可能會失敗。  
  
   
  
## Examples  
 下列程式碼範例示範另一個應用程式定義域中執行程式碼最簡單的方式。 此範例會定義名為類別`Worker`繼承自<xref:System.MarshalByRefObject>。 `Worker`類別會定義方法，以顯示其執行所在之應用程式定義域的名稱。 此範例會建立的執行個體`Worker`在預設應用程式定義域和新的應用程式定義域中。  
  
> [!NOTE]
>  包含的組件`Worker`必須載入到兩個應用程式定義域，但它可以載入新的應用程式定義域只存在於其他組件。  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typename" /> 中找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有使用權限來呼叫這個建構函式。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">能夠讀取檔案包含組件資訊清單中，或如果您要建立從模組資訊清單檔以外的類型。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求型別之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="activationAttributes">一個或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>建立指定型別的新執行個體。 參數會指定定義型別所在的組件、型別的名稱和啟動屬性的陣列。</summary>
        <returns>
          <paramref name="typeName" /> 指定之物件的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 這個方法會呼叫預設建構函式`typeName`。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。 請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。  
  
> [!NOTE]
>  若要呼叫的方法的早期繫結`M`類型的物件`T1`所傳回的<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，方法會進行早期繫結呼叫的型別物件的方法和`T2`組件中`C`以外目前的組件或包含的組件`T1`，組件`C`載入目前的應用程式定義域。 即使早期繫結呼叫，就會發生此載入`T1.M()`的主體中所做<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。 如果目前的網域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的網域稍後嘗試載入組件`C`，負載可能會失敗。  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typename" /> 中找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有使用權限來呼叫這個建構函式。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</param>
        <param name="culture">用來控制類型強制的特定文化特性物件。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see langword="CultureInfo" />。</param>
        <param name="activationAttributes">一個或多個屬性的陣列，此屬性可參與啟動過程。 一般來說，就是包含單一 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件的陣列。 會指定啟動遠端物件所需的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>藉由指定是否忽略型別名稱的大小寫、用於選取要建立之型別的繫結屬性和繫結器、建構函式的引數、文化特性，以及啟動屬性，為指定之組件中定義的指定型別，建立新的執行個體。</summary>
        <returns>
          <paramref name="typeName" /> 指定之物件的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。 請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。  
  
> [!NOTE]
>  若要呼叫的方法的早期繫結`M`類型的物件`T1`所傳回的<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，方法會進行早期繫結呼叫的型別物件的方法和`T2`組件中`C`以外目前的組件或包含的組件`T1`，組件`C`載入目前的應用程式定義域。 即使早期繫結呼叫，就會發生此載入`T1.M()`的主體中所做<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。 如果目前的網域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的網域稍後嘗試載入組件`C`，負載可能會失敗。  
  
   
  
## Examples  
 下列範例示範如何使用`ignoreCase`參數。  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到符合的建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typename" /> 中找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有使用權限來呼叫這個建構函式。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
 用以編譯 <paramref name="assemblyName" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</param>
        <param name="culture">用來控制類型強制的特定文化特性物件。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see langword="CultureInfo" />。</param>
        <param name="activationAttributes">一個或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <param name="securityAttributes">用來授權建立 <paramref name="typeName" /> 的資訊。</param>
        <summary>建立指定型別的新執行個體。 參數會指定型別的名稱，以及如何尋找和建立它。</summary>
        <returns>
          <paramref name="typeName" /> 指定之物件的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。 請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。  
  
> [!NOTE]
>  若要呼叫的方法的早期繫結`M`類型的物件`T1`所傳回的<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，方法會進行早期繫結呼叫的型別物件的方法和`T2`組件中`C`以外目前的組件或包含的組件`T1`，組件`C`載入目前的應用程式定義域。 即使早期繫結呼叫，就會發生此載入`T1.M()`的主體中所做<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。 如果目前的網域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的網域稍後嘗試載入組件`C`，負載可能會失敗。  
  
   
  
## Examples  
 下列範例示範如何使用`ignoreCase`參數。  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到符合的建構函式。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typename" /> 中找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有使用權限來呼叫這個建構函式。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立指定組件檔案中所定義的指定型別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱 (包括路徑)，此檔案包含會定義要求之型別的組件。 此組件使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法載入。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求型別之完整名稱 (包括命名空間，但不包括組件)。</param>
        <summary>建立指定組件檔案中所定義的指定型別的新執行個體。</summary>
        <returns>對新執行個體而言是包裝函式的物件，如果沒有找到 <paramref name="typeName" />，則為 <see langword="null" />。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設建構函式`typeName`叫用。  
  
 如需詳細資訊，請參閱 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。  
  
 當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域中，進行呼叫的應用程式定義域以外的執行個體，在目標應用程式定義域中載入的組件時。 不過，如果呼叫的應用程式定義域中執行個體未包裝，以特定方式使用的未包裝的執行個體可能會導致要載入至呼叫的應用程式定義域的組件。 例如，未包裝的執行個體之後，可能會要求其型別資訊，以便呼叫其方法晚期繫結。 當組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。  
  
-   如果另一個版本相同的組件的先前已載入至呼叫的應用程式定義域中，或如果呼叫的應用程式定義域的載入路徑為不同的目標應用程式定義域，例外狀況<xref:System.MissingMethodException>可能會發生。  
  
-   如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>嘗試轉型執行個體時，可能會擲回。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>方法多載來建立目標應用程式定義域中的物件的執行個體，並呼叫其方法。  
  
 此範例會定義`MarshallableExample`類別，可以跨應用程式定義域界限封送處理。 範例會建置目前執行的組件的路徑、 建立目標應用程式定義域，並使用<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>方法多載來載入目標應用程式定義域中的範例組件和建立的執行個體`MarshallableExample`。  
  
> [!NOTE]
>  路徑是在此範例中，絕對路徑，但相對路徑也可以運作，因為<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>方法用來載入組件。  
  
 如果之後解除包裝的物件控制代碼，此範例會示範三種方式可使用目標應用程式定義域中的物件：  
  
-   叫用方法，以使用反映的晚期繫結。 這需要型別資訊，這會導致要載入至呼叫端的應用程式定義域的組件。 （在此範例中，已經載入也是。）  
  
-   呼叫端和被呼叫端知道介面將物件轉型。 如果呼叫的組件或呼叫端和被呼叫端所參考的第三個組件中定義的介面，則呼叫的組件不載入至呼叫端的應用程式定義域。  
  
-   直接呼叫端知道它的型別時，請使用物件。 組件必須載入到呼叫端的應用程式定義域。  
  
 若要避免被呼叫的組件載入至呼叫端的應用程式定義域的另一個方法是呼叫者是衍生自<xref:System.MarshalByRefObject>類別，以及定義可以在目標應用程式定義域中執行的方法。 該方法可以使用反映來檢查目標組件，因為目標組件已載入至目標應用程式定義域。 範例，請參閱<xref:System.AppDomain.DynamicDirectory%2A>屬性。  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typeName" /> 中找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.MissingMethodException">找不到無參數的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有使用權限來呼叫這個建構函式。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyFile" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱 (包括路徑)，此檔案包含會定義要求之型別的組件。 此組件使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法載入。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求型別之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="activationAttributes">一個或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>建立指定組件檔案中所定義的指定型別的新執行個體。</summary>
        <returns>對新執行個體而言是包裝函式的物件，如果沒有找到 <paramref name="typeName" />，則為 <see langword="null" />。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設建構函式`typeName`叫用。  
  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域中，進行呼叫的應用程式定義域以外的執行個體，在目標應用程式定義域中載入的組件時。 不過，如果呼叫的應用程式定義域中執行個體未包裝，以特定方式使用的未包裝的執行個體可能會導致要載入至呼叫的應用程式定義域的組件。 例如，未包裝的執行個體之後，可能會要求其型別資訊，以便呼叫其方法晚期繫結。 當組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。  
  
-   如果另一個版本相同的組件的先前已載入至呼叫的應用程式定義域中，或如果呼叫的應用程式定義域的載入路徑為不同的目標應用程式定義域，例外狀況<xref:System.MissingMethodException>可能會發生。  
  
-   如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>嘗試轉型執行個體時，可能會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typeName" /> 中找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有使用權限來呼叫這個建構函式。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.NotSupportedException">呼叫端不可以提供不是繼承自 <see cref="T:System.MarshalByRefObject" /> 的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyFile" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱 (包括路徑)，此檔案包含會定義要求之型別的組件。 此組件使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法載入。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求型別之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一個或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>建立指定組件檔案中所定義的指定型別的新執行個體。</summary>
        <returns>對新執行個體而言是包裝函式的物件，如果沒有找到 <paramref name="typeName" />，則為 <see langword="null" />。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。  
  
 當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域中，進行呼叫的應用程式定義域以外的執行個體，在目標應用程式定義域中載入的組件時。 不過，如果呼叫的應用程式定義域中執行個體未包裝，以特定方式使用的未包裝的執行個體可能會導致要載入至呼叫的應用程式定義域的組件。 例如，未包裝的執行個體之後，可能會要求其型別資訊，以便呼叫其方法晚期繫結。 當組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。  
  
-   如果另一個版本相同的組件的先前已載入至呼叫的應用程式定義域中，或如果呼叫的應用程式定義域的載入路徑為不同的目標應用程式定義域，例外狀況<xref:System.MissingMethodException>可能會發生。  
  
-   如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>嘗試轉型執行個體時，可能會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">呼叫端不可以提供不是繼承自 <see cref="T:System.MarshalByRefObject" /> 的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typeName" /> 中找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有足以呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
 用以編譯 <paramref name="assemblyFile" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱 (包括路徑)，此檔案包含會定義要求之型別的組件。 此組件使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法載入。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求型別之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一個或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <param name="securityAttributes">用來授權建立 <paramref name="typeName" /> 的資訊。</param>
        <summary>建立指定組件檔案中所定義的指定型別的新執行個體。</summary>
        <returns>對新執行個體而言是包裝函式的物件，如果沒有找到 <paramref name="typeName" />，則為 <see langword="null" />。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域中，進行呼叫的應用程式定義域以外的執行個體，在目標應用程式定義域中載入的組件時。 不過，如果呼叫的應用程式定義域中執行個體未包裝，以特定方式使用的未包裝的執行個體可能會導致要載入至呼叫的應用程式定義域的組件。 例如，未包裝的執行個體之後，可能會要求其型別資訊，以便呼叫其方法晚期繫結。 當組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。  
  
-   如果另一個版本相同的組件的先前已載入至呼叫的應用程式定義域中，或如果呼叫的應用程式定義域的載入路徑為不同的目標應用程式定義域，例外狀況<xref:System.MissingMethodException>可能會發生。  
  
-   如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>嘗試轉型執行個體時，可能會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">呼叫端不可以提供不是繼承自 <see cref="T:System.MarshalByRefObject" /> 的啟動屬性。  
  
-或- 
 <paramref name="securityAttributes" /> 不是 <see langword="null" />。 若未啟用舊版 CAS 原則，<paramref name="securityAttributes" /> 應為 <see langword="null" />。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typeName" /> 中找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有足以呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyFile" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立指定組件檔案中所定義的指定型別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">定義所要求型別之組件的檔名和路徑。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求型別之完整名稱 (包括命名空間，但不包括組件)。</param>
        <summary>建立指定組件檔案中所定義的指定型別的新執行個體。</summary>
        <returns>要求的物件；當找不到 <paramref name="typeName" /> 時，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 這個方法會呼叫預設建構函式`typeName`。  
  
 如需詳細資訊，請參閱 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typeName" /> 中找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到無參數的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有使用權限來呼叫這個建構函式。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">定義所要求型別之組件的檔名和路徑。</param>
        <param name="typeName">所要求型別的完整名稱，包括命名空間，但不包括組件 (請參閱 <see cref="P:System.Type.FullName" /> 屬性)。</param>
        <param name="activationAttributes">一個或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>建立指定組件檔案中所定義的指定型別的新執行個體。</summary>
        <returns>要求的物件；當找不到 <paramref name="typeName" /> 時，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 這個方法會呼叫預設建構函式`typeName`。  
  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">呼叫端不可以提供不是繼承自 <see cref="T:System.MarshalByRefObject" /> 的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typeName" /> 中找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到無參數的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有使用權限來呼叫這個建構函式。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">定義所要求型別之組件的檔名和路徑。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求型別之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一個或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>藉由指定是否忽略型別名稱的大小寫、用於選取要建立之型別的繫結屬性和繫結器、建構函式的引數、文化特性，以及啟動屬性，為指定之組件檔中定義的指定型別，建立新的執行個體。</summary>
        <returns>要求的物件；當找不到 <paramref name="typeName" /> 時，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">呼叫端不可以提供不是繼承自 <see cref="T:System.MarshalByRefObject" /> 的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typeName" /> 中找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有足以呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
 用以編譯 <paramref name="assemblyName" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">定義所要求型別之組件的檔名和路徑。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求型別之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。 如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。 如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一個或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <param name="securityAttributes">用來授權建立 <paramref name="typeName" /> 的資訊。</param>
        <summary>建立指定組件檔案中所定義的指定型別的新執行個體。</summary>
        <returns>要求的物件；當找不到 <paramref name="typeName" /> 時，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">呼叫端不可以提供不是繼承自 <see cref="T:System.MarshalByRefObject" /> 的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="typeName" /> 中找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有足以呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see cref="T:System.Threading.Thread" /> 的目前應用程式定義域。</summary>
        <value>目前的應用程式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會建立新的應用程式定義域。 <xref:System.AppDomain.CurrentDomain%2A>屬性用來取得<xref:System.AppDomain>物件，表示目前的應用程式定義域。 <xref:System.AppDomain.FriendlyName%2A>屬性會提供目前的應用程式定義域，然後在命令列顯示的名稱。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在目前的應用程式定義域中定義動態組件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">提供給動態組件的存取模式。</param>
        <summary>使用指定的名稱和存取模式定義動態組件。</summary>
        <returns>使用指定名稱和存取模式的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
-或- 
<paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">提供給動態組件的存取模式。</param>
        <param name="assemblyAttributes">要套用到組件的可列舉屬性清單，或者如果沒有任何屬性，則是 <see langword="null" />。</param>
        <summary>使用指定的名稱、存取模式及自訂屬性來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法多載來指定將無法正常運作除非建立動態組件時，它們會套用的屬性。 比方說，安全性屬性這類<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果在建立動態組件之後，它們會加入。  
  
 這個方法應只用來定義動態組件中目前的應用程式定義域。 如需有關這項限制的詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 中引進這個方法多載[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立動態組件具有<xref:System.Security.SecurityTransparentAttribute>。 屬性必須指定為陣列的項目<xref:System.Reflection.Emit.CustomAttributeBuilder>物件。  
  
 建立第一個步驟<xref:System.Reflection.Emit.CustomAttributeBuilder>是取得屬性的建構函式。 建構函式沒有任何參數，因此<xref:System.Type.GetConstructor%2A>方法呼叫的空陣列<xref:System.Type>物件，以表示參數的類型。 第二個步驟是將產生<xref:System.Reflection.ConstructorInfo>物件的建構函式<xref:System.Reflection.Emit.CustomAttributeBuilder>類別，以及類型的空陣列<xref:System.Object>來表示引數。  
  
 產生<xref:System.Reflection.Emit.CustomAttributeBuilder>接著會傳遞給<xref:System.AppDomain.DefineDynamicAssembly%2A>做為唯一的項目陣列的方法。  
  
 範例程式碼定義的模組，然後輸入新的動態組件，並接著會顯示組件的屬性。  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
-或- 
<paramref name="name" /> 的 <see langword="Name" /> 屬性以泛空白字元開頭，或者含有斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="evidence">提供給動態組件的辨識項。 此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</param>
        <summary>使用指定的名稱、存取模式和辨識項來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有完全受信任的呼叫端可以提供他們`evidence`定義動態時<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 首先，程式碼範例會嘗試建立的執行個體`MyDynamicType`藉由呼叫<xref:System.AppDomain.CreateInstance%2A>方法具有無效的組件名稱，並攔截產生的例外狀況。  
  
 程式碼範例接著會新增事件處理常式<xref:System.AppDomain.AssemblyResolve>事件，然後再次嘗試建立的執行個體`MyDynamicType`。 在呼叫期間<xref:System.AppDomain.CreateInstance%2A>，則<xref:System.AppDomain.AssemblyResolve>無效的組件都會引發事件。 事件處理常式會建立動態組件，其中包含名為的型別`MyDynamicType`、 提供的類型的無參數建構函式，並傳回新的動態組件。 在呼叫<xref:System.AppDomain.CreateInstance%2A>成功，然後完成的建構函式和`MyDynamicType`在主控台上顯示一則訊息。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
-或- 
<paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存組件的目錄名稱。 如果 <paramref name="dir" /> 為 <see langword="null" />，目錄會預設為目前的目錄。</param>
        <summary>使用指定的名稱、存取模式和儲存目錄來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
-或- 
<paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">提供給動態組件的存取模式。</param>
        <param name="assemblyAttributes">要套用到組件的可列舉屬性清單，或者如果沒有任何屬性，則是 <see langword="null" />。</param>
        <param name="securityContextSource">安全性內容的來源。</param>
        <summary>定義動態組件，這個動態組件具有指定的名稱、存取模式和自訂模式，並且使用指定的來源做為安全性內容。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法多載來指定將無法正常運作除非建立動態組件時，它們會套用的屬性。 比方說，安全性屬性這類<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果在建立動態組件之後，它們會加入。  
  
 這個方法應只用來定義動態組件中目前的應用程式定義域。 如需有關這項限制的詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
-或- 
<paramref name="name" /> 的 <see langword="Name" /> 屬性以泛空白字元開頭，或者含有斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="securityContextSource" /> 的值不是其中一個列舉值。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存組件的目錄名稱。 如果 <paramref name="dir" /> 為 <see langword="null" />，目錄會預設為目前的目錄。</param>
        <param name="evidence">提供給動態組件的辨識項。 此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</param>
        <summary>使用指定的名稱、存取模式、儲存目錄和辨識項來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有完全受信任的呼叫端可以提供他們`evidence`定義動態時<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
-或- 
<paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="requiredPermissions">必要的使用權限要求。</param>
        <param name="optionalPermissions">選擇性的權限要求。</param>
        <param name="refusedPermissions">拒絕的使用權限要求。</param>
        <summary>使用指定的名稱、存取模式和使用權限要求來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不會使用，除非已儲存並重新載入到記憶體的動態組件。 若要指定不會儲存到磁碟，請使用的多載的暫時性組件的權限要求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，也會為要求的權限，並提供為指定的辨識項<xref:System.Security.Policy.Evidence>物件。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
-或- 
<paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存動態組件的目錄名稱。 如果 <paramref name="dir" /> 是 <see langword="null" />，就會使用目前的目錄。</param>
        <param name="isSynchronized">若要在動態組件中同步 (Synchronize) 建立模組、型別和成員，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <param name="assemblyAttributes">要套用到組件的可列舉屬性清單，或者如果沒有任何屬性，則是 <see langword="null" />。</param>
        <summary>使用指定的名稱、存取模式、儲存目錄和同步處理選項來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法多載來指定將無法正常運作除非建立動態組件時，它們會套用的屬性。 比方說，安全性屬性這類<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果在建立動態組件之後，它們會加入。  
  
 如果`isSynchronized`是`true`，下列方法產生<xref:System.Reflection.Emit.AssemblyBuilder>將會同步處理： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 其中兩種方法會呼叫不同的執行緒上，如果其中一個會封鎖直到另完成為止。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
-或- 
<paramref name="name" /> 的 <see langword="Name" /> 屬性以泛空白字元開頭，或者含有斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="evidence">提供給動態組件的辨識項。 此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</param>
        <param name="requiredPermissions">必要的權限要求。</param>
        <param name="optionalPermissions">選擇性的權限要求。</param>
        <param name="refusedPermissions">拒絕的使用權限要求。</param>
        <summary>使用指定的名稱、存取模式、辨識項和使用權限要求來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，並`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，而且重新載入到記憶體。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`。 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 只有完全受信任的呼叫端可以提供他們`evidence`定義動態時<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
-或- 
<paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存組件的目錄名稱。 如果 <paramref name="dir" /> 為 <see langword="null" />，目錄會預設為目前的目錄。</param>
        <param name="requiredPermissions">必要的使用權限要求。</param>
        <param name="optionalPermissions">選擇性的權限要求。</param>
        <param name="refusedPermissions">拒絕的使用權限要求。</param>
        <summary>使用指定的名稱、存取模式、儲存目錄和使用權限要求來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不會使用，除非已儲存並重新載入到記憶體的動態組件。 若要指定不會儲存到磁碟，請使用的多載的暫時性組件的權限要求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，也會為要求的權限，並提供為指定的辨識項<xref:System.Security.Policy.Evidence>物件。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
-或- 
<paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存組件的目錄名稱。 如果 <paramref name="dir" /> 為 <see langword="null" />，目錄會預設為目前的目錄。</param>
        <param name="evidence">提供給動態組件的辨識項。 此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</param>
        <param name="requiredPermissions">必要的權限要求。</param>
        <param name="optionalPermissions">選擇性的權限要求。</param>
        <param name="refusedPermissions">拒絕的使用權限要求。</param>
        <summary>使用指定的名稱、存取模式、儲存目錄、辨識項和使用權限要求來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，並`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，而且重新載入到記憶體。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`。 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 只有完全受信任的呼叫端可以提供他們`evidence`定義動態時<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
-或- 
<paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存動態組件的目錄名稱。 如果 <paramref name="dir" /> 為 <see langword="null" />，目錄會預設為目前的目錄。</param>
        <param name="evidence">提供給動態組件的辨識項。 此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</param>
        <param name="requiredPermissions">必要的權限要求。</param>
        <param name="optionalPermissions">選擇性的權限要求。</param>
        <param name="refusedPermissions">拒絕的使用權限要求。</param>
        <param name="isSynchronized">若要在動態組件中同步 (Synchronize) 建立模組、型別和成員，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>使用指定的名稱、存取模式、儲存目錄、辨識項、使用權限要求和同步選項來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，並`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，而且重新載入到記憶體。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`。 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 只有完全受信任的呼叫端可以提供其辨識項，當定義動態<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。 部分信任的呼叫端必須提供`null`針對`evidence`參數。 如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 如果`isSynchronized`是`true`，下列方法產生<xref:System.Reflection.Emit.AssemblyBuilder>將會同步處理： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 如果這些方法的兩個不同的執行緒上呼叫，其中將會封鎖其他作業完成之前。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
-或- 
<paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存動態組件的目錄名稱。 如果 <paramref name="dir" /> 是 <see langword="null" />，就會使用目前的目錄。</param>
        <param name="evidence">提供給動態組件的辨識項。 此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</param>
        <param name="requiredPermissions">必要的權限要求。</param>
        <param name="optionalPermissions">選擇性的權限要求。</param>
        <param name="refusedPermissions">拒絕的使用權限要求。</param>
        <param name="isSynchronized">若要在動態組件中同步 (Synchronize) 建立模組、型別和成員，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <param name="assemblyAttributes">要套用到組件的可列舉屬性清單，或者如果沒有任何屬性，則是 <see langword="null" />。</param>
        <summary>使用指定的名稱、存取模式、儲存目錄、辨識項、使用權限要求、同步選項及自訂屬性來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法多載來指定將無法正常運作除非建立動態組件時，它們會套用的屬性。 比方說，安全性屬性這類<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果在建立動態組件之後，它們會加入。  
  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，並`refusedPermissions`才會使用的參數`evidence`也提供參數，或如果儲存動態組件，而且重新載入到記憶體。  
  
> [!NOTE]
>  當您開發可發出動態組件的程式碼時，我們建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>加上旗標在`refusedPermissions`參數。 此旗標包含確保的 Microsoft intermediate language (MSIL) 會進行驗證。 這項技術會偵測到意外產生無法驗證的程式碼，否則這是非常難以偵測。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 只有完全受信任的呼叫端可以提供辨識項，當定義動態<xref:System.Reflection.Assembly>。 執行階段對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。 部分信任的呼叫端必須提供`null`針對`evidence`參數。 如果`evidence`是`null`，執行階段將 （也就是，目前的授與和拒絕集） 的權限集合從呼叫者的組件複製到的動態組件所定義，且標示為已解決的原則。  
  
 如果動態組件會儲存至磁碟，則後續載入會根據儲存動態組件的位置與相關聯的原則授與。  
  
 如果`isSynchronized`是`true`，下列方法產生<xref:System.Reflection.Emit.AssemblyBuilder>將會同步處理： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 其中兩種方法會呼叫不同的執行緒上，如果其中一個會封鎖直到另完成為止。  
  
 中引進這個方法多載[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
-或- 
<paramref name="name" /> 的 <see langword="Name" /> 屬性以泛空白字元開頭，或者含有斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">指定呼叫方法的委派。</param>
        <summary>在指定的委派所識別的其他應用程式定義域中執行程式碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` 可以封送處理為傳值方式指定， <xref:System.MarshalByRefObject>，或<xref:System.ContextBoundObject>。  
  
   
  
## Examples  
 下列範例示範如何使用靜態<xref:System.AppDomain.DoCallBack%2A>方法。  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 下列範例示範如何使用<xref:System.AppDomain.DoCallBack%2A>值的方法。  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 下列範例示範如何使用<xref:System.AppDomain.DoCallBack%2A>所參考的方法。  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得在已經初始化應用程式定義域時，由主應用程式提供的定義域管理員。</summary>
        <value>物件，表示在已經初始化應用程式定義域時，由主應用程式提供的定義域管理員；如果未提供任何定義域管理員，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 受管理的主機，common language runtime (CLR) 可以提供網域管理員。 可以初始化新的應用程式定義域中參與的定義域管理員，並將其提供其他管理員中，例如<xref:System.Security.HostSecurityManager>，參與的應用程式定義域的作業。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於將要卸載 <see cref="T:System.AppDomain" /> 時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler>委派為這個事件可以在應用程式網域卸載之前執行任何終止活動。  
  
 每個應用程式定義域必須執行處理卸載時應該註冊這個事件的事件處理常式。 共用的事件處理常式應該不使用，因為<xref:System.EventHandler>委派不會識別正在卸載的網域。  
  
> [!NOTE]
>  預設應用程式定義域中永遠不會引發這個事件。  
  
 請勿在執行緒引發事件的相關假設。 可以在不同的執行緒以外的呼叫引發事件<xref:System.AppDomain.Unload%2A>方法。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得組件解析程式用來探查動態建立之組件的目錄。</summary>
        <value>組件解析程式用來探查以動態建立組件的目錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要設定的動態的目錄，將指定的基底目錄路徑<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>屬性<xref:System.AppDomainSetup>會用以建立新的應用程式定義域的物件。 修改指派給屬性的基底目錄路徑的簡單名稱是指派給字串的雜湊程式碼子目錄<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>屬性，所以基底目錄格式*原始路徑* \\*雜湊碼*。 此基底目錄的子目錄動態的目錄。 其簡單的名稱是值<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>屬性，因此它的格式*原始路徑*\\*雜湊碼*\\*應用程式名稱*。  
  
   
  
## Examples  
 下列範例與目錄的應用程式定義域建立動態組件的、 發出動態組件和將它儲存在動態的目錄中，將組件載入新的應用程式定義域然後使用它。  
  
 此範例會建立<xref:System.AppDomainSetup>物件以及設定其<xref:System.AppDomainSetup.ApplicationName%2A>"Example"的屬性並將其<xref:System.AppDomainSetup.DynamicBase%2A>"C:\DynamicAssemblyDir"的屬性。 此範例接著會顯示<xref:System.AppDomainSetup.DynamicBase%2A>屬性，以顯示應用程式名稱的雜湊碼，已附加為原本指派路徑的子目錄。  
  
> [!NOTE]
>  在此範例中的基底目錄就是要探查路徑外部的範例應用程式。 請務必在編譯中的不同位置的範例。 刪除的基底目錄及其所有子目錄每次執行此範例的資訊。  
  
 此範例會建立新的應用程式定義域中，使用<xref:System.AppDomainSetup>物件。 此範例會使用<xref:System.AppDomain.DynamicDirectory%2A>屬性，以擷取目錄的名稱，因此它可以建立該目錄。 （此範例可以輕鬆地建立目錄事先藉由串連的原始路徑，應用程式名稱，而應用程式名稱的雜湊碼。）  
  
 此範例包含 `GenerateDynamicAssembly`方法，會發出名為組件`DynamicHelloWorld.dll`並將它儲存在新的應用程式定義域的動態目錄中。 動態組件包含一種類型， `HelloWorld`，，有一個靜態方法 (`Shared`方法，在 Visual Basic 中的) 名為`HelloFromAD`。 呼叫這個方法會顯示應用程式定義域的名稱。  
  
 `Example`類別衍生自<xref:System.MarshalByRefObject>，因此範例可以建立類別的執行個體，在新的應用程式定義域，並呼叫其`Test`方法。 `Test`方法會依其顯示名稱載入的動態組件，並呼叫靜態`HelloFromAD`方法。  
  
 您可以顯示的動態目錄搜尋一般探查路徑之後，撰寫程式碼組件名為`DynamicHelloWorld.dll`和編譯此範例中的相同目錄中。 組件必須具有一個名為類別`HelloWorld`靜態方法，名為`HelloFromAD`。 這個方法不需要有相同的功能與在範例中，它只可以在主控台中顯示的字串。 組件也必須<xref:System.Reflection.AssemblyVersionAttribute>將它的版本設定為 1.0.0.0 的屬性。 當您執行範例時，才能動態的目錄中搜尋找到您編譯目前目錄中的組件。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取的路徑資訊。 關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與此應用程式定義域相關聯的 <see cref="T:System.Security.Policy.Evidence" />。</summary>
        <value>與此應用程式定義域相關聯的辨識項。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>執行包含在指定檔案中的組件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要執行之組件的檔案名稱。</param>
        <summary>執行包含在指定檔案中的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
 若要建立<xref:System.AppDomain>載入並執行，請使用<xref:System.AppDomain.CreateDomain%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyFile" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件沒有進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要執行之組件的檔案名稱。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <summary>使用指定的辨識項，執行包含在指定檔案中的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 <xref:System.AppDomain.ExecuteAssembly%2A>方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyFile" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件沒有進入點。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要執行之組件的檔案名稱。</param>
        <param name="args">組件的進入點引數。</param>
        <summary>使用指定的引數，執行包含在指定檔案中的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
 <paramref name="assemblyFile" /> 已採用比目前載入版本更新的 Common Language Runtime 進行編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件沒有進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要執行之組件的檔案名稱。</param>
        <param name="assemblySecurity">組件的提供辨識項。</param>
        <param name="args">組件的進入點引數。</param>
        <summary>使用指定的辨識項和引數，執行包含在指定檔案中的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyFile" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> 不是 <see langword="null" />。 不啟用舊版的 CAS 原則時，<paramref name="assemblySecurity" /> 應該是 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件沒有進入點。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要執行之組件的檔案名稱。</param>
        <param name="args">組件的進入點引數。</param>
        <param name="hashValue">表示計算出來的雜湊碼的值。</param>
        <param name="hashAlgorithm">表示組件資訊清單所使用的雜湊演算法。</param>
        <summary>使用指定的引數、雜湊值和雜湊演算法，執行包含在指定檔案中的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
 <paramref name="assemblyFile" /> 已採用比目前載入版本更新的 Common Language Runtime 進行編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件沒有進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要執行之組件的檔案名稱。</param>
        <param name="assemblySecurity">組件的提供辨識項。</param>
        <param name="args">組件的進入點引數。</param>
        <param name="hashValue">表示計算出來的雜湊碼的值。</param>
        <param name="hashAlgorithm">表示組件資訊清單所使用的雜湊演算法。</param>
        <summary>使用指定的辨識項、引數、雜湊值和雜湊演算法，執行包含在指定檔案中的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 ︰ 範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyFile" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> 不是 <see langword="null" />。 不啟用舊版的 CAS 原則時，<paramref name="assemblySecurity" /> 應該是 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件沒有進入點。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>執行組件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <summary>執行組件，需提供其顯示名稱。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 若要建立<xref:System.AppDomain>載入並執行，請使用<xref:System.AppDomain.CreateDomain%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 <paramref name="assemblyName" /> 指定的組件。</exception>
        <exception cref="T:System.BadImageFormatException">由 <paramref name="assemblyName" /> 指定的組件不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyName" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">找到由 <paramref name="assemblyName" /> 指定的組件，不過無法載入。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件沒有進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <see cref="T:System.Reflection.AssemblyName" /> 物件，表示組件的名稱。</param>
        <param name="args">啟動處理序時要傳遞的命令列引數。</param>
        <summary>使用指定的引數，執行具有指定之 <see cref="T:System.Reflection.AssemblyName" /> 的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 <paramref name="assemblyName" /> 指定的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 所指定的組件不是有效的組件。  
  
-或- 
 <paramref name="assemblyName" /> 已採用比目前載入版本更新的 Common Language Runtime 進行編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件沒有進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <summary>使用指定之辨識項，在有提供組件的顯示名稱之條件下執行這個組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
> [!NOTE]
>  當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。 做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代的辨識項載入器所提供的片段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 <paramref name="assemblyName" /> 指定的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 所指定的組件不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyName" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件沒有進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="args">啟動處理序時要傳遞的命令列引數。</param>
        <summary>使用指定的引數，執行具有指定之顯示名稱的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 <paramref name="assemblyName" /> 指定的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 所指定的組件不是有效的組件。  
  
-或- 
 <paramref name="assemblyName" /> 已採用比目前載入版本更新的 Common Language Runtime 進行編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件沒有進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <see cref="T:System.Reflection.AssemblyName" /> 物件，表示組件的名稱。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <param name="args">啟動處理序時要傳遞的命令列引數。</param>
        <summary>使用指定之辨識項和引數，在有提供 <see cref="T:System.Reflection.AssemblyName" /> 的條件下執行組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
> [!NOTE]
>  當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。 做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代的辨識項載入器所提供的片段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 <paramref name="assemblyName" /> 指定的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 所指定的組件不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyName" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> 不是 <see langword="null" />。 不啟用舊版的 CAS 原則時，<paramref name="assemblySecurity" /> 應該是 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件沒有進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <param name="args">啟動處理序時要傳遞的命令列引數。</param>
        <summary>使用指定之辨識項和引數，在有提供組件的顯示名稱之條件下執行該組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
> [!NOTE]
>  當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。 做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代的辨識項載入器所提供的片段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 <paramref name="assemblyName" /> 指定的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 所指定的組件不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyName" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> 不是 <see langword="null" />。 不啟用舊版的 CAS 原則時，<paramref name="assemblySecurity" /> 應該是 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件沒有進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當執行階段在呼叫堆疊中搜尋應用程式定義域的例外處理常式之前，在 Managed 程式碼中擲回例外狀況時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件是只有通知。 處理這個事件不會處理例外狀況或會影響後續的例外狀況以任何方式處理。 在引發事件，並已叫用事件處理常式之後，common language runtime (CLR) 會開始搜尋例外狀況處理常式。 <xref:System.AppDomain.FirstChanceException> 第一個有機會檢查任何 managed 例外狀況可讓應用程式定義域。  
  
 每個應用程式網域，就可以處理事件。 如果執行緒會透過多個應用程式定義域傳遞執行呼叫時，CLR 可讓您開始搜尋應用程式定義域中相符的例外狀況處理常式之前，已註冊的事件處理常式中，每個應用程式定義域中引發事件。 在處理事件之後，搜尋會將相符的例外狀況處理常式，該應用程式定義域中。 如果找不到，就會在下一步 的應用程式定義域引發事件。  
  
 您必須處理所有例外狀況發生在事件處理常式<xref:System.AppDomain.FirstChanceException>事件。 否則，<xref:System.AppDomain.FirstChanceException>是遞迴引發。 這可能會導致堆疊溢位和應用程式終止。 我們建議您為限制的執行區域 (Cer)，實作此事件的事件處理常式，以防止基礎結構相關例外狀況，例如記憶體不足或堆疊溢位例外狀況通知時，會影響虛擬機器正在處理中。  
  
 此事件不會引發例外狀況，表示損毀的程序的狀態，例如存取違規，除非事件處理常式上為安全性關鍵，而且有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>屬性。  
  
 正在處理此通知事件時，common language runtime 會暫止執行緒中止。  
  
   
  
## Examples  
 下列範例會建立一系列具名的應用程式定義域`AD0`經由`AD3`，使用`Worker`每個應用程式定義域中的物件。 每個`Worker`物件具有的參考`Worker`物件在下一步 的應用程式網域中，除了`Worker`最後一個應用程式定義域中。 <xref:System.AppDomain.FirstChanceException>以外的所有應用程式定義域中處理事件`AD1`。  
  
> [!NOTE]
>  除了此範例中，示範多個應用程式定義域中的第一個可能的例外狀況通知，您可以找到簡單使用案例[如何： 接收 First-chance 例外狀況通知](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)。  
  
 預設應用程式定義域時已建立的應用程式定義域，呼叫`TestException`第一個應用程式定義域的方法。 每個`Worker`物件會呼叫`TestException`方法下, 一步 的應用程式定義域，直到最後一個`Worker`會擲回例外狀況處理或未處理的。 因此，目前的執行緒通過所有的應用程式定義域中，和`TestException`新增到每個應用程式定義域中的堆疊。  
  
 當上次`Worker`物件會處理例外狀況，<xref:System.AppDomain.FirstChanceException>只有在最後一個應用程式定義域引發事件。 其他的應用程式定義域永遠不會有機會處理例外狀況，因此不會引發事件。  
  
 當上次`Worker`物件不會處理例外狀況，<xref:System.AppDomain.FirstChanceException>每個應用程式在網域中，事件處理常式就會引發事件。 每個事件處理常式已完成之後，堆疊會繼續回溯直到預設應用程式定義域所捕捉的例外狀況。  
  
> [!NOTE]
>  若要查看如何堆疊顯示隨著接近引發事件，並使其更接近預設應用程式定義域，變更`e.Exception.Message`要`e.Exception`在`FirstChanceHandler`事件處理常式。 請注意，當`TestException`稱為跨應用程式定義域界限，它會出現兩次： 一次的 proxy，一次虛設常式。  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113">如何：接收第一個可能發生的例外狀況通知</related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式定義域的易記名稱。</summary>
        <value>這個應用程式定義域的易記名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設應用程式定義域的易記名稱是可執行檔的程序的檔案名稱。 例如，用來啟動處理程序的可執行檔是否`"c:\MyAppDirectory\MyAssembly.exe"`，預設應用程式定義域的易記名稱是`"MyAssembly.exe"`。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.AppDomain.FriendlyName%2A>屬性來取得目前的應用程式定義域的易記名稱。 預設應用程式定義域的易記名稱會是應用程式的可執行檔的名稱。 在程式碼範例也會顯示應用程式定義域的其他資訊。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得已載入至這個應用程式定義域之執行內容的組件。</summary>
        <returns>這個應用程式定義域中的組件陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例使用<xref:System.AppDomain.GetAssemblies%2A>方法來取得已載入至應用程式定義域的所有組件清單。 組件隨即顯示到主控台。  
  
 若要執行此程式碼範例，您需要建立名為組件`CustomLibrary.dll`，或變更組件名稱傳遞給<xref:System.AppDomain.GetAssemblies%2A>方法。  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得目前的執行緒識別項。</summary>
        <returns>32 位元帶正負號的整數 (Signed Integer)，其為目前執行緒的識別項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>屬性，這是穩定甚至當.NET Framework 由裝載環境能支援 fiber （也就是輕量型執行緒）。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫這個方法。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">預先定義的應用程式定義域屬性的名稱，或是已經定義的應用程式定義域屬性的名稱。</param>
        <summary>針對指定之名稱取得儲存在目前應用程式定義域中的值。</summary>
        <returns>
          <paramref name="name" /> 屬性的值，如果這個屬性不存在則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來擷取值的描述屬性的這個執行個體的名稱資料組的內部快取中的項目<xref:System.AppDomain>。 請注意，比較`name`索引鍵 / 值組的名稱會區分大小寫。  
  
 快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。 您可以查看其值與<xref:System.AppDomain.GetData%2A>方法或對等項目<xref:System.AppDomainSetup>屬性。  
  
 您可以插入或修改您自己的使用者定義名稱資料組，而且<xref:System.AppDomain.SetData%2A>方法，並檢查其值與<xref:System.AppDomain.GetData%2A>方法。  
  
 下表描述`name`每個預先定義的系統項目和其對應<xref:System.AppDomainSetup>屬性。  
  
|'Name' 的值|屬性|  
|---------------------|--------------|  
|「 APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|「 APP_LAUNCH_URL"|（沒有內容）<br /><br /> 「 APP_LAUNCH_URL"表示原先要求的使用者之前任何重新導向, 的 URL。 它位於已啟動應用程式，例如 Internet Explorer 的瀏覽器時，才。 並非所有瀏覽器提供此值。|  
|「 APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|「 BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|「 CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|「 CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|「 DEV_PATH"|（沒有內容）|  
|「 DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|「 DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|「 FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|「 LICENSE_FILE"或特定應用程式的字串|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|「 LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|「 LOCATION_URI"|（沒有內容）|  
|「 PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> 「 REGEX_DEFAULT_MATCH_TIMEOUT"不是系統項目和它的值可以藉由呼叫設定<xref:System.AppDomain.SetData%2A>方法。|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 下列範例會建立新的應用程式定義域、 設定的網域中，系統提供值，並將新的值組的網域。 下列範例示範如何使用<xref:System.AppDomain.GetData%2A>方法來擷取這些值組中的資料，並對主控台顯示它們。  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑本身，如果此屬性會套用至路徑中的資訊。 關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得目前執行個體的型別。</summary>
        <returns>目前執行個體的型別。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可唯一識別處理序中之應用程式定義域的整數。</summary>
        <value>可識別應用程式定義域的整數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會建立第二個應用程式定義域，並顯示相關的預設網域和新的網域資訊。  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>藉由防止建立使用期 (Lease) 來為 <see cref="T:System.AppDomain" /> 提供無限的存留期。</summary>
        <returns>一定是 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要測試的相容性參數。</param>
        <summary>取得可為 Null 的布林值，這個值表示是否已設定任何相容性參數，如果是的話，是否已設定指定的相容性參數。</summary>
        <returns>如果未設定任何相容性參數則為 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，否則為布林值，以表示是否已設定 <paramref name="value" /> 所指定之相容性參數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會測試是否已指定相容性參數設定為目前的應用程式定義域。 相容性參數通常還原行為 （例如排序方式字串） 的.NET framework 版本之間已變更。  它們由呼叫設定<xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType>方法，然後再建立應用程式定義域。  
  
 下表提供可以設定以還原舊版的.NET framework 的行為的相容性參數的範例。  
  
|參數|意義|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|程式碼存取安全性 (CAS)[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]啟用此應用程式定義域中。 請參閱[ &lt;NetFx40_LegacySecurityPolicy&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)。|  
|"NetFx40_Legacy20SortingBehavior"|排序的預設值的字串[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]這個應用程式定義域中已啟用。 它的成功需要 sort00001000.dll 安裝。 請參閱[ &lt;CompatSortNLSVersion&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)。|  
|"NetFx40_Legacy40SortingBehavior"|排序的預設值的字串[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和 Unicode 5.0 會啟用此應用程式定義域中。 它的成功需要 sort00060101.dll 安裝。|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> 格式化行為的[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]啟用此應用程式定義域中。  請參閱[ &lt;TimeSpan_LegacyFormatMode&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)和 「 還原舊版 TimeSpan 格式化 」 一節的<xref:System.TimeSpan>主題。|  
|"UseRandomizedStringHashAlgorithm"|執行階段計算字串的雜湊碼在每個應用程式定義域為基準，而不是使用單一的雜湊演算法可跨應用程式定義域產生一致雜湊碼。 請參閱[ &lt;UseRandomizedStringHashAlgorithm&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，指出應用程式定義域是否為該處理序的預設應用程式定義域。</summary>
        <returns>如果目前的 <see cref="T:System.AppDomain" /> 物件代表處理程序的預設應用程式定義域，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個受管理的程序具有預設應用程式定義域。 在 預設網域，開始執行。  
  
   
  
## Examples  
 下列程式碼範例會建立第二個應用程式定義域，並顯示相關的預設網域和新的網域資訊。  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示這個應用程式定義域是否正在卸載，以及其包含的物件是否正在由 Common Language Runtime 加以最終處理。</summary>
        <returns>如果這個應用程式定義域正在卸載且 Common Language Runtime 已開始叫用完成項，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 物件的最終處理方法會提供物件的記憶體回收之前執行任何必要的清除作業的機會。 在最終處理之後, 此物件會為可存取，但處於無效狀態，因此無法使用。 最後，記憶體回收完成，並回收物件。  
  
 在下列情況的其中一個呼叫物件的完成項方法： 記憶體回收期間，當正在關閉通用語言執行平台，或包含物件的應用程式定義域卸載時。 <xref:System.AppDomain.IsFinalizingForUnload%2A>方法會傳回`true`只有在最後一個案例中; 它不會傳回`true`當最終處理的結果從例行回收或 CLR 關閉。  
  
> [!NOTE]
>  若要判斷是否因為 CLR 關閉，所以最終處理，請使用<xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType>屬性。 它會傳回`true`最終處理是否因為應用程式定義域正在卸載或 clr 正在關閉。  
  
 同時在您完成的方法執行期間定義域卸載，您可能想要存取靜態欄位所參考，且具有最終處理方法的另一個物件。 不過，您無法可靠地執行，因為存取的物件可能會有已經結束。  
  
> [!NOTE]
>  此規則的例外是<xref:System.Console>類別，其中包含參考資料流物件的靜態欄位，但您可以一律，即使在網域卸載或系統關機期間寫入系統主控台中，因此，特別實作。  
  
 物件的完成項方法中使用這個方法，以判斷是否包含物件的應用程式定義域正在卸載。 如果是這樣，您無法可靠地存取具有完成項方法，並且由靜態欄位參考的任何物件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，該值指出載入至目前應用程式定義域中的組件是否在完全信任情況下執行。</summary>
        <value>如果載入目前應用程式定義域中的組件在完全信任情況下執行，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法永遠傳回`true`桌面上執行的應用程式的預設應用程式定義域。 它會傳回`false`，利用所建立的沙箱化應用程式網域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載，除非應用程式定義域授與的權限相當於完全信任。  
  
   
  
## Examples  
 下列範例示範<xref:System.AppDomain.IsFullyTrusted%2A>屬性和<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>與完全信任和部分信任的應用程式定義域的屬性。 應用程式的預設應用程式定義域為完全受信任的應用程式網域。 部分信任的應用程式定義域由使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載。  
  
 此範例會使用`Worker`類別衍生自<xref:System.MarshalByRefObject>，因此它可以封送處理跨應用程式定義域界限。 此範例會建立`Worker`預設應用程式定義域中的物件。 然後它會呼叫`TestIsFullyTrusted`方法，以顯示屬性值，應用程式定義域並載入至應用程式定義域的兩個組件： mscorlib，這是.NET Framework 和範例組件的一部分。 這兩個組件是完全受信任，所以完全信任，應用程式定義域。  
  
 此範例會建立另一個`Worker`物件在沙箱應用程式定義域，然後再次呼叫`TestIsFullyTrusted`方法。 Mscorlib 永遠是受信任，甚至是在部分信任的應用程式網域中，但是範例組件是以部分信任。  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前應用程式定義域是否會授與一組使用權限給所有載入至該應用程式定義域中的組件。</summary>
        <value>如果目前應用程式定義域具有一組同質性權限，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回`true`使用所建立的沙箱化應用程式定義域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載。 沙箱應用程式定義域具有一組同質性權限;也就是相同的權限集授與載入應用程式定義域的所有部分信任組件。 （選擇性） 沙箱應用程式定義域會有免套用此權限集，並改為使用完全信任執行的強式名稱組件清單。  
  
 完全受信任的程式碼可以使用<xref:System.AppDomain.PermissionSet%2A>屬性來判斷沙箱應用程式定義域的同質性的授權集。  
  
 這個屬性也會傳回`true`預設應用程式定義域的桌面應用程式，因為該應用程式定義域會完全信任授與所有組件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 <see cref="T:System.Reflection.Assembly" /> 載入這個應用程式定義域中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <see langword="byte" /> 型別的陣列，是包含發出組件之以 COFF 為基礎的影像。</param>
        <summary>載入具有以通用物件檔案格式 (COFF) 為基礎的影像 (包含發出的 <see cref="T:System.Reflection.Assembly" />) 之 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是應用程式定義域的信任層級相同。  
  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例示範如何載入原始的組件的使用。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="rawAssembly" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">物件，描述要載入的組件。</param>
        <summary>載入 <see cref="T:System.Reflection.Assembly" />，指定它的 <see cref="T:System.Reflection.AssemblyName" />。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 如果尚未載入要求的組件的版本，這個方法會傳回載入的組件，即使要求不同的版本。  
  
 提供的部分組件名稱`assemblyRef`不建議使用。 （部分的名稱會省略一或多個文化特性、 版本或公開金鑰語彙基元。 採用而不是字串的多載<xref:System.Reflection.AssemblyName>物件，"MyAssembly，版本 = 1.0.0.0"舉例說明部分的名稱和"MyAssembly，version=1.0.0.0，Culture = neutral，PublicKeyToken = 18ab3442da84b47"是完整名稱的範例。)使用部分的名稱已對效能產生負面影響。 此外，部分組件名稱可以載入組件從全域組件快取才有的應用程式的基底目錄中的組件的完整複本 (<xref:System.AppDomain.BaseDirectory%2A>或<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>)。  
  
 如果目前<xref:System.AppDomain>物件表示應用程式定義域`A`，而<xref:System.AppDomain.Load%2A>方法從應用程式定義域呼叫`B`，組件會載入兩個應用程式定義域。 例如，下列程式碼載入`MyAssembly`至新的應用程式定義域`ChildDomain`也到應用程式定義域執行的程式碼：  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 組件載入這兩個網域，因為<xref:System.Reflection.Assembly>不是衍生自<xref:System.MarshalByRefObject>，並因此傳回值的<xref:System.AppDomain.Load%2A>方法無法封送處理。 相反地，common language runtime 會嘗試載入至呼叫的應用程式定義域的組件。 載入至兩個應用程式定義域的組件可能是不同的兩個應用程式定義域的路徑設定是否不同。  
  
> [!NOTE]
>  如果兩個<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>屬性和<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>屬性所設定，第一次嘗試載入組件會使用顯示名稱 (包括版本、 文化特性，並依此類推，所傳回<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性)。 如果找不到檔案，<xref:System.Reflection.AssemblyName.CodeBase%2A>屬性用來搜尋該組件。 如果使用找到的組件<xref:System.Reflection.AssemblyName.CodeBase%2A>，顯示名稱比對組件。 如果比對失敗，<xref:System.IO.FileLoadException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyRef" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyRef" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <summary>載入 <see cref="T:System.Reflection.Assembly" />，指定它的顯示名稱。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> 為 <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyString" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyString" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <see langword="byte" /> 型別的陣列，是包含發出組件之以 COFF 為基礎的影像。</param>
        <param name="rawSymbolStore">
          <see langword="byte" /> 型別的陣列，包含表示組件符號的未經處理位元組。</param>
        <summary>載入具有以通用物件檔案格式 (COFF) 為基礎的影像 (包含發出的 <see cref="T:System.Reflection.Assembly" />) 之 <see cref="T:System.Reflection.Assembly" />。 表示 <see cref="T:System.Reflection.Assembly" /> 符號的未經處理位元組也會載入。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是應用程式定義域的信任層級相同。  
  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例示範如何載入原始的組件的使用。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="rawAssembly" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">物件，描述要載入的組件。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <summary>載入 <see cref="T:System.Reflection.Assembly" />，指定它的 <see cref="T:System.Reflection.AssemblyName" />。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> 為 <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyRef" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyRef" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取的路徑，不是格式"file:// 或"\\\UNC\dir\\"或"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">組件的顯示名稱。 請參閱<see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <summary>載入 <see cref="T:System.Reflection.Assembly" />，指定它的顯示名稱。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> 為 <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyString" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyString" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取的路徑，不是格式"file:// 或"\\\UNC\dir\\"或"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <see langword="byte" /> 型別的陣列，是包含發出組件之以 COFF 為基礎的影像。</param>
        <param name="rawSymbolStore">
          <see langword="byte" /> 類型的陣列，包含代表組件符號的未經處理位元組。</param>
        <param name="securityEvidence">用於載入組件的辨識項。</param>
        <summary>載入具有以通用物件檔案格式 (COFF) 為基礎的影像 (包含發出的 <see cref="T:System.Reflection.Assembly" />) 之 <see cref="T:System.Reflection.Assembly" />。 表示 <see cref="T:System.Reflection.Assembly" /> 符號的未經處理位元組也會載入。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是應用程式定義域的信任層級相同。  
  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例示範如何載入原始的組件的使用。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="rawAssembly" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">組件或模組會使用兩個不同的辨識項載入兩次。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> 不是 <see langword="null" />。 不啟用舊版的 CAS 原則時，<paramref name="securityEvidence" /> 應該是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取的路徑，不是格式"file:// 或"\\\UNC\dir\\"或"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否對目前處理序啟用應用程式定義域的 CPU 和記憶體監視。 一旦對處理程序啟用監視，就不能停用。</summary>
        <value>如果啟用監視則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這`static`屬性 (`Shared`屬性在 Visual Basic) 控制 CPU 和記憶體監視的程序中的所有應用程式定義域。  
  
 如果您嘗試將此屬性設定為`false`，則<xref:System.ArgumentException>會擲回例外狀況，即使目前屬性的值是`false`。  
  
 一旦啟用監視，您可以使用<xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>， <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>， <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>，和<xref:System.AppDomain.MonitoringTotalProcessorTime%2A>執行個體來監視個別的應用程式定義域的 CPU 和記憶體使用的屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的處理序嘗試要指派值 <see langword="false" /> 給這個屬性。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">應用程式定義域資源監視</related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd">&lt;appdomainResourceMonitoring&gt;項目</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得自上次回收作業後存留下來，且已知正由目前應用程式定義域參考之位元組的數目。</summary>
        <value>存留的位元組數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每次記憶體回收會更新統計資料。 不過，它們會保證完整、 阻斷式收集; 之後，才是正確的也就是的集合，其中包含所有層代和，以停止應用程式，這時集合就會發生。 比方說，<xref:System.GC.Collect?displayProperty=nameWithType>方法多載會執行完整、 阻斷式收集。 （並行集合會在背景進行的而且不會封鎖應用程式）。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (在 Visual Basic中為 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 屬性設為 <see langword="false" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">應用程式定義域資源監視</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>針對處理序中的所有應用程式定義域，取得自上次回收作業存留下來的位元組總數。</summary>
        <value>處理序的存留位元組總數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完整、 阻斷式收集之後, 的位元組數目目前保留位於此數字代表 managed 堆積。 它應該接近所報告的數字<xref:System.GC.GetTotalMemory%2A>方法。 暫時的集合之後, 此數字代表位元組數目目前保留要即時暫時層代中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (在 Visual Basic中為 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 屬性設為 <see langword="false" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">應用程式定義域資源監視</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式定義域自其建立後已配置之所有記憶體的總大小 (以位元組為單位)，但不減去已回收的記憶體。</summary>
        <value>所有記憶體配置的總大小。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (在 Visual Basic中為 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 屬性設為 <see langword="false" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">應用程式定義域資源監視</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得自處理序啟動後，所有執行緒在目前應用程式定義域中執行時用掉的處理器時間總計。</summary>
        <value>目前應用程式定義域的處理器時間總計。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 總時間所報告的應用程式定義域包含應用程式定義域中執行的處理序中的每個執行緒所花費的時間。  
  
 呼叫 unmanaged 程式碼的執行緒仍會關聯應用程式定義域，並執行 unmanaged 程式碼會報告應用程式定義域進行呼叫所花費的處理器時間。  
  
 當執行緒遭到封鎖或睡眠中，它不會佔用處理器時間。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (在 Visual Basic中為 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 屬性設為 <see langword="false" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">應用程式定義域資源監視</related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得沙箱應用程式定義域的使用權限集。</summary>
        <value>沙箱應用程式定義域的使用權限集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用所建立的沙箱應用程式定義域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載有一組同質性權限，也就是相同的權限集授與所有部分信任的組件載入應用程式定義域。 （選擇性） 沙箱應用程式定義域會有免套用此權限集，並改為使用完全信任執行的強式名稱組件清單。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生在預設的應用程式定義域的父處理序結束時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler>針對此事件可以執行終止活動，例如關閉檔案，釋出儲存體，在處理序結束之前。  
  
 從.NET Framework 2.0 版開始，每個註冊的事件處理常式的應用程式定義域會引發這個事件。  
  
> [!NOTE]
>  總執行時間的所有<xref:System.AppDomain.ProcessExit>事件處理常式是受到限制，就如同所有的完成項執行時間總計會限制在關閉處理序。 預設值為兩秒。 受管理的主機可以呼叫來變更此執行階段[iclrpolicymanager:: Settimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)方法[OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)列舉值。  
  
 在.NET framework 1.0 和 1.1 版中，此事件是引發只在預設應用程式網域中，並且只有在預設應用程式定義域中註冊事件處理常式。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生在僅限反映之內容中的組件解析失敗時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在僅限反映的內容中，會不會自動解析相依性。 它們必須預先載入或傳回由這個事件處理常式。 當組件具有尚未載入至僅限反映內容的相依性時，會引發這個事件。 遺失的相依性由<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>屬性。 <xref:System.ResolveEventHandler>本項目中必須傳回符合相依性的組件。 傳回組件必須載入僅限反映的內容。  
  
> [!IMPORTANT]
>  僅針對遺失的相依性的組件載入僅限反映的內容會引發這個事件 (例如，藉由使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>方法)。 如果找不到要載入的組件時，它不會引發。  
  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性會傳回要求無法解析組件載入的組件。 了解要求的組件的識別可能會有助於識別正確版本的相依性，如果一個以上的版本。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
 對於此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>套用原則之前，屬性會傳回組件名稱。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回已經載入到應用程式定義域之僅限反映的內容之組件。</summary>
        <returns>
          <see cref="T:System.Reflection.Assembly" /> 物件的陣列，其表示已經載入到應用程式定義域之僅限反映的內容之組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回已載入至僅限反映內容的組件。 若要取得已載入的組件的執行，請使用<xref:System.AppDomain.GetAssemblies%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例會載入 System.dll 組件，到執行內容，然後放入僅限反映的內容。 <xref:System.AppDomain.GetAssemblies%2A>和<xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A>方法用來顯示每個內容所載入的組件。  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得組件解析程式應該在其中探查私用組件的路徑，此路徑位在基底目錄下。</summary>
        <value>組件解析程式應該在其中探查私用組件的路徑，此路徑位在基底目錄下。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 私用組件會部署在相同的目錄結構與應用程式。 如果所指定的路徑<xref:System.AppDomain.RelativeSearchPath%2A>屬性不是下方<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>，則會忽略它。  
  
 這個屬性會傳回設定使用的值<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取的路徑資訊。 關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於資源的解析失敗時 (原因是因為該資源在組件中不是有效連結或內嵌的資源)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ResolveEventHandler>針對此事件可嘗試找出包含資源的組件，並將它傳回。  
  
> [!IMPORTANT]
>  如果解析失敗，因為針對有效的連結資源找不到檔案，不會引發此事件。 如果找不到的資訊清單資源資料流，但如果找不到個別的資源索引鍵，則不會引發它，就會引發這個事件。  
  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性包含要求之資源的組件。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">安全性原則層級。</param>
        <summary>為這個應用程式定義域建立安全性原則層級。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 載入組件之前呼叫這個方法<xref:System.AppDomain>為了讓安全性原則，以產生的影響。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.AppDomain.SetAppDomainPolicy%2A>方法來設定應用程式定義域的安全性原則層級。  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Policy.PolicyException">安全性原則層級已經設定。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">陰影複本位置的完整路徑。</param>
        <summary>將指定的目錄路徑建立為陰影複製組件的所在位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果，則會忽略快取路徑<xref:System.AppDomainSetup.ApplicationName%2A>屬性未設定。 請參閱 <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> 屬性。  
  
 如需陰影複製的詳細資訊請參閱 <<c0> [ 陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">陰影複製組件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將某個值指派給應用程式定義域屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">要建立或變更的使用者定義之應用程式定義域屬性的名稱。</param>
        <param name="data">屬性的值。</param>
        <summary>將指定值指派至指定的應用程式定義域屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法中插入項目，或修改的值描述屬性的這個執行個體的名稱資料組的內部快取中的項目<xref:System.AppDomain>。  
  
 快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。 您無法插入或修改系統項目使用此方法。 嘗試修改系統項目方法呼叫沒有任何作用中;此方法不會擲回例外狀況。 您可以查看使用的系統項目的值<xref:System.AppDomain.GetData%2A>方法或對等項目<xref:System.AppDomainSetup>屬性中所述<xref:System.AppDomain.GetData%2A>。  
  
 您可以呼叫這個方法，以評估供應"REGEX_DEFAULT_MATCH_TIMEOUT 」 的規則運算式模式的預設逾時間隔的值設定的值`name`引數和<xref:System.TimeSpan>值，表示在逾時值與間隔`data`引數。 您可以也插入或修改您自己的使用者定義名稱資料組使用這個方法並檢查其值與<xref:System.AppDomain.GetData%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29>方法用來建立新的值組。 然後此範例使用<xref:System.AppDomain.GetData%2A>方法來擷取值，並將它顯示到主控台。  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">要建立或變更的使用者定義之應用程式定義域屬性的名稱。</param>
        <param name="data">屬性的值。</param>
        <param name="permission">當擷取屬性時，向呼叫端要求的使用權限。</param>
        <summary>將指定之值指派給指定之應用程式定義域屬性，而當擷取這個屬性時，有指定向呼叫端要求的使用權限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來插入或修改您的使用者定義的項目，在內部快取的名稱/資料組，可描述應用程式定義域的屬性。 當您將項目時，您可以指定的權限要求，以強制在擷取的項目時。颾魤 ㄛ 您可以呼叫這個方法，以評估供應"REGEX_DEFAULT_MATCH_TIMEOUT 」 的規則運算式模式的預設逾時間隔的值設定的值`name`引數和<xref:System.TimeSpan>值，表示做為值的逾時間隔`data`引數。  
  
 您無法使用這個方法，將安全性需求的系統定義的屬性字串。  
  
 快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。 您無法插入或修改系統項目使用此方法。 嘗試修改系統項目方法呼叫沒有任何作用中;此方法不會擲回例外狀況。 您可以查看使用的系統項目的值<xref:System.AppDomain.GetData%2A>方法或對等項目<xref:System.AppDomainSetup>屬性，如 < 備註 > 一節所述<xref:System.AppDomain.GetData%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> 可指定系統定義之屬性字串，且 <paramref name="permission" /> 不是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">完整的路徑，代表用來儲存動態組件之子目錄的基底目錄。</param>
        <summary>建立指定的目錄路徑，做為存放及存取動態所產生檔案之子目錄的基底目錄。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會設定<xref:System.AppDomainSetup.DynamicBase%2A>屬性內部的<xref:System.AppDomainSetup>與這個執行個體相關聯。  
  
   
  
## Examples  
 此方法現已淘汰，並不應該用於新的開發。 下列範例示範如何使用非過時的替代方式，<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>屬性。 如需此範例的說明，請參閱 <<c0> <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> 屬性或<xref:System.AppDomain.DynamicDirectory%2A>屬性。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">其中一個 <see cref="T:System.Security.Principal.PrincipalPolicy" /> 值，可指定要附加至執行緒的主體物件之型別。</param>
        <summary>如果執行緒在這個應用程式定義域執行時嘗試繫結至主體物件，則指定主體物件和識別 (Identity) 物件應該如何附加至執行緒的方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定此值才會生效，如果您將使用之前<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性。 例如，如果您設定<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>到指定的主體 （例如，泛型主體），然後使用<xref:System.AppDomain.SetPrincipalPolicy%2A>方法來設定<xref:System.Security.Principal.PrincipalPolicy>到<xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>，目前的主體會保留泛用的主體。  
  
   
  
## Examples  
 下列範例示範使用的執行緒上作用<xref:System.AppDomain.SetPrincipalPolicy%2A>方法，以變更應用程式定義域的主體的原則。 它也會示範使用的效果<xref:System.AppDomain.SetThreadPrincipal%2A>變更適用於附加至應用程式定義域中的執行緒之主體的方法。  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">操作主體物件的能力。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開啟陰影複製。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
   
  
## Examples  
 此方法現已淘汰，並不應該用於新的開發。  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">陰影複製組件</related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">目錄名稱的清單，其中的每個名稱以分號隔開。</param>
        <summary>建立指定的目錄路徑為要陰影複製的組件位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，陰影複製會包含經由探查所找到的所有組件。 <xref:System.AppDomain.SetShadowCopyPath%2A>方法會將陰影複製限制為所指定的目錄中的組件`path`。  
  
 <xref:System.AppDomain.SetShadowCopyPath%2A>方法不會指定要搜尋的組件的其他目錄。 要陰影複製組件必須已經位於搜尋路徑中，例如下<xref:System.AppDomain.BaseDirectory%2A>。 <xref:System.AppDomain.SetShadowCopyPath%2A>方法可讓您指定的搜尋路徑適合將陰影複製。  
  
 這個方法會設定<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>屬性內部的<xref:System.AppDomainSetup>與這個執行個體相關聯。  
  
 如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
   
  
## Examples  
 此方法現已淘汰，並不應該用於新的開發。  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">陰影複製組件</related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">要附加至執行緒的主體物件。</param>
        <summary>如果執行緒在這個應用程式定義域中執行時嘗試繫結至預設的主體物件，則設定預設的主體物件來附加至執行緒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範使用的效果<xref:System.AppDomain.SetThreadPrincipal%2A>變更適用於附加至應用程式定義域中執行的執行緒之主體的方法。 它也會顯示在使用的執行緒上作用<xref:System.AppDomain.SetPrincipalPolicy%2A>方法，以變更應用程式定義域的主體的原則。  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Policy.PolicyException">主要執行緒已經設定。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">操作主體物件的能力。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個執行個體的應用程式定義域組態資訊。</summary>
        <value>應用程式定義域初始化資訊。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得是否已設定應用程式定義域以進行檔案陰影複製的指示。</summary>
        <value>如果已設定應用程式定義域以進行檔案陰影複製，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱 <<c0> <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> 並[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">陰影複製組件</related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="rgszNames">要對應之傳入的名稱陣列。</param>
        <param name="cNames">要對應的名稱計數。</param>
        <param name="lcid">用於解譯名稱的地區設定內容。</param>
        <param name="rgDispId">呼叫端配置的陣列，用於接收對應於名稱的 ID。</param>
        <summary>將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要傳回的型別資訊。</param>
        <param name="lcid">型別資訊的地區設定識別項。</param>
        <param name="ppTInfo">接收要求的型別資訊物件的指標。</param>
        <summary>擷取物件的型別資訊，可以用來取得介面的型別資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetTypeInfo`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向接收物件提供的型別資訊介面數目的位置。</param>
        <summary>擷取物件提供的型別資訊介面數目 (0 或 1)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">辨識成員。</param>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="lcid">地區設定內容，用於解譯引數。</param>
        <param name="wFlags">描述呼叫之內容的旗標。</param>
        <param name="pDispParams">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中元素數目的計數。</param>
        <param name="pVarResult">指向用於儲存結果之位置的指標。</param>
        <param name="pExcepInfo">包含例外狀況資訊的結構指標。</param>
        <param name="puArgErr">第一個有錯誤的引數索引。</param>
        <summary>提供物件所公開的屬性和方法的存取權。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::Invoke`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得字串表示，其中包含應用程式定義域及任何內容原則的易記名稱。</summary>
        <returns>將常值字串 "Name:"、應用程式定義域的易記名稱、內容原則的字串表示或字串 "There are no context policies" 串連起來所構成的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例顯示的傳回值<xref:System.AppDomain.ToString%2A>方法。  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">已經卸載目前的 <see cref="T:System.AppDomain" /> 所表示的應用程式定義域。</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於型別解析失敗時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.TypeResolve> Common language runtime 無法判斷組件可以建立要求的型別時，就會發生事件。 如果類型定義中的動態組件，或動態組件中未定義類型，但執行階段不知道哪個組件中定義型別，也可能會發生。 後者的情況可能會發生時<xref:System.Type.GetType%2A?displayProperty=nameWithType>呼叫組件名稱未限定的型別名稱。  
  
 <xref:System.ResolveEventHandler>針對此事件可以嘗試找出並建立類型。  
  
 不過，<xref:System.AppDomain.TypeResolve>事件不會發生執行階段可讓您知道不可能以尋找特定組件中的類型。 比方說，不會不會發生此事件的型別找不到靜態組件中因為執行階段知道類型無法以動態方式新增至靜態組件。  
  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性包含要求的型別之組件。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.TypeResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於未攔截到例外狀況時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會通知無法攔截的例外狀況。 它可讓應用程式之前的系統預設處理常式回報給使用者的例外狀況，並終止應用程式記錄例外狀況的相關資訊。 如果應用程式的狀態相關的足夠資訊可用，則可能會採取其他動作，例如儲存供稍後復原計畫資料。 請謹慎，因為未處理例外狀況時，會損毀程式資料。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，應用程式終止偵錯選項報告和使用者會引發這個事件之前，而不是在後。  
  
 可以在任何應用程式定義域中處理這個事件。 不過，事件不一定會引發例外狀況的發生位置的應用程式定義域中。 只有當執行緒在整個堆疊已回溯而未找到適用的例外狀況處理常式，因此可以引發事件的第一個位置是在執行緒的起源的應用程式定義域，是未處理例外狀況。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，只會針對應用程式啟動時，會將由系統建立預設應用程式定義域發生此事件。 如果應用程式建立其他應用程式定義域，指定此事件的委派，這些應用程式網域中沒有任何作用。  
  
 如果<xref:System.AppDomain.UnhandledException>預設應用程式定義域中處理事件，會引發這個事件發生的任何未處理例外狀況，在任何執行緒中，無論何種應用程式定義域中啟動的執行緒。 如果有事件處理常式的應用程式定義域中啟動執行緒<xref:System.AppDomain.UnhandledException>，應用程式定義域中引發事件。 如果該應用程式定義域不是預設的應用程式定義域，而且也沒有事件處理常式預設應用程式定義域中，會引發事件，這兩個應用程式定義域中。  
  
 比方說，假設啟動執行緒應用程式定義域 」 AD1"，"AD2，"的應用程式定義域中呼叫的方法，並從中呼叫應用程式定義域 」 AD3 」，方法會擲回例外狀況。 第一個應用程式定義域，<xref:System.AppDomain.UnhandledException>可以引發事件是 「 AD1"。 如果該應用程式定義域不是預設應用程式定義域，也是預設應用程式定義域中引發事件。  
  
> [!NOTE]
>  Common language runtime 會暫止的執行緒中止時的事件處理常式<xref:System.AppDomain.UnhandledException>執行事件。  
  
 如果事件處理常式<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>屬性與適當的旗標，事件處理常式會被視為限制的執行區域。  
  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，此事件不會引發例外狀況的損毀的程序的狀態，例如堆疊溢位，或存取違規，除非事件處理常式上為安全性關鍵，而且有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>屬性。  
  
 在.NET framework 1.0 和 1.1 版中，主應用程式執行緒以外的執行緒中發生未處理例外狀況會由執行階段會攔截，並因此不會造成應用程式終止。 因此，就可能<xref:System.AppDomain.UnhandledException>而不終止應用程式會引發事件。 從.NET Framework 2.0 版開始，這個子執行緒中的未處理例外狀況的支援已移除，因為這類的無訊息失敗的累積效果包含效能降低、 損毀的資料和鎖定，且很難偵錯。 如需詳細資訊，包括一份案例中，執行階段不會終止，請參閱[受控執行緒中的例外狀況](~/docs/standard/threading/exceptions-in-managed-threads.md)。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
## <a name="other-events-for-unhandled-exceptions"></a>未處理例外狀況的其他事件  
 針對特定應用程式模型，<xref:System.AppDomain.UnhandledException>事件可以清空的其他事件，如果主應用程式執行緒中發生未處理的例外狀況。  
  
 使用 Windows Forms 應用程式，在未處理的例外狀況中的主應用程式執行緒的原因<xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType>會引發事件。 如果處理此事件，預設行為是未處理的例外狀況不會終止應用程式，雖然應用程式處於未知狀態。 在此情況下，<xref:System.AppDomain.UnhandledException>不會引發事件。 可以變更此行為，藉由使用應用程式組態檔，或是利用<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType>方法，以將模式變更為<xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType>之前<xref:System.Windows.Forms.Application.ThreadException>連結事件處理常式。 只適用於主應用程式執行緒。 <xref:System.AppDomain.UnhandledException>其他執行緒中擲回未處理的例外狀況都會引發事件。  
  
 從 Microsoft Visual Studio 2005 開始，Visual Basic 應用程式架構可以提供另一個事件在主應用程式執行緒的未處理例外狀況。 請參閱<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType>事件。 此事件具有與所使用的事件引數物件的名稱相同的事件引數物件<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>，但具有不同的屬性。 這個事件引數物件的有特別的是，<xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>屬性，可讓應用程式繼續執行，而忽略未處理的例外狀況 （並讓應用程式處於未知狀態）。 在此情況下，<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>不會引發事件。  
  
   
  
## Examples  
 如以下範例將示範<xref:System.AppDomain.UnhandledException>事件。 它會定義事件處理常式， `MyHandler`，叫用時的預設應用程式定義域中擲回未處理的例外狀況。 然後，會擲回兩個例外狀況。 第一個由**try/catch**區塊。 第二個是未處理，並叫用`MyHandle`應用程式終止之前的常式。  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">要卸載的應用程式定義域。</param>
        <summary>卸載指定的應用程式定義域。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 2.0 版中已有執行緒專門用來卸載應用程式定義域。 這可改善可靠性，尤其是當裝載.NET Framework。 當執行緒呼叫<xref:System.AppDomain.Unload%2A>，目標網域已標示為卸載。 專用的執行緒嘗試卸載定義域，並在網域中的所有執行緒都被都中止。 如果執行緒不會中止，例如因為它正在執行 unmanaged 程式碼，或因為它執行`finally`區塊，然後在一段時間後的<xref:System.CannotUnloadAppDomainException>初次呼叫的執行緒中擲回<xref:System.AppDomain.Unload%2A>。 如果無法最終中止的執行緒結束時，目標網域不卸載。 因此，在.NET Framework 2.0 版`domain`不保證會卸除，因為它可能無法終止正在執行的執行緒。  
  
> [!NOTE]
>  在某些情況下，呼叫<xref:System.AppDomain.Unload%2A>會導致立即<xref:System.CannotUnloadAppDomainException>，例如在完成項呼叫。  
  
 中的執行緒`domain`使用終止<xref:System.Threading.Thread.Abort%2A>方法，就會擲回<xref:System.Threading.ThreadAbortException>執行緒中。 不過，應該立即終止執行緒，它會繼續執行無法預期的一段時間中`finally`子句。  
  
## <a name="version-compatibility"></a>版本相容性  
 在.NET Framework 1.0 和 1.1，如果呼叫執行緒<xref:System.AppDomain.Unload%2A>正在執行`domain`，另一個執行緒已啟動執行卸載作業。 如果`domain`不能卸載<xref:System.CannotUnloadAppDomainException>該執行緒不在原始呼叫的執行緒中擲回<xref:System.AppDomain.Unload%2A>。 不過，如果執行緒呼叫<xref:System.AppDomain.Unload%2A>外部執行`domain`，執行緒會收到例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何卸載應用程式定義域。  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">無法卸載 <paramref name="domain" />。</exception>
        <exception cref="T:System.Exception">卸載程序期間發生錯誤。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要加入此事件的事件處理常式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
  </Members>
</Type>