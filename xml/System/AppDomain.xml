<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c3ab234edad8a65f7b4b6688da32990c9642f79d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731662" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示應用程式定義域，也就是應用程式執行的獨立環境。 這個類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式定義域，都由<xref:System.AppDomain>物件，協助您為執行 managed 程式碼提供隔離、 卸載和安全性界限。  
  
-   使用應用程式定義域來隔離可能會讓處理序關閉的工作。 如果狀態<xref:System.AppDomain>，正在執行的工作變得不穩定，<xref:System.AppDomain>而不會影響處理序可以卸載。 當處理程序必須執行很長，不需要重新啟動時，這很重要。 您也可以使用應用程式定義域來隔離不應共用資料的工作。  
  
-   如果預設應用程式定義域載入組件，它不能從記憶體中卸載的情況，而處理序正在執行。 不過，如果您開啟第二個應用程式定義域載入並執行組件時，組件會卸載應用程式定義域卸載時。 您可以使用這項技術來減少偶爾使用大型 Dll 的長時間執行程序的工作集。  
  
 多個應用程式定義域可以單一處理序中執行;不過，沒有任何應用程式定義域和執行緒之間的一對一關聯性。 數個執行緒可以屬於單一應用程式定義域，並給定的執行緒並不會侷限於單一應用程式定義域，在任何時候，而執行緒執行單一應用程式網域中。  
  
 使用建立應用程式定義域<xref:System.AppDomain.CreateDomain%2A>方法。 <xref:System.AppDomain> 執行個體用來載入並執行組件 (<xref:System.Reflection.Assembly>)。 當<xref:System.AppDomain>已不再使用時，它可以卸載。  
  
 <xref:System.AppDomain>類別會實作一組可讓回應在載入組件，應用程式定義域都將被解除載入，或擲回未處理的例外狀況時的應用程式的事件。  
  
 如需有關如何使用應用程式定義域的詳細資訊，請參閱[應用程式定義域](~/docs/framework/app-domains/application-domains.md)。  
  
 這個類別會實作<xref:System.MarshalByRefObject>， <xref:System._AppDomain>，和<xref:System.Security.IEvidenceFactory>介面。  
  
 您絕對不要建立的遠端執行包裝函式<xref:System.AppDomain>物件。 這樣可發佈的遠端參考的<xref:System.AppDomain>，例如公開方法<xref:System.AppDomain.CreateInstance%2A>遠端存取和有效終結該的 程式碼存取安全性<xref:System.AppDomain>。 惡意用戶端連線到遠端<xref:System.AppDomain>無法取得任何資源的存取權<xref:System.AppDomain>本身具有存取權。 無法建立遠端使用包裝函式，以擴充任何型別<xref:System.MarshalByRefObject>以及實作可能由惡意用戶端用來略過安全性系統的方法。  
  
> [!CAUTION]
>  預設值為<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>屬性是`false`。 這項設定是不安全的服務。 若要防止服務下載部分信任程式碼，將此屬性設定為`true`。  
  
   
  
## Examples  
 這個範例示範如何建立新<xref:System.AppDomain>，具現化類型中的新<xref:System.AppDomain>，以及該類型的物件之間的通訊。 此外，此範例示範如何卸載<xref:System.AppDomain>造成要進行記憶體回收的物件。  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前應用程式定義域的啟動內容。</summary>
        <value>物件，表示目前應用程式定義域的啟動內容，如果此定義域沒有任何啟動內容，則為 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要附加到私用路徑的目錄名稱。</param>
        <summary>將指定的目錄名稱附加至私用 (Private) 路徑清單。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不建議使用此屬性，因為它可能會探查路徑的組件之後變更它們已經載入。 請改用 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> 屬性。  
  
 私用的路徑或相對搜尋路徑是相對於組件解析程式其中探查私用組件的基底目錄路徑。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式定義域中的應用程式之識別。</summary>
        <value>物件，可識別應用程式定義域中的應用程式。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得資訊，以描述授與應用程式的權限，以及該應用程式是否有允許其執行的信任層級。</summary>
        <value>物件，可針對應用程式定義域中的應用程式來封裝使用權限和信任資訊。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱，其格式為 <see cref="P:System.Reflection.Assembly.FullName" /> 屬性所提供。</param>
        <summary>在套用原則之後傳回組件的顯示名稱。</summary>
        <returns>一個字串，其中包含套用原則之後的組件顯示名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ApplyPolicy%2A>方法會採用單一組件顯示名稱和傳回原則後顯示名稱。 這是您需要載入組件使用 「 原則 」，因為僅限反映的內容不會套用原則時相當實用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於載入組件時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AssemblyLoadEventHandler>委派這個事件指出哪些組件已載入。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.AssemblyLoad>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於組件解析失敗時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它負責<xref:System.ResolveEventHandler>傳回組件由所指定的這個事件<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>屬性，或傳回 null，如果組件無法辨識。 組件必須載入執行內容。如果載入僅限反映的內容時，會引發這個事件的負載將會失敗。  
  
 如需使用這個事件的指引，請參閱[解析組件載入](~/docs/framework/app-domains/resolve-assembly-loads.md)。  
  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性會傳回要求無法解析組件載入的組件。 例如，載入器可能無法載入要求的組件的相依性，因為要求的組件和其相依性不探查路徑中。 了解要求的組件的識別可能有助於在尋找相依性或識別最正確的版本，如果使用多個版本的相依性。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
> [!IMPORTANT]
>  開頭為[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、<xref:System.ResolveEventHandler>引發的所有組件，包括資源組件。 在舊版中，資源組件不引發事件。 如果當地語系化的作業系統，此處理常式可能會多次呼叫： 每個文化特性在後援鍊結中的一次。  
  
 對於此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>屬性在套用原則之前，會傳回組件名稱。  
  
> [!IMPORTANT]
>  如果多個事件處理常式註冊這個事件，事件 handlersarecalled 順序的事件處理常式傳回的值之前，不是`null`。 會忽略後續的事件處理常式。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得組件解析程式 (Resolver) 用來探查組件的基底目錄。</summary>
        <value>組件解析程式用來探查組件的基底目錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會對應至<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>屬性。 它也可使用擷取<xref:System.AppDomain.GetData%2A>與字串"APPBASE"的方法。  
  
   
  
## Examples  
 下列程式碼範例會建立新的應用程式定義域，指定要用於搜尋組件時，載入定義域的基底目錄。 然後此範例使用<xref:System.AppDomain.BaseDirectory%2A>屬性，以取得基底目錄路徑，以顯示到主控台。  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑本身中的資訊，如果包含路徑的格式為"file:// 或\\\UNC\dir 或"c:\\"。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將指定私用組件位置的路徑重設為空字串 ("")。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 私用路徑是相對於 common language runtime 會搜尋來尋找私用組件的基底目錄路徑。  
  
 如需詳細資訊，請參閱<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.AppDomain.ClearPrivatePath%2A>方法從已載入組件時所要搜尋的私用路徑的清單移除所有項目。  
  
 這個方法已經過時，並不應該用於新的開發工作。  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將含有陰影複製的組件目錄清單重設為空字串 ("")。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 陰影複製路徑是儲存的陰影複製組件的所在目錄的清單。  
  
 如需詳細資訊，請參閱<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>和[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立指定 COM 類型的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">檔案的名稱，此檔案包含定義要求類型的組件。</param>
        <param name="typeName">要求類型的名稱。</param>
        <summary>建立指定 COM 類型的新執行個體。 指定包含組件 (包含類型和類型名稱) 之檔案名稱的參數。</summary>
        <returns>物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法，而不需要載入的型別在本機從遠端建立物件。  
  
 傳回值必須解除包裝以存取實際物件。  
  
 A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>屬性的值`true`必須應用於明確或預設 COM 型別，此方法來建立執行個體的該類型; 否則<xref:System.TypeLoadException>就會擲回。  
  
   
  
## Examples  
 下列範例將示範  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException">無法載入這個類型。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.MissingMethodException">找不到無參數的公用建構函式。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" />這是抽象類別。  
  
 -或-  
  
 這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> 為空字串 ("")。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.NullReferenceException">所要參考的 COM 物件為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱，此檔案包含定義要求類型的組件。</param>
        <param name="typeName">要求類型的名稱。</param>
        <param name="hashValue">表示計算出來的雜湊碼的值。</param>
        <param name="hashAlgorithm">表示組件資訊清單所使用的雜湊演算法。</param>
        <summary>建立指定 COM 類型的新執行個體。 指定包含組件 (包含類型和類型名稱) 之檔案名稱的參數。</summary>
        <returns>物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法，而不需要載入的型別在本機從遠端建立物件。  
  
 傳回值必須解除包裝以存取實際物件。  
  
 A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>屬性的值`true`必須應用於明確或預設 COM 型別，此方法來建立執行個體的該類型; 否則<xref:System.TypeLoadException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException">無法載入這個類型。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.MissingMethodException">找不到無參數的公用建構函式。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" />這是抽象類別。  
  
 -或-  
  
 這個成員曾被晚期繫結機制叫用過。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 為空字串 ("")。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.NullReferenceException">所要參考的 COM 物件為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新的應用程式定義域。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">定義域的易記名稱。</param>
        <summary>建立具有指定名稱的新應用程式定義域。</summary>
        <returns>新建立的應用程式定義域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `friendlyName`參數的目的在於識別讓人了以有意義的方式中的網域。 此字串應該是適合在使用者介面中顯示。  
  
 這個方法多載會使用<xref:System.AppDomainSetup>來自預設應用程式定義域的資訊。  
  
   
  
## Examples  
 下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">定義域的易記名稱。 這個易記名稱可以在使用者介面中顯示以識別該定義域。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.FriendlyName" />。</param>
        <param name="securityInfo">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。 傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</param>
        <summary>使用提供的辨識項，建立具有指定名稱的新應用程式定義域。</summary>
        <returns>新建立的應用程式定義域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載會使用<xref:System.AppDomainSetup>來自預設應用程式定義域的資訊。  
  
 如果`securityInfo`是未提供，使用目前的應用程式定義域的辨識項。  
  
> [!IMPORTANT]
>  請勿使用這個方法多載來建立沙箱化應用程式定義域。 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱化應用程式定義域。  
  
   
  
## Examples  
 下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">定義域的易記名稱。 這個易記名稱可以在使用者介面中顯示以識別該定義域。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.FriendlyName" />。</param>
        <param name="securityInfo">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。 傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</param>
        <param name="info">物件，包含應用程式定義域初始化資訊。</param>
        <summary>使用指定名稱、辨識項和應用程式定義域安裝資訊，建立新的應用程式定義域。</summary>
        <returns>新建立的應用程式定義域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`info`是未提供，這個方法多載會使用<xref:System.AppDomainSetup>來自預設應用程式定義域的資訊。  
  
 如果`securityInfo`是未提供，使用目前的應用程式定義域的辨識項。  
  
> [!IMPORTANT]
>  請勿使用這個方法多載來建立沙箱化應用程式定義域。 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱化應用程式定義域。  
  
   
  
## Examples  
 下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">定義域的易記名稱。 這個易記名稱可以在使用者介面中顯示以識別該定義域。 如需詳細資訊，請參閱 <see cref="P:System.AppDomain.FriendlyName" /> 的說明。</param>
        <param name="securityInfo">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。 傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</param>
        <param name="info">物件，包含應用程式定義域初始化資訊。</param>
        <param name="grantSet">預設使用權限集合，其授與給載入無特定授權的新應用程式定義域中的所有組件。</param>
        <param name="fullTrustAssemblies">強式名稱的陣列，表示在新的應用程式定義域中視為完全信任的組件。</param>
        <summary>使用指定之名稱、辨識項、應用程式定義域設定資訊、預設權限集合及完全信任的組件陣列，建立新的應用程式定義域。</summary>
        <returns>新建立的應用程式定義域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須設定<xref:System.AppDomainSetup.ApplicationBase%2A>屬性<xref:System.AppDomainSetup>物件，您會提供`info`。 否則，會擲回例外狀況。  
  
 如果`securityInfo`是未提供，使用目前的應用程式定義域的辨識項。  
  
 針對提供的資料`grantSet`和`fullTrustAssemblies`用來建立<xref:System.Security.Policy.ApplicationTrust>新的應用程式定義域的物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">應用程式定義域為 <see langword="null" />。  
  
 -或-  
  
 未在提供給 <paramref name="info" /> 的 <see cref="P:System.AppDomainSetup.ApplicationBase" /> 物件上設定 <see cref="T:System.AppDomainSetup" /> 屬性。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立和管理應用程式定義域的能力。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">定義域的易記名稱。 這個易記名稱可以在使用者介面中顯示以識別該定義域。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.FriendlyName" />。</param>
        <param name="securityInfo">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。 傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</param>
        <param name="appBasePath">組件解析程式用來探查組件的基底目錄。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.BaseDirectory" />。</param>
        <param name="appRelativeSearchPath">相對於組件解析程式應該探查私用組件之基底目錄的路徑。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.RelativeSearchPath" />。</param>
        <param name="shadowCopyFiles">如果為 <see langword="true" />，則會將組件的陰影複本載入這個應用程式定義域中。</param>
        <summary>使用辨識項、應用程式基底路徑、相對搜尋路徑和指定是否要將組件的陰影複本載入應用程式定義域的參數，建立具有指定名稱的新應用程式定義域。</summary>
        <returns>新建立的應用程式定義域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`securityInfo`是未提供，使用目前的應用程式定義域的辨識項。  
  
 如需陰影複製的詳細資訊，請參閱<xref:System.AppDomain.ShadowCopyFiles%2A>和[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
> [!IMPORTANT]
>  請勿使用這個方法多載來建立沙箱化應用程式定義域。 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱化應用程式定義域。  
  
   
  
## Examples  
 下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">定義域的易記名稱。 這個易記名稱可以在使用者介面中顯示以識別該定義域。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.FriendlyName" />。</param>
        <param name="securityInfo">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。 傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</param>
        <param name="appBasePath">組件解析程式用來探查組件的基底目錄。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.BaseDirectory" />。</param>
        <param name="appRelativeSearchPath">相對於組件解析程式應該探查私用組件之基底目錄的路徑。 如需詳細資訊，請參閱<see cref="P:System.AppDomain.RelativeSearchPath" />。</param>
        <param name="shadowCopyFiles">
          <see langword="true" /> 表示將組件的陰影複本載入到應用程式定義域中。</param>
        <param name="adInit">
          <see cref="T:System.AppDomainInitializer" /> 委派，表示當初始化新的 <see cref="T:System.AppDomain" /> 物件時所叫用的回呼方法。</param>
        <param name="adInitArgs">當初始化新的 <see cref="T:System.AppDomain" /> 物件時，要傳遞給由 <c>adInit</c> 代表的回呼之字串引數陣列。</param>
        <summary>使用辨識項、應用程式基底路徑、相對搜尋路徑和指定是否要將組件的陰影複本載入應用程式定義域的參數，建立具有指定名稱的新應用程式定義域。 指定當初始化應用程式定義域時所叫用的回呼方法，以及要傳遞給該回呼方法的字串引數陣列。</summary>
        <returns>新建立的應用程式定義域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所表示的方法`adInit`新建立的應用程式定義域的內容中執行。  
  
 如果`securityInfo`是未提供，使用目前的應用程式定義域的辨識項。  
  
 如需陰影複製的詳細資訊，請參閱<xref:System.AppDomain.ShadowCopyFiles%2A>和[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
> [!IMPORTANT]
>  請勿使用這個方法多載來建立沙箱化應用程式定義域。 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱化應用程式定義域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立在指定組件中所定義之指定類型的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <summary>建立指定組件中所定義之指定類型的新執行個體。</summary>
        <returns>物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫預設建構函式`typeName`。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。  
  
 嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標的應用程式定義域中不是目前的應用程式定義域會在目標應用程式定義域中的組件載入成功。 因為<xref:System.Reflection.Assembly>不<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>目前的應用程式定義域載入組件，common language runtime 會嘗試對目前的應用程式定義域載入組件，負載可能會失敗。 目前的應用程式定義域中載入的組件可能從不同的兩個應用程式定義域的路徑設定是否先載入的組件不同。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
 此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>建立指定組件中所定義之指定類型的新執行個體。 參數會指定啟動屬性的陣列。</summary>
        <returns>物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫預設建構函式`typeName`。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。  
  
 嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標的應用程式定義域中不是目前的應用程式定義域會在目標應用程式定義域中的組件載入成功。 因為<xref:System.Reflection.Assembly>不<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>目前的應用程式定義域載入組件，common language runtime 會嘗試對目前的應用程式定義域載入組件，負載可能會失敗。 目前的應用程式定義域中載入的組件可能從不同的兩個應用程式定義域的路徑設定是否先載入的組件不同。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有類型成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <c>typeName</c> 建構函式的搜尋。 如果 <c>bindingAttr</c> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <c>binder</c> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <c>args</c> 必須是空陣列或 Null。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <c>args</c> 到型式類型 (為 <c>typeName</c> 建構函式宣告) 的強制轉型。 如果「文化特性 (Culture)」<c></c>是 <see langword="null" />，則使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
 此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>建立指定組件中所定義之指定類型的新執行個體。 參數會指定繫結器、繫結旗標、建構函式引數、用來解譯引數的特定文化特性資訊，以及選擇性的啟動屬性。</summary>
        <returns>物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。  
  
 嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標的應用程式定義域中不是目前的應用程式定義域會在目標應用程式定義域中的組件載入成功。 因為<xref:System.Reflection.Assembly>不<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>目前的應用程式定義域載入組件，common language runtime 會嘗試對目前的應用程式定義域載入組件，負載可能會失敗。 目前的應用程式定義域中載入的組件可能從不同的兩個應用程式定義域的路徑設定是否先載入的組件不同。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
 -或-  
  
 用以編譯 <paramref name="assemblyName" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有類型成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <c>typeName</c> 建構函式的搜尋。 如果 <c>bindingAttr</c> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <c>binder</c> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <c>args</c> 必須是空陣列或 Null。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <c>args</c> 到型式類型 (為 <c>typeName</c> 建構函式宣告) 的強制轉型。 如果「文化特性 (Culture)」<c></c>是 <see langword="null" />，則使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
 此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <param name="securityAttributes">用來授權建立 <c>typeName</c> 的資訊。</param>
        <summary>建立指定組件中所定義之指定類型的新執行個體。 參數會指定繫結器 (Binder)、繫結旗標、建構函式引數、用來解譯引數的特定文化特性資訊、啟動屬性，以及建立類型的授權。</summary>
        <returns>物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。  
  
 嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標的應用程式定義域中不是目前的應用程式定義域會在目標應用程式定義域中的組件載入成功。 因為<xref:System.Reflection.Assembly>不<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>目前的應用程式定義域載入組件，common language runtime 會嘗試對目前的應用程式定義域載入組件，負載可能會失敗。 目前的應用程式定義域中載入的組件可能從不同的兩個應用程式定義域的路徑設定是否先載入的組件不同。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。  
  
 -或-  
  
 <paramref name="securityAttributes" /> 不是 <see langword="null" />。 不啟用舊版的 CAS 原則時，<paramref name="securityAttributes" /> 應該是 <see langword="null." />。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有類型成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立指定類型的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <summary>建立指定類型的新執行個體。 參數會指定定義類型所在的組件和類型的名稱。</summary>
        <returns>
          <paramref name="typeName" /> 指定之物件的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是便利的方法，它結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 這個方法會呼叫預設建構函式`typeName`。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。 請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。  
  
> [!NOTE]
>  如果您進行早期繫結呼叫的方法`M`型別的物件的`T1`所傳回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，而該方法的型別物件的方法的早期繫結呼叫`T2`組件中`C`以外目前組件或組件包含`T1`，組件`C`會載入目前應用程式定義域。 即使早期繫結呼叫，就會發生此載入`T1.M()`中的主體進行<xref:System.Reflection.Emit.DynamicMethod>，或其他動態產生的程式碼中。 如果目前的定義域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的定義域之後嘗試載入組件`C`，負載可能會失敗。  
  
   
  
## Examples  
 下列程式碼範例示範最簡單的方式，另一個應用程式定義域中執行程式碼。 此範例會定義名為類別`Worker`繼承自<xref:System.MarshalByRefObject>。 `Worker`類別定義的方法，顯示它正在執行的應用程式定義域的名稱。 此範例會建立的執行個體`Worker`在預設應用程式定義域和新的應用程式定義域中。  
  
> [!NOTE]
>  包含的組件`Worker`必須載入到兩個應用程式定義域，但只存在於新的應用程式定義域的其他組件可以載入。  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">能夠讀取該檔案包含組件資訊清單中，或如果您要建立從模組資訊清單檔以外的類型。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
 此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>建立指定類型的新執行個體。 參數會指定定義類型所在的組件、類型的名稱和啟動屬性的陣列。</summary>
        <returns>
          <paramref name="typeName" /> 指定之物件的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是便利的方法，它結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 這個方法會呼叫預設建構函式`typeName`。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。 請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。  
  
> [!NOTE]
>  如果您進行早期繫結呼叫的方法`M`型別的物件的`T1`所傳回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，而該方法的型別物件的方法的早期繫結呼叫`T2`組件中`C`以外目前組件或組件包含`T1`，組件`C`會載入目前應用程式定義域。 即使早期繫結呼叫，就會發生此載入`T1.M()`中的主體進行<xref:System.Reflection.Emit.DynamicMethod>，或其他動態產生的程式碼中。 如果目前的定義域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的定義域之後嘗試載入組件`C`，負載可能會失敗。  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有類型成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <c>typeName</c> 建構函式的搜尋。 如果 <c>bindingAttr</c> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <c>binder</c> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <c>args</c> 必須是空陣列或 Null。</param>
        <param name="culture">用來控制類型強制的特定文化特性物件。 如果「文化特性 (Culture)」<c></c>是 <see langword="null" />，則使用目前執行緒的 <see langword="CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 一般來說，就是包含單一 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件的陣列。 會指定啟動遠端物件所需的 URL。  
  
 此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>藉由指定是否忽略類型名稱的大小寫、用於選取要建立之類型的繫結屬性和繫結器、建構函式的引數、文化特性，以及啟動屬性，為指定之組件中定義的指定類型，建立新的執行個體。</summary>
        <returns>
          <paramref name="typeName" /> 指定之物件的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是便利的方法，它結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。 請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。  
  
> [!NOTE]
>  如果您進行早期繫結呼叫的方法`M`型別的物件的`T1`所傳回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，而該方法的型別物件的方法的早期繫結呼叫`T2`組件中`C`以外目前組件或組件包含`T1`，組件`C`會載入目前應用程式定義域。 即使早期繫結呼叫，就會發生此載入`T1.M()`中的主體進行<xref:System.Reflection.Emit.DynamicMethod>，或其他動態產生的程式碼中。 如果目前的定義域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的定義域之後嘗試載入組件`C`，負載可能會失敗。  
  
   
  
## Examples  
 下列範例示範如何使用`ignoreCase`參數。  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
 -或-  
  
 用以編譯 <paramref name="assemblyName" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有類型成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <c>typeName</c> 建構函式的搜尋。 如果 <c>bindingAttr</c> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <c>binder</c> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <c>args</c> 必須是空陣列或 Null。</param>
        <param name="culture">用來控制類型強制的特定文化特性物件。 如果「文化特性 (Culture)」<c></c>是 <see langword="null" />，則使用目前執行緒的 <see langword="CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
 此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <param name="securityAttributes">用來授權建立 <c>typeName</c> 的資訊。</param>
        <summary>建立指定類型的新執行個體。 參數會指定類型的名稱，以及如何尋找和建立它。</summary>
        <returns>
          <paramref name="typeName" /> 指定之物件的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是便利的方法，它結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。 請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。  
  
> [!NOTE]
>  如果您進行早期繫結呼叫的方法`M`型別的物件的`T1`所傳回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，而該方法的型別物件的方法的早期繫結呼叫`T2`組件中`C`以外目前組件或組件包含`T1`，組件`C`會載入目前應用程式定義域。 即使早期繫結呼叫，就會發生此載入`T1.M()`中的主體進行<xref:System.Reflection.Emit.DynamicMethod>，或其他動態產生的程式碼中。 如果目前的定義域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的定義域之後嘗試載入組件`C`，負載可能會失敗。  
  
   
  
## Examples  
 下列範例示範如何使用`ignoreCase`參數。  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有類型成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立指定組件檔案中所定義之指定類型的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱 (包括路徑)，此檔案包含會定義要求之類型的組件。 此組件使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法載入。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <summary>建立指定組件檔案中所定義之指定類型的新執行個體。</summary>
        <returns>對新執行個體而言是包裝函式的物件，但如果沒有找到 <paramref name="typeName" />，則為 <see langword="null" />。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設建構函式`typeName`叫用。  
  
 如需詳細資訊，請參閱 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。  
  
 當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域以外進行呼叫的應用程式定義域中的執行個體、 組件會在目標應用程式定義域中載入。 不過，如果呼叫的應用程式定義域中執行個體解除包裝，使用包裝的執行個體所規定的方式可能會導致要呼叫的應用程式定義域載入組件。 例如，執行個體已解除包裝之後，可能會要求其類型資訊，才能呼叫其方法晚期繫結。 組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。  
  
-   如果另一個版本的相同組件先前已載入至呼叫的應用程式定義域，或例如是不同的目標應用程式定義域的例外狀況呼叫的應用程式定義域的載入路徑<xref:System.MissingMethodException>可能會發生。  
  
-   如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>試圖轉換執行個體可能會擲回。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>方法多載來建立目標應用程式定義域中物件的執行個體並呼叫其方法。  
  
 此範例會定義`MarshallableExample`類別，可以跨應用程式定義域界限封送處理。 此範例會建立目前執行的組件的路徑、 建立目標應用程式定義域，並使用<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>範例組件載入到目標應用程式定義域，並建立的執行個體的方法多載`MarshallableExample`。  
  
> [!NOTE]
>  路徑為絕對的在此範例中，但是相對路徑也可以運作，因為<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>方法用來載入組件。  
  
 之後進行解除包裝的物件控制代碼，此範例會示範三種方式可使用目標應用程式定義域中的物件：  
  
-   使用晚期繫結，使用反映，叫用方法。 這需要類型資訊，則組件載入至呼叫端的應用程式定義域。 （在此範例中，它已經載入。）  
  
-   轉型至呼叫端和被呼叫端知道介面的物件。 如果呼叫的組件中或第三個呼叫端和被呼叫端所參考的組件定義介面，呼叫的組件未載入至呼叫端的應用程式定義域。  
  
-   直接呼叫端知道其型別時，請使用物件。 組件必須載入至呼叫端的應用程式定義域。  
  
 若要避免被呼叫的組件載入至呼叫端的應用程式定義域的另一個方法是呼叫者是衍生自<xref:System.MarshalByRefObject>類別，以及定義目標應用程式定義域中執行的方法。 該方法可以使用反映來查看目標組件，因為目標組件已載入至目標應用程式定義域。 請參閱範例的<xref:System.AppDomain.DynamicDirectory%2A>屬性。  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.MissingMethodException">找不到無參數的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有足以呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyFile" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱 (包括路徑)，此檔案包含會定義要求之類型的組件。 此組件使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法載入。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
 此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>建立指定組件檔案中所定義之指定類型的新執行個體。</summary>
        <returns>對新執行個體而言是包裝函式的物件，但如果沒有找到 <paramref name="typeName" />，則為 <see langword="null" />。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設建構函式`typeName`叫用。  
  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域以外進行呼叫的應用程式定義域中的執行個體、 組件會在目標應用程式定義域中載入。 不過，如果呼叫的應用程式定義域中執行個體解除包裝，使用包裝的執行個體所規定的方式可能會導致要呼叫的應用程式定義域載入組件。 例如，執行個體已解除包裝之後，可能會要求其類型資訊，才能呼叫其方法晚期繫結。 組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。  
  
-   如果另一個版本的相同組件先前已載入至呼叫的應用程式定義域，或例如是不同的目標應用程式定義域的例外狀況呼叫的應用程式定義域的載入路徑<xref:System.MissingMethodException>可能會發生。  
  
-   如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>試圖轉換執行個體可能會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有足以呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyFile" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱 (包括路徑)，此檔案包含會定義要求之類型的組件。 此組件使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法載入。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <c>typeName</c> 建構函式的搜尋。 如果 <c>bindingAttr</c> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <c>binder</c> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <c>args</c> 必須是空陣列或 Null。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <c>args</c> 到型式類型 (為 <c>typeName</c> 建構函式宣告) 的強制轉型。 如果「文化特性 (Culture)」<c></c>是 <see langword="null" />，則使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
 此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>建立指定組件檔案中所定義之指定類型的新執行個體。</summary>
        <returns>對新執行個體而言是包裝函式的物件，但如果沒有找到 <paramref name="typeName" />，則為 <see langword="null" />。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。  
  
 當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域以外進行呼叫的應用程式定義域中的執行個體、 組件會在目標應用程式定義域中載入。 不過，如果呼叫的應用程式定義域中執行個體解除包裝，使用包裝的執行個體所規定的方式可能會導致要呼叫的應用程式定義域載入組件。 例如，執行個體已解除包裝之後，可能會要求其類型資訊，才能呼叫其方法晚期繫結。 組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。  
  
-   如果另一個版本的相同組件先前已載入至呼叫的應用程式定義域，或例如是不同的目標應用程式定義域的例外狀況呼叫的應用程式定義域的載入路徑<xref:System.MissingMethodException>可能會發生。  
  
-   如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>試圖轉換執行個體可能會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有足以呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
 -或-  
  
 用以編譯 <paramref name="assemblyFile" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱 (包括路徑)，此檔案包含會定義要求之類型的組件。 此組件使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法載入。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <c>typeName</c> 建構函式的搜尋。 如果 <c>bindingAttr</c> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <c>binder</c> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <c>args</c> 必須是空陣列或 Null。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <c>args</c> 到型式類型 (為 <c>typeName</c> 建構函式宣告) 的強制轉型。 如果「文化特性 (Culture)」<c></c>是 <see langword="null" />，則使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
 此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <param name="securityAttributes">用來授權建立 <c>typeName</c> 的資訊。</param>
        <summary>建立指定組件檔案中所定義之指定類型的新執行個體。</summary>
        <returns>對新執行個體而言是包裝函式的物件，但如果沒有找到 <paramref name="typeName" />，則為 <see langword="null" />。 傳回值需要解除包裝以存取實際物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域以外進行呼叫的應用程式定義域中的執行個體、 組件會在目標應用程式定義域中載入。 不過，如果呼叫的應用程式定義域中執行個體解除包裝，使用包裝的執行個體所規定的方式可能會導致要呼叫的應用程式定義域載入組件。 例如，執行個體已解除包裝之後，可能會要求其類型資訊，才能呼叫其方法晚期繫結。 組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。  
  
-   如果另一個版本的相同組件先前已載入至呼叫的應用程式定義域，或例如是不同的目標應用程式定義域的例外狀況呼叫的應用程式定義域的載入路徑<xref:System.MissingMethodException>可能會發生。  
  
-   如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>試圖轉換執行個體可能會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。  
  
 -或-  
  
 <paramref name="securityAttributes" /> 不是 <see langword="null" />。 若未啟用舊版 CAS 原則，<paramref name="securityAttributes" /> 應為 <see langword="null" />。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有足以呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyFile" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.NullReferenceException">這個執行個體是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立指定組件檔案中所定義之指定類型的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">定義所要求類型之組件的檔案名稱與路徑。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <summary>建立指定組件檔案中所定義之指定類型的新執行個體。</summary>
        <returns>要求的物件；當找不到 <paramref name="typeName" /> 時，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是便利的方法，它結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 這個方法會呼叫預設建構函式`typeName`。  
  
 如需詳細資訊，請參閱 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyName" /> 中找不到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到無參數的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有足以呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">定義所要求類型之組件的檔案名稱與路徑。</param>
        <param name="typeName">所要求類型的完整名稱，包括命名空間，但不包括組件 (請參閱 <see cref="P:System.Type.FullName" /> 屬性)。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
 此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>建立指定組件檔案中所定義之指定類型的新執行個體。</summary>
        <returns>要求的物件；當找不到 <paramref name="typeName" /> 時，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是便利的方法，它結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 這個方法會呼叫預設建構函式`typeName`。  
  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyName" /> 中找不到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到無參數的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有足以呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">定義所要求類型之組件的檔案名稱與路徑。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <c>typeName</c> 建構函式的搜尋。 如果 <c>bindingAttr</c> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <c>binder</c> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <c>args</c> 必須是空陣列或 Null。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <c>args</c> 到型式類型 (為 <c>typeName</c> 建構函式宣告) 的強制轉型。 如果「文化特性 (Culture)」<c></c>是 <see langword="null" />，則使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
 此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>藉由指定是否忽略類型名稱的大小寫、用於選取要建立之類型的繫結屬性和繫結器、建構函式的引數、文化特性，以及啟動屬性，為指定之組件檔中定義的指定類型，建立新的執行個體。</summary>
        <returns>要求的物件；當找不到 <paramref name="typeName" /> 時，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是便利的方法，它結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyName" /> 中找不到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有足以呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
 -或-  
  
 用以編譯 <paramref name="assemblyName" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">定義所要求類型之組件的檔案名稱與路徑。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</param>
        <param name="ignoreCase">布林值，指出是否執行區分大小寫的搜尋。</param>
        <param name="bindingAttr">零或多個位元旗標的組合，此位元旗標會影響 <c>typeName</c> 建構函式的搜尋。 如果 <c>bindingAttr</c> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。 如果 <c>binder</c> 為 null，則會使用預設繫結器。</param>
        <param name="args">要傳遞到建構函式的引數。 這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。 如果慣用預設的建構函式，則 <c>args</c> 必須是空陣列或 Null。</param>
        <param name="culture">特定文化特性的資訊，其可控制 <c>args</c> 到型式類型 (為 <c>typeName</c> 建構函式宣告) 的強制轉型。 如果「文化特性 (Culture)」<c></c>是 <see langword="null" />，則使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  
  
 此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <param name="securityAttributes">用來授權建立 <c>typeName</c> 的資訊。</param>
        <summary>建立指定組件檔案中所定義之指定類型的新執行個體。</summary>
        <returns>要求的物件；當找不到 <paramref name="typeName" /> 時，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是便利的方法，它結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.TypeLoadException">
          在 <paramref name="assemblyName" /> 中找不到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的公用建構函式。</exception>
        <exception cref="T:System.MethodAccessException">呼叫端沒有足以呼叫這個建構函式的權限。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單之檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see cref="T:System.Threading.Thread" /> 的目前應用程式定義域。</summary>
        <value>目前的應用程式定義域。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會建立新的應用程式定義域。 <xref:System.AppDomain.CurrentDomain%2A>屬性用來取得<xref:System.AppDomain>物件，代表目前的應用程式定義域。 <xref:System.AppDomain.FriendlyName%2A>屬性提供的名稱，即會顯示在命令列的目前應用程式定義域。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在目前的應用程式定義域中定義動態組件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">提供給動態組件的存取模式。</param>
        <summary>使用指定的名稱和存取模式定義動態組件。</summary>
        <returns>使用指定名稱和存取模式的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
> [!NOTE]
>  在開發期間發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並且包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>中`refusedPermissions`參數可確保已驗證的 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">提供給動態組件的存取模式。</param>
        <param name="assemblyAttributes">要套用到組件的可列舉屬性清單，如果沒有任何屬性，則是 <see langword="null" />。</param>
        <summary>使用指定的名稱、存取模式及自訂屬性來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法多載來指定無法正常運作除非建立動態組件時，它們會套用的屬性。 例如，安全性等屬性時<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果建立動態組件之後加入。  
  
 這個方法應用於只在目前的應用程式定義域中定義動態組件。 如需有關這項限制的詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 中引進這個方法多載[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立動態組件具有<xref:System.Security.SecurityTransparentAttribute>。 屬性必須指定陣列的項目為<xref:System.Reflection.Emit.CustomAttributeBuilder>物件。  
  
 建立第一個步驟<xref:System.Reflection.Emit.CustomAttributeBuilder>，取得屬性的建構函式。 建構函式具有任何參數，所以<xref:System.Type.GetConstructor%2A>方法呼叫的空陣列<xref:System.Type>物件，以表示參數的類型。 第二個步驟是將產生<xref:System.Reflection.ConstructorInfo>物件的建構函式<xref:System.Reflection.Emit.CustomAttributeBuilder>類別，以及類型的空陣列<xref:System.Object>來表示引數。  
  
 產生<xref:System.Reflection.Emit.CustomAttributeBuilder>會接著傳遞給<xref:System.AppDomain.DefineDynamicAssembly%2A>方法以做為陣列的唯一項目。  
  
 範例程式碼模組和類型會定義新的動態組件，並顯示組件的屬性。  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="name" /> 的 <see langword="Name" /> 屬性以泛空白字元開頭，或者含有斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="evidence">提供給動態組件的辨識項。 此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</param>
        <summary>使用指定的名稱、存取模式和辨識項來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有完全受信任的呼叫端可以提供其`evidence`定義動態時<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與權限。 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`是`null`，執行階段將複製的權限集合，也就是目前授與及拒絕呼叫者的集合，<xref:System.Reflection.Assembly>來動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>會儲存到磁碟，後續的載入時，會與位置關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
> [!NOTE]
>  在開發期間發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並且包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>中`refusedPermissions`參數可確保已驗證的 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 首先，程式碼範例會嘗試建立的執行個體`MyDynamicType`藉由呼叫<xref:System.AppDomain.CreateInstance%2A>方法具有無效的組件名稱，並攔截產生的例外狀況。  
  
 程式碼範例將事件處理常式<xref:System.AppDomain.AssemblyResolve>事件，並再次嘗試建立的執行個體`MyDynamicType`。 若要在呼叫期間<xref:System.AppDomain.CreateInstance%2A>、<xref:System.AppDomain.AssemblyResolve>無效的組件都會引發事件。 此事件處理常式會建立動態組件包含名為類型`MyDynamicType`，會提供類型的無參數建構函式，並傳回新的動態組件。 呼叫<xref:System.AppDomain.CreateInstance%2A>成功，然後完成的建構函式和`MyDynamicType`主控台會顯示訊息。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存組件的目錄名稱。 如果 <c>dir</c> 為 <see langword="null" />，目錄會預設為目前的目錄。</param>
        <summary>使用指定的名稱、存取模式和儲存目錄來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
> [!NOTE]
>  在開發期間發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並且包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>中`refusedPermissions`參數可確保已驗證的 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">提供給動態組件的存取模式。</param>
        <param name="assemblyAttributes">要套用到組件的可列舉屬性清單，如果沒有任何屬性，則是 <see langword="null" />。</param>
        <param name="securityContextSource">安全性內容的來源。</param>
        <summary>定義動態組件，這個動態組件具有指定的名稱、存取模式和自訂模式，並且使用指定的來源做為安全性內容。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法多載來指定無法正常運作除非建立動態組件時，它們會套用的屬性。 例如，安全性等屬性時<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果建立動態組件之後加入。  
  
 這個方法應用於只在目前的應用程式定義域中定義動態組件。 如需有關這項限制的詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="name" /> 的 <see langword="Name" /> 屬性以泛空白字元開頭，或者含有斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="securityContextSource" /> 的值不是其中一個列舉值。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存組件的目錄名稱。 如果 <c>dir</c> 為 <see langword="null" />，目錄會預設為目前的目錄。</param>
        <param name="evidence">提供給動態組件的辨識項。 此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</param>
        <summary>使用指定的名稱、存取模式、儲存目錄和辨識項來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有完全受信任的呼叫端可以提供其`evidence`定義動態時<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與權限。 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`是`null`，執行階段將複製的權限集合，也就是目前授與及拒絕呼叫者的集合，<xref:System.Reflection.Assembly>來動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>會儲存到磁碟，後續的載入時，會與位置關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
> [!NOTE]
>  在開發期間發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並且包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>中`refusedPermissions`參數可確保已驗證的 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="requiredPermissions">必要的權限要求。</param>
        <param name="optionalPermissions">選擇性的權限要求。</param>
        <param name="refusedPermissions">拒絕的權限要求。</param>
        <summary>使用指定的名稱、存取模式和權限要求來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不會使用，除非已儲存並載入記憶體的動態組件。 不會儲存到磁碟，請使用多載的暫時性組件的指定權限要求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項也會為要求的權限，並提供為<xref:System.Security.Policy.Evidence>物件。  
  
> [!NOTE]
>  在開發期間發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並且包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>中`refusedPermissions`參數可確保已驗證的 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存動態組件的目錄名稱。 如果 <c>dir</c> 是 <see langword="null" />，就會使用目前的目錄。</param>
        <param name="isSynchronized">
          若要在動態組件中同步建立模組、類型和成員，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <param name="assemblyAttributes">要套用到組件的可列舉屬性清單，如果沒有任何屬性，則是 <see langword="null" />。</param>
        <summary>使用指定的名稱、存取模式、儲存目錄和同步處理選項來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法多載來指定無法正常運作除非建立動態組件時，它們會套用的屬性。 例如，安全性等屬性時<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果建立動態組件之後加入。  
  
 如果`isSynchronized`是`true`，產生的下列方法<xref:System.Reflection.Emit.AssemblyBuilder>將同步處理： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 如果這些方法的兩個不同的執行緒上呼叫，其中一個會封鎖直到另完成為止。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="name" /> 的 <see langword="Name" /> 屬性以泛空白字元開頭，或者含有斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="evidence">提供給動態組件的辨識項。 此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</param>
        <param name="requiredPermissions">必要的權限要求。</param>
        <param name="optionalPermissions">選擇性的權限要求。</param>
        <param name="refusedPermissions">拒絕的權限要求。</param>
        <summary>使用指定的名稱、存取模式、辨識項和權限要求來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，並載入記憶體。  
  
> [!NOTE]
>  在開發期間發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`。 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>中`refusedPermissions`參數可確保已驗證的 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 只有完全受信任的呼叫端可以提供其`evidence`定義動態時<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與權限。 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`是`null`，執行階段將複製的權限集合，也就是目前授與及拒絕呼叫者的集合，<xref:System.Reflection.Assembly>來動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>會儲存到磁碟，後續的載入時，會與位置關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存組件的目錄名稱。 如果 <c>dir</c> 為 <see langword="null" />，目錄會預設為目前的目錄。</param>
        <param name="requiredPermissions">必要的權限要求。</param>
        <param name="optionalPermissions">選擇性的權限要求。</param>
        <param name="refusedPermissions">拒絕的權限要求。</param>
        <summary>使用指定的名稱、存取模式、儲存目錄和權限要求來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不會使用，除非已儲存並載入記憶體的動態組件。 不會儲存到磁碟，請使用多載的暫時性組件的指定權限要求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項也會為要求的權限，並提供為<xref:System.Security.Policy.Evidence>物件。  
  
> [!NOTE]
>  在開發期間發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並且包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>中`refusedPermissions`參數可確保已驗證的 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存組件的目錄名稱。 如果 <c>dir</c> 為 <see langword="null" />，目錄會預設為目前的目錄。</param>
        <param name="evidence">提供給動態組件的辨識項。 此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</param>
        <param name="requiredPermissions">必要的權限要求。</param>
        <param name="optionalPermissions">選擇性的權限要求。</param>
        <param name="refusedPermissions">拒絕的權限要求。</param>
        <summary>使用指定的名稱、存取模式、儲存目錄、辨識項和權限要求來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，並載入記憶體。  
  
> [!NOTE]
>  在開發期間發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`。 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>中`refusedPermissions`參數可確保已驗證的 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 只有完全受信任的呼叫端可以提供其`evidence`定義動態時<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與權限。 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`是`null`，執行階段將複製的權限集合，也就是目前授與及拒絕呼叫者的集合，<xref:System.Reflection.Assembly>來動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>會儲存到磁碟，後續的載入時，會與位置關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存動態組件的目錄名稱。 如果 <c>dir</c> 為 <see langword="null" />，目錄會預設為目前的目錄。</param>
        <param name="evidence">提供給動態組件的辨識項。 此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</param>
        <param name="requiredPermissions">必要的權限要求。</param>
        <param name="optionalPermissions">選擇性的權限要求。</param>
        <param name="refusedPermissions">拒絕的權限要求。</param>
        <param name="isSynchronized">
          若要在動態組件中同步建立模組、類型和成員，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>使用指定的名稱、存取模式、儲存目錄、辨識項、權限要求和同步選項來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，並載入記憶體。  
  
> [!NOTE]
>  在開發期間發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`。 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>中`refusedPermissions`參數可確保已驗證的 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 只有完全受信任的呼叫端可以提供的辨識項時定義動態<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與權限。 部分信任的呼叫端必須提供`null`如`evidence`參數。 如果`evidence`是`null`，執行階段將複製的權限集合，也就是目前授與及拒絕呼叫者的集合，<xref:System.Reflection.Assembly>來動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>會儲存到磁碟，後續的載入時，會與位置關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 如果`isSynchronized`是`true`，產生的下列方法<xref:System.Reflection.Emit.AssemblyBuilder>將同步處理： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 如果這些方法的兩個不同的執行緒上呼叫，其中一個會封鎖直到另完成為止。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">動態組件的唯一識別。</param>
        <param name="access">將用來存取動態組件的模式。</param>
        <param name="dir">將儲存動態組件的目錄名稱。 如果 <c>dir</c> 是 <see langword="null" />，就會使用目前的目錄。</param>
        <param name="evidence">提供給動態組件的辨識項。 此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</param>
        <param name="requiredPermissions">必要的權限要求。</param>
        <param name="optionalPermissions">選擇性的權限要求。</param>
        <param name="refusedPermissions">拒絕的權限要求。</param>
        <param name="isSynchronized">
          若要在動態組件中同步建立模組、類型和成員，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <param name="assemblyAttributes">要套用到組件的可列舉屬性清單，如果沒有任何屬性，則是 <see langword="null" />。</param>
        <summary>使用指定的名稱、存取模式、儲存目錄、辨識項、權限要求、同步選項及自訂屬性來定義動態組件。</summary>
        <returns>使用指定名稱和功能的動態組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法多載來指定無法正常運作除非建立動態組件時，它們會套用的屬性。 例如，安全性等屬性時<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果建立動態組件之後加入。  
  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`參數，才使用`evidence`也提供參數，或如果儲存動態組件，並載入記憶體。  
  
> [!NOTE]
>  當您開發發出動態組件的程式碼時，我們建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>加上旗標`refusedPermissions`參數。 納入這個旗標，可確保的 Microsoft intermediate language (MSIL)，即會驗證。 這項技術會偵測到無法驗證的程式碼，否則這可能會很難偵測到不小心產生。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼使用它時擲回。  
  
 只有完全受信任的呼叫端可以提供辨識項時定義動態<xref:System.Reflection.Assembly>。 執行階段對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與權限。 部分信任的呼叫端必須提供`null`如`evidence`參數。 如果`evidence`是`null`，執行階段將權限集合 （也就是，目前的授與及拒絕集） 從呼叫者的組件複製到正在定義，並將原則標記為已解決的動態組件。  
  
 如果在動態組件會儲存至磁碟，則後續載入時，會授與儲存動態組件的位置與相關聯的原則為基礎。  
  
 如果`isSynchronized`是`true`，產生的下列方法<xref:System.Reflection.Emit.AssemblyBuilder>將同步處理： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 如果這些方法的兩個不同的執行緒上呼叫，其中一個會封鎖直到另完成為止。  
  
 中引進這個方法多載[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="name" /> 的 <see langword="Name" /> 屬性以泛空白字元開頭，或者含有斜線或反斜線。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">指定要呼叫之方法的委派。</param>
        <summary>在指定的委派所識別的其他應用程式定義域中執行程式碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` 可以指定封送處理傳值方式， <xref:System.MarshalByRefObject>，或<xref:System.ContextBoundObject>。  
  
   
  
## Examples  
 下列範例將示範如何使用靜態<xref:System.AppDomain.DoCallBack%2A>方法。  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 下列範例將示範如何使用<xref:System.AppDomain.DoCallBack%2A>方法的值。  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 下列範例將示範如何使用<xref:System.AppDomain.DoCallBack%2A>所參考的方法。  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得在已經初始化應用程式定義域時，由主應用程式提供的定義域管理員。</summary>
        <value>物件，表示在已經初始化應用程式定義域時，由主應用程式提供的定義域管理員；如果未提供任何定義域管理員，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 受管理的主機，common language runtime (CLR) 可以提供網域管理員。 網域管理員可以參與初始化新的應用程式定義域，並提供其他管理員，例如<xref:System.Security.HostSecurityManager>，參與應用程式定義域的作業。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於將要卸載 <see cref="T:System.AppDomain" /> 時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler>委派這個事件可以在應用程式網域卸載之前執行任何終止活動。  
  
 每個應用程式定義域中需要執行處理卸載時應該註冊此事件的事件處理常式。 不能使用共用的事件處理常式，因為<xref:System.EventHandler>委派不會識別正在卸載的網域。  
  
> [!NOTE]
>  預設應用程式定義域中永遠不會引發這個事件。  
  
 請勿在執行緒引發事件的相關假設。 可能比呼叫不同的執行緒上引發此事件<xref:System.AppDomain.Unload%2A>方法。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得組件解析程式用來探查動態建立之組件的目錄。</summary>
        <value>組件解析程式用來探查以動態建立組件的目錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要設定動態目錄，將指定之基底目錄路徑<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>屬性<xref:System.AppDomainSetup>將用來建立新的應用程式定義域的物件。 修改指派給屬性的基底目錄路徑的簡單名稱是指派給字串的雜湊程式碼的子目錄<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>屬性，因此基底目錄的格式是*原始路徑* \\*雜湊碼*。 動態目錄是此基底目錄的子目錄。 其簡單的名稱為的值<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>屬性，因此其格式是*原始路徑*\\*雜湊碼*\\*應用程式名稱*。  
  
   
  
## Examples  
 下列範例與目錄的應用程式定義域建立動態組件、 發出動態組件並將它儲存在動態目錄中，對新的應用程式定義域載入組件然後使用它。  
  
 此範例會建立<xref:System.AppDomainSetup>物件，然後設定其<xref:System.AppDomainSetup.ApplicationName%2A>「 範例 」 的屬性和其<xref:System.AppDomainSetup.DynamicBase%2A>"C:\DynamicAssemblyDir"的屬性。 此範例接著會顯示<xref:System.AppDomainSetup.DynamicBase%2A>屬性，以顯示應用程式名稱的雜湊碼，做為原本指派路徑的子目錄已附加。  
  
> [!NOTE]
>  在此範例中的基底目錄就是要外之探查路徑中的範例應用程式。 請務必編譯此範例中不同的位置。 刪除基底目錄和其所有子目錄每次您執行範例。  
  
 此範例會建立新的應用程式定義域中，使用<xref:System.AppDomainSetup>物件。 此範例會使用<xref:System.AppDomain.DynamicDirectory%2A>屬性來擷取目錄的名稱，因此它可以建立該目錄。 （此範例無法輕鬆地建立目錄事先藉由串連的原始路徑，雜湊程式碼的應用程式名稱，而應用程式名稱）。  
  
 此範例包含`GenerateDynamicAssembly`方法發出的組件名為`DynamicHelloWorld.dll`並將它儲存在新的應用程式定義域動態目錄中。 動態組件包含一種類型， `HelloWorld`，具有靜態方法 (`Shared`在 Visual Basic 中的方法) 名為`HelloFromAD`。 呼叫這個方法會顯示應用程式網域的名稱。  
  
 `Example`類別衍生自<xref:System.MarshalByRefObject>，因此此範例可以建立類別的執行個體中的新應用程式定義域和呼叫其`Test`方法。 `Test`方法會依其顯示名稱載入的動態組件，並呼叫靜態`HelloFromAD`方法。  
  
 您可以顯示動態目錄搜尋一般探查路徑之後，撰寫程式碼組件名為`DynamicHelloWorld.dll`及編譯此範例中的相同目錄中。 組件必須具有名為類別`HelloWorld`的靜態方法，名為`HelloFromAD`。 這個方法不需要具有相同的功能與在範例中。它只可以在主控台中顯示字串。 組件也必須<xref:System.Reflection.AssemblyVersionAttribute>其版本設定為 1.0.0.0 設定的屬性。 當您執行範例時，才能動態目錄中搜尋找到您目前的目錄中編譯的組件。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取路徑資訊。 關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與此應用程式定義域相關聯的 <see cref="T:System.Security.Policy.Evidence" />。</summary>
        <value>與此應用程式定義域相關聯的辨識項。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>執行包含在指定檔案中的組件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要執行之組件的檔案名稱。</param>
        <summary>執行包含在指定檔案中的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始在.NET Framework 標頭中指定的進入點執行。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
 若要建立<xref:System.AppDomain>載入和執行，請使用<xref:System.AppDomain.CreateDomain%2A>方法。  
  
   
  
## Examples  
 下列範例將示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>兩個不同網域上。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyFile" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件不具任何進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要執行之組件的檔案名稱。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <summary>使用指定的辨識項，執行包含在指定檔案中的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始在.NET Framework 標頭中指定的進入點執行。  
  
 <xref:System.AppDomain.ExecuteAssembly%2A>方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下列範例將示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>兩個不同網域上。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyFile" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件不具任何進入點。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要執行之組件的檔案名稱。</param>
        <param name="args">組件的進入點引數。</param>
        <summary>使用指定的引數，執行包含在指定檔案中的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始在.NET Framework 標頭中指定的進入點執行。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下列範例將示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>兩個不同網域上。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
 -或-  
  
 用以編譯 <paramref name="assemblyFile" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件不具任何進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要執行之組件的檔案名稱。</param>
        <param name="assemblySecurity">組件的提供辨識項。</param>
        <param name="args">組件的進入點引數。</param>
        <summary>使用指定的辨識項和引數，執行包含在指定檔案中的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始在.NET Framework 標頭中指定的進入點執行。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下列範例將示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>兩個不同網域上。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyFile" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> 不是 <see langword="null" />。 若未啟用舊版 CAS 原則，<paramref name="assemblySecurity" /> 應為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件不具任何進入點。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要執行之組件的檔案名稱。</param>
        <param name="args">組件的進入點引數。</param>
        <param name="hashValue">表示計算出來的雜湊碼的值。</param>
        <param name="hashAlgorithm">表示組件資訊清單所使用的雜湊演算法。</param>
        <summary>使用指定的引數、雜湊值和雜湊演算法，執行包含在指定檔案中的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始在.NET Framework 標頭中指定的進入點執行。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下列範例將示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>兩個不同網域上。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
 -或-  
  
 用以編譯 <paramref name="assemblyFile" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件不具任何進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要執行之組件的檔案名稱。</param>
        <param name="assemblySecurity">組件的提供辨識項。</param>
        <param name="args">組件的進入點引數。</param>
        <param name="hashValue">表示計算出來的雜湊碼的值。</param>
        <param name="hashAlgorithm">表示組件資訊清單所使用的雜湊演算法。</param>
        <summary>使用指定的辨識項、引數、雜湊值和雜湊演算法，執行包含在指定檔案中的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始在.NET Framework 標頭中指定的進入點執行。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 ︰ 範例將示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>兩個不同網域上。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyFile" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> 不是 <see langword="null" />。 若未啟用舊版 CAS 原則，<paramref name="assemblySecurity" /> 應為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件不具任何進入點。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>執行組件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <summary>執行需提供其顯示名稱的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入組件與<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始在.NET Framework 標頭中指定的進入點執行。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 若要建立<xref:System.AppDomain>載入和執行，請使用<xref:System.AppDomain.CreateDomain%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" /> 所指定的組件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 所指定的組件不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyName" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件不具任何進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，讓存取本身，在路徑中的資訊，並將顯示名稱重新導向到路徑的讀取權限。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <see cref="T:System.Reflection.AssemblyName" /> 物件，代表組件的名稱。</param>
        <param name="args">啟動處理程序時要傳遞的命令列引數。</param>
        <summary>使用指定的引數，執行具有指定之 <see cref="T:System.Reflection.AssemblyName" /> 的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入組件與<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始在.NET Framework 標頭中指定的進入點執行。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" /> 所指定的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 所指定的組件不是有效的組件。  
  
 -或-  
  
 用以編譯 <paramref name="assemblyName" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件不具任何進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，讓存取本身，在路徑中的資訊，並將顯示名稱重新導向到路徑的讀取權限。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <summary>使用指定之辨識項，執行需提供其顯示名稱的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入組件與<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始在.NET Framework 標頭中指定的進入點執行。  
  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
> [!NOTE]
>  當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法<xref:System.Security.Policy.Evidence>合併片段的辨識項的參數。 做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代載入器所提供的辨識項的片段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" /> 所指定的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 所指定的組件不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyName" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件不具任何進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，讓存取本身，在路徑中的資訊，並將顯示名稱重新導向到路徑的讀取權限。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="args">啟動處理程序時要傳遞的命令列引數。</param>
        <summary>使用指定的引數，執行具有指定之顯示名稱的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入組件與<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始在.NET Framework 標頭中指定的進入點執行。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" /> 所指定的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 所指定的組件不是有效的組件。  
  
 -或-  
  
 用以編譯 <paramref name="assemblyName" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件不具任何進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，讓存取本身，在路徑中的資訊，並將顯示名稱重新導向到路徑的讀取權限。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <see cref="T:System.Reflection.AssemblyName" /> 物件，代表組件的名稱。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <param name="args">啟動處理程序時要傳遞的命令列引數。</param>
        <summary>使用指定之辨識項和引數，執行需提供 <see cref="T:System.Reflection.AssemblyName" /> 的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入組件與<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始在.NET Framework 標頭中指定的進入點執行。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
> [!NOTE]
>  當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法<xref:System.Security.Policy.Evidence>合併片段的辨識項的參數。 做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代載入器所提供的辨識項的片段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" /> 所指定的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 所指定的組件不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyName" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> 不是 <see langword="null" />。 若未啟用舊版 CAS 原則，<paramref name="assemblySecurity" /> 應為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件不具任何進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，讓存取本身，在路徑中的資訊，並將顯示名稱重新導向到路徑的讀取權限。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <param name="args">啟動處理程序時要傳遞的命令列引數。</param>
        <summary>使用指定之辨識項和引數，執行需提供其顯示名稱的組件。</summary>
        <returns>組件的進入點所傳回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入組件與<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始在.NET Framework 標頭中指定的進入點執行。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
> [!NOTE]
>  當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法<xref:System.Security.Policy.Evidence>合併片段的辨識項的參數。 做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代載入器所提供的辨識項的片段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" /> 所指定的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 所指定的組件不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyName" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> 不是 <see langword="null" />。 若未啟用舊版 CAS 原則，<paramref name="assemblySecurity" /> 應為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">指定的組件不具任何進入點。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，讓存取本身，在路徑中的資訊，並將顯示名稱重新導向到路徑的讀取權限。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">執行主控台應用程式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於執行階段在呼叫堆疊中搜尋應用程式定義域的例外狀況處理常式之前，在 Managed 程式碼中擲回例外狀況時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件是只有通知。 處理這個事件不會處理此例外狀況或會影響後續的例外狀況以任何方式處理。 在引發事件，並已叫用事件處理常式之後，common language runtime (CLR) 會開始搜尋的例外狀況處理常式。 <xref:System.AppDomain.FirstChanceException> 應用程式定義域提供第一個有機會檢查任何 managed 例外狀況。  
  
 每個應用程式定義域可以處理事件。 如果執行緒通過時執行呼叫的多個應用程式定義域，CLR 開始搜尋應用程式定義域中相符的例外狀況處理常式之前，已註冊的事件處理常式中，每個應用程式定義域中引發事件。 在處理事件之後，搜尋會針對應用程式定義域中相符的例外狀況處理常式。 如果找不到下, 一個應用程式定義域中引發事件。  
  
 您必須處理所有例外狀況發生在事件處理常式的<xref:System.AppDomain.FirstChanceException>事件。 否則，<xref:System.AppDomain.FirstChanceException>遞迴引發。 這可能會導致堆疊溢位和應用程式終止。 我們建議您為限制的執行區域 (Cer)，實作此事件的事件處理常式，以防止基礎結構相關例外狀況，例如記憶體不足或堆疊溢位例外狀況通知時，會影響虛擬機器正在處理中。  
  
 不會引發這個事件的例外狀況，表示損毀的程序的狀態，例如存取違規，除非此事件處理常式為安全性關鍵的而且有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>屬性。  
  
 在處理此通知事件時，common language runtime 會暫止執行緒中止。  
  
   
  
## Examples  
 下列範例會建立名為應用程式定義域的一系列`AD0`透過`AD3`，與`Worker`每個應用程式定義域中的物件。 每個`Worker`物件具有參考`Worker`物件中下一個應用程式定義域中，除了`Worker`最後一個應用程式定義域中。 <xref:System.AppDomain.FirstChanceException>以外的所有應用程式網域中處理事件`AD1`。  
  
> [!NOTE]
>  除了本範例，示範如何在多個應用程式定義域中的第一個出現的例外狀況通知，您可以找到簡單的使用案例仍在[如何： 接收 First-chance 例外狀況通知](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)。  
  
 預設應用程式定義域時已建立應用程式定義域，呼叫`TestException`方法的第一個應用程式定義域。 每個`Worker`物件會呼叫`TestException`方法下一步的應用程式定義域，直到最後一個`Worker`擲回的例外狀況處理，或未處理的。 因此，目前的執行緒通過所有應用程式定義域，並`TestException`加入至每個應用程式定義域中的堆疊。  
  
 當最後一個`Worker`物件會處理例外狀況，<xref:System.AppDomain.FirstChanceException>只有在最後一個應用程式定義域引發事件。 其他應用程式定義域永遠不會有機會處理例外狀況，因此不會引發事件。  
  
 當最後一個`Worker`物件不會處理例外狀況，<xref:System.AppDomain.FirstChanceException>每個應用程式定義域中具有事件處理常式就會引發事件。 每個事件處理常式已完成之後，會繼續堆疊回溯直到預設應用程式定義域攔截例外狀況。  
  
> [!NOTE]
>  若要查看如何堆疊顯示隨著接近引發事件並使其更接近預設應用程式定義域，變更`e.Exception.Message`至`e.Exception`中`FirstChanceHandler`事件處理常式。 請注意，當`TestException`稱為跨應用程式網域界限，會出現兩次： 一次來進行 proxy 和虛設常式一次。  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式定義域的易記名稱。</summary>
        <value>這個應用程式定義域的易記名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設應用程式定義域的易記名稱是處理程序可執行檔的檔案名稱。 例如，如果用來啟動處理程序的可執行檔是`"c:\MyAppDirectory\MyAssembly.exe"`，預設應用程式定義域的易記名稱是`"MyAssembly.exe"`。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.AppDomain.FriendlyName%2A>屬性來取得目前應用程式定義域的易記名稱。 預設應用程式定義域的易記名稱會是應用程式的可執行檔的名稱。 程式碼範例也會顯示應用程式定義域有關的其他資訊。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得已載入至這個應用程式定義域之執行內容的組件。</summary>
        <returns>這個應用程式定義域中的組件陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例使用<xref:System.AppDomain.GetAssemblies%2A>方法來取得已載入至應用程式定義域的所有組件清單。 組件隨即顯示到主控台。  
  
 若要執行這個程式碼範例，您必須建立名為組件`CustomLibrary.dll`，或變更組件名稱傳遞給<xref:System.AppDomain.GetAssemblies%2A>方法。  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得目前的執行緒識別項。</summary>
        <returns>32 位元帶正負號的整數 (Signed Integer)，其為目前執行緒的識別項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>屬性，也就是穩定即使當.NET Framework 由支援 fiber （也就是輕量型執行緒） 的環境。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫這個方法。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">預先定義的應用程式定義域屬性的名稱，或是已經定義的應用程式定義域屬性的名稱。</param>
        <summary>針對指定之名稱取得儲存在目前應用程式定義域中的值。</summary>
        <returns>
          <paramref name="name" /> 屬性的值；如果這個屬性不存在，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來擷取值的描述屬性的這個執行個體的名稱資料組的內部快取中的項目<xref:System.AppDomain>。 請注意，比較的`name`具有索引鍵-值組的名稱會區分大小寫。  
  
 快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。 您可以檢查其值與<xref:System.AppDomain.GetData%2A>方法或對等<xref:System.AppDomainSetup>屬性。  
  
 您可以插入或修改與您的使用者定義名稱資料組<xref:System.AppDomain.SetData%2A>方法，並查看其值與<xref:System.AppDomain.GetData%2A>方法。  
  
 下表描述`name`每個預先定義的系統項目和其相對應<xref:System.AppDomainSetup>屬性。  
  
|'Name' 的值|屬性|  
|---------------------|--------------|  
|「 APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|（沒有屬性）<br /><br /> "APP_LAUNCH_URL 」 表示使用者之前的任何重新導向, 原本要求的 URL。 它只有時使用已啟動應用程式，例如 Internet Explorer 的瀏覽器。 並非所有瀏覽器提供此值。|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|（沒有屬性）|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|「 LICENSE_FILE"或特定應用程式的字串|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|「 LOCATION_URI"|（沒有屬性）|  
|"PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> 「 REGEX_DEFAULT_MATCH_TIMEOUT"不是系統項目和其值可以藉由呼叫設定<xref:System.AppDomain.SetData%2A>方法。|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 下列範例會建立新的應用程式定義域、 設定系統提供的值，並將新的值組的網域。 下列範例示範如何使用<xref:System.AppDomain.GetData%2A>方法來擷取這些值組的資料，並對主控台顯示它們。  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取本身，如果此屬性會套用至路徑的路徑中的資訊。 關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得目前執行個體的類型。</summary>
        <returns>目前執行個體的類型。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可唯一識別處理程序中之應用程式定義域的整數。</summary>
        <value>可識別應用程式定義域的整數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會建立第二個應用程式定義域，並顯示預設網域與新網域的相關資訊。  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>藉由防止建立租用 (Lease)，為 <see cref="T:System.AppDomain" /> 提供無限的存留期。</summary>
        <returns>一定是 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要測試的相容性參數。</param>
        <summary>取得可為 Null 的布林值，這個值表示是否已設定任何相容性參數，如果已設定，是否已設定指定的相容性參數。</summary>
        <returns>如果未設定任何相容性參數則為 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)；否則為布林值，以表示是否已設定 <paramref name="value" /> 所指定之相容性參數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會測試是否已針對目前的應用程式定義域設定指定的相容性參數。 相容性參數通常還原行為 （例如排序方式字串），.NET Framework 版本之間變更。  藉由呼叫設定<xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType>方法，然後再建立應用程式定義域。  
  
 下表提供可以還原舊版.NET Framework 的行為設定的相容性參數的範例。  
  
|參數|意義|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|程式碼存取安全性 (CAS)[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]啟用這個應用程式定義域中。 請參閱[ &lt;NetFx40_LegacySecurityPolicy&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)。|  
|"NetFx40_Legacy20SortingBehavior"|排序的預設值的字串[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]這個應用程式定義域中已啟用。 它的成功與否需要 sort00001000.dll 安裝。 請參閱[ &lt;CompatSortNLSVersion&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)。|  
|"NetFx40_Legacy40SortingBehavior"|排序的預設值的字串[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]而且 Unicode 5.0 已啟用這個應用程式定義域中。 它的成功與否需要 sort00060101.dll 安裝。|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> 格式化行為[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]啟用這個應用程式定義域中。  請參閱[ &lt;TimeSpan_LegacyFormatMode&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)和 「 還原舊版 TimeSpan 格式 」 的區段<xref:System.TimeSpan>主題。|  
|"UseRandomizedStringHashAlgorithm"|執行階段計算字串的雜湊程式碼上每個應用程式網域為基礎，而不是使用單一的雜湊演算法產生一致的雜湊程式碼在應用程式定義域。 請參閱[ &lt;UseRandomizedStringHashAlgorithm&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，指出應用程式定義域是否為該處理程序的預設應用程式定義域。</summary>
        <returns>
          如果目前的 <see cref="T:System.AppDomain" /> 物件代表處理程序的預設應用程式定義域，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個受管理的程序具有預設應用程式定義域。 在 預設網域，開始執行。  
  
   
  
## Examples  
 下列程式碼範例會建立第二個應用程式定義域，並顯示預設網域與新網域的相關資訊。  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示這個應用程式定義域是否正在卸載，以及其包含的物件是否正在由 Common Language Runtime 進行最終處理。</summary>
        <returns>
          如果這個應用程式定義域正在卸載且 Common Language Runtime 已開始叫用完成項，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 物件的最終處理方法會提供物件的記憶體回收之前執行任何必要的清除作業的機會。 最終處理物件之後存取，但處於無效狀態，因此無法使用。 最後，記憶體回收完成，並回收物件。  
  
 物件的最終處理方法會呼叫其中一種在下列情況： 記憶體回收期間，當正在關閉通用語言執行平台，或包含物件的應用程式定義域卸載時。 <xref:System.AppDomain.IsFinalizingForUnload%2A>方法會傳回`true`只能在最後一個的情況; 它不會傳回`true`如果最終處理而產生從常式回收或 CLR 關機。  
  
> [!NOTE]
>  若要判斷是否因為 CLR 關閉而最終處理，請使用<xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType>屬性。 它會傳回`true`最終處理是否由於應用程式定義域正在卸載或 clr 正在關閉。  
  
 執行時在最終處理方法定義域卸載時，可能會想要存取另一個物件參考的靜態欄位，且具有最終處理方法。 不過，您無法可靠地達成因為所存取的物件可能有已完成。  
  
> [!NOTE]
>  此規則的例外是<xref:System.Console>類別，其中包含參考資料流物件的靜態欄位，但特別讓您可以撰寫主控台中，即使在網域卸載或系統關機期間實作。  
  
 使用此方法中的物件最終處理方法，以判斷是否包含物件的應用程式定義域正在卸載。 如果是這樣，您無法可靠地存取任何物件具有最終處理方法，並由靜態欄位參考。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，該值指出載入目前應用程式定義域中的組件是否在完全信任情況下執行。</summary>
        <value>
          如果載入目前應用程式定義域中的組件在完全信任情況下執行，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法一律會傳回`true`在桌面上執行的應用程式的預設應用程式定義域。 它會傳回`false`，使用所建立的沙箱化應用程式網域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載，除非應用程式定義域授與的權限相當於完全信任。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.IsFullyTrusted%2A>屬性和<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>與完全信任和部分信任的應用程式定義域的屬性。 應用程式的預設應用程式定義域的完全信任的應用程式網域。 在部分信任的應用程式定義域由使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載。  
  
 此範例會使用`Worker`類別衍生自<xref:System.MarshalByRefObject>，因此它可以封送處理跨應用程式定義域界限。 此範例會建立`Worker`預設應用程式定義域中的物件。 然後它會呼叫`TestIsFullyTrusted`方法，以顯示應用程式定義域和兩個組件載入至應用程式定義域的屬性值： mscorlib，是.NET Framework 中，範例組件的一部分。 應用程式定義域是完全受信任的因此兩個組件是完全受信任。  
  
 此範例會建立另一個`Worker`物件中的沙箱化應用程式定義域和再次呼叫`TestIsFullyTrusted`方法。 Mscorlib 永遠是受信任的即使在部分信任的應用程式網域中，但是範例組件是以部分信任。  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前應用程式定義域是否會授與一組權限給所有載入該應用程式定義域中的組件。</summary>
        <value>
          如果目前應用程式定義域具有一組同質性權限，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回`true`使用所建立的沙箱化應用程式定義域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載。 沙箱化應用程式定義域具有一組同質性權限;也就是相同的權限集授與給所有載入應用程式定義域的部分信任組件。 沙箱應用程式定義域 （選擇性） 具有免套用此權限集，並改為以完全信任執行的強式名稱組件的清單。  
  
 完全信任的程式碼可以使用<xref:System.AppDomain.PermissionSet%2A>屬性來判斷沙箱應用程式定義域的同質性的授權集。  
  
 這個屬性也會傳回`true`預設應用程式定義域的桌面應用程式，因為該應用程式定義域授與完全信任給所有組件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 <see cref="T:System.Reflection.Assembly" /> 載入這個應用程式定義域中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <see langword="byte" /> 類型的陣列，這是包含發出組件之以 COFF 為基礎的影像。</param>
        <summary>載入具備通用物件檔案格式 (COFF) 影像 (包含發出的 <see cref="T:System.Reflection.Assembly" />) 的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是在應用程式定義域的信任層級相同。  
  
 這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域中載入組件，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例示範如何使用載入原始組件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="rawAssembly" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">物件，描述要載入的組件。</param>
        <summary>載入提供了 <see cref="T:System.Reflection.AssemblyName" /> 的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域中載入組件，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 如果已載入要求的組件的版本，這個方法會傳回載入的組件，即使要求不同的版本。  
  
 提供的部分組件名稱`assemblyRef`不建議使用。 （部分的名稱會省略一或多個文化特性、 版本或公開金鑰語彙基元。 對於採用而不是字串的多載<xref:System.Reflection.AssemblyName>物件，"MyAssembly，Version = 1.0.0.0"是部分名稱的範例和"MyAssembly，Version = 1.0.0.0，Culture = neutral，PublicKeyToken = 18ab3442da84b47 」 是完整名稱的範例。)使用部分的名稱有對效能產生負面影響。 此外，部分組件名稱可以載入組件從全域組件快取中的應用程式基底目錄的組件的完全相同複本如果 (<xref:System.AppDomain.BaseDirectory%2A>或<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>)。  
  
 如果目前<xref:System.AppDomain>物件都代表應用程式定義域`A`，而<xref:System.AppDomain.Load%2A>方法從應用程式定義域呼叫`B`，組件會載入至兩個應用程式定義域。 例如，下列程式碼載入`MyAssembly`至新的應用程式定義域`ChildDomain`也到應用程式定義域執行的程式碼：  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 因為組件載入至兩個網域<xref:System.Reflection.Assembly>不是衍生自<xref:System.MarshalByRefObject>，而因此傳回值的<xref:System.AppDomain.Load%2A>方法無法封送處理。 相反地，common language runtime 會嘗試對呼叫的應用程式定義域載入組件。 組件載入至兩個應用程式定義域可能會不同，如果路徑設定為兩個應用程式網域不同。  
  
> [!NOTE]
>  如果兩個<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>屬性和<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>屬性會設定，第一次嘗試載入組件會使用的顯示名稱 (包括所傳回的版本、 文化特性，依此類推，<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性)。 如果找不到檔案，<xref:System.Reflection.AssemblyName.CodeBase%2A>屬性用來搜尋該組件。 如果使用找到的組件<xref:System.Reflection.AssemblyName.CodeBase%2A>，會針對組件比對的顯示名稱。 如果配對失敗，<xref:System.IO.FileLoadException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyRef" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyRef" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <summary>載入提供了顯示名稱的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域中載入組件，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> 是 <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyString" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyString" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <see langword="byte" /> 類型的陣列，這是包含發出組件之以 COFF 為基礎的影像。</param>
        <param name="rawSymbolStore">
          <see langword="byte" /> 類型的陣列，包含代表組件符號的未經處理位元組。</param>
        <summary>載入具備通用物件檔案格式 (COFF) 影像 (包含發出的 <see cref="T:System.Reflection.Assembly" />) 的 <see cref="T:System.Reflection.Assembly" />。 也會載入代表 <see cref="T:System.Reflection.Assembly" /> 符號且未經處理的位元組。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是在應用程式定義域的信任層級相同。  
  
 這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域中載入組件，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例示範如何使用載入原始組件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="rawAssembly" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">物件，描述要載入的組件。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <summary>載入提供了 <see cref="T:System.Reflection.AssemblyName" /> 的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域中載入組件，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> 是 <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyRef" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyRef" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">讀取的路徑不是格式"file:// 或"\\\UNC\dir\\"或"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">組件的顯示名稱。 請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <summary>載入提供了顯示名稱的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域中載入組件，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> 是 <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="assemblyString" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyString" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">使用辨識項載入組件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">讀取的路徑不是格式"file:// 或"\\\UNC\dir\\"或"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <see langword="byte" /> 類型的陣列，這是包含發出組件之以 COFF 為基礎的影像。</param>
        <param name="rawSymbolStore">
          <see langword="byte" /> 類型的陣列，包含代表組件符號的未經處理位元組。</param>
        <param name="securityEvidence">用於載入組件的辨識項。</param>
        <summary>載入具備通用物件檔案格式 (COFF) 影像 (包含發出的 <see cref="T:System.Reflection.Assembly" />) 的 <see cref="T:System.Reflection.Assembly" />。 也會載入代表 <see cref="T:System.Reflection.Assembly" /> 符號且未經處理的位元組。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是在應用程式定義域的信任層級相同。  
  
 這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域中載入組件，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例示範如何使用載入原始組件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的組件。  
  
 -或-  
  
 目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="rawAssembly" /> 是使用更新的版本所編譯。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> 不是 <see langword="null" />。 若未啟用舊版 CAS 原則，<paramref name="securityEvidence" /> 應為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取從檔案或目錄，以及在本身的路徑資訊的存取權的存取。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">讀取的路徑不是格式"file:// 或"\\\UNC\dir\\"或"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否對目前處理程序啟用應用程式定義域的 CPU 和記憶體監視。 一旦對處理程序啟用監視，就不能停用。</summary>
        <value>
          如果啟用監視，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這`static`屬性 (`Shared`屬性在 Visual Basic) 控制 CPU 和記憶體監視的程序中的所有應用程式定義域。  
  
 如果您嘗試將此屬性設定為`false`、<xref:System.ArgumentException>擲回例外狀況，即使目前屬性的值是`false`。  
  
 一旦啟用監視，您可以使用<xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>， <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>， <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>，和<xref:System.AppDomain.MonitoringTotalProcessorTime%2A>執行個體來監視個別的應用程式定義域的 CPU 和記憶體使用的屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">目前的處理序嘗試要指派值 <see langword="false" /> 給這個屬性。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得自上次回收作業後存留下來，且已知正由目前應用程式定義域參考之位元組的數目。</summary>
        <value>存留的位元組數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每次記憶體回收會更新統計資料。 不過，保證能夠精確只後執行完整的封鎖集合也就是的集合，其中包含所有層代和停止應用程式，這時集合就會發生。 例如，<xref:System.GC.Collect?displayProperty=nameWithType>方法多載會執行完整的封鎖集合。 （同時回收就會發生在背景中且不會封鎖應用程式。）  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (在 Visual Basic中為 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 屬性設為 <see langword="false" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>針對處理程序中的所有應用程式定義域，取得自上次回收作業存留下來的位元組總數。</summary>
        <value>處理程序的存留位元組總數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完整的封鎖收集後，目前的位元組數目保留在即時此數字代表 managed 堆積。 它應該接近所報告的數字<xref:System.GC.GetTotalMemory%2A>方法。 暫時收集之後，此數字代表的位元組數目目前保留要即時暫時層代中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (在 Visual Basic中為 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 屬性設為 <see langword="false" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式定義域自其建立後已配置之所有記憶體的總大小 (以位元組為單位)，但不減去已回收的記憶體。</summary>
        <value>所有記憶體配置的總大小。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (在 Visual Basic中為 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 屬性設為 <see langword="false" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得自處理程序啟動後，所有執行緒在目前應用程式定義域中執行時用掉的處理器時間總計。</summary>
        <value>目前應用程式定義域的處理器時間總計。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 總時間所報告之應用程式定義域中包含應用程式定義域中執行程序中的每個執行緒所花費的時間。  
  
 呼叫 unmanaged 程式碼的執行緒仍會關聯於應用程式定義域，並執行 unmanaged 程式碼會報告已呼叫的應用程式定義域所花費的處理器時間。  
  
 當執行緒被封鎖或睡眠中，它不會耗用處理器時間。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (在 Visual Basic中為 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 屬性設為 <see langword="false" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得沙箱應用程式定義域的權限集。</summary>
        <value>沙箱應用程式定義域的權限集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用所建立的沙箱化應用程式定義域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載有一組同質性權限; 也就是相同的權限集授與給所有載入應用程式定義域的部分信任組件。 沙箱應用程式定義域 （選擇性） 具有免套用此權限集，並改為以完全信任執行的強式名稱組件的清單。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於預設應用程式定義域的父處理程序結束時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler>針對此事件可以執行終止活動，例如關閉檔案，釋放儲存體等等，在處理序結束之前。  
  
 從.NET Framework 2.0 版開始，每個應用程式定義域中註冊事件處理常式會引發這個事件。  
  
> [!NOTE]
>  總執行時間的所有<xref:System.AppDomain.ProcessExit>事件處理常式是受到限制，就如同所有完成的執行時間總計是在處理序關機有限。 預設值為兩秒。 受管理的主機可以呼叫來變更這個執行階段[iclrpolicymanager:: Settimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)方法[OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)列舉值。  
  
 在.NET framework 1.0 和 1.1 版中，此事件是引發只在預設應用程式網域中，而且只有在預設應用程式定義域中註冊事件處理常式。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於僅限反映之內容中的組件解析失敗時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在僅限反映的內容中，會不會自動解析相依性。 而且必須預先載入或傳回為這個事件處理常式。 當組件具有尚未載入到僅限反映的內容相依性，會引發這個事件。 遺失的相依性由指定<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>屬性。 <xref:System.ResolveEventHandler>對於這個事件必須傳回符合相依性的組件。 傳回的組件必須載入到僅限反映的內容。  
  
> [!IMPORTANT]
>  僅針對遺失的相依性的組件載入僅限反映的內容會引發這個事件 (例如，藉由使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>方法)。 如果找不到要載入的組件時，它不會引發。  
  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性會傳回要求無法解析組件載入的組件。 了解要求的組件的識別可能會用來識別正確版本的相依性，如果一個以上的版本可用。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
 對於此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>屬性在套用原則之前，會傳回組件名稱。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回已經載入到應用程式定義域之僅限反映的內容之組件。</summary>
        <returns>
          <see cref="T:System.Reflection.Assembly" /> 物件的陣列，代表已經載入到應用程式定義域中僅限反映之內容的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回已載入僅限反映之內容的組件。 若要取得已載入的組件的執行，請使用<xref:System.AppDomain.GetAssemblies%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例會載入 System.dll 組件至執行內容，然後放入僅限反映的內容。 <xref:System.AppDomain.GetAssemblies%2A>和<xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A>方法用來顯示每個內容所載入的組件。  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試在卸載的應用程式定義域中執行作業。</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得組件解析程式應該在其中探查私用組件的路徑，此路徑位於基底目錄下。</summary>
        <value>組件解析程式應該在其中探查私用組件的路徑，此路徑位於基底目錄下。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 私用組件會部署在相同的目錄結構與應用程式。 如果所指定的路徑<xref:System.AppDomain.RelativeSearchPath%2A>屬性不是在<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>，則會忽略它。  
  
 這個屬性會傳回設定使用的值<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取路徑資訊。 關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於資源的解析失敗時 (原因是因為該資源在組件中不是有效連結或內嵌的資源)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ResolveEventHandler>針對此事件可以嘗試找出包含資源的組件，並將它傳回。  
  
> [!IMPORTANT]
>  如果解析失敗，因為沒有檔案找不到有效的連結資源，不會引發這個事件。 如果找不到資訊清單資源資料流，但不是會引發如果找不到個別的資源索引鍵，就會引發此事件。  
  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性包含要求之資源的組件。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">安全性原則層級。</param>
        <summary>為這個應用程式定義域建立安全性原則層級。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 載入組件之前呼叫這個方法<xref:System.AppDomain>效果的安全性原則的順序。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.AppDomain.SetAppDomainPolicy%2A>方法，以設定應用程式定義域的安全性原則層級。  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Policy.PolicyException">安全性原則層級已經設定。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">陰影複本位置的完整路徑。</param>
        <summary>將指定的目錄路徑建立為陰影複製組件的所在位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果，則會忽略快取路徑<xref:System.AppDomainSetup.ApplicationName%2A>屬性未設定。 請參閱 <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> 屬性。  
  
 如需陰影複製的詳細資訊請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將某個值指派給應用程式定義域屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">要建立或變更的使用者定義之應用程式定義域屬性的名稱。</param>
        <param name="data">屬性的值。</param>
        <summary>將指定值指派至指定的應用程式定義域屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來插入的項目，或修改的值描述屬性的這個執行個體的名稱資料組的內部快取中的項目<xref:System.AppDomain>。  
  
 快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。 您無法插入或修改使用此方法的系統項目。 嘗試修改系統項目方法呼叫沒有任何作用中。此方法不會擲回例外狀況。 您可以檢查與系統項目的值<xref:System.AppDomain.GetData%2A>方法或對等<xref:System.AppDomainSetup>屬性中所述<xref:System.AppDomain.GetData%2A>。  
  
 您可以呼叫此方法以設定的預設逾時間隔由 「 REGEX_DEFAULT_MATCH_TIMEOUT"評估規則運算式模式的值做為值`name`引數和<xref:System.TimeSpan>值，表示在逾時值與間隔`data`引數。 也可以插入或修改這個方法與您自己的使用者定義名稱資料組並且檢查其值與<xref:System.AppDomain.GetData%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29>方法來建立新的值組。 然後此範例使用<xref:System.AppDomain.GetData%2A>方法來擷取值，並將它顯示到主控台。  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">要建立或變更的使用者定義之應用程式定義域屬性的名稱。</param>
        <param name="data">屬性的值。</param>
        <param name="permission">當擷取屬性時，向呼叫端要求的權限。</param>
        <summary>將指定之值指派給指定之應用程式定義域屬性，而當擷取這個屬性時，有指定向呼叫端要求的權限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來插入或修改自己使用者定義的項目，描述應用程式定義域屬性的名稱/資料組的內部快取中。 當您插入項目時，您可以指定權限要求來擷取項目時，強制執行。此外，您可以呼叫此方法以設定的預設逾時間隔由 「 REGEX_DEFAULT_MATCH_TIMEOUT"評估規則運算式模式的值做為值`name`引數和<xref:System.TimeSpan>值，表示做為值的逾時間隔`data`引數。  
  
 您無法使用這個方法的安全性要求給系統定義的屬性字串。  
  
 快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。 您無法插入或修改使用此方法的系統項目。 嘗試修改系統項目方法呼叫沒有任何作用中。此方法不會擲回例外狀況。 您可以檢查與系統項目的值<xref:System.AppDomain.GetData%2A>方法或對等<xref:System.AppDomainSetup>的 < 備註 > 一節所述的內容<xref:System.AppDomain.GetData%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> 可指定系統定義之屬性字串，且 <paramref name="permission" /> 不是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">完整的路徑，代表用來儲存動態組件之子目錄的基底目錄。</param>
        <summary>建立指定的目錄路徑，做為存放及存取動態產生檔案之子目錄的基底目錄。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會設定<xref:System.AppDomainSetup.DynamicBase%2A>屬性內部的<xref:System.AppDomainSetup>與這個執行個體相關聯。  
  
   
  
## Examples  
 這個方法已經過時，並不應該用於新的開發工作。 下列範例示範如何使用非過時的替代方式，<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>屬性。 如需此範例的說明，請參閱<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>屬性或<xref:System.AppDomain.DynamicDirectory%2A>屬性。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">其中一個 <see cref="T:System.Security.Principal.PrincipalPolicy" /> 值，指定要附加至執行緒之主體物件的類型。</param>
        <summary>如果執行緒在這個應用程式定義域執行時嘗試繫結至主體，則指定主體和識別 (Identity) 物件應該如何附加至執行緒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定此值才會生效，如果您使用之前設定<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性。 例如，如果您設定<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>到指定的主體 （例如，泛型主體），然後使用<xref:System.AppDomain.SetPrincipalPolicy%2A>方法，以設定<xref:System.Security.Principal.PrincipalPolicy>至<xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>，目前的主體會保留泛型主體。  
  
   
  
## Examples  
 下列範例顯示使用的執行緒上影響<xref:System.AppDomain.SetPrincipalPolicy%2A>方法，以變更應用程式定義域的主體的原則。 它也會顯示使用的效果<xref:System.AppDomain.SetThreadPrincipal%2A>方法，以變更適用於附加至應用程式定義域中的執行緒的主體。  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">操作主體物件的能力。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開啟陰影複製。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
   
  
## Examples  
 這個方法已經過時，並不應該用於新的開發工作。  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">目錄名稱的清單，其中的每個名稱以分號隔開。</param>
        <summary>建立指定的目錄路徑，做為要陰影複製的組件位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，陰影複製包含經由探查所找到的所有組件。 <xref:System.AppDomain.SetShadowCopyPath%2A>方法會限制所指定目錄中的組件的陰影複製`path`。  
  
 <xref:System.AppDomain.SetShadowCopyPath%2A>方法不會指定要在其中搜尋組件的其他目錄。 要陰影複製組件必須已經位於搜尋路徑，例如下<xref:System.AppDomain.BaseDirectory%2A>。 <xref:System.AppDomain.SetShadowCopyPath%2A>方法可讓您指定的搜尋路徑有資格要陰影複製。  
  
 這個方法會設定<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>屬性內部的<xref:System.AppDomainSetup>與這個執行個體相關聯。  
  
 如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
   
  
## Examples  
 這個方法已經過時，並不應該用於新的開發工作。  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">要附加至執行緒的主體物件。</param>
        <summary>如果執行緒在這個應用程式定義域中執行時嘗試繫結至預設的主體，則設定預設的主體物件附加至執行緒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例顯示使用的效果<xref:System.AppDomain.SetThreadPrincipal%2A>方法，以變更適用於附加至應用程式定義域中執行的執行緒的主體。 它也會顯示在使用的執行緒上影響<xref:System.AppDomain.SetPrincipalPolicy%2A>方法，以變更應用程式定義域的主體的原則。  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Policy.PolicyException">主要執行緒已經設定。</exception>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">操作主體物件的能力。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個執行個體的應用程式定義域組態資訊。</summary>
        <value>應用程式定義域初始化資訊。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得是否已設定應用程式定義域以進行檔案陰影複製的指示。</summary>
        <value>
          如果已設定應用程式定義域以進行檔案陰影複製，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>和[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">嘗試對卸載的應用程式定義域執行作業。</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="rgszNames">要對應之傳入的名稱陣列。</param>
        <param name="cNames">要對應的名稱計數。</param>
        <param name="lcid">用於解譯名稱的地區設定內容。</param>
        <param name="rgDispId">呼叫端配置的陣列，用於接收對應於名稱的 ID。</param>
        <summary>將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要傳回的類型資訊。</param>
        <param name="lcid">類型資訊的地區設定識別項。</param>
        <param name="ppTInfo">接收要求的類型資訊物件的指標。</param>
        <summary>擷取物件的類型資訊，可以用來取得介面的類型資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfo`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向接收物件提供的類型資訊介面數目的位置。</param>
        <summary>擷取物件提供的類型資訊介面數目 (0 或 1)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">辨識成員。</param>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="lcid">地區設定內容，用於解譯引數。</param>
        <param name="wFlags">描述呼叫之內容的旗標。</param>
        <param name="pDispParams">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</param>
        <param name="pVarResult">指向用於儲存結果之位置的指標。</param>
        <param name="pExcepInfo">包含例外狀況資訊的結構指標。</param>
        <param name="puArgErr">第一個有錯誤的引數索引。</param>
        <summary>提供物件所公開的屬性和方法的存取權。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::Invoke`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得字串表示，其中包含應用程式定義域及任何內容原則的易記名稱。</summary>
        <returns>將常值字串 "Name:"、應用程式定義域的易記名稱、內容原則的字串表示或字串 "There are no context policies" 串連起來所構成的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例顯示的傳回值<xref:System.AppDomain.ToString%2A>方法。  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">已經卸載目前的 <see cref="T:System.AppDomain" /> 所表示的應用程式定義域。</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於類型解析失敗時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.TypeResolve> Common language runtime 無法判斷組件可以建立要求的型別時，就會發生事件。 如果類型定義在動態組件，或動態組件中未定義型別，但執行階段不知道哪個組件中定義此類型，也可能會發生。 後者的情況可能會發生時<xref:System.Type.GetType%2A?displayProperty=nameWithType>呼叫組件名稱不合格的型別名稱。  
  
 <xref:System.ResolveEventHandler>針對此事件可以嘗試找出並建立型別。  
  
 不過，<xref:System.AppDomain.TypeResolve>事件不會發生執行階段知道不可能在特定的組件中尋找的型別。 例如，不會不會發生此事件類型中找不到靜態組件因為執行階段知道類型無法以動態方式加入至靜態組件。  
  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性包含要求的類型之組件。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.TypeResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於未攔截到例外狀況時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個事件會提供無法攔截的例外狀況的通知。 它可讓應用程式系統預設處理常式報告給使用者的例外狀況和終止應用程式之前記錄例外狀況的相關資訊。 應用程式的狀態相關的足夠資訊是否可用，則可能會採取其他動作，例如儲存供稍後復原程式資料。 請謹慎，因為當未處理例外狀況程式資料可能變成損毀。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，應用程式終止和偵錯選項會向使用者報告就會引發此事件之前，而非之後。  
  
 在任何應用程式定義域中，可以處理這個事件。 不過，此事件不一定會引發例外狀況的發生位置的應用程式定義域中。 只有當執行緒在整個堆疊已回溯而不尋找適用的例外狀況處理常式，因此可能引發此事件的第一個位置是在該執行緒的來源應用程式定義域中，會形成未處理例外狀況。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，只針對應用程式啟動時，系統所建立的預設應用程式定義域會發生此事件。 如果應用程式建立其他應用程式定義域，這些應用程式定義域中指定此事件的委派沒有任何作用。  
  
 如果<xref:System.AppDomain.UnhandledException>預設應用程式定義域中處理事件，會引發此事件發生的任何未處理任何執行緒，無論何種應用程式定義域中的例外狀況已啟動執行緒。 如果有事件處理常式的應用程式定義域中啟動執行緒<xref:System.AppDomain.UnhandledException>，應用程式定義域中引發事件。 如果應用程式定義域不是預設應用程式定義域，而且也沒有事件處理常式預設應用程式定義域中，會引發兩個應用程式定義域中。  
  
 比方說，假設在執行緒啟動應用程式定義域"AD1 」，呼叫的方法"AD2，」 的應用程式定義域中，從該處呼叫應用程式定義域"AD3 」，方法會擲回例外狀況。 第一個應用程式定義域，<xref:System.AppDomain.UnhandledException>可以引發事件會 「 AD1"。 如果應用程式定義域不是預設應用程式定義域，也可能引發此事件的預設應用程式定義域。  
  
> [!NOTE]
>  Common language runtime 會暫止執行緒中止時的事件處理常式<xref:System.AppDomain.UnhandledException>事件正在執行。  
  
 如果事件處理常式具有<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>屬性與適當的旗標，此事件處理常式會被視為限制的執行區域。  
  
 從開始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，不會引發這個事件的例外狀況，損毀的處理程序的狀態，例如，堆疊溢位，或存取違規，除非此事件處理常式為安全性關鍵的而且有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>屬性。  
  
 在.NET framework 1.0 和 1.1 版中，主應用程式執行緒以外的執行緒中發生未處理例外狀況捕捉到的執行階段，因此不會造成應用程式結束。 因此，很可能讓<xref:System.AppDomain.UnhandledException>而不需要應用程式終止會引發事件。 從.NET Framework 2.0 版開始，這個子執行緒中的未處理例外狀況的支援已移除，因為這類的無訊息失敗的累積效果包含效能降低、 損毀的資料和鎖定，且很難偵錯。 如需詳細資訊，包括清單的情況下，執行階段不會終止，請參閱[Managed 執行緒中的例外狀況](~/docs/standard/threading/exceptions-in-managed-threads.md)。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
## <a name="other-events-for-unhandled-exceptions"></a>未處理例外狀況的其他事件  
 某些應用程式模型，<xref:System.AppDomain.UnhandledException>事件可以清空的其他事件，如果主應用程式執行緒中發生未處理的例外狀況。  
  
 使用 Windows Form 應用程式，在未處理主應用程式執行緒發生原因的例外狀況<xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType>會引發事件。 如果處理此事件，預設行為是未處理的例外狀況不會終止該應用程式，雖然應用程式處於未知狀態。 在此情況下，<xref:System.AppDomain.UnhandledException>不會引發事件。 可以變更此行為，藉由使用應用程式組態檔，或是利用<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType>方法，以將模式變更為<xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType>之前<xref:System.Windows.Forms.Application.ThreadException>連結事件處理常式。 只適用於主應用程式執行緒。 <xref:System.AppDomain.UnhandledException>其他執行緒中擲回未處理的例外狀況就會引發事件。  
  
 從 Microsoft Visual Studio 2005 開始，Visual Basic 應用程式架構可以提供另一個事件中主應用程式執行緒的未處理例外狀況。 請參閱<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType>事件。 這個事件必須與所使用的事件引數物件的名稱相同的事件引數物件<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>，但具有不同的屬性。 特別是，此事件的引數物件具有<xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>屬性，可讓應用程式繼續執行，而忽略未處理的例外狀況 （並讓應用程式處於未知狀態）。 在此情況下，<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>不會引發事件。  
  
   
  
## Examples  
 如以下範例示範<xref:System.AppDomain.UnhandledException>事件。 它會定義事件處理常式， `MyHandler`，每當預設應用程式定義域中擲回未處理的例外狀況時，會叫用。 則會擲回兩個例外狀況。 第一個工作由**try/catch**區塊。 第二個未處理，並叫用`MyHandle`應用程式終止前的常式。  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">要卸載的應用程式定義域。</param>
        <summary>卸載指定的應用程式定義域。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 2.0 版中已有執行緒專門用來卸載應用程式定義域。 這可改善可靠性，尤其是當裝載.NET Framework。 當一個執行緒呼叫<xref:System.AppDomain.Unload%2A>，目標網域已標示為卸載。 專用的執行緒嘗試卸載定義域，並在網域中的所有執行緒都會都中止。 如果執行緒不會中止，例如因為它正在執行 unmanaged 程式碼，或因為它正在執行`finally`區塊，然後在一段時間之後<xref:System.CannotUnloadAppDomainException>初次呼叫的執行緒中擲回<xref:System.AppDomain.Unload%2A>。 如果無法最終中止的執行緒結束，則目標網域未卸載。 因此，在.NET Framework 2.0 版`domain`不保證卸除，因為它可能無法終止正在執行的執行緒。  
  
> [!NOTE]
>  在某些情況下，呼叫<xref:System.AppDomain.Unload%2A>會導致立即<xref:System.CannotUnloadAppDomainException>，例如如果呼叫完成項中。  
  
 中的執行緒`domain`使用終止<xref:System.Threading.Thread.Abort%2A>方法，就會擲回<xref:System.Threading.ThreadAbortException>執行緒中。 雖然執行緒應該會立即結束，它會繼續執行的無法預期的時間量以`finally`子句。  
  
## <a name="version-compatibility"></a>版本相容性  
 在.NET Framework 1.0 和 1.1，如果呼叫執行緒<xref:System.AppDomain.Unload%2A>，正在`domain`，另一個執行緒已啟動執行卸載作業。 如果`domain`無法卸載，<xref:System.CannotUnloadAppDomainException>該執行緒不在原始呼叫的執行緒中擲回<xref:System.AppDomain.Unload%2A>。 不過，如果執行緒呼叫<xref:System.AppDomain.Unload%2A>執行外部`domain`，執行緒會收到例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何卸載應用程式定義域。  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          無法卸載 <paramref name="domain" />。</exception>
        <exception cref="T:System.Exception">卸載程序期間發生錯誤。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要加入此事件的事件處理常式。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
  </Members>
</Type>