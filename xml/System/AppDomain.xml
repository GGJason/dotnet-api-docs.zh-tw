<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="77e5b29fae81c7e7c9afa3a56b486d48eb06a161" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37484884" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents an application domain, which is an isolated environment where applications execute. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式定義域，由<xref:System.AppDomain>物件，可協助提供隔離、 卸載和安全性界限執行 managed 程式碼。  
  
-   您可以使用應用程式定義域來隔離可能會使處理序的工作。 如果狀態<xref:System.AppDomain>，正在執行的工作變得不穩定，<xref:System.AppDomain>即可予以卸載而不會影響此程序。 當長時間執行的處理序，必須將它不需要重新啟動時，這很重要。 您也可以使用應用程式定義域來隔離不應共用資料的工作。  
  
-   如果組件載入至預設應用程式定義域時，它不能從記憶體卸載的情況，而處理序正在執行。 不過，如果您開啟以載入和執行組件的第二個應用程式定義域時，組件會卸載該應用程式定義域卸載時。 您可以使用這項技巧來減少有時候使用大型的 Dll 的長時間執行處理序的工作集。  
  
 多個應用程式定義域可以單一處理序中執行;不過，沒有應用程式定義域和執行緒之間的一對一關聯性。 數個執行緒可以隸屬於單一應用程式網域，而且雖然之給定的執行緒並不侷限於單一應用程式網域，在任何時候，執行緒會執行單一應用程式定義域中。  
  
 使用建立應用程式定義域<xref:System.AppDomain.CreateDomain%2A>方法。 <xref:System.AppDomain> 執行個體用來載入和執行組件 (<xref:System.Reflection.Assembly>)。 當<xref:System.AppDomain>已不再使用中，它可以卸載。  
  
 <xref:System.AppDomain>類別會實作一組可讓應用程式在載入組件，應用程式定義域將會卸載，或擲回未處理的例外狀況時回應的事件。  
  
 如需有關如何使用應用程式定義域的詳細資訊，請參閱 <<c0> [ 應用程式定義域](~/docs/framework/app-domains/application-domains.md)。  
  
 這個類別會實作<xref:System.MarshalByRefObject>， <xref:System._AppDomain>，和<xref:System.Security.IEvidenceFactory>介面。  
  
 您應該永遠不會建立可遠端處理包裝函式<xref:System.AppDomain>物件。 如此一來，無法發行的遠端參考<xref:System.AppDomain>，例如公開方法<xref:System.AppDomain.CreateInstance%2A>遠端存取並有效地終結該的 程式碼存取安全性<xref:System.AppDomain>。 惡意用戶端連接到遠端<xref:System.AppDomain>無法存取任何資源<xref:System.AppDomain>本身具有存取權。 不會建立可遠端處理的包裝函式延伸任何型別的<xref:System.MarshalByRefObject>和實作可能遭到惡意用戶端用來略過安全性系統的方法。  
  
> [!CAUTION]
>  預設值<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>屬性是`false`。 此設定是不安全的服務。 若要避免服務下載部分信任程式碼，請將此屬性設定為`true`。  
  
   
  
## Examples  
 此範例示範如何建立新<xref:System.AppDomain>，具現化型別中的新<xref:System.AppDomain>，並與該類型的物件。 此外，此範例示範如何卸載<xref:System.AppDomain>造成要進行記憶體回收的物件。  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the activation context for the current application domain.</summary>
        <value>物件，表示目前應用程式定義域的啟動內容，如果此定義域沒有任何啟動內容，則為 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The name of the directory to be appended to the private path.</param>
        <summary>Appends the specified directory name to the private path list.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不建議使用這個屬性，因為它們已經被載入之後，它可能會針對組件變更探查的路徑。 請改用 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> 屬性。  
  
 私用的路徑或相對搜尋路徑是相對於組件解析程式其中探查私用組件的基底目錄路徑。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the identity of the application in the application domain.</summary>
        <value>物件，可識別應用程式定義域中的應用程式。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets information describing permissions granted to an application and whether the application has a trust level that allows it to run.</summary>
        <value>物件，可針對應用程式定義域中的應用程式來封裝使用權限和信任資訊。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The assembly display name, in the form provided by the <see cref="P:System.Reflection.Assembly.FullName" /> property.</param>
        <summary>Returns the assembly display name after policy has been applied.</summary>
        <returns>A string containing the assembly display name after policy has been applied.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ApplyPolicy%2A>方法會採用組件的顯示名稱，並傳回原則後顯示名稱。 這非常有用，如果您要載入組件使用 「 原則 」，因為僅限反映的內容不會套用原則。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an assembly is loaded.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AssemblyLoadEventHandler>委派這個事件表示哪些組件已載入。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.AssemblyLoad>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the resolution of an assembly fails.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它負責<xref:System.ResolveEventHandler>傳回組件中所指定此事件<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>屬性，或傳回 null，如果無法辨識的組件。 組件必須載入到執行內容;如果載入僅限反映的內容時，會引發這個事件的負載將會失敗。  
  
 如需使用這個事件的指引，請參閱 <<c0> [ 解析組件載入](~/docs/framework/app-domains/resolve-assembly-loads.md)。  
  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性會傳回要求無法解析組件載入的組件。 例如，載入器可能無法載入要求的組件的相依性，因為要求的組件和其相依性不在探查路徑。 了解要求的組件的識別可能有助於在尋找相依性，或找出正確的版本中，如果使用多個版本的相依性。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
> [!IMPORTANT]
>  開頭[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，則<xref:System.ResolveEventHandler>所有組件，包括資源組件都會引發事件。 在舊版中，資源組件不引發事件。 如果當地語系化的作業系統，可能會呼叫處理常式多次： 每個文化特性後援鏈結中的一次。  
  
 對於此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>套用原則之前，屬性會傳回組件名稱。  
  
> [!IMPORTANT]
>  如果此事件註冊一個以上的事件處理常式，事件 handlersarecalled，直到事件處理常式的傳回值的順序，不是`null`。 後續的事件處理常式會被忽略。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the base directory that the assembly resolver uses to probe for assemblies.</summary>
        <value>組件解析程式用來探查組件的基底目錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性會對應至<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>屬性。 它也可以擷取使用<xref:System.AppDomain.GetData%2A>與字串"APPBASE"的方法。  
  
   
  
## Examples  
 下列程式碼範例會建立新的應用程式定義域，指定要載入定義域時搜尋組件使用的基底目錄。 然後此範例使用<xref:System.AppDomain.BaseDirectory%2A>屬性取得的基底目錄路徑，顯示到主控台。  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑本身中的資訊，包括如果路徑的格式為"file:// 或\\\UNC\dir 或"c:\\"。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the path that specifies the location of private assemblies to the empty string ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 私用路徑是相對於 common language runtime 會搜尋來尋找私用組件的基底目錄路徑。  
  
 如需詳細資訊，請參閱<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.AppDomain.ClearPrivatePath%2A>方法，以從載入的組件時所要搜尋的私用路徑的清單中移除所有項目。  
  
 此方法現已淘汰，並不應該用於新的開發。  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the list of directories containing shadow copied assemblies to the empty string ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 陰影複製路徑是儲存的陰影複製組件的所在的目錄清單。  
  
 如需詳細資訊，請參閱 <<c0> <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> 並[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new instance of a specified COM type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The name of a file containing an assembly that defines the requested type.</param>
        <param name="typeName">The name of the requested type.</param>
        <summary>Creates a new instance of a specified COM type. Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</summary>
        <returns>An object that is a wrapper for the new instance specified by <paramref name="typeName" />. The return value needs to be unwrapped to access the real object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法，從遠端建立物件，而不需要載入在本機的型別。  
  
 傳回的值必須解除包裝以存取實際物件。  
  
 A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>屬性的值`true`必須套用明確或預設為 COM 型別，此方法來建立該類型; 的執行個體，否則為<xref:System.TypeLoadException>就會擲回。  
  
   
  
## Examples  
 下列範例會示範  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">The type cannot be loaded.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.MissingMethodException">No public parameterless constructor was found.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> is not found.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> is an abstract class.  -or-  This member was invoked with a late-binding mechanism.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> is an empty string ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> is not a valid assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.NullReferenceException">The COM object that is being referred to is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The name of a file containing an assembly that defines the requested type.</param>
        <param name="typeName">The name of the requested type.</param>
        <param name="hashValue">Represents the value of the computed hash code.</param>
        <param name="hashAlgorithm">Represents the hash algorithm used by the assembly manifest.</param>
        <summary>Creates a new instance of a specified COM type. Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</summary>
        <returns>An object that is a wrapper for the new instance specified by <paramref name="typeName" />. The return value needs to be unwrapped to access the real object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法，從遠端建立物件，而不需要載入在本機的型別。  
  
 傳回的值必須解除包裝以存取實際物件。  
  
 A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>屬性的值`true`必須套用明確或預設為 COM 型別，此方法來建立該類型; 的執行個體，否則為<xref:System.TypeLoadException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">The type cannot be loaded.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.MissingMethodException">No public parameterless constructor was found.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> is not found.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> is an abstract class.  -or-  This member was invoked with a late-binding mechanism.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> is the empty string ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> is not a valid assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.NullReferenceException">The COM object that is being referred to is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new application domain.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">The friendly name of the domain.</param>
        <summary>Creates a new application domain with the specified name.</summary>
        <returns>The newly created application domain.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `friendlyName`參數要識別網域是讓人有意義的方式。 此字串應該是適合在使用者介面中顯示。  
  
 這個方法多載會使用<xref:System.AppDomainSetup>從預設應用程式定義域的資訊。  
  
   
  
## Examples  
 下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidence that establishes the identity of the code that runs in the application domain. Pass <see langword="null" /> to use the evidence of the current application domain.</param>
        <summary>Creates a new application domain with the given name using the supplied evidence.</summary>
        <returns>The newly created application domain.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載會使用<xref:System.AppDomainSetup>從預設應用程式定義域的資訊。  
  
 如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。  
  
> [!IMPORTANT]
>  請勿使用這個方法多載來建立沙箱應用程式定義域。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，所提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱應用程式定義域。  
  
   
  
## Examples  
 下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidence that establishes the identity of the code that runs in the application domain. Pass <see langword="null" /> to use the evidence of the current application domain.</param>
        <param name="info">An object that contains application domain initialization information.</param>
        <summary>Creates a new application domain using the specified name, evidence, and application domain setup information.</summary>
        <returns>The newly created application domain.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`info`是未提供，這個方法多載會使用<xref:System.AppDomainSetup>從預設應用程式定義域的資訊。  
  
 如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。  
  
> [!IMPORTANT]
>  請勿使用這個方法多載來建立沙箱應用程式定義域。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，所提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱應用程式定義域。  
  
   
  
## Examples  
 下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see the description of <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidence that establishes the identity of the code that runs in the application domain. Pass <see langword="null" /> to use the evidence of the current application domain.</param>
        <param name="info">An object that contains application domain initialization information.</param>
        <param name="grantSet">A default permission set that is granted to all assemblies loaded into the new application domain that do not have specific grants.</param>
        <param name="fullTrustAssemblies">An array of strong names representing assemblies to be considered fully trusted in the new application domain.</param>
        <summary>Creates a new application domain using the specified name, evidence, application domain setup information, default permission set, and array of fully trusted assemblies.</summary>
        <returns>The newly created application domain.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須設定<xref:System.AppDomainSetup.ApplicationBase%2A>的屬性<xref:System.AppDomainSetup>物件，為您提供`info`。 否則，會擲回例外狀況。  
  
 如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。  
  
 提供的資訊`grantSet`並`fullTrustAssemblies`用來建立<xref:System.Security.Policy.ApplicationTrust>新的應用程式定義域的物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The application domain is <see langword="null" />.  -or-  The <see cref="P:System.AppDomainSetup.ApplicationBase" /> property is not set on the <see cref="T:System.AppDomainSetup" /> object that is supplied for <paramref name="info" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立及管理應用程式定義域的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidence that establishes the identity of the code that runs in the application domain. Pass <see langword="null" /> to use the evidence of the current application domain.</param>
        <param name="appBasePath">The base directory that the assembly resolver uses to probe for assemblies. For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">The path relative to the base directory where the assembly resolver should probe for private assemblies. For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">If <see langword="true" />, a shadow copy of an assembly is loaded into this application domain.</param>
        <summary>Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</summary>
        <returns>The newly created application domain.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。  
  
 如需陰影複製的詳細資訊，請參閱<xref:System.AppDomain.ShadowCopyFiles%2A>並[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
> [!IMPORTANT]
>  請勿使用這個方法多載來建立沙箱應用程式定義域。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，所提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱應用程式定義域。  
  
   
  
## Examples  
 下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidence that establishes the identity of the code that runs in the application domain. Pass <see langword="null" /> to use the evidence of the current application domain.</param>
        <param name="appBasePath">The base directory that the assembly resolver uses to probe for assemblies. For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">The path relative to the base directory where the assembly resolver should probe for private assemblies. For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">
          <see langword="true" /> to load a shadow copy of an assembly into the application domain.</param>
        <param name="adInit">An <see cref="T:System.AppDomainInitializer" /> delegate that represents a callback method to invoke when the new <see cref="T:System.AppDomain" /> object is initialized.</param>
        <param name="adInitArgs">An array of string arguments to be passed to the callback represented by <c>adInit</c>, when the new <see cref="T:System.AppDomain" /> object is initialized.</param>
        <summary>Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain. Specifies a callback method that is invoked when the application domain is initialized, and an array of string arguments to pass the callback method.</summary>
        <returns>The newly created application domain.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所表示之方法`adInit`新建立的應用程式定義域的內容中執行。  
  
 如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。  
  
 如需陰影複製的詳細資訊，請參閱<xref:System.AppDomain.ShadowCopyFiles%2A>並[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
> [!IMPORTANT]
>  請勿使用這個方法多載來建立沙箱應用程式定義域。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，所提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱應用程式定義域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new instance of a specified type defined in a specified assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <summary>Creates a new instance of the specified type defined in the specified assembly.</summary>
        <returns>An object that is a wrapper for the new instance specified by <paramref name="typeName" />. The return value needs to be unwrapped to access the real object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫預設建構函式`typeName`。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。  
  
 嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標上，不是目前的應用程式定義域的應用程式定義域會導致成功的載入目標應用程式定義域中的組件。 由於<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>針對至目前的應用程式定義域載入的組件，common language runtime 會嘗試將組件載入目前的應用程式定義域和負載可能會失敗。 載入至目前的應用程式定義域的組件可能不同於已在不同的兩個應用程式定義域的路徑設定是否先載入的組件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> was not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have permission to call this constructor.</exception>
        <exception cref="T:System.MissingMethodException">No matching public constructor was found.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">This instance is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <param name="activationAttributes">An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.  This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development. Distributed applications should instead use Windows Communication Foundation.</param>
        <summary>Creates a new instance of the specified type defined in the specified assembly. A parameter specifies an array of activation attributes.</summary>
        <returns>An object that is a wrapper for the new instance specified by <paramref name="typeName" />. The return value needs to be unwrapped to access the real object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫預設建構函式`typeName`。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。  
  
 嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標上，不是目前的應用程式定義域的應用程式定義域會導致成功的載入目標應用程式定義域中的組件。 由於<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>針對至目前的應用程式定義域載入的組件，common language runtime 會嘗試將組件載入目前的應用程式定義域和負載可能會失敗。 載入至目前的應用程式定義域的組件可能不同於已在不同的兩個應用程式定義域的路徑設定是否先載入的組件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> was not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have permission to call this constructor.</exception>
        <exception cref="T:System.MissingMethodException">No matching public constructor was found.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">This instance is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <param name="ignoreCase">A Boolean value specifying whether to perform a case-sensitive search or not.</param>
        <param name="bindingAttr">A combination of zero or more bit flags that affect the search for the <c>typeName</c> constructor. If <c>bindingAttr</c> is zero, a case-sensitive search for public constructors is conducted.</param>
        <param name="binder">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection. If <c>binder</c> is null, the default binder is used.</param>
        <param name="args">The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <c>args</c> must be an empty array or null.</param>
        <param name="culture">Culture-specific information that governs the coercion of <c>args</c> to the formal types declared for the <c>typeName</c> constructor. If <c>culture</c> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</param>
        <param name="activationAttributes">An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.  This parameter is related to client-activated objects. Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development. Distributed applications should instead use Windows Communication Foundation.</param>
        <summary>Creates a new instance of the specified type defined in the specified assembly. Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, and optional activation attributes.</summary>
        <returns>An object that is a wrapper for the new instance specified by <paramref name="typeName" />. The return value needs to be unwrapped to access the real object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。  
  
 嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標上，不是目前的應用程式定義域的應用程式定義域會導致成功的載入目標應用程式定義域中的組件。 由於<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>針對至目前的應用程式定義域載入的組件，common language runtime 會嘗試將組件載入目前的應用程式定義域和負載可能會失敗。 載入至目前的應用程式定義域的組件可能不同於已在不同的兩個應用程式定義域的路徑設定是否先載入的組件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> is not a valid assembly.  -or-  <paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> was not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have permission to call this constructor.</exception>
        <exception cref="T:System.MissingMethodException">No matching constructor was found.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">This instance is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <param name="ignoreCase">A Boolean value specifying whether to perform a case-sensitive search or not.</param>
        <param name="bindingAttr">A combination of zero or more bit flags that affect the search for the <c>typeName</c> constructor. If <c>bindingAttr</c> is zero, a case-sensitive search for public constructors is conducted.</param>
        <param name="binder">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection. If <c>binder</c> is null, the default binder is used.</param>
        <param name="args">The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <c>args</c> must be an empty array or null.</param>
        <param name="culture">Culture-specific information that governs the coercion of <c>args</c> to the formal types declared for the <c>typeName</c> constructor. If <c>culture</c> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</param>
        <param name="activationAttributes">An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.  This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development. Distributed applications should instead use Windows Communication Foundation.</param>
        <param name="securityAttributes">Information used to authorize creation of <c>typeName</c>.</param>
        <summary>Creates a new instance of the specified type defined in the specified assembly. Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, activation attributes, and authorization to create the type.</summary>
        <returns>An object that is a wrapper for the new instance specified by <paramref name="typeName" />. The return value needs to be unwrapped to access the real object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。  
  
 嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標上，不是目前的應用程式定義域的應用程式定義域會導致成功的載入目標應用程式定義域中的組件。 由於<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>針對至目前的應用程式定義域載入的組件，common language runtime 會嘗試將組件載入目前的應用程式定義域和負載可能會失敗。 載入至目前的應用程式定義域的組件可能不同於已在不同的兩個應用程式定義域的路徑設定是否先載入的組件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> was not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have permission to call this constructor.</exception>
        <exception cref="T:System.MissingMethodException">No matching constructor was found.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.  -or-  <paramref name="securityAttributes" /> is not <see langword="null" />. When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null." /></exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">This instance is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new instance of a specified type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <summary>Creates a new instance of the specified type. Parameters specify the assembly where the type is defined, and the name of the type.</summary>
        <returns>An instance of the object specified by <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 這個方法會呼叫預設建構函式`typeName`。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。 請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。  
  
> [!NOTE]
>  若要呼叫的方法的早期繫結`M`類型的物件`T1`所傳回的<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，方法會進行早期繫結呼叫的型別物件的方法和`T2`組件中`C`以外目前的組件或包含的組件`T1`，組件`C`載入目前的應用程式定義域。 即使早期繫結呼叫，就會發生此載入`T1.M()`的主體中所做<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。 如果目前的網域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的網域稍後嘗試載入組件`C`，負載可能會失敗。  
  
   
  
## Examples  
 下列程式碼範例示範另一個應用程式定義域中執行程式碼最簡單的方式。 此範例會定義名為類別`Worker`繼承自<xref:System.MarshalByRefObject>。 `Worker`類別會定義方法，以顯示其執行所在之應用程式定義域的名稱。 此範例會建立的執行個體`Worker`在預設應用程式定義域和新的應用程式定義域中。  
  
> [!NOTE]
>  包含的組件`Worker`必須載入到兩個應用程式定義域，但它可以載入新的應用程式定義域只存在於其他組件。  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No matching public constructor was found.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> was not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have permission to call this constructor.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">能夠讀取檔案包含組件資訊清單中，或如果您要建立從模組資訊清單檔以外的類型。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <param name="activationAttributes">An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.  This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development. Distributed applications should instead use Windows Communication Foundation.</param>
        <summary>Creates a new instance of the specified type. Parameters specify the assembly where the type is defined, the name of the type, and an array of activation attributes.</summary>
        <returns>An instance of the object specified by <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 這個方法會呼叫預設建構函式`typeName`。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。 請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。  
  
> [!NOTE]
>  若要呼叫的方法的早期繫結`M`類型的物件`T1`所傳回的<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，方法會進行早期繫結呼叫的型別物件的方法和`T2`組件中`C`以外目前的組件或包含的組件`T1`，組件`C`載入目前的應用程式定義域。 即使早期繫結呼叫，就會發生此載入`T1.M()`的主體中所做<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。 如果目前的網域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的網域稍後嘗試載入組件`C`，負載可能會失敗。  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No matching public constructor was found.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> was not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have permission to call this constructor.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <param name="ignoreCase">A Boolean value specifying whether to perform a case-sensitive search or not.</param>
        <param name="bindingAttr">A combination of zero or more bit flags that affect the search for the <c>typeName</c> constructor. If <c>bindingAttr</c> is zero, a case-sensitive search for public constructors is conducted.</param>
        <param name="binder">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection. If <c>binder</c> is null, the default binder is used.</param>
        <param name="args">The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <c>args</c> must be an empty array or null.</param>
        <param name="culture">A culture-specific object used to govern the coercion of types. If <c>culture</c> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</param>
        <param name="activationAttributes">An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. that specifies the URL that is required to activate a remote object.  This parameter is related to client-activated objects. Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development. Distributed applications should instead use Windows Communication Foundation.</param>
        <summary>Creates a new instance of the specified type defined in the specified assembly, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</summary>
        <returns>An instance of the object specified by <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。 請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。  
  
> [!NOTE]
>  若要呼叫的方法的早期繫結`M`類型的物件`T1`所傳回的<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，方法會進行早期繫結呼叫的型別物件的方法和`T2`組件中`C`以外目前的組件或包含的組件`T1`，組件`C`載入目前的應用程式定義域。 即使早期繫結呼叫，就會發生此載入`T1.M()`的主體中所做<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。 如果目前的網域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的網域稍後嘗試載入組件`C`，負載可能會失敗。  
  
   
  
## Examples  
 下列範例示範如何使用`ignoreCase`參數。  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No matching constructor was found.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> was not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have permission to call this constructor.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> is not a valid assembly.  -or-  <paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <param name="ignoreCase">A Boolean value specifying whether to perform a case-sensitive search or not.</param>
        <param name="bindingAttr">A combination of zero or more bit flags that affect the search for the <c>typeName</c> constructor. If <c>bindingAttr</c> is zero, a case-sensitive search for public constructors is conducted.</param>
        <param name="binder">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection. If <c>binder</c> is null, the default binder is used.</param>
        <param name="args">The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <c>args</c> must be an empty array or null.</param>
        <param name="culture">A culture-specific object used to govern the coercion of types. If <c>culture</c> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</param>
        <param name="activationAttributes">An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.  This parameter is related to client-activated objects. Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development. Distributed applications should instead use Windows Communication Foundation.</param>
        <param name="securityAttributes">Information used to authorize creation of <c>typeName</c>.</param>
        <summary>Creates a new instance of the specified type. Parameters specify the name of the type, and how it is found and created.</summary>
        <returns>An instance of the object specified by <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。 請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。  
  
> [!NOTE]
>  若要呼叫的方法的早期繫結`M`類型的物件`T1`所傳回的<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，方法會進行早期繫結呼叫的型別物件的方法和`T2`組件中`C`以外目前的組件或包含的組件`T1`，組件`C`載入目前的應用程式定義域。 即使早期繫結呼叫，就會發生此載入`T1.M()`的主體中所做<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。 如果目前的網域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的網域稍後嘗試載入組件`C`，負載可能會失敗。  
  
   
  
## Examples  
 下列範例示範如何使用`ignoreCase`參數。  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No matching constructor was found.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> was not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have permission to call this constructor.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">提供所有型別成員上叫用作業的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new instance of a specified type defined in the specified assembly file.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The name, including the path, of a file that contains an assembly that defines the requested type. The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <summary>Creates a new instance of the specified type defined in the specified assembly file.</summary>
        <returns>An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found. The return value needs to be unwrapped to access the real object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設建構函式`typeName`叫用。  
  
 如需詳細資訊，請參閱 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。  
  
 當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域中，進行呼叫的應用程式定義域以外的執行個體，在目標應用程式定義域中載入的組件時。 不過，如果呼叫的應用程式定義域中執行個體未包裝，以特定方式使用的未包裝的執行個體可能會導致要載入至呼叫的應用程式定義域的組件。 例如，未包裝的執行個體之後，可能會要求其型別資訊，以便呼叫其方法晚期繫結。 當組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。  
  
-   如果另一個版本相同的組件的先前已載入至呼叫的應用程式定義域中，或如果呼叫的應用程式定義域的載入路徑為不同的目標應用程式定義域，例外狀況<xref:System.MissingMethodException>可能會發生。  
  
-   如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>嘗試轉型執行個體時，可能會擲回。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>方法多載來建立目標應用程式定義域中的物件的執行個體，並呼叫其方法。  
  
 此範例會定義`MarshallableExample`類別，可以跨應用程式定義域界限封送處理。 範例會建置目前執行的組件的路徑、 建立目標應用程式定義域，並使用<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>方法多載來載入目標應用程式定義域中的範例組件和建立的執行個體`MarshallableExample`。  
  
> [!NOTE]
>  路徑是在此範例中，絕對路徑，但相對路徑也可以運作，因為<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>方法用來載入組件。  
  
 如果之後解除包裝的物件控制代碼，此範例會示範三種方式可使用目標應用程式定義域中的物件：  
  
-   叫用方法，以使用反映的晚期繫結。 這需要型別資訊，這會導致要載入至呼叫端的應用程式定義域的組件。 （在此範例中，已經載入也是。）  
  
-   呼叫端和被呼叫端知道介面將物件轉型。 如果呼叫的組件或呼叫端和被呼叫端所參考的第三個組件中定義的介面，則呼叫的組件不載入至呼叫端的應用程式定義域。  
  
-   直接呼叫端知道它的型別時，請使用物件。 組件必須載入到呼叫端的應用程式定義域。  
  
 若要避免被呼叫的組件載入至呼叫端的應用程式定義域的另一個方法是呼叫者是衍生自<xref:System.MarshalByRefObject>類別，以及定義可以在目標應用程式定義域中執行的方法。 該方法可以使用反映來檢查目標組件，因為目標組件已載入至目標應用程式定義域。 範例，請參閱<xref:System.AppDomain.DynamicDirectory%2A>屬性。  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> is <see langword="null" />.  -or-  <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> was not found.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.MissingMethodException">No parameterless public constructor was found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have sufficient permission to call this constructor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.NullReferenceException">This instance is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The name, including the path, of a file that contains an assembly that defines the requested type. The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <param name="activationAttributes">An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.  This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development. Distributed applications should instead use Windows Communication Foundation.</param>
        <summary>Creates a new instance of the specified type defined in the specified assembly file.</summary>
        <returns>An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found. The return value needs to be unwrapped to access the real object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設建構函式`typeName`叫用。  
  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域中，進行呼叫的應用程式定義域以外的執行個體，在目標應用程式定義域中載入的組件時。 不過，如果呼叫的應用程式定義域中執行個體未包裝，以特定方式使用的未包裝的執行個體可能會導致要載入至呼叫的應用程式定義域的組件。 例如，未包裝的執行個體之後，可能會要求其型別資訊，以便呼叫其方法晚期繫結。 當組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。  
  
-   如果另一個版本相同的組件的先前已載入至呼叫的應用程式定義域中，或如果呼叫的應用程式定義域的載入路徑為不同的目標應用程式定義域，例外狀況<xref:System.MissingMethodException>可能會發生。  
  
-   如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>嘗試轉型執行個體時，可能會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> was not found.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have sufficient permission to call this constructor.</exception>
        <exception cref="T:System.MissingMethodException">No matching public constructor was found.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.NullReferenceException">This instance is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The name, including the path, of a file that contains an assembly that defines the requested type. The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <param name="ignoreCase">A Boolean value specifying whether to perform a case-sensitive search or not.</param>
        <param name="bindingAttr">A combination of zero or more bit flags that affect the search for the <c>typeName</c> constructor. If <c>bindingAttr</c> is zero, a case-sensitive search for public constructors is conducted.</param>
        <param name="binder">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection. If <c>binder</c> is null, the default binder is used.</param>
        <param name="args">The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <c>args</c> must be an empty array or null.</param>
        <param name="culture">Culture-specific information that governs the coercion of <c>args</c> to the formal types declared for the <c>typeName</c> constructor. If <c>culture</c> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</param>
        <param name="activationAttributes">An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.  This parameter is related to client-activated objects. Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development. Distributed applications should instead use Windows Communication Foundation.</param>
        <summary>Creates a new instance of the specified type defined in the specified assembly file.</summary>
        <returns>An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found. The return value needs to be unwrapped to access the real object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。  
  
 當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域中，進行呼叫的應用程式定義域以外的執行個體，在目標應用程式定義域中載入的組件時。 不過，如果呼叫的應用程式定義域中執行個體未包裝，以特定方式使用的未包裝的執行個體可能會導致要載入至呼叫的應用程式定義域的組件。 例如，未包裝的執行個體之後，可能會要求其型別資訊，以便呼叫其方法晚期繫結。 當組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。  
  
-   如果另一個版本相同的組件的先前已載入至呼叫的應用程式定義域中，或如果呼叫的應用程式定義域的載入路徑為不同的目標應用程式定義域，例外狀況<xref:System.MissingMethodException>可能會發生。  
  
-   如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>嘗試轉型執行個體時，可能會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> is <see langword="null" />.  -or-  <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> was not found.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">No matching public constructor was found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have sufficient permission to call this constructor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> is not a valid assembly.  -or-  <paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.NullReferenceException">This instance is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The name, including the path, of a file that contains an assembly that defines the requested type. The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <param name="ignoreCase">A Boolean value specifying whether to perform a case-sensitive search or not.</param>
        <param name="bindingAttr">A combination of zero or more bit flags that affect the search for the <c>typeName</c> constructor. If <c>bindingAttr</c> is zero, a case-sensitive search for public constructors is conducted.</param>
        <param name="binder">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection. If <c>binder</c> is null, the default binder is used.</param>
        <param name="args">The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <c>args</c> must be an empty array or null.</param>
        <param name="culture">Culture-specific information that governs the coercion of <c>args</c> to the formal types declared for the <c>typeName</c> constructor. If <c>culture</c> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</param>
        <param name="activationAttributes">An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.  This parameter is related to client-activated objects. Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development. Distributed applications should instead use Windows Communication Foundation.</param>
        <param name="securityAttributes">Information used to authorize creation of <c>typeName</c>.</param>
        <summary>Creates a new instance of the specified type defined in the specified assembly file.</summary>
        <returns>An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found. The return value needs to be unwrapped to access the real object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域中，進行呼叫的應用程式定義域以外的執行個體，在目標應用程式定義域中載入的組件時。 不過，如果呼叫的應用程式定義域中執行個體未包裝，以特定方式使用的未包裝的執行個體可能會導致要載入至呼叫的應用程式定義域的組件。 例如，未包裝的執行個體之後，可能會要求其型別資訊，以便呼叫其方法晚期繫結。 當組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。  
  
-   如果另一個版本相同的組件的先前已載入至呼叫的應用程式定義域中，或如果呼叫的應用程式定義域的載入路徑為不同的目標應用程式定義域，例外狀況<xref:System.MissingMethodException>可能會發生。  
  
-   如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>嘗試轉型執行個體時，可能會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> is <see langword="null" />.  -or-  <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.  -or-  <paramref name="securityAttributes" /> is not <see langword="null" />. When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> was not found.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">No matching public constructor was found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have sufficient permission to call this constructor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.NullReferenceException">This instance is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new instance of a specified type defined in the specified assembly file.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The file name and path of the assembly that defines the requested type.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <summary>Creates a new instance of the specified type defined in the specified assembly file.</summary>
        <returns>The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 這個方法會呼叫預設建構函式`typeName`。  
  
 如需詳細資訊，請參閱 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> is <see langword="null" />.  -or-  <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> was not found.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">No parameterless public constructor was found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have sufficient permission to call this constructor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The file name and path of the assembly that defines the requested type.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly (see the <see cref="P:System.Type.FullName" /> property).</param>
        <param name="activationAttributes">An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.  This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development. Distributed applications should instead use Windows Communication Foundation.</param>
        <summary>Creates a new instance of the specified type defined in the specified assembly file.</summary>
        <returns>The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 這個方法會呼叫預設建構函式`typeName`。  
  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> is <see langword="null" />.  -or-  <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> was not found.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">No parameterless public constructor was found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have sufficient permission to call this constructor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The file name and path of the assembly that defines the requested type.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <param name="ignoreCase">A Boolean value specifying whether to perform a case-sensitive search or not.</param>
        <param name="bindingAttr">A combination of zero or more bit flags that affect the search for the <c>typeName</c> constructor. If <c>bindingAttr</c> is zero, a case-sensitive search for public constructors is conducted.</param>
        <param name="binder">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection. If <c>binder</c> is null, the default binder is used.</param>
        <param name="args">The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <c>args</c> must be an empty array or null.</param>
        <param name="culture">Culture-specific information that governs the coercion of <c>args</c> to the formal types declared for the <c>typeName</c> constructor. If <c>culture</c> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</param>
        <param name="activationAttributes">An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.  This parameter is related to client-activated objects. Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development. Distributed applications should instead use Windows Communication Foundation.</param>
        <summary>Creates a new instance of the specified type defined in the specified assembly file, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</summary>
        <returns>The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> is <see langword="null" />.  -or-  <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> was not found.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">No matching public constructor was found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have sufficient permission to call this constructor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> is not a valid assembly.  -or-  <paramref name="assemblyName" /> was compiled with a later version of the common language runtime that the version that is currently loaded.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The file name and path of the assembly that defines the requested type.</param>
        <param name="typeName">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</param>
        <param name="ignoreCase">A Boolean value specifying whether to perform a case-sensitive search or not.</param>
        <param name="bindingAttr">A combination of zero or more bit flags that affect the search for the <c>typeName</c> constructor. If <c>bindingAttr</c> is zero, a case-sensitive search for public constructors is conducted.</param>
        <param name="binder">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection. If <c>binder</c> is null, the default binder is used.</param>
        <param name="args">The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <c>args</c> must be an empty array or null.</param>
        <param name="culture">Culture-specific information that governs the coercion of <c>args</c> to the formal types declared for the <c>typeName</c> constructor. If <c>culture</c> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</param>
        <param name="activationAttributes">An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.  This parameter is related to client-activated objects. Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development. Distributed applications should instead use Windows Communication Foundation.</param>
        <param name="securityAttributes">Information used to authorize creation of <c>typeName</c>.</param>
        <summary>Creates a new instance of the specified type defined in the specified assembly file.</summary>
        <returns>The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是很便利的方法，結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> is <see langword="null" />.  -or-  <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> was not found.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">No matching public constructor was found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have sufficient permission to call this constructor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">提供讀取包含組件資訊清單檔案的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current application domain for the current <see cref="T:System.Threading.Thread" />.</summary>
        <value>目前的應用程式定義域。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會建立新的應用程式定義域。 <xref:System.AppDomain.CurrentDomain%2A>屬性用來取得<xref:System.AppDomain>物件，表示目前的應用程式定義域。 <xref:System.AppDomain.FriendlyName%2A>屬性會提供目前的應用程式定義域，然後在命令列顯示的名稱。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Defines a dynamic assembly in the current application domain.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">The unique identity of the dynamic assembly.</param>
        <param name="access">The access mode for the dynamic assembly.</param>
        <summary>Defines a dynamic assembly with the specified name and access mode.</summary>
        <returns>A dynamic assembly with the specified name and access mode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.  -or-  The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">The unique identity of the dynamic assembly.</param>
        <param name="access">The access mode for the dynamic assembly.</param>
        <param name="assemblyAttributes">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</param>
        <summary>Defines a dynamic assembly with the specified name, access mode, and custom attributes.</summary>
        <returns>A dynamic assembly with the specified name and features.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法多載來指定將無法正常運作除非建立動態組件時，它們會套用的屬性。 比方說，安全性屬性這類<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果在建立動態組件之後，它們會加入。  
  
 這個方法應只用來定義動態組件中目前的應用程式定義域。 如需有關這項限制的詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 中引進這個方法多載[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立動態組件具有<xref:System.Security.SecurityTransparentAttribute>。 屬性必須指定為陣列的項目<xref:System.Reflection.Emit.CustomAttributeBuilder>物件。  
  
 建立第一個步驟<xref:System.Reflection.Emit.CustomAttributeBuilder>是取得屬性的建構函式。 建構函式沒有任何參數，因此<xref:System.Type.GetConstructor%2A>方法呼叫的空陣列<xref:System.Type>物件，以表示參數的類型。 第二個步驟是將產生<xref:System.Reflection.ConstructorInfo>物件的建構函式<xref:System.Reflection.Emit.CustomAttributeBuilder>類別，以及類型的空陣列<xref:System.Object>來表示引數。  
  
 產生<xref:System.Reflection.Emit.CustomAttributeBuilder>接著會傳遞給<xref:System.AppDomain.DefineDynamicAssembly%2A>做為唯一的項目陣列的方法。  
  
 範例程式碼定義的模組，然後輸入新的動態組件，並接著會顯示組件的屬性。  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.  -or-  The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">The unique identity of the dynamic assembly.</param>
        <param name="access">The mode in which the dynamic assembly will be accessed.</param>
        <param name="evidence">The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution.</param>
        <summary>Defines a dynamic assembly using the specified name, access mode, and evidence.</summary>
        <returns>A dynamic assembly with the specified name and features.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有完全受信任的呼叫端可以提供他們`evidence`定義動態時<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 首先，程式碼範例會嘗試建立的執行個體`MyDynamicType`藉由呼叫<xref:System.AppDomain.CreateInstance%2A>方法具有無效的組件名稱，並攔截產生的例外狀況。  
  
 程式碼範例接著會新增事件處理常式<xref:System.AppDomain.AssemblyResolve>事件，然後再次嘗試建立的執行個體`MyDynamicType`。 在呼叫期間<xref:System.AppDomain.CreateInstance%2A>，則<xref:System.AppDomain.AssemblyResolve>無效的組件都會引發事件。 事件處理常式會建立動態組件，其中包含名為的型別`MyDynamicType`、 提供的類型的無參數建構函式，並傳回新的動態組件。 在呼叫<xref:System.AppDomain.CreateInstance%2A>成功，然後完成的建構函式和`MyDynamicType`在主控台上顯示一則訊息。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.  -or-  The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The unique identity of the dynamic assembly.</param>
        <param name="access">The mode in which the dynamic assembly will be accessed.</param>
        <param name="dir">The name of the directory where the assembly will be saved. If <c>dir</c> is <see langword="null" />, the directory defaults to the current directory.</param>
        <summary>Defines a dynamic assembly using the specified name, access mode, and storage directory.</summary>
        <returns>A dynamic assembly with the specified name and features.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.  -or-  The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">The unique identity of the dynamic assembly.</param>
        <param name="access">The access mode for the dynamic assembly.</param>
        <param name="assemblyAttributes">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</param>
        <param name="securityContextSource">The source of the security context.</param>
        <summary>Defines a dynamic assembly with the specified name, access mode, and custom attributes, and using the specified source for its security context.</summary>
        <returns>A dynamic assembly with the specified name and features.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法多載來指定將無法正常運作除非建立動態組件時，它們會套用的屬性。 比方說，安全性屬性這類<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果在建立動態組件之後，它們會加入。  
  
 這個方法應只用來定義動態組件中目前的應用程式定義域。 如需有關這項限制的詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.  -or-  The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="securityContextSource" /> was not one of the enumeration values.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">The unique identity of the dynamic assembly.</param>
        <param name="access">The mode in which the dynamic assembly will be accessed.</param>
        <param name="dir">The name of the directory where the assembly will be saved. If <c>dir</c> is <see langword="null" />, the directory defaults to the current directory.</param>
        <param name="evidence">The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution.</param>
        <summary>Defines a dynamic assembly using the specified name, access mode, storage directory, and evidence.</summary>
        <returns>A dynamic assembly with the specified name and features.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有完全受信任的呼叫端可以提供他們`evidence`定義動態時<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.  -or-  The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">The unique identity of the dynamic assembly.</param>
        <param name="access">The mode in which the dynamic assembly will be accessed.</param>
        <param name="requiredPermissions">The required permissions request.</param>
        <param name="optionalPermissions">The optional permissions request.</param>
        <param name="refusedPermissions">The refused permissions request.</param>
        <summary>Defines a dynamic assembly using the specified name, access mode, and permission requests.</summary>
        <returns>A dynamic assembly with the specified name and features.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不會使用，除非已儲存並重新載入到記憶體的動態組件。 若要指定不會儲存到磁碟，請使用的多載的暫時性組件的權限要求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，也會為要求的權限，並提供為指定的辨識項<xref:System.Security.Policy.Evidence>物件。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.  -or-  The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">The unique identity of the dynamic assembly.</param>
        <param name="access">The mode in which the dynamic assembly will be accessed.</param>
        <param name="dir">The name of the directory where the dynamic assembly will be saved. If <c>dir</c> is <see langword="null" />, the current directory is used.</param>
        <param name="isSynchronized">
          <see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</param>
        <param name="assemblyAttributes">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</param>
        <summary>Defines a dynamic assembly using the specified name, access mode, storage directory, and synchronization option.</summary>
        <returns>A dynamic assembly with the specified name and features.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法多載來指定將無法正常運作除非建立動態組件時，它們會套用的屬性。 比方說，安全性屬性這類<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果在建立動態組件之後，它們會加入。  
  
 如果`isSynchronized`是`true`，下列方法產生<xref:System.Reflection.Emit.AssemblyBuilder>將會同步處理： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 其中兩種方法會呼叫不同的執行緒上，如果其中一個會封鎖直到另完成為止。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.  -or-  The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">The unique identity of the dynamic assembly.</param>
        <param name="access">The mode in which the dynamic assembly will be accessed.</param>
        <param name="evidence">The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution.</param>
        <param name="requiredPermissions">The required permissions request.</param>
        <param name="optionalPermissions">The optional permissions request.</param>
        <param name="refusedPermissions">The refused permissions request.</param>
        <summary>Defines a dynamic assembly using the specified name, access mode, evidence, and permission requests.</summary>
        <returns>A dynamic assembly with the specified name and features.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，並`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，而且重新載入到記憶體。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`。 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 只有完全受信任的呼叫端可以提供他們`evidence`定義動態時<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.  -or-  The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">The unique identity of the dynamic assembly.</param>
        <param name="access">The mode in which the dynamic assembly will be accessed.</param>
        <param name="dir">The name of the directory where the assembly will be saved. If <c>dir</c> is <see langword="null" />, the directory defaults to the current directory.</param>
        <param name="requiredPermissions">The required permissions request.</param>
        <param name="optionalPermissions">The optional permissions request.</param>
        <param name="refusedPermissions">The refused permissions request.</param>
        <summary>Defines a dynamic assembly using the specified name, access mode, storage directory, and permission requests.</summary>
        <returns>A dynamic assembly with the specified name and features.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不會使用，除非已儲存並重新載入到記憶體的動態組件。 若要指定不會儲存到磁碟，請使用的多載的暫時性組件的權限要求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，也會為要求的權限，並提供為指定的辨識項<xref:System.Security.Policy.Evidence>物件。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.  -or-  The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">The unique identity of the dynamic assembly.</param>
        <param name="access">The mode in which the dynamic assembly will be accessed.</param>
        <param name="dir">The name of the directory where the assembly will be saved. If <c>dir</c> is <see langword="null" />, the directory defaults to the current directory.</param>
        <param name="evidence">The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution.</param>
        <param name="requiredPermissions">The required permissions request.</param>
        <param name="optionalPermissions">The optional permissions request.</param>
        <param name="refusedPermissions">The refused permissions request.</param>
        <summary>Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, and permission requests.</summary>
        <returns>A dynamic assembly with the specified name and features.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，並`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，而且重新載入到記憶體。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`。 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 只有完全受信任的呼叫端可以提供他們`evidence`定義動態時<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 這個方法應該只用來定義動態組件中目前的應用程式定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.  -or-  The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">The unique identity of the dynamic assembly.</param>
        <param name="access">The mode in which the dynamic assembly will be accessed.</param>
        <param name="dir">The name of the directory where the dynamic assembly will be saved. If <c>dir</c> is <see langword="null" />, the directory defaults to the current directory.</param>
        <param name="evidence">The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution.</param>
        <param name="requiredPermissions">The required permissions request.</param>
        <param name="optionalPermissions">The optional permissions request.</param>
        <param name="refusedPermissions">The refused permissions request.</param>
        <param name="isSynchronized">
          <see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</param>
        <summary>Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, permission requests, and synchronization option.</summary>
        <returns>A dynamic assembly with the specified name and features.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，並`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，而且重新載入到記憶體。  
  
> [!NOTE]
>  在開發期間會發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`。 包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 只有完全受信任的呼叫端可以提供其辨識項，當定義動態<xref:System.Reflection.Assembly>。 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。 部分信任的呼叫端必須提供`null`針對`evidence`參數。 如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。  
  
 如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。  
  
 如果`isSynchronized`是`true`，下列方法產生<xref:System.Reflection.Emit.AssemblyBuilder>將會同步處理： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 如果這些方法的兩個不同的執行緒上呼叫，其中將會封鎖其他作業完成之前。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.  -or-  The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">The unique identity of the dynamic assembly.</param>
        <param name="access">The mode in which the dynamic assembly will be accessed.</param>
        <param name="dir">The name of the directory where the dynamic assembly will be saved. If <c>dir</c> is <see langword="null" />, the current directory is used.</param>
        <param name="evidence">The evidence that is supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution.</param>
        <param name="requiredPermissions">The required permissions request.</param>
        <param name="optionalPermissions">The optional permissions request.</param>
        <param name="refusedPermissions">The refused permissions request.</param>
        <param name="isSynchronized">
          <see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</param>
        <param name="assemblyAttributes">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</param>
        <summary>Defines a dynamic assembly with the specified name, access mode, storage directory, evidence, permission requests, synchronization option, and custom attributes.</summary>
        <returns>A dynamic assembly with the specified name and features.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法多載來指定將無法正常運作除非建立動態組件時，它們會套用的屬性。 比方說，安全性屬性這類<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果在建立動態組件之後，它們會加入。  
  
 針對指定的權限要求`requiredPermissions`， `optionalPermissions`，並`refusedPermissions`才會使用的參數`evidence`也提供參數，或如果儲存動態組件，而且重新載入到記憶體。  
  
> [!NOTE]
>  當您開發可發出動態組件的程式碼時，我們建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>加上旗標在`refusedPermissions`參數。 此旗標包含確保的 Microsoft intermediate language (MSIL) 會進行驗證。 這項技術會偵測到意外產生無法驗證的程式碼，否則這是非常難以偵測。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。  
  
 只有完全受信任的呼叫端可以提供辨識項，當定義動態<xref:System.Reflection.Assembly>。 執行階段對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。 部分信任的呼叫端必須提供`null`針對`evidence`參數。 如果`evidence`是`null`，執行階段將 （也就是，目前的授與和拒絕集） 的權限集合從呼叫者的組件複製到的動態組件所定義，且標示為已解決的原則。  
  
 如果動態組件會儲存至磁碟，則後續載入會根據儲存動態組件的位置與相關聯的原則授與。  
  
 如果`isSynchronized`是`true`，下列方法產生<xref:System.Reflection.Emit.AssemblyBuilder>將會同步處理： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 其中兩種方法會呼叫不同的執行緒上，如果其中一個會封鎖直到另完成為止。  
  
 中引進這個方法多載[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.  -or-  The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">A delegate that specifies a method to call.</param>
        <summary>Executes the code in another application domain that is identified by the specified delegate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` 可以封送處理為傳值方式指定， <xref:System.MarshalByRefObject>，或<xref:System.ContextBoundObject>。  
  
   
  
## Examples  
 下列範例示範如何使用靜態<xref:System.AppDomain.DoCallBack%2A>方法。  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 下列範例示範如何使用<xref:System.AppDomain.DoCallBack%2A>值的方法。  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 下列範例示範如何使用<xref:System.AppDomain.DoCallBack%2A>所參考的方法。  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the domain manager that was provided by the host when the application domain was initialized.</summary>
        <value>物件，表示在已經初始化應用程式定義域時，由主應用程式提供的定義域管理員；如果未提供任何定義域管理員，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 受管理的主機，common language runtime (CLR) 可以提供網域管理員。 可以初始化新的應用程式定義域中參與的定義域管理員，並將其提供其他管理員中，例如<xref:System.Security.HostSecurityManager>，參與的應用程式定義域的作業。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an <see cref="T:System.AppDomain" /> is about to be unloaded.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler>委派為這個事件可以在應用程式網域卸載之前執行任何終止活動。  
  
 每個應用程式定義域必須執行處理卸載時應該註冊這個事件的事件處理常式。 共用的事件處理常式應該不使用，因為<xref:System.EventHandler>委派不會識別正在卸載的網域。  
  
> [!NOTE]
>  預設應用程式定義域中永遠不會引發這個事件。  
  
 請勿在執行緒引發事件的相關假設。 可以在不同的執行緒以外的呼叫引發事件<xref:System.AppDomain.Unload%2A>方法。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the directory that the assembly resolver uses to probe for dynamically created assemblies.</summary>
        <value>組件解析程式用來探查以動態建立組件的目錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要設定的動態的目錄，將指定的基底目錄路徑<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>屬性<xref:System.AppDomainSetup>會用以建立新的應用程式定義域的物件。 修改指派給屬性的基底目錄路徑的簡單名稱是指派給字串的雜湊程式碼子目錄<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>屬性，所以基底目錄格式*原始路徑* \\*雜湊碼*。 此基底目錄的子目錄動態的目錄。 其簡單的名稱是值<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>屬性，因此它的格式*原始路徑*\\*雜湊碼*\\*應用程式名稱*。  
  
   
  
## Examples  
 下列範例與目錄的應用程式定義域建立動態組件的、 發出動態組件和將它儲存在動態的目錄中，將組件載入新的應用程式定義域然後使用它。  
  
 此範例會建立<xref:System.AppDomainSetup>物件以及設定其<xref:System.AppDomainSetup.ApplicationName%2A>"Example"的屬性並將其<xref:System.AppDomainSetup.DynamicBase%2A>"C:\DynamicAssemblyDir"的屬性。 此範例接著會顯示<xref:System.AppDomainSetup.DynamicBase%2A>屬性，以顯示應用程式名稱的雜湊碼，已附加為原本指派路徑的子目錄。  
  
> [!NOTE]
>  在此範例中的基底目錄就是要探查路徑外部的範例應用程式。 請務必在編譯中的不同位置的範例。 刪除的基底目錄及其所有子目錄每次執行此範例的資訊。  
  
 此範例會建立新的應用程式定義域中，使用<xref:System.AppDomainSetup>物件。 此範例會使用<xref:System.AppDomain.DynamicDirectory%2A>屬性，以擷取目錄的名稱，因此它可以建立該目錄。 （此範例可以輕鬆地建立目錄事先藉由串連的原始路徑，應用程式名稱，而應用程式名稱的雜湊碼。）  
  
 此範例包含 `GenerateDynamicAssembly`方法，會發出名為組件`DynamicHelloWorld.dll`並將它儲存在新的應用程式定義域的動態目錄中。 動態組件包含一種類型， `HelloWorld`，，有一個靜態方法 (`Shared`方法，在 Visual Basic 中的) 名為`HelloFromAD`。 呼叫這個方法會顯示應用程式定義域的名稱。  
  
 `Example`類別衍生自<xref:System.MarshalByRefObject>，因此範例可以建立類別的執行個體，在新的應用程式定義域，並呼叫其`Test`方法。 `Test`方法會依其顯示名稱載入的動態組件，並呼叫靜態`HelloFromAD`方法。  
  
 您可以顯示的動態目錄搜尋一般探查路徑之後，撰寫程式碼組件名為`DynamicHelloWorld.dll`和編譯此範例中的相同目錄中。 組件必須具有一個名為類別`HelloWorld`靜態方法，名為`HelloFromAD`。 這個方法不需要有相同的功能與在範例中，它只可以在主控台中顯示的字串。 組件也必須<xref:System.Reflection.AssemblyVersionAttribute>將它的版本設定為 1.0.0.0 的屬性。 當您執行範例時，才能動態的目錄中搜尋找到您編譯目前目錄中的組件。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取的路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Security.Policy.Evidence" /> associated with this application domain.</summary>
        <value>與此應用程式定義域相關聯的辨識項。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executes the assembly contained in the specified file.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The name of the file that contains the assembly to execute.</param>
        <summary>Executes the assembly contained in the specified file.</summary>
        <returns>The value returned by the entry point of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
 若要建立<xref:System.AppDomain>載入並執行，請使用<xref:System.AppDomain.CreateDomain%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> is not found.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.MissingMethodException">The specified assembly has no entry point.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The name of the file that contains the assembly to execute.</param>
        <param name="assemblySecurity">Evidence for loading the assembly.</param>
        <summary>Executes the assembly contained in the specified file, using the specified evidence.</summary>
        <returns>The value returned by the entry point of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 <xref:System.AppDomain.ExecuteAssembly%2A>方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> is not found.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.MissingMethodException">The specified assembly has no entry point.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The name of the file that contains the assembly to execute.</param>
        <param name="args">The arguments to the entry point of the assembly.</param>
        <summary>Executes the assembly contained in the specified file, using the specified arguments.</summary>
        <returns>The value that is returned by the entry point of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> is not found.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> is not a valid assembly.  -or-  <paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.MissingMethodException">The specified assembly has no entry point.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The name of the file that contains the assembly to execute.</param>
        <param name="assemblySecurity">The supplied evidence for the assembly.</param>
        <param name="args">The arguments to the entry point of the assembly.</param>
        <summary>Executes the assembly contained in the specified file, using the specified evidence and arguments.</summary>
        <returns>The value returned by the entry point of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> is not found.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> is not <see langword="null" />. When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">The specified assembly has no entry point.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The name of the file that contains the assembly to execute.</param>
        <param name="args">The arguments to the entry point of the assembly.</param>
        <param name="hashValue">Represents the value of the computed hash code.</param>
        <param name="hashAlgorithm">Represents the hash algorithm used by the assembly manifest.</param>
        <summary>Executes the assembly contained in the specified file, using the specified arguments, hash value, and hash algorithm.</summary>
        <returns>The value that is returned by the entry point of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> is not found.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> is not a valid assembly.  -or-  <paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.MissingMethodException">The specified assembly has no entry point.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The name of the file that contains the assembly to execute.</param>
        <param name="assemblySecurity">The supplied evidence for the assembly.</param>
        <param name="args">The arguments to the entry point of the assembly.</param>
        <param name="hashValue">Represents the value of the computed hash code.</param>
        <param name="hashAlgorithm">Represents the hash algorithm used by the assembly manifest.</param>
        <summary>Executes the assembly contained in the specified file, using the specified evidence, arguments, hash value, and hash algorithm.</summary>
        <returns>The value returned by the entry point of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 ︰ 範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> is not found.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> is not <see langword="null" />. When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">The specified assembly has no entry point.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executes an assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Executes an assembly given its display name.</summary>
        <returns>The value returned by the entry point of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 若要建立<xref:System.AppDomain>載入並執行，請使用<xref:System.AppDomain.CreateDomain%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The assembly specified by <paramref name="assemblyName" /> is not found.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</exception>
        <exception cref="T:System.MissingMethodException">The specified assembly has no entry point.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</param>
        <param name="args">Command-line arguments to pass when starting the process.</param>
        <summary>Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified arguments.</summary>
        <returns>The value that is returned by the entry point of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">The assembly specified by <paramref name="assemblyName" /> is not found.</exception>
        <exception cref="T:System.IO.FileLoadException">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.  -or-  <paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.MissingMethodException">The specified assembly has no entry point.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidence for loading the assembly.</param>
        <summary>Executes an assembly given its display name, using the specified evidence.</summary>
        <returns>The value returned by the entry point of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
> [!NOTE]
>  當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。 做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代的辨識項載入器所提供的片段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The assembly specified by <paramref name="assemblyName" /> is not found.</exception>
        <exception cref="T:System.IO.FileLoadException">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.MissingMethodException">The specified assembly has no entry point.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">Command-line arguments to pass when starting the process.</param>
        <summary>Executes the assembly given its display name, using the specified arguments.</summary>
        <returns>The value that is returned by the entry point of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The assembly specified by <paramref name="assemblyName" /> is not found.</exception>
        <exception cref="T:System.IO.FileLoadException">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.  -or-  <paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.MissingMethodException">The specified assembly has no entry point.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</param>
        <param name="assemblySecurity">Evidence for loading the assembly.</param>
        <param name="args">Command-line arguments to pass when starting the process.</param>
        <summary>Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified evidence and arguments.</summary>
        <returns>The value returned by the entry point of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
> [!NOTE]
>  當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。 做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代的辨識項載入器所提供的片段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">The assembly specified by <paramref name="assemblyName" /> is not found.</exception>
        <exception cref="T:System.IO.FileLoadException">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> is not <see langword="null" />. When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">The specified assembly has no entry point.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidence for loading the assembly.</param>
        <param name="args">Command-line arguments to pass when starting the process.</param>
        <summary>Executes the assembly given its display name, using the specified evidence and arguments.</summary>
        <returns>The value returned by the entry point of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 組件會開始執行的.NET Framework 標頭中指定的進入點。  
  
 這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。  
  
> [!NOTE]
>  當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。 做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代的辨識項載入器所提供的片段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The assembly specified by <paramref name="assemblyName" /> is not found.</exception>
        <exception cref="T:System.IO.FileLoadException">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</exception>
        <exception cref="T:System.BadImageFormatException">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> is not <see langword="null" />. When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">The specified assembly has no entry point.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於存取網站時的顯示名稱會被重新導向至的 URL。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要執行主控台應用程式。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an exception is thrown in managed code, before the runtime searches the call stack for an exception handler in the application domain.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件是只有通知。 處理這個事件不會處理例外狀況或會影響後續的例外狀況以任何方式處理。 在引發事件，並已叫用事件處理常式之後，common language runtime (CLR) 會開始搜尋例外狀況處理常式。 <xref:System.AppDomain.FirstChanceException> 第一個有機會檢查任何 managed 例外狀況可讓應用程式定義域。  
  
 每個應用程式網域，就可以處理事件。 如果執行緒會透過多個應用程式定義域傳遞執行呼叫時，CLR 可讓您開始搜尋應用程式定義域中相符的例外狀況處理常式之前，已註冊的事件處理常式中，每個應用程式定義域中引發事件。 在處理事件之後，搜尋會將相符的例外狀況處理常式，該應用程式定義域中。 如果找不到，就會在下一步 的應用程式定義域引發事件。  
  
 您必須處理所有例外狀況發生在事件處理常式<xref:System.AppDomain.FirstChanceException>事件。 否則，<xref:System.AppDomain.FirstChanceException>是遞迴引發。 這可能會導致堆疊溢位和應用程式終止。 我們建議您為限制的執行區域 (Cer)，實作此事件的事件處理常式，以防止基礎結構相關例外狀況，例如記憶體不足或堆疊溢位例外狀況通知時，會影響虛擬機器正在處理中。  
  
 此事件不會引發例外狀況，表示損毀的程序的狀態，例如存取違規，除非事件處理常式上為安全性關鍵，而且有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>屬性。  
  
 正在處理此通知事件時，common language runtime 會暫止執行緒中止。  
  
   
  
## Examples  
 下列範例會建立一系列具名的應用程式定義域`AD0`經由`AD3`，使用`Worker`每個應用程式定義域中的物件。 每個`Worker`物件具有的參考`Worker`物件在下一步 的應用程式網域中，除了`Worker`最後一個應用程式定義域中。 <xref:System.AppDomain.FirstChanceException>以外的所有應用程式定義域中處理事件`AD1`。  
  
> [!NOTE]
>  除了此範例中，示範多個應用程式定義域中的第一個可能的例外狀況通知，您可以找到簡單使用案例[如何： 接收 First-chance 例外狀況通知](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)。  
  
 預設應用程式定義域時已建立的應用程式定義域，呼叫`TestException`第一個應用程式定義域的方法。 每個`Worker`物件會呼叫`TestException`方法下, 一步 的應用程式定義域，直到最後一個`Worker`會擲回例外狀況處理或未處理的。 因此，目前的執行緒通過所有的應用程式定義域中，和`TestException`新增到每個應用程式定義域中的堆疊。  
  
 當上次`Worker`物件會處理例外狀況，<xref:System.AppDomain.FirstChanceException>只有在最後一個應用程式定義域引發事件。 其他的應用程式定義域永遠不會有機會處理例外狀況，因此不會引發事件。  
  
 當上次`Worker`物件不會處理例外狀況，<xref:System.AppDomain.FirstChanceException>每個應用程式在網域中，事件處理常式就會引發事件。 每個事件處理常式已完成之後，堆疊會繼續回溯直到預設應用程式定義域所捕捉的例外狀況。  
  
> [!NOTE]
>  若要查看如何堆疊顯示隨著接近引發事件，並使其更接近預設應用程式定義域，變更`e.Exception.Message`要`e.Exception`在`FirstChanceHandler`事件處理常式。 請注意，當`TestException`稱為跨應用程式定義域界限，它會出現兩次： 一次的 proxy，一次虛設常式。  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the friendly name of this application domain.</summary>
        <value>這個應用程式定義域的易記名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設應用程式定義域的易記名稱是可執行檔的程序的檔案名稱。 例如，用來啟動處理程序的可執行檔是否`"c:\MyAppDirectory\MyAssembly.exe"`，預設應用程式定義域的易記名稱是`"MyAssembly.exe"`。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.AppDomain.FriendlyName%2A>屬性來取得目前的應用程式定義域的易記名稱。 預設應用程式定義域的易記名稱會是應用程式的可執行檔的名稱。 在程式碼範例也會顯示應用程式定義域的其他資訊。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the assemblies that have been loaded into the execution context of this application domain.</summary>
        <returns>An array of assemblies in this application domain.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例使用<xref:System.AppDomain.GetAssemblies%2A>方法來取得已載入至應用程式定義域的所有組件清單。 組件隨即顯示到主控台。  
  
 若要執行此程式碼範例，您需要建立名為組件`CustomLibrary.dll`，或變更組件名稱傳遞給<xref:System.AppDomain.GetAssemblies%2A>方法。  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the current thread identifier.</summary>
        <returns>A 32-bit signed integer that is the identifier of the current thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>屬性，這是穩定甚至當.NET Framework 由裝載環境能支援 fiber （也就是輕量型執行緒）。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫這個方法。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of a predefined application domain property, or the name of an application domain property you have defined.</param>
        <summary>Gets the value stored in the current application domain for the specified name.</summary>
        <returns>The value of the <paramref name="name" /> property, or <see langword="null" /> if the property does not exist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來擷取值的描述屬性的這個執行個體的名稱資料組的內部快取中的項目<xref:System.AppDomain>。 請注意，比較`name`索引鍵 / 值組的名稱會區分大小寫。  
  
 快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。 您可以查看其值與<xref:System.AppDomain.GetData%2A>方法或對等項目<xref:System.AppDomainSetup>屬性。  
  
 您可以插入或修改您自己的使用者定義名稱資料組，而且<xref:System.AppDomain.SetData%2A>方法，並檢查其值與<xref:System.AppDomain.GetData%2A>方法。  
  
 下表描述`name`每個預先定義的系統項目和其對應<xref:System.AppDomainSetup>屬性。  
  
|'Name' 的值|屬性|  
|---------------------|--------------|  
|「 APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|「 APP_LAUNCH_URL"|（沒有內容）<br /><br /> 「 APP_LAUNCH_URL"表示原先要求的使用者之前任何重新導向, 的 URL。 它位於已啟動應用程式，例如 Internet Explorer 的瀏覽器時，才。 並非所有瀏覽器提供此值。|  
|「 APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|「 BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|「 CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|「 CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|「 DEV_PATH"|（沒有內容）|  
|「 DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|「 DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|「 FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|「 LICENSE_FILE"或特定應用程式的字串|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|「 LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|「 LOCATION_URI"|（沒有內容）|  
|「 PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> 「 REGEX_DEFAULT_MATCH_TIMEOUT"不是系統項目和它的值可以藉由呼叫設定<xref:System.AppDomain.SetData%2A>方法。|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 下列範例會建立新的應用程式定義域、 設定的網域中，系統提供值，並將新的值組的網域。 下列範例示範如何使用<xref:System.AppDomain.GetData%2A>方法來擷取這些值組中的資料，並對主控台顯示它們。  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑本身，如果此屬性會套用至路徑中的資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the type of the current instance.</summary>
        <returns>The type of the current instance.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an integer that uniquely identifies the application domain within the process.</summary>
        <value>可識別應用程式定義域的整數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會建立第二個應用程式定義域，並顯示相關的預設網域和新的網域資訊。  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gives the <see cref="T:System.AppDomain" /> an infinite lifetime by preventing a lease from being created.</summary>
        <returns>Always <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The compatibility switch to test.</param>
        <summary>Gets a nullable Boolean value that indicates whether any compatibility switches are set, and if so, whether the specified compatibility switch is set.</summary>
        <returns>A null reference (<see langword="Nothing" /> in Visual Basic) if no compatibility switches are set; otherwise, a Boolean value that indicates whether the compatibility switch that is specified by <paramref name="value" /> is set.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會測試是否已指定相容性參數設定為目前的應用程式定義域。 相容性參數通常還原行為 （例如排序方式字串） 的.NET framework 版本之間已變更。  它們由呼叫設定<xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType>方法，然後再建立應用程式定義域。  
  
 下表提供可以設定以還原舊版的.NET framework 的行為的相容性參數的範例。  
  
|參數|意義|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|程式碼存取安全性 (CAS)[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]啟用此應用程式定義域中。 請參閱[ &lt;NetFx40_LegacySecurityPolicy&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)。|  
|"NetFx40_Legacy20SortingBehavior"|排序的預設值的字串[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]這個應用程式定義域中已啟用。 它的成功需要 sort00001000.dll 安裝。 請參閱[ &lt;CompatSortNLSVersion&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)。|  
|"NetFx40_Legacy40SortingBehavior"|排序的預設值的字串[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和 Unicode 5.0 會啟用此應用程式定義域中。 它的成功需要 sort00060101.dll 安裝。|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> 格式化行為的[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]啟用此應用程式定義域中。  請參閱[ &lt;TimeSpan_LegacyFormatMode&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)和 「 還原舊版 TimeSpan 格式化 」 一節的<xref:System.TimeSpan>主題。|  
|"UseRandomizedStringHashAlgorithm"|執行階段計算字串的雜湊碼在每個應用程式定義域為基準，而不是使用單一的雜湊演算法可跨應用程式定義域產生一致雜湊碼。 請參閱[ &lt;UseRandomizedStringHashAlgorithm&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a value that indicates whether the application domain is the default application domain for the process.</summary>
        <returns>
          <see langword="true" /> if the current <see cref="T:System.AppDomain" /> object represents the default application domain for the process; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個受管理的程序具有預設應用程式定義域。 在 預設網域，開始執行。  
  
   
  
## Examples  
 下列程式碼範例會建立第二個應用程式定義域，並顯示相關的預設網域和新的網域資訊。  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates whether this application domain is unloading, and the objects it contains are being finalized by the common language runtime.</summary>
        <returns>
          <see langword="true" /> if this application domain is unloading and the common language runtime has started invoking finalizers; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 物件的最終處理方法會提供物件的記憶體回收之前執行任何必要的清除作業的機會。 在最終處理之後, 此物件會為可存取，但處於無效狀態，因此無法使用。 最後，記憶體回收完成，並回收物件。  
  
 在下列情況的其中一個呼叫物件的完成項方法： 記憶體回收期間，當正在關閉通用語言執行平台，或包含物件的應用程式定義域卸載時。 <xref:System.AppDomain.IsFinalizingForUnload%2A>方法會傳回`true`只有在最後一個案例中; 它不會傳回`true`當最終處理的結果從例行回收或 CLR 關閉。  
  
> [!NOTE]
>  若要判斷是否因為 CLR 關閉，所以最終處理，請使用<xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType>屬性。 它會傳回`true`最終處理是否因為應用程式定義域正在卸載或 clr 正在關閉。  
  
 同時在您完成的方法執行期間定義域卸載，您可能想要存取靜態欄位所參考，且具有最終處理方法的另一個物件。 不過，您無法可靠地執行，因為存取的物件可能會有已經結束。  
  
> [!NOTE]
>  此規則的例外是<xref:System.Console>類別，其中包含參考資料流物件的靜態欄位，但您可以一律，即使在網域卸載或系統關機期間寫入系統主控台中，因此，特別實作。  
  
 物件的完成項方法中使用這個方法，以判斷是否包含物件的應用程式定義域正在卸載。 如果是這樣，您無法可靠地存取具有完成項方法，並且由靜態欄位參考的任何物件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether assemblies that are loaded into the current application domain execute with full trust.</summary>
        <value>如果載入目前應用程式定義域中的組件在完全信任情況下執行，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法永遠傳回`true`桌面上執行的應用程式的預設應用程式定義域。 它會傳回`false`，利用所建立的沙箱化應用程式網域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載，除非應用程式定義域授與的權限相當於完全信任。  
  
   
  
## Examples  
 下列範例示範<xref:System.AppDomain.IsFullyTrusted%2A>屬性和<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>與完全信任和部分信任的應用程式定義域的屬性。 應用程式的預設應用程式定義域為完全受信任的應用程式網域。 部分信任的應用程式定義域由使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載。  
  
 此範例會使用`Worker`類別衍生自<xref:System.MarshalByRefObject>，因此它可以封送處理跨應用程式定義域界限。 此範例會建立`Worker`預設應用程式定義域中的物件。 然後它會呼叫`TestIsFullyTrusted`方法，以顯示屬性值，應用程式定義域並載入至應用程式定義域的兩個組件： mscorlib，這是.NET Framework 和範例組件的一部分。 這兩個組件是完全受信任，所以完全信任，應用程式定義域。  
  
 此範例會建立另一個`Worker`物件在沙箱應用程式定義域，然後再次呼叫`TestIsFullyTrusted`方法。 Mscorlib 永遠是受信任，甚至是在部分信任的應用程式網域中，但是範例組件是以部分信任。  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current application domain has a set of permissions that is granted to all assemblies that are loaded into the application domain.</summary>
        <value>如果目前應用程式定義域具有一組同質性權限，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回`true`使用所建立的沙箱化應用程式定義域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載。 沙箱應用程式定義域具有一組同質性權限;也就是相同的權限集授與載入應用程式定義域的所有部分信任組件。 （選擇性） 沙箱應用程式定義域會有免套用此權限集，並改為使用完全信任執行的強式名稱組件清單。  
  
 完全受信任的程式碼可以使用<xref:System.AppDomain.PermissionSet%2A>屬性來判斷沙箱應用程式定義域的同質性的授權集。  
  
 這個屬性也會傳回`true`預設應用程式定義域的桌面應用程式，因為該應用程式定義域會完全信任授與所有組件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Loads an <see cref="T:System.Reflection.Assembly" /> into this application domain.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</param>
        <summary>Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>The loaded assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是應用程式定義域的信任層級相同。  
  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例示範如何載入原始的組件的使用。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> is <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">An object that describes the assembly to load.</param>
        <summary>Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>The loaded assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 如果尚未載入要求的組件的版本，這個方法會傳回載入的組件，即使要求不同的版本。  
  
 提供的部分組件名稱`assemblyRef`不建議使用。 （部分的名稱會省略一或多個文化特性、 版本或公開金鑰語彙基元。 採用而不是字串的多載<xref:System.Reflection.AssemblyName>物件，"MyAssembly，版本 = 1.0.0.0"舉例說明部分的名稱和"MyAssembly，version=1.0.0.0，Culture = neutral，PublicKeyToken = 18ab3442da84b47"是完整名稱的範例。)使用部分的名稱已對效能產生負面影響。 此外，部分組件名稱可以載入組件從全域組件快取才有的應用程式的基底目錄中的組件的完整複本 (<xref:System.AppDomain.BaseDirectory%2A>或<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>)。  
  
 如果目前<xref:System.AppDomain>物件表示應用程式定義域`A`，而<xref:System.AppDomain.Load%2A>方法從應用程式定義域呼叫`B`，組件會載入兩個應用程式定義域。 例如，下列程式碼載入`MyAssembly`至新的應用程式定義域`ChildDomain`也到應用程式定義域執行的程式碼：  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 組件載入這兩個網域，因為<xref:System.Reflection.Assembly>不是衍生自<xref:System.MarshalByRefObject>，並因此傳回值的<xref:System.AppDomain.Load%2A>方法無法封送處理。 相反地，common language runtime 會嘗試載入至呼叫的應用程式定義域的組件。 載入至兩個應用程式定義域的組件可能是不同的兩個應用程式定義域的路徑設定是否不同。  
  
> [!NOTE]
>  如果兩個<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>屬性和<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>屬性所設定，第一次嘗試載入組件會使用顯示名稱 (包括版本、 文化特性，並依此類推，所傳回<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性)。 如果找不到檔案，<xref:System.Reflection.AssemblyName.CodeBase%2A>屬性用來搜尋該組件。 如果使用找到的組件<xref:System.Reflection.AssemblyName.CodeBase%2A>，顯示名稱比對組件。 如果比對失敗，<xref:System.IO.FileLoadException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> is not found.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</summary>
        <returns>The loaded assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> is <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> is not found.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">提供存取組件的位置，如果組件不是本機的能力。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</param>
        <param name="rawSymbolStore">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</param>
        <summary>Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />. The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</summary>
        <returns>The loaded assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是應用程式定義域的信任層級相同。  
  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例示範如何載入原始的組件的使用。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> is <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">An object that describes the assembly to load.</param>
        <param name="assemblySecurity">Evidence for loading the assembly.</param>
        <summary>Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>The loaded assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> is <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> is not found.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取的路徑，不是格式"file:// 或"\\\UNC\dir\\"或"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidence for loading the assembly.</param>
        <summary>Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</summary>
        <returns>The loaded assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> is <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> is not found.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取的路徑，不是格式"file:// 或"\\\UNC\dir\\"或"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</param>
        <param name="rawSymbolStore">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</param>
        <param name="securityEvidence">Evidence for loading the assembly.</param>
        <summary>Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />. The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</summary>
        <returns>The loaded assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是應用程式定義域的信任層級相同。  
  
 這個方法應只將組件載入目前的應用程式定義域。 為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。  
  
   
  
## Examples  
 下列範例示範如何載入原始的組件的使用。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> is <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> is not a valid assembly.  -or-  Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> is not <see langword="null" />. When legacy CAS policy is not enabled, <paramref name="securityEvidence" /> should be <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用於讀取的路徑，不是格式"file:// 或"\\\UNC\dir\\"或"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether CPU and memory monitoring of application domains is enabled for the current process. Once monitoring is enabled for a process, it cannot be disabled.</summary>
        <value>如果啟用監視，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這`static`屬性 (`Shared`屬性在 Visual Basic) 控制 CPU 和記憶體監視的程序中的所有應用程式定義域。  
  
 如果您嘗試將此屬性設定為`false`，則<xref:System.ArgumentException>會擲回例外狀況，即使目前屬性的值是`false`。  
  
 一旦啟用監視，您可以使用<xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>， <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>， <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>，和<xref:System.AppDomain.MonitoringTotalProcessorTime%2A>執行個體來監視個別的應用程式定義域的 CPU 和記憶體使用的屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current process attempted to assign the value <see langword="false" /> to this property.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of bytes that survived the last collection and that are known to be referenced by the current application domain.</summary>
        <value>存留的位元組數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每次記憶體回收會更新統計資料。 不過，它們會保證完整、 阻斷式收集; 之後，才是正確的也就是的集合，其中包含所有層代和，以停止應用程式，這時集合就會發生。 比方說，<xref:System.GC.Collect?displayProperty=nameWithType>方法多載會執行完整、 阻斷式收集。 （並行集合會在背景進行的而且不會封鎖應用程式）。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the total bytes that survived from the last collection for all application domains in the process.</summary>
        <value>處理程序的存留位元組總數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完整、 阻斷式收集之後, 的位元組數目目前保留位於此數字代表 managed 堆積。 它應該接近所報告的數字<xref:System.GC.GetTotalMemory%2A>方法。 暫時的集合之後, 此數字代表位元組數目目前保留要即時暫時層代中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the total size, in bytes, of all memory allocations that have been made by the application domain since it was created, without subtracting memory that has been collected.</summary>
        <value>所有記憶體配置的總大小。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the total processor time that has been used by all threads while executing in the current application domain, since the process started.</summary>
        <value>目前應用程式定義域的處理器時間總計。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 總時間所報告的應用程式定義域包含應用程式定義域中執行的處理序中的每個執行緒所花費的時間。  
  
 呼叫 unmanaged 程式碼的執行緒仍會關聯應用程式定義域，並執行 unmanaged 程式碼會報告應用程式定義域進行呼叫所花費的處理器時間。  
  
 當執行緒遭到封鎖或睡眠中，它不會佔用處理器時間。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the permission set of a sandboxed application domain.</summary>
        <value>沙箱應用程式定義域的權限集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用所建立的沙箱應用程式定義域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載有一組同質性權限，也就是相同的權限集授與所有部分信任的組件載入應用程式定義域。 （選擇性） 沙箱應用程式定義域會有免套用此權限集，並改為使用完全信任執行的強式名稱組件清單。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the default application domain's parent process exits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler>針對此事件可以執行終止活動，例如關閉檔案，釋出儲存體，在處理序結束之前。  
  
 從.NET Framework 2.0 版開始，每個註冊的事件處理常式的應用程式定義域會引發這個事件。  
  
> [!NOTE]
>  總執行時間的所有<xref:System.AppDomain.ProcessExit>事件處理常式是受到限制，就如同所有的完成項執行時間總計會限制在關閉處理序。 預設值為兩秒。 受管理的主機可以呼叫來變更此執行階段[iclrpolicymanager:: Settimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)方法[OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)列舉值。  
  
 在.NET framework 1.0 和 1.1 版中，此事件是引發只在預設應用程式網域中，並且只有在預設應用程式定義域中註冊事件處理常式。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the resolution of an assembly fails in the reflection-only context.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在僅限反映的內容中，會不會自動解析相依性。 它們必須預先載入或傳回由這個事件處理常式。 當組件具有尚未載入至僅限反映內容的相依性時，會引發這個事件。 遺失的相依性由<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>屬性。 <xref:System.ResolveEventHandler>本項目中必須傳回符合相依性的組件。 傳回組件必須載入僅限反映的內容。  
  
> [!IMPORTANT]
>  僅針對遺失的相依性的組件載入僅限反映的內容會引發這個事件 (例如，藉由使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>方法)。 如果找不到要載入的組件時，它不會引發。  
  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性會傳回要求無法解析組件載入的組件。 了解要求的組件的識別可能會有助於識別正確版本的相依性，如果一個以上的版本。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
 對於此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>套用原則之前，屬性會傳回組件名稱。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the assemblies that have been loaded into the reflection-only context of the application domain.</summary>
        <returns>An array of <see cref="T:System.Reflection.Assembly" /> objects that represent the assemblies loaded into the reflection-only context of the application domain.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回已載入至僅限反映內容的組件。 若要取得已載入的組件的執行，請使用<xref:System.AppDomain.GetAssemblies%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例會載入 System.dll 組件，到執行內容，然後放入僅限反映的內容。 <xref:System.AppDomain.GetAssemblies%2A>和<xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A>方法用來顯示每個內容所載入的組件。  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">An operation is attempted on an unloaded application domain.</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path under the base directory where the assembly resolver should probe for private assemblies.</summary>
        <value>組件解析程式應該在其中探查私用組件的路徑，此路徑位於基底目錄下。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 私用組件會部署在相同的目錄結構與應用程式。 如果所指定的路徑<xref:System.AppDomain.RelativeSearchPath%2A>屬性不是下方<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>，則會忽略它。  
  
 這個屬性會傳回設定使用的值<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取的路徑資訊。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the resolution of a resource fails because the resource is not a valid linked or embedded resource in the assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ResolveEventHandler>針對此事件可嘗試找出包含資源的組件，並將它傳回。  
  
> [!IMPORTANT]
>  如果解析失敗，因為針對有效的連結資源找不到檔案，不會引發此事件。 如果找不到的資訊清單資源資料流，但如果找不到個別的資源索引鍵，則不會引發它，就會引發這個事件。  
  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性包含要求之資源的組件。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">The security policy level.</param>
        <summary>Establishes the security policy level for this application domain.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 載入組件之前呼叫這個方法<xref:System.AppDomain>為了讓安全性原則，以產生的影響。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.AppDomain.SetAppDomainPolicy%2A>方法來設定應用程式定義域的安全性原則層級。  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">The security policy level has already been set.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The fully qualified path to the shadow copy location.</param>
        <summary>Establishes the specified directory path as the location where assemblies are shadow copied.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果，則會忽略快取路徑<xref:System.AppDomainSetup.ApplicationName%2A>屬性未設定。 請參閱 <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> 屬性。  
  
 如需陰影複製的詳細資訊請參閱 <<c0> [ 陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Assigns a value to an application domain property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">The name of a user-defined application domain property to create or change.</param>
        <param name="data">The value of the property.</param>
        <summary>Assigns the specified value to the specified application domain property.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法中插入項目，或修改的值描述屬性的這個執行個體的名稱資料組的內部快取中的項目<xref:System.AppDomain>。  
  
 快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。 您無法插入或修改系統項目使用此方法。 嘗試修改系統項目方法呼叫沒有任何作用中;此方法不會擲回例外狀況。 您可以查看使用的系統項目的值<xref:System.AppDomain.GetData%2A>方法或對等項目<xref:System.AppDomainSetup>屬性中所述<xref:System.AppDomain.GetData%2A>。  
  
 您可以呼叫這個方法，以評估供應"REGEX_DEFAULT_MATCH_TIMEOUT 」 的規則運算式模式的預設逾時間隔的值設定的值`name`引數和<xref:System.TimeSpan>值，表示在逾時值與間隔`data`引數。 您可以也插入或修改您自己的使用者定義名稱資料組使用這個方法並檢查其值與<xref:System.AppDomain.GetData%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29>方法用來建立新的值組。 然後此範例使用<xref:System.AppDomain.GetData%2A>方法來擷取值，並將它顯示到主控台。  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">The name of a user-defined application domain property to create or change.</param>
        <param name="data">The value of the property.</param>
        <param name="permission">The permission to demand of the caller when the property is retrieved.</param>
        <summary>Assigns the specified value to the specified application domain property, with a specified permission to demand of the caller when the property is retrieved.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來插入或修改您的使用者定義的項目，在內部快取的名稱/資料組，可描述應用程式定義域的屬性。 當您將項目時，您可以指定的權限要求，以強制在擷取的項目時。颾魤 ㄛ 您可以呼叫這個方法，以評估供應"REGEX_DEFAULT_MATCH_TIMEOUT 」 的規則運算式模式的預設逾時間隔的值設定的值`name`引數和<xref:System.TimeSpan>值，表示做為值的逾時間隔`data`引數。  
  
 您無法使用這個方法，將安全性需求的系統定義的屬性字串。  
  
 快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。 您無法插入或修改系統項目使用此方法。 嘗試修改系統項目方法呼叫沒有任何作用中;此方法不會擲回例外狀況。 您可以查看使用的系統項目的值<xref:System.AppDomain.GetData%2A>方法或對等項目<xref:System.AppDomainSetup>屬性，如 < 備註 > 一節所述<xref:System.AppDomain.GetData%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> specifies a system-defined property string and <paramref name="permission" /> is not <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The fully qualified path that is the base directory for subdirectories where dynamic assemblies are stored.</param>
        <summary>Establishes the specified directory path as the base directory for subdirectories where dynamically generated files are stored and accessed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會設定<xref:System.AppDomainSetup.DynamicBase%2A>屬性內部的<xref:System.AppDomainSetup>與這個執行個體相關聯。  
  
   
  
## Examples  
 此方法現已淘汰，並不應該用於新的開發。 下列範例示範如何使用非過時的替代方式，<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>屬性。 如需此範例的說明，請參閱 <<c0> <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> 屬性或<xref:System.AppDomain.DynamicDirectory%2A>屬性。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">One of the <see cref="T:System.Security.Principal.PrincipalPolicy" /> values that specifies the type of the principal object to attach to threads.</param>
        <summary>Specifies how principal and identity objects should be attached to a thread if the thread attempts to bind to a principal while executing in this application domain.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定此值才會生效，如果您將使用之前<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性。 例如，如果您設定<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>到指定的主體 （例如，泛型主體），然後使用<xref:System.AppDomain.SetPrincipalPolicy%2A>方法來設定<xref:System.Security.Principal.PrincipalPolicy>到<xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>，目前的主體會保留泛用的主體。  
  
   
  
## Examples  
 下列範例示範使用的執行緒上作用<xref:System.AppDomain.SetPrincipalPolicy%2A>方法，以變更應用程式定義域的主體的原則。 它也會示範使用的效果<xref:System.AppDomain.SetThreadPrincipal%2A>變更適用於附加至應用程式定義域中的執行緒之主體的方法。  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">操作主體物件的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Turns on shadow copying.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
   
  
## Examples  
 此方法現已淘汰，並不應該用於新的開發。  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">A list of directory names, where each name is separated by a semicolon.</param>
        <summary>Establishes the specified directory path as the location of assemblies to be shadow copied.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，陰影複製會包含經由探查所找到的所有組件。 <xref:System.AppDomain.SetShadowCopyPath%2A>方法會將陰影複製限制為所指定的目錄中的組件`path`。  
  
 <xref:System.AppDomain.SetShadowCopyPath%2A>方法不會指定要搜尋的組件的其他目錄。 要陰影複製組件必須已經位於搜尋路徑中，例如下<xref:System.AppDomain.BaseDirectory%2A>。 <xref:System.AppDomain.SetShadowCopyPath%2A>方法可讓您指定的搜尋路徑適合將陰影複製。  
  
 這個方法會設定<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>屬性內部的<xref:System.AppDomainSetup>與這個執行個體相關聯。  
  
 如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
   
  
## Examples  
 此方法現已淘汰，並不應該用於新的開發。  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">The principal object to attach to threads.</param>
        <summary>Sets the default principal object to be attached to threads if they attempt to bind to a principal while executing in this application domain.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範使用的效果<xref:System.AppDomain.SetThreadPrincipal%2A>變更適用於附加至應用程式定義域中執行的執行緒之主體的方法。 它也會顯示在使用的執行緒上作用<xref:System.AppDomain.SetPrincipalPolicy%2A>方法，以變更應用程式定義域的主體的原則。  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">The thread principal has already been set.</exception>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">操作主體物件的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the application domain configuration information for this instance.</summary>
        <value>應用程式定義域初始化資訊。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an indication whether the application domain is configured to shadow copy files.</summary>
        <value>如果已設定應用程式定義域以進行檔案陰影複製，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱 <<c0> <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> 並[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The operation is attempted on an unloaded application domain.</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="rgszNames">Passed-in array of names to be mapped.</param>
        <param name="cNames">Count of the names to be mapped.</param>
        <param name="lcid">The locale context in which to interpret the names.</param>
        <param name="rgDispId">Caller-allocated array which receives the IDs corresponding to the names.</param>
        <summary>Maps a set of names to a corresponding set of dispatch identifiers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">The type information to return.</param>
        <param name="lcid">The locale identifier for the type information.</param>
        <param name="ppTInfo">Receives a pointer to the requested type information object.</param>
        <summary>Retrieves the type information for an object, which can then be used to get the type information for an interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetTypeInfo`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Points to a location that receives the number of type information interfaces provided by the object.</param>
        <summary>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifies the member.</param>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="lcid">The locale context in which to interpret arguments.</param>
        <param name="wFlags">Flags describing the context of the call.</param>
        <param name="pDispParams">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</param>
        <param name="pVarResult">Pointer to the location where the result is to be stored.</param>
        <param name="pExcepInfo">Pointer to a structure that contains exception information.</param>
        <param name="puArgErr">The index of the first argument that has an error.</param>
        <summary>Provides access to properties and methods exposed by an object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::Invoke`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtains a string representation that includes the friendly name of the application domain and any context policies.</summary>
        <returns>A string formed by concatenating the literal string "Name:", the friendly name of the application domain, and either string representations of the context policies or the string "There are no context policies."</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例顯示的傳回值<xref:System.AppDomain.ToString%2A>方法。  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">The application domain represented by the current <see cref="T:System.AppDomain" /> has been unloaded.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the resolution of a type fails.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.TypeResolve> Common language runtime 無法判斷組件可以建立要求的型別時，就會發生事件。 如果類型定義中的動態組件，或動態組件中未定義類型，但執行階段不知道哪個組件中定義型別，也可能會發生。 後者的情況可能會發生時<xref:System.Type.GetType%2A?displayProperty=nameWithType>呼叫組件名稱未限定的型別名稱。  
  
 <xref:System.ResolveEventHandler>針對此事件可以嘗試找出並建立類型。  
  
 不過，<xref:System.AppDomain.TypeResolve>事件不會發生執行階段可讓您知道不可能以尋找特定組件中的類型。 比方說，不會不會發生此事件的型別找不到靜態組件中因為執行階段知道類型無法以動態方式新增至靜態組件。  
  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性包含要求的型別之組件。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列範例會示範<xref:System.AppDomain.TypeResolve>事件。  
  
 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an exception is not caught.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會通知無法攔截的例外狀況。 它可讓應用程式之前的系統預設處理常式回報給使用者的例外狀況，並終止應用程式記錄例外狀況的相關資訊。 如果應用程式的狀態相關的足夠資訊可用，則可能會採取其他動作，例如儲存供稍後復原計畫資料。 請謹慎，因為未處理例外狀況時，會損毀程式資料。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，應用程式終止偵錯選項報告和使用者會引發這個事件之前，而不是在後。  
  
 可以在任何應用程式定義域中處理這個事件。 不過，事件不一定會引發例外狀況的發生位置的應用程式定義域中。 只有當執行緒在整個堆疊已回溯而未找到適用的例外狀況處理常式，因此可以引發事件的第一個位置是在執行緒的起源的應用程式定義域，是未處理例外狀況。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，只會針對應用程式啟動時，會將由系統建立預設應用程式定義域發生此事件。 如果應用程式建立其他應用程式定義域，指定此事件的委派，這些應用程式網域中沒有任何作用。  
  
 如果<xref:System.AppDomain.UnhandledException>預設應用程式定義域中處理事件，會引發這個事件發生的任何未處理例外狀況，在任何執行緒中，無論何種應用程式定義域中啟動的執行緒。 如果有事件處理常式的應用程式定義域中啟動執行緒<xref:System.AppDomain.UnhandledException>，應用程式定義域中引發事件。 如果該應用程式定義域不是預設的應用程式定義域，而且也沒有事件處理常式預設應用程式定義域中，會引發事件，這兩個應用程式定義域中。  
  
 比方說，假設啟動執行緒應用程式定義域 」 AD1"，"AD2，"的應用程式定義域中呼叫的方法，並從中呼叫應用程式定義域 」 AD3 」，方法會擲回例外狀況。 第一個應用程式定義域，<xref:System.AppDomain.UnhandledException>可以引發事件是 「 AD1"。 如果該應用程式定義域不是預設應用程式定義域，也是預設應用程式定義域中引發事件。  
  
> [!NOTE]
>  Common language runtime 會暫止的執行緒中止時的事件處理常式<xref:System.AppDomain.UnhandledException>執行事件。  
  
 如果事件處理常式<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>屬性與適當的旗標，事件處理常式會被視為限制的執行區域。  
  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，此事件不會引發例外狀況的損毀的程序的狀態，例如堆疊溢位，或存取違規，除非事件處理常式上為安全性關鍵，而且有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>屬性。  
  
 在.NET framework 1.0 和 1.1 版中，主應用程式執行緒以外的執行緒中發生未處理例外狀況會由執行階段會攔截，並因此不會造成應用程式終止。 因此，就可能<xref:System.AppDomain.UnhandledException>而不終止應用程式會引發事件。 從.NET Framework 2.0 版開始，這個子執行緒中的未處理例外狀況的支援已移除，因為這類的無訊息失敗的累積效果包含效能降低、 損毀的資料和鎖定，且很難偵錯。 如需詳細資訊，包括一份案例中，執行階段不會終止，請參閱[受控執行緒中的例外狀況](~/docs/standard/threading/exceptions-in-managed-threads.md)。  
  
 若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
## <a name="other-events-for-unhandled-exceptions"></a>未處理例外狀況的其他事件  
 針對特定應用程式模型，<xref:System.AppDomain.UnhandledException>事件可以清空的其他事件，如果主應用程式執行緒中發生未處理的例外狀況。  
  
 使用 Windows Forms 應用程式，在未處理的例外狀況中的主應用程式執行緒的原因<xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType>會引發事件。 如果處理此事件，預設行為是未處理的例外狀況不會終止應用程式，雖然應用程式處於未知狀態。 在此情況下，<xref:System.AppDomain.UnhandledException>不會引發事件。 可以變更此行為，藉由使用應用程式組態檔，或是利用<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType>方法，以將模式變更為<xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType>之前<xref:System.Windows.Forms.Application.ThreadException>連結事件處理常式。 只適用於主應用程式執行緒。 <xref:System.AppDomain.UnhandledException>其他執行緒中擲回未處理的例外狀況都會引發事件。  
  
 從 Microsoft Visual Studio 2005 開始，Visual Basic 應用程式架構可以提供另一個事件在主應用程式執行緒的未處理例外狀況。 請參閱<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType>事件。 此事件具有與所使用的事件引數物件的名稱相同的事件引數物件<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>，但具有不同的屬性。 這個事件引數物件的有特別的是，<xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>屬性，可讓應用程式繼續執行，而忽略未處理的例外狀況 （並讓應用程式處於未知狀態）。 在此情況下，<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>不會引發事件。  
  
   
  
## Examples  
 如以下範例將示範<xref:System.AppDomain.UnhandledException>事件。 它會定義事件處理常式， `MyHandler`，叫用時的預設應用程式定義域中擲回未處理的例外狀況。 然後，會擲回兩個例外狀況。 第一個由**try/catch**區塊。 第二個是未處理，並叫用`MyHandle`應用程式終止之前的常式。  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">An application domain to unload.</param>
        <summary>Unloads the specified application domain.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 2.0 版中已有執行緒專門用來卸載應用程式定義域。 這可改善可靠性，尤其是當裝載.NET Framework。 當執行緒呼叫<xref:System.AppDomain.Unload%2A>，目標網域已標示為卸載。 專用的執行緒嘗試卸載定義域，並在網域中的所有執行緒都被都中止。 如果執行緒不會中止，例如因為它正在執行 unmanaged 程式碼，或因為它執行`finally`區塊，然後在一段時間後的<xref:System.CannotUnloadAppDomainException>初次呼叫的執行緒中擲回<xref:System.AppDomain.Unload%2A>。 如果無法最終中止的執行緒結束時，目標網域不卸載。 因此，在.NET Framework 2.0 版`domain`不保證會卸除，因為它可能無法終止正在執行的執行緒。  
  
> [!NOTE]
>  在某些情況下，呼叫<xref:System.AppDomain.Unload%2A>會導致立即<xref:System.CannotUnloadAppDomainException>，例如在完成項呼叫。  
  
 中的執行緒`domain`使用終止<xref:System.Threading.Thread.Abort%2A>方法，就會擲回<xref:System.Threading.ThreadAbortException>執行緒中。 不過，應該立即終止執行緒，它會繼續執行無法預期的一段時間中`finally`子句。  
  
## <a name="version-compatibility"></a>版本相容性  
 在.NET Framework 1.0 和 1.1，如果呼叫執行緒<xref:System.AppDomain.Unload%2A>正在執行`domain`，另一個執行緒已啟動執行卸載作業。 如果`domain`不能卸載<xref:System.CannotUnloadAppDomainException>該執行緒不在原始呼叫的執行緒中擲回<xref:System.AppDomain.Unload%2A>。 不過，如果執行緒呼叫<xref:System.AppDomain.Unload%2A>外部執行`domain`，執行緒會收到例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何卸載應用程式定義域。  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> is <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          <paramref name="domain" /> could not be unloaded.</exception>
        <exception cref="T:System.Exception">An error occurred during the unload process.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要加入此事件的事件處理常式。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
  </Members>
</Type>